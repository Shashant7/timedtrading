<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Timed Trading - Trade Tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Trade Tracker — refined design system */
      :root {
        --tt-bg-base: #0c0f14;
        --tt-bg-surface: #13171e;
        --tt-bg-elevated: #1a1f28;
        --tt-bg-hover: rgba(255,255,255,0.04);
        --tt-border: rgba(255,255,255,0.08);
        --tt-border-strong: rgba(255,255,255,0.12);
        --tt-text: #f0f2f5;
        --tt-text-muted: #8b92a0;
        --tt-text-faint: #5c6475;
        --tt-accent: #22c55e;
        --tt-accent-dim: rgba(34, 197, 94, 0.2);
        --tt-negative: #ef4444;
        --tt-negative-dim: rgba(239, 68, 68, 0.2);
        --tt-radius: 12px;
        --tt-radius-sm: 8px;
        --tt-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }
      body {
        background: var(--tt-bg-base);
        color: var(--tt-text);
        font-family: var(--tt-font);
        -webkit-font-smoothing: antialiased;
      }
      .tt-card {
        background: var(--tt-bg-surface);
        border: 1px solid var(--tt-border);
        border-radius: var(--tt-radius);
      }
      .tt-pill {
        padding: 6px 12px;
        border-radius: 9999px;
        font-size: 13px;
        font-weight: 500;
        transition: background 0.15s, color 0.15s;
      }
      .tt-pill-active {
        background: var(--tt-bg-elevated);
        color: var(--tt-text);
      }
      .tt-pill-inactive {
        background: transparent;
        color: var(--tt-text-muted);
      }
      .tt-pill-inactive:hover {
        color: var(--tt-text);
        background: var(--tt-bg-hover);
      }
      .tt-label {
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--tt-text-faint);
      }
      .loading-spinner {
        border: 2px solid var(--tt-border);
        border-top-color: var(--tt-accent);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .slide-in-right {
        animation: slideInRight 0.25s ease-out;
      }
      @keyframes slideInRight {
        from { transform: translateX(8px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, memo, useRef } = React;

      // ─────────────────────────────────────────────────────────────
      // Constants
      // ─────────────────────────────────────────────────────────────
      const API_BASE = "https://timed-trading-ingest.shashant.workers.dev";
      // API_KEY removed for security - write operations disabled for public access
      // To enable trade management, implement proper authentication
      const TRADE_SIZE = 1000; // $1000 per trade
      const BASELINE_ACCOUNT = 100000; // starting account value for P&L display
      const FUTURES_TICKERS = new Set([
        "ES",
        "NQ",
        "YM",
        "RTY",
        "CL",
        "GC",
        "SI",
        "HG",
        "NG",
      ]);

      // Futures contract specifications (point value per contract) - matches worker
      const FUTURES_SPECS = {
        "ES1!": { pointValue: 50, name: "E-mini S&P 500" },
        "NQ1!": { pointValue: 20, name: "E-mini Nasdaq-100" },
        "MES1!": { pointValue: 5, name: "Micro E-mini S&P 500" },
        "MNQ1!": { pointValue: 2, name: "Micro E-mini Nasdaq-100" },
        "YM1!": { pointValue: 5, name: "E-mini Dow" },
        "RTY1!": { pointValue: 50, name: "E-mini Russell 2000" },
        ES: { pointValue: 50, name: "E-mini S&P 500" },
        NQ: { pointValue: 20, name: "E-mini Nasdaq-100" },
        YM: { pointValue: 5, name: "E-mini Dow" },
      };

      const USD_FMT = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        maximumFractionDigits: 2,
      });
      const INT_FMT = new Intl.NumberFormat("en-US");

      function fmtUsd(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return "—";
        return USD_FMT.format(n);
      }

      function fmtInt(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return "—";
        return INT_FMT.format(n);
      }

      // Normalize API ts to ms (entry_ts/exit_ts may be seconds from older data)
      function tsToMs(ts) {
        const n = Number(ts);
        if (!Number.isFinite(n)) return null;
        return n < 1e12 ? n * 1000 : n;
      }

      function resolveDirection(src) {
        const direct = String(src?.direction || "").toUpperCase();
        if (direct === "LONG" || direct === "SHORT") return direct;
        const state = String(src?.state || "");
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        const triggerDir = String(src?.trigger_dir || "").toUpperCase();
        if (triggerDir.includes("BULL")) return "LONG";
        if (triggerDir.includes("BEAR")) return "SHORT";
        return null;
      }

      function computeEntryRef(src) {
        const entryRef = Number(src?.entry_ref);
        if (Number.isFinite(entryRef) && entryRef > 0) return entryRef;
        const trigger = Number(src?.trigger_price);
        if (Number.isFinite(trigger) && trigger > 0) return trigger;
        const entryPrice = Number(src?.entryPrice);
        if (Number.isFinite(entryPrice) && entryPrice > 0) return entryPrice;
        const price = Number(src?.price ?? src?.currentPrice);
        return Number.isFinite(price) && price > 0 ? price : null;
      }

      function computeTpTargetPrice(src) {
        const directTarget = Number(src?.tp_target_price ?? src?.tp_target);
        if (Number.isFinite(directTarget) && directTarget > 0)
          return directTarget;
        const tp = Number(src?.tp);
        if (Number.isFinite(tp) && tp > 0) return tp;
        return null;
      }

      function computeTpMaxPrice(src) {
        const directMax = Number(src?.tp_max_price ?? src?.tp_max);
        if (Number.isFinite(directMax) && directMax > 0) return directMax;
        const entry = computeEntryRef(src);
        if (!Number.isFinite(entry)) return null;
        const dir = resolveDirection(src);
        const tpLevels = Array.isArray(src?.tp_levels) ? src.tp_levels : [];
        const candidates = tpLevels
          .map((tp) => {
            const price =
              tp && typeof tp === "object" && tp.price != null
                ? Number(tp.price)
                : Number(tp);
            return Number.isFinite(price) ? price : null;
          })
          .filter((p) => Number.isFinite(p));
        if (candidates.length === 0) return null;
        if (dir === "LONG") {
          const valid = candidates.filter((p) => p > entry);
          return valid.length > 0 ? Math.max(...valid) : null;
        }
        if (dir === "SHORT") {
          const valid = candidates.filter((p) => p < entry);
          return valid.length > 0 ? Math.min(...valid) : null;
        }
        return null;
      }

      function getIngestMs(src) {
        const raw = src?.ingest_ts ?? src?.ingest_time ?? src?.ts;
        if (raw == null) return null;
        const msRaw =
          typeof raw === "number" ? raw : new Date(String(raw)).getTime();
        // Heuristic: if seconds, convert to ms
        const ms =
          typeof msRaw === "number" && msRaw > 0 && msRaw < 1e12
            ? msRaw * 1000
            : msRaw;
        return Number.isFinite(ms) ? ms : null;
      }

      function getNyClock(now = new Date()) {
        try {
          const parts = new Intl.DateTimeFormat("en-US", {
            timeZone: "America/New_York",
            weekday: "short",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          }).formatToParts(now);
          const get = (type) => parts.find((p) => p.type === type)?.value;
          const weekday = get("weekday") || "";
          const hour = Number(get("hour"));
          const minute = Number(get("minute"));
          return {
            weekday,
            hour: Number.isFinite(hour) ? hour : null,
            minute: Number.isFinite(minute) ? minute : null,
          };
        } catch {
          return { weekday: "", hour: null, minute: null };
        }
      }

      function isNyRegularMarketOpen(now = new Date()) {
        const { weekday, hour, minute } = getNyClock(now);
        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return true; // fail open
        const wd = String(weekday || "").toLowerCase();
        const isWeekday =
          wd.startsWith("mon") ||
          wd.startsWith("tue") ||
          wd.startsWith("wed") ||
          wd.startsWith("thu") ||
          wd.startsWith("fri");
        if (!isWeekday) return false;
        const mins = hour * 60 + minute;
        const open = 9 * 60 + 30;
        const close = 16 * 60;
        return mins >= open && mins <= close;
      }

      function ageLabelFromMinutes(ageMin) {
        const m = Number(ageMin);
        if (!Number.isFinite(m) || m < 0) return null;
        if (m >= 60 * 24) return `${Math.round(m / (60 * 24))}d`;
        if (m >= 120) return `${Math.round(m / 60)}h`;
        return `${Math.round(m)}m`;
      }

      function getStaleInfo(src, { maxAgeMin = 90 } = {}) {
        const staleness = String(src?.staleness || "").toUpperCase();
        const ingestMs = getIngestMs(src);
        const ageMin = Number.isFinite(ingestMs)
          ? (Date.now() - ingestMs) / 60000
          : null;
        const staleByFlag = staleness && staleness !== "FRESH";
        const staleByAge = Number.isFinite(ageMin) && ageMin > maxAgeMin;
        const isStale = !!(staleByFlag || staleByAge);
        return {
          staleness: staleness || null,
          ingestMs,
          ageMin: Number.isFinite(ageMin) ? ageMin : null,
          ageLabel: ageLabelFromMinutes(ageMin),
          staleByFlag: !!staleByFlag,
          staleByAge: !!staleByAge,
          isStale,
        };
      }

      function getDailyChange(t) {
        const marketOpen = isNyRegularMarketOpen();
        const maxAgeMin = marketOpen ? 90 : 72 * 60;
        const stale = getStaleInfo(t, { maxAgeMin });
        if (stale.isStale && (marketOpen || stale.staleByFlag)) {
          return { dayChg: null, dayPct: null, stale, marketOpen };
        }
        const price = Number(t?.price);
        const pickNum = (obj, keys) => {
          for (const k of keys) {
            const v = Number(obj?.[k]);
            if (Number.isFinite(v)) return v;
          }
          return null;
        };
        const prevClose = pickNum(t, [
          "prev_close",
          "previous_close",
          "prior_close",
          "yclose",
          "close_prev",
        ]);
        let dayChg = pickNum(t, [
          "day_change",
          "daily_change",
          "change",
          "session_change",
          "chg",
          "ch",
        ]);
        let dayPct = pickNum(t, [
          "day_change_pct",
          "daily_change_pct",
          "change_pct",
          "pct_change",
          "session_change_pct",
          "chp",
        ]);
        if (
          !Number.isFinite(dayChg) &&
          !Number.isFinite(dayPct) &&
          Number.isFinite(price) &&
          price > 0 &&
          Number.isFinite(prevClose) &&
          prevClose > 0
        ) {
          dayChg = price - prevClose;
          dayPct = (dayChg / prevClose) * 100;
        }
        if (
          !Number.isFinite(dayChg) &&
          Number.isFinite(dayPct) &&
          Number.isFinite(price) &&
          price > 0
        ) {
          const p = dayPct / 100;
          if (Number.isFinite(p) && Math.abs(p) < 5) {
            const prev = price / (1 + p);
            const abs = price - prev;
            dayChg = Number.isFinite(abs) ? abs : null;
          }
        }
        if (
          !Number.isFinite(dayPct) &&
          Number.isFinite(dayChg) &&
          Number.isFinite(price) &&
          price > 0
        ) {
          const prev = price - dayChg;
          if (Number.isFinite(prev) && Math.abs(prev) > 1e-9) {
            dayPct = (dayChg / prev) * 100;
          }
        }
        return { dayChg, dayPct, stale, marketOpen };
      }

      function computeReturnPct(src) {
        const direct =
          Number(src?.expected_return_pct) ||
          Number(src?.tp_target_pct) ||
          Number(src?.tp_max_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(src);
        const tpTarget = computeTpTargetPrice(src) ?? computeTpMaxPrice(src);
        if (!Number.isFinite(entry) || !Number.isFinite(tpTarget)) return null;
        return (Math.abs(tpTarget - entry) / entry) * 100;
      }

      function computeRiskPct(src) {
        const direct = Number(src?.risk_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(src);
        const sl = Number(src?.sl);
        if (!Number.isFinite(entry) || !Number.isFinite(sl)) return null;
        return (Math.abs(entry - sl) / entry) * 100;
      }

      function computeEtaDays(src) {
        const staleness = String(src?.staleness || "").toUpperCase();
        if (staleness && staleness !== "FRESH") return null;
        const baseEta = Number(src?.eta_days_v2 ?? src?.eta_days);
        if (!Number.isFinite(baseEta) || baseEta <= 0) return null;
        const dir = resolveDirection(src);
        const entry = computeEntryRef(src);
        const target = computeTpTargetPrice(src);
        const current = Number(src?.price ?? src?.currentPrice);
        if (
          !Number.isFinite(entry) ||
          !Number.isFinite(target) ||
          !Number.isFinite(current) ||
          !dir
        ) {
          return baseEta;
        }
        const totalDist = Math.abs(target - entry);
        if (!Number.isFinite(totalDist) || totalDist <= 0) return baseEta;
        const progress =
          dir === "LONG"
            ? (current - entry) / (target - entry)
            : (entry - current) / (entry - target);
        if (!Number.isFinite(progress)) return baseEta;
        const clamped = Math.max(0, Math.min(1, progress));
        const remaining = baseEta * (1 - clamped);
        return Math.max(0.1, Math.round(remaining * 100) / 100);
      }

      function computeHorizonBucket(src) {
        const bucket = String(src?.horizon_bucket || "")
          .trim()
          .toUpperCase();
        if (bucket) return bucket.replace("_", " ");
        const eta = computeEtaDays(src);
        if (!Number.isFinite(eta)) return "—";
        if (eta <= 7) return "SHORT TERM";
        if (eta <= 30) return "SWING";
        return "POSITIONAL";
      }

      function computeHorizonKey(src) {
        const bucket = String(src?.horizon_bucket || "")
          .trim()
          .toUpperCase();
        if (bucket) return bucket;
        const eta = computeEtaDays(src);
        if (!Number.isFinite(eta)) return "UNKNOWN";
        if (eta <= 7) return "SHORT_TERM";
        if (eta <= 30) return "SWING";
        return "POSITIONAL";
      }

      // ─────────────────────────────────────────────────────────────
      // Hooks
      // ─────────────────────────────────────────────────────────────
      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);
        const hasLoadedRef = React.useRef(false);

        const fetchData = useCallback(async () => {
          try {
            if (!hasLoadedRef.current) setLoading(true);
            setRefreshing(true);
            setError(null);
            const timestamp = Date.now();
            const res = await fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache, no-store, must-revalidate",
                Pragma: "no-cache",
                Expires: "0",
              },
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && json.data) {
              setData(json.data);
              setLastUpdate(new Date());
              hasLoadedRef.current = true;
            } else {
              throw new Error(json.error || "Invalid response");
            }
          } catch (err) {
            setError(err.message);
            console.error("Fetch error:", err);
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 30000); // Refresh every 30 seconds (keep prices fresh)
          return () => clearInterval(interval);
        }, [fetchData]);

        return {
          data,
          loading,
          refreshing,
          error,
          lastUpdate,
          refetch: fetchData,
        };
      }

      function useSimulatedTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const hasLoadedRef = React.useRef(false);

        // Fetch trades from Worker
        const fetchTrades = useCallback(async (version = null) => {
          try {
            if (!hasLoadedRef.current) setLoading(true);
            setRefreshing(true);
            setError(null);
            const ts = Date.now();
            // Prefer D1 positions so trades include history[] (execution timeline)
            const source = "positions";
            const baseUrl = version
              ? `${API_BASE}/timed/trades?source=${source}&version=${encodeURIComponent(version)}`
              : `${API_BASE}/timed/trades?source=${source}`;
            const url = `${baseUrl}&_t=${ts}`;
            console.log(`[UI] Fetching trades from ${url}`);
            const res = await fetch(url, {
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache, no-store, must-revalidate",
                Pragma: "no-cache",
                Expires: "0",
              },
            });
            console.log(`[UI] Response status: ${res.status}, ok: ${res.ok}`);
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[UI] HTTP ${res.status} error:`, errorText);
              throw new Error(
                `HTTP ${res.status}: ${errorText.substring(0, 100)}`,
              );
            }
            const json = await res.json();
            console.log(`[UI] Response:`, {
              ok: json.ok,
              count: json.count,
              totalCount: json.totalCount,
              tradesLength: json.trades?.length,
              versions: json.versions,
            });
            if (json.ok && Array.isArray(json.trades)) {
              console.log(`[UI] ✅ Setting ${json.trades.length} trades`);
              setTrades(json.trades);
              hasLoadedRef.current = true;
            } else {
              console.error(`[UI] ❌ Invalid response:`, json);
              setTrades([]); // Set empty array instead of throwing
              throw new Error(json.error || "Invalid response format");
            }
          } catch (err) {
            setError(err.message);
            console.error("[UI] Fetch trades error:", err);
            setTrades([]); // Ensure trades is set to empty array on error
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        // Load trades on mount
        useEffect(() => {
          fetchTrades();
        }, [fetchTrades]);

        // Save trade to Worker - DISABLED for public access (security)
        const saveTrade = useCallback(async (trade) => {
          throw new Error(
            "Trade management is disabled for public access. This is a read-only dashboard.",
          );
        }, []);

        const addTrade = useCallback(
          async (trade) => {
            await saveTrade(trade);
          },
          [saveTrade],
        );

        const updateTrade = useCallback(
          async (tradeId, updates) => {
            const existingTrade = trades.find((t) => t.id === tradeId);
            if (!existingTrade) {
              console.error("Trade not found:", tradeId);
              return;
            }
            const updatedTrade = { ...existingTrade, ...updates };
            await saveTrade(updatedTrade);
          },
          [trades, saveTrade],
        );

        return {
          trades,
          loading,
          refreshing,
          error,
          addTrade,
          updateTrade,
          refetch: fetchTrades,
        };
      }

      // Paper portfolio (Kanban-driven executions)
      function usePaperPortfolio() {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);

        const fetchPortfolio = useCallback(async () => {
          try {
            setRefreshing(true);
            setError(null);
            const ts = Date.now();
            const url = `${API_BASE}/timed/portfolio?_t=${ts}`;
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "portfolio_failed");
            setData(json);
            setLastUpdate(new Date());
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        useEffect(() => {
          fetchPortfolio();
          const interval = setInterval(fetchPortfolio, 30000);
          return () => clearInterval(interval);
        }, [fetchPortfolio]);

        return {
          data,
          loading,
          refreshing,
          error,
          lastUpdate,
          refetch: fetchPortfolio,
        };
      }

      // ─────────────────────────────────────────────────────────────
      // Ledger (D1) Hooks
      // ─────────────────────────────────────────────────────────────

      function useLedgerSummary({ since = null, until = null } = {}) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSummary = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const qs = new URLSearchParams();
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            const url = `${API_BASE}/timed/ledger/summary?${qs.toString()}`;
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok)
              throw new Error(json.error || "ledger_summary_failed");
            setData(json);
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
          }
        }, [since, until]);

        useEffect(() => {
          fetchSummary();
        }, [fetchSummary]);

        return { data, loading, error, refetch: fetchSummary };
      }

      function useLedgerTrades({
        ticker = "",
        status = "all",
        since = null,
        until = null,
        pageSize = 200,
      } = {}) {
        const [items, setItems] = useState([]);
        const [loading, setLoading] = useState(true);
        const [loadingMore, setLoadingMore] = useState(false);
        const [error, setError] = useState(null);
        const [hasMore, setHasMore] = useState(false);
        const [cursor, setCursor] = useState(null);

        const buildUrl = useCallback(
          (cursorVal) => {
            const qs = new URLSearchParams();
            if (ticker) qs.set("ticker", ticker);
            if (status && status !== "all") qs.set("status", status);
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            qs.set("limit", String(pageSize));
            if (cursorVal) qs.set("cursor", String(cursorVal));
            return `${API_BASE}/timed/ledger/trades?${qs.toString()}`;
          },
          [ticker, status, since, until, pageSize],
        );

        const fetchFirstPage = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(buildUrl(null), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_trades_failed");
            const trades = Array.isArray(json.trades) ? json.trades : [];
            setItems(trades);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
            setItems([]);
            setHasMore(false);
            setCursor(null);
          } finally {
            setLoading(false);
          }
        }, [buildUrl]);

        const fetchMore = useCallback(async () => {
          if (!cursor || loadingMore) return;
          try {
            setLoadingMore(true);
            const res = await fetch(buildUrl(cursor), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_trades_failed");
            const trades = Array.isArray(json.trades) ? json.trades : [];
            setItems((prev) => [...prev, ...trades]);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
          } finally {
            setLoadingMore(false);
          }
        }, [buildUrl, cursor, loadingMore]);

        useEffect(() => {
          fetchFirstPage();
        }, [fetchFirstPage]);

        return {
          items,
          loading,
          loadingMore,
          error,
          hasMore,
          fetchMore,
          refetch: fetchFirstPage,
        };
      }

      function useLedgerAlerts({
        ticker = "",
        since = null,
        until = null,
        pageSize = 200,
      } = {}) {
        const [items, setItems] = useState([]);
        const [loading, setLoading] = useState(true);
        const [loadingMore, setLoadingMore] = useState(false);
        const [error, setError] = useState(null);
        const [hasMore, setHasMore] = useState(false);
        const [cursor, setCursor] = useState(null);

        const buildUrl = useCallback(
          (cursorVal) => {
            const qs = new URLSearchParams();
            if (ticker) qs.set("ticker", ticker);
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            qs.set("limit", String(pageSize));
            if (cursorVal) qs.set("cursor", String(cursorVal));
            return `${API_BASE}/timed/ledger/alerts?${qs.toString()}`;
          },
          [ticker, since, until, pageSize],
        );

        const fetchFirstPage = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(buildUrl(null), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_alerts_failed");
            const alerts = Array.isArray(json.alerts) ? json.alerts : [];
            setItems(alerts);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
            setItems([]);
            setHasMore(false);
            setCursor(null);
          } finally {
            setLoading(false);
          }
        }, [buildUrl]);

        const fetchMore = useCallback(async () => {
          if (!cursor || loadingMore) return;
          try {
            setLoadingMore(true);
            const res = await fetch(buildUrl(cursor), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_alerts_failed");
            const alerts = Array.isArray(json.alerts) ? json.alerts : [];
            setItems((prev) => [...prev, ...alerts]);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
          } finally {
            setLoadingMore(false);
          }
        }, [buildUrl, cursor, loadingMore]);

        useEffect(() => {
          fetchFirstPage();
        }, [fetchFirstPage]);

        return {
          items,
          loading,
          loadingMore,
          error,
          hasMore,
          fetchMore,
          refetch: fetchFirstPage,
        };
      }

      function useLedgerTradeDetail(tradeId, includeEvidence = false) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);

        const fetchDetail = useCallback(async () => {
          if (!tradeId) {
            setData(null);
            setError(null);
            return;
          }
          try {
            setLoading(true);
            setError(null);
            const qs = includeEvidence ? "?includeEvidence=1" : "";
            const res = await fetch(
              `${API_BASE}/timed/ledger/trades/${encodeURIComponent(tradeId)}${qs}`,
              { cache: "no-store" },
            );
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok)
              throw new Error(json.error || "ledger_trade_detail_failed");
            setData(json);
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
          }
        }, [tradeId, includeEvidence]);

        useEffect(() => {
          fetchDetail();
        }, [fetchDetail]);

        return { data, loading, error, refetch: fetchDetail };
      }

      function useSectors() {
        const [sectors, setSectors] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSectors = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/sectors`, {
              cache: "no-store",
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.sectors)) {
              setSectors(json.sectors);
            } else {
              setSectors([]);
            }
          } catch (err) {
            setError(err.message);
            setSectors([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchSectors();
          const interval = setInterval(fetchSectors, 300000);
          return () => clearInterval(interval);
        }, [fetchSectors]);

        return { sectors, loading, error, refetch: fetchSectors };
      }

      // ─────────────────────────────────────────────────────────────
      // Trade Simulation Logic
      // ─────────────────────────────────────────────────────────────
      function shouldTriggerTrade(ticker, prevData) {
        // Skip futures
        if (FUTURES_TICKERS.has(ticker.ticker.toUpperCase())) return false;

        // Must have valid entry/exit levels
        if (!ticker.price || !ticker.sl || !ticker.tp) return false;

        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const alignedLong = state === "HTF_BULL_LTF_BULL";
        const alignedShort = state === "HTF_BEAR_LTF_BEAR";
        const aligned = alignedLong || alignedShort;
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        const side = ent.side; // LONG or SHORT

        // Corridor must match alignment
        const corridorAlignedOK =
          (side === "LONG" && alignedLong) ||
          (side === "SHORT" && alignedShort);

        if (!inCorridor || !corridorAlignedOK) return false;

        // Check for trigger conditions (matches worker logic)
        const enteredAligned = prevData && prevData.state !== state && aligned;
        const trigReason = String(ticker.trigger_reason || "");
        const trigOk =
          trigReason === "EMA_CROSS" || trigReason === "SQUEEZE_RELEASE";
        const sqRelease = !!flags.sq30_release;
        const hasTrigger = !!ticker.trigger_price && !!ticker.trigger_ts;

        // Must be: in corridor + corridor aligns + (entered aligned OR trigger OR squeeze release)
        const shouldConsiderAlert =
          inCorridor &&
          corridorAlignedOK &&
          (enteredAligned || trigOk || sqRelease || hasTrigger);

        // Check Momentum Elite status
        const momentumElite = !!flags.momentum_elite;

        // Threshold gates (with Momentum Elite adjustments - matching worker logic)
        const baseMinRR = 1.5;
        const baseMaxComp = 0.4;
        const baseMaxPhase = 0.6;
        const baseMinRank = 70;

        // Adjust thresholds for Momentum Elite (more lenient for quality stocks)
        const minRR = momentumElite
          ? Math.max(1.2, baseMinRR * 0.9)
          : baseMinRR; // Lower RR requirement
        const maxComp = momentumElite
          ? Math.min(0.5, baseMaxComp * 1.25)
          : baseMaxComp; // Allow higher completion
        const maxPhase = momentumElite
          ? Math.min(0.7, baseMaxPhase * 1.17)
          : baseMaxPhase; // Allow higher phase
        const minRank = momentumElite
          ? Math.max(60, baseMinRank - 10)
          : baseMinRank; // Lower rank requirement

        const rr = Number(ticker.rr) || 0;
        const comp = Number(ticker.completion) || 0;
        const phase = Number(ticker.phase_pct) || 0;
        const rank = Number(ticker.rank) || 0;

        const rrOk = rr >= minRR;
        const compOk = comp <= maxComp;
        const phaseOk = phase <= maxPhase;
        const rankOk = rank >= minRank;

        // Also consider Momentum Elite as a trigger condition (quality signal)
        const momentumEliteTrigger =
          momentumElite && inCorridor && corridorAlignedOK;

        // Enhanced trigger: original conditions OR Momentum Elite in good setup
        const enhancedTrigger = shouldConsiderAlert || momentumEliteTrigger;

        return enhancedTrigger && rrOk && compOk && phaseOk && rankOk;
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
        const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL"))
          return {
            text: "LONG",
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        if (state.includes("BEAR"))
          return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: null, color: "text-[var(--tt-text-muted)]", bg: "bg-[var(--tt-bg-elevated)]" };
      }

      function calculateTrade(ticker, entryPrice, existingTrade = null) {
        const directionObj = getDirection(ticker);
        const direction = directionObj.text;
        if (!direction) return null;

        const sl = Number(ticker.sl);
        const tp = Number(ticker.tp);
        const currentPrice = Number(ticker.price);

        if (
          !Number.isFinite(sl) ||
          !Number.isFinite(tp) ||
          !Number.isFinite(currentPrice)
        ) {
          return null;
        }

        // Determine if this is a futures contract
        const tickerSymbol = String(ticker.ticker || "").toUpperCase();
        const isFutures =
          FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");

        // For futures: trade 1 contract, calculate P&L based on point value
        // For stocks: calculate shares based on dollar amount
        let shares;
        let pointValue = 1; // Default for stocks (price per share)

        if (isFutures && FUTURES_SPECS[tickerSymbol]) {
          // Futures: always trade 1 contract
          shares = 1;
          pointValue = FUTURES_SPECS[tickerSymbol].pointValue;
        } else {
          // Stocks: calculate shares from dollar amount
          shares = TRADE_SIZE / entryPrice;
        }

        // Calculate P&L based on current price
        let pnl = 0;
        let pnlPct = 0;
        let status = "OPEN";

        // Check for partial trim (if position was already trimmed)
        const trimmedPct = existingTrade ? existingTrade.trimmedPct || 0 : 0;
        const remainingShares = shares * (1 - trimmedPct);

        // Calculate price differences (in points for futures, dollars for stocks)
        const priceDiff = currentPrice - entryPrice;
        const tpDiff = tp - entryPrice;
        const slDiff = sl - entryPrice;

        if (direction === "LONG") {
          // Check if hit TP or SL first
          const hitTP = currentPrice >= tp;
          const hitSL = currentPrice <= sl;

          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const trimPnl = tpDiff * shares * pointValue * 0.5;
              const trimPnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              pnl = tpDiff * shares * pointValue;
              pnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            pnl = slDiff * shares * pointValue;
            pnlPct = ((sl - entryPrice) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            pnl = priceDiff * shares * pointValue;
            pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        } else {
          // SHORT
          // Check if hit TP or SL first
          const hitTP = currentPrice <= tp;
          const hitSL = currentPrice >= sl;

          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const shortTpDiff = entryPrice - tp;
              const trimPnl = shortTpDiff * shares * pointValue * 0.5;
              const trimPnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              const shortTpDiff = entryPrice - tp;
              pnl = shortTpDiff * shares * pointValue;
              pnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            const shortSlDiff = entryPrice - sl;
            pnl = shortSlDiff * shares * pointValue;
            pnlPct = ((entryPrice - sl) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            const shortPriceDiff = entryPrice - currentPrice;
            pnl = shortPriceDiff * shares * pointValue;
            pnlPct = ((entryPrice - currentPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        }

        return {
          shares,
          pnl,
          pnlPct,
          status,
          currentPrice,
        };
      }

      // ─────────────────────────────────────────────────────────────
      // Trade Tracking
      // ─────────────────────────────────────────────────────────────
      // Trade simulation is now handled by Worker - UI just fetches and displays
      // No need for useTradeSimulation hook anymore - Worker handles everything

      // ─────────────────────────────────────────────────────────────
      // Analytics & Learning
      // ─────────────────────────────────────────────────────────────
      function useTradeAnalytics(trades) {
        return useMemo(() => {
          const EPS = 1e-6;

          const clamp01 = (x) => Math.max(0, Math.min(1, x));
          const smoothWinRate = (wins, losses) => {
            // Laplace smoothing (prevents noisy 1/1 = 100% claims)
            const w = Number(wins || 0);
            const l = Number(losses || 0);
            const n = w + l;
            return n > 0 ? (w + 1) / (n + 2) : 0;
          };
          const confidenceLabel = (n) => {
            if (n >= 30) return "high";
            if (n >= 10) return "medium";
            if (n >= 5) return "low";
            return "very low";
          };
          const getExitReason = (trade) => {
            if (!trade) return null;
            if (trade.exitReason) return String(trade.exitReason);
            const hist = trade.history;
            if (Array.isArray(hist)) {
              for (let i = hist.length - 1; i >= 0; i--) {
                const e = hist[i];
                if (e && e.type === "EXIT") {
                  if (e.reason) return String(e.reason);
                  const note = String(e.note || "");
                  const m = note.match(/\(([^)]+)\)\s*$/);
                  if (m && m[1]) return String(m[1]);
                }
              }
            }
            return null;
          };
          const hasTrimEvent = (trade) => {
            if (!trade) return false;
            if ((Number(trade.trimmedPct) || 0) > EPS) return true;
            const hist = trade.history;
            return (
              Array.isArray(hist) && hist.some((e) => e && e.type === "TRIM")
            );
          };

          const horizonKeyForTrade = (trade) => {
            if (!trade) return "UNKNOWN";
            return computeHorizonKey(trade);
          };

          const computeExcursions = (trade) => {
            if (!trade) return null;
            const entry = Number(trade.entryPrice);
            if (!Number.isFinite(entry) || entry <= 0) return null;
            const prices = [entry];
            if (Array.isArray(trade.history)) {
              trade.history.forEach((e) => {
                if (e && Number.isFinite(Number(e.price))) {
                  prices.push(Number(e.price));
                }
              });
            }
            const exit = Number(trade.exitPrice ?? trade.exit_price);
            if (Number.isFinite(exit)) prices.push(exit);
            const current = Number(trade.currentPrice);
            if (Number.isFinite(current)) prices.push(current);
            const maxP = Math.max(...prices);
            const minP = Math.min(...prices);
            const isLong =
              String(trade.direction || "").toUpperCase() !== "SHORT";
            const mfe = isLong ? maxP - entry : entry - minP;
            const mae = isLong ? entry - minP : maxP - entry;
            const mfePct = (mfe / entry) * 100;
            const maePct = (mae / entry) * 100;
            return {
              mfe: Number.isFinite(mfe) ? mfe : null,
              mae: Number.isFinite(mae) ? mae : null,
              mfePct: Number.isFinite(mfePct) ? mfePct : null,
              maePct: Number.isFinite(maePct) ? maePct : null,
            };
          };

          // Helper to check if trade has remaining shares/contracts (not fully closed)
          const hasRemainingShares = (t) => {
            const tickerSym = String(t.ticker || "").toUpperCase();
            const isFut = FUTURES_SPECS[tickerSym] || tickerSym.endsWith("1!");
            const shares =
              t.shares ||
              (isFut && FUTURES_SPECS[tickerSym]
                ? 1
                : TRADE_SIZE / (t.entryPrice || 1));
            const trimmedPct = t.trimmedPct || 0;
            const remainingShares = shares - shares * trimmedPct;
            return remainingShares > 0;
          };

          // Trimmed trades: positions that have been partially trimmed (check trimmedPct > 0 OR status TP_HIT_TRIM)
          // AND still have remaining shares (not fully closed)
          const trimmed = trades.filter((t) => {
            const trimmedPct = t.trimmedPct || 0;
            const isTrimmed = trimmedPct > 0 || t.status === "TP_HIT_TRIM";
            return isTrimmed && hasRemainingShares(t);
          });

          // Closed trades: positions with WIN or LOSS status (regardless of remaining shares)
          // Note: If status is WIN/LOSS, the trade is considered closed for analytics purposes
          const closed = trades.filter((t) => {
            return t.status === "WIN" || t.status === "LOSS";
          });

          // Open trades: currently open positions that haven't been trimmed yet
          const open = trades.filter((t) => {
            const trimmedPct = t.trimmedPct || 0;
            const isTrimmed = trimmedPct > 0 || t.status === "TP_HIT_TRIM";
            const isClosed =
              (t.status === "WIN" || t.status === "LOSS") &&
              !hasRemainingShares(t);
            return (
              (t.status === "OPEN" || !t.status) && !isTrimmed && !isClosed
            );
          });

          const openTrades = open.length;
          const trimmedTrades = trimmed.length;
          const closedTrades = closed.length;
          const totalTrades = openTrades + trimmedTrades + closedTrades; // Sum of all categories

          const wins = closed.filter((t) => t.status === "WIN").length;
          const losses = closed.filter((t) => t.status === "LOSS").length;
          const winRate = closedTrades > 0 ? (wins / closedTrades) * 100 : 0;

          // Calculate Closed P&L: includes fully closed trades + realized P&L from trimmed positions
          const closedPnl = closed.reduce((sum, t) => sum + (t.pnl || 0), 0);

          // Calculate realized P&L from trimmed positions
          const trimmedRealizedPnl = trimmed.reduce((sum, t) => {
            const tickerSym = String(t.ticker || "").toUpperCase();
            const isFut = FUTURES_SPECS[tickerSym] || tickerSym.endsWith("1!");
            const pointVal =
              isFut && FUTURES_SPECS[tickerSym]
                ? FUTURES_SPECS[tickerSym].pointValue
                : 1;
            const shares =
              t.shares ||
              (isFut && FUTURES_SPECS[tickerSym]
                ? 1
                : TRADE_SIZE / (t.entryPrice || 1));
            const trimmedPct = t.trimmedPct || 0;
            const trimmedShares = shares * trimmedPct;
            const entryPrice = t.entryPrice || 0;
            const tp = t.tp || entryPrice; // Use TP price where trimmed occurred

            if (trimmedShares > 0 && entryPrice > 0) {
              const direction = t.direction || "LONG";
              if (direction === "LONG") {
                // LONG: profit = (TP - Entry) * trimmed shares * point value
                const priceDiff = tp - entryPrice;
                return sum + priceDiff * trimmedShares * pointVal;
              } else {
                // SHORT: profit = (Entry - TP) * trimmed shares * point value
                const priceDiff = entryPrice - tp;
                return sum + priceDiff * trimmedShares * pointVal;
              }
            }
            return sum;
          }, 0);

          // Total Closed P&L = fully closed + trimmed realized
          const totalPnl = closedPnl + trimmedRealizedPnl;

          // Open P&L: unrealized P&L from open positions (including remaining shares in trimmed positions)
          const openPnl = [...open, ...trimmed].reduce((sum, t) => {
            const shares = t.shares || TRADE_SIZE / (t.entryPrice || 1); // Allow fractional shares
            const trimmedPct = t.trimmedPct || 0;
            const remainingShares = shares - shares * trimmedPct; // Allow fractional shares
            const entryPrice = t.entryPrice || 0;
            const currentPrice = t.currentPrice || entryPrice;

            if (remainingShares > 0 && entryPrice > 0) {
              const direction = t.direction || "LONG";
              if (direction === "LONG") {
                return sum + (currentPrice - entryPrice) * remainingShares;
              } else {
                return sum + (entryPrice - currentPrice) * remainingShares;
              }
            }
            return sum;
          }, 0);

          // Calculate average win/loss
          const winningTrades = closed.filter((t) => t.status === "WIN");
          const losingTrades = closed.filter((t) => t.status === "LOSS");
          const avgWin =
            winningTrades.length > 0
              ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) /
                winningTrades.length
              : 0;
          const avgLoss =
            losingTrades.length > 0
              ? losingTrades.reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0) /
                losingTrades.length
              : 0;
          const profitFactor =
            avgLoss > 0 ? avgWin / avgLoss : avgWin > 0 ? Infinity : 0;

          const excursionStats = closed
            .map((t) => computeExcursions(t))
            .filter(Boolean);
          const avgMfePct =
            excursionStats.length > 0
              ? excursionStats.reduce((s, x) => s + (x.mfePct || 0), 0) /
                excursionStats.length
              : 0;
          const avgMaePct =
            excursionStats.length > 0
              ? excursionStats.reduce((s, x) => s + (x.maePct || 0), 0) /
                excursionStats.length
              : 0;

          const capturedStats = closed
            .map((t) => {
              const entry = Number(t.entryPrice);
              const exit = Number(t.exitPrice ?? t.exit_price);
              const target = Number(t.tp_target_price ?? t.tp);
              if (
                !Number.isFinite(entry) ||
                !Number.isFinite(exit) ||
                !Number.isFinite(target)
              )
                return null;
              const isLong =
                String(t.direction || "").toUpperCase() !== "SHORT";
              const denom = isLong ? target - entry : entry - target;
              const num = isLong ? exit - entry : entry - exit;
              if (!Number.isFinite(denom) || Math.abs(denom) < EPS) return null;
              const pct = (num / denom) * 100;
              return Number.isFinite(pct) ? pct : null;
            })
            .filter((v) => Number.isFinite(v));
          const avgCapturedPct =
            capturedStats.length > 0
              ? capturedStats.reduce((s, v) => s + v, 0) / capturedStats.length
              : 0;

          const horizonStats = {};
          for (const t of closed) {
            const key = horizonKeyForTrade(t);
            if (!horizonStats[key]) {
              horizonStats[key] = {
                n: 0,
                wins: 0,
                losses: 0,
                totalPnl: 0,
                mfePct: 0,
                maePct: 0,
                capturedPct: 0,
                capturedN: 0,
              };
            }
            const bucket = horizonStats[key];
            bucket.n += 1;
            if (t.status === "WIN") bucket.wins += 1;
            if (t.status === "LOSS") bucket.losses += 1;
            bucket.totalPnl += Number(t.pnl || 0);
            const ex = computeExcursions(t);
            if (ex && Number.isFinite(ex.mfePct)) bucket.mfePct += ex.mfePct;
            if (ex && Number.isFinite(ex.maePct)) bucket.maePct += ex.maePct;
            const entry = Number(t.entryPrice);
            const exit = Number(t.exitPrice ?? t.exit_price);
            const target = Number(t.tp_target_price ?? t.tp);
            const isLong = String(t.direction || "").toUpperCase() !== "SHORT";
            if (
              Number.isFinite(entry) &&
              Number.isFinite(exit) &&
              Number.isFinite(target)
            ) {
              const denom = isLong ? target - entry : entry - target;
              const num = isLong ? exit - entry : entry - exit;
              if (Number.isFinite(denom) && Math.abs(denom) > EPS) {
                bucket.capturedPct += (num / denom) * 100;
                bucket.capturedN += 1;
              }
            }
          }

          Object.keys(horizonStats).forEach((key) => {
            const s = horizonStats[key];
            const n = Math.max(1, s.n);
            const winRateH = s.n > 0 ? (s.wins / s.n) * 100 : 0;
            const avgWinH =
              s.wins > 0
                ? closed
                    .filter(
                      (t) =>
                        horizonKeyForTrade(t) === key && t.status === "WIN",
                    )
                    .reduce((sum, t) => sum + (t.pnl || 0), 0) / s.wins
                : 0;
            const avgLossH =
              s.losses > 0
                ? closed
                    .filter(
                      (t) =>
                        horizonKeyForTrade(t) === key && t.status === "LOSS",
                    )
                    .reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0) /
                  s.losses
                : 0;
            s.winRate = winRateH;
            s.expectancy =
              (winRateH / 100) * avgWinH - (1 - winRateH / 100) * avgLossH;
            s.avgMfePct = s.mfePct / n;
            s.avgMaePct = s.maePct / n;
            s.avgCapturedPct =
              s.capturedN > 0 ? s.capturedPct / s.capturedN : 0;
          });

          // Analyze by signal combinations
          const signalAnalysis = {};
          closed.forEach((trade) => {
            const signals = [];
            if (trade.flags?.sq30_release) signals.push("SqueezeRelease");
            if (trade.flags?.sq30_on) signals.push("SqueezeOn");
            if (trade.flags?.phase_zone_change) signals.push("PhaseZoneChange");
            if (trade.inCorridor) signals.push("InCorridor");
            const key = signals.sort().join("+") || "None";

            if (!signalAnalysis[key]) {
              signalAnalysis[key] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") signalAnalysis[key].wins++;
            if (trade.status === "LOSS") signalAnalysis[key].losses++;
            signalAnalysis[key].totalPnl += trade.pnl || 0;
          });

          // Analyze by RR ranges
          const rrAnalysis = {};
          closed.forEach((trade) => {
            const rr = trade.rr || 0;
            let range = "Unknown";
            if (rr >= 2.0) range = "RR ≥ 2.0";
            else if (rr >= 1.5) range = "RR 1.5-2.0";
            else if (rr >= 1.0) range = "RR 1.0-1.5";
            else if (rr > 0) range = "RR < 1.0";

            if (!rrAnalysis[range]) {
              rrAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rrAnalysis[range].wins++;
            if (trade.status === "LOSS") rrAnalysis[range].losses++;
            rrAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Analyze by rank ranges
          const rankAnalysis = {};
          closed.forEach((trade) => {
            const rank = trade.rank || 0;
            let range = "Unknown";
            if (rank >= 80) range = "Rank ≥ 80";
            else if (rank >= 70) range = "Rank 70-80";
            else if (rank >= 60) range = "Rank 60-70";
            else if (rank > 0) range = "Rank < 60";

            if (!rankAnalysis[range]) {
              rankAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rankAnalysis[range].wins++;
            if (trade.status === "LOSS") rankAnalysis[range].losses++;
            rankAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Generate recommendations
          const recommendations = { filters: [], management: [] };

          const pushRec = (bucket, rec) => {
            if (!bucket || !recommendations[bucket]) return;
            recommendations[bucket].push(rec);
          };

          // Find best performing signal combinations
          const bestSignals = Object.entries(signalAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5) // Reduce noise
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              // Prefer higher winrate, then larger sample, then higher pnl
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })
            .slice(0, 3);

          if (bestSignals.length > 0) {
            const [sigKey, stats] = bestSignals[0];
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (wr >= 0.55 && n >= 5) {
              pushRec("filters", {
                type: "signal",
                priority: n >= 15 ? "high" : "medium",
                message: `Filters: Favor ${sigKey} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)} per trade, n=${n}, confidence ${confidenceLabel(n)})`,
              });
            }
          }

          // Find best RR range
          const bestRR = Object.entries(rrAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5)
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })[0];

          if (bestRR) {
            const [range, stats] = bestRR;
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (n >= 5 && (wr >= 0.52 || avgPnl > 0)) {
              pushRec("filters", {
                type: "rr",
                priority: n >= 15 ? "medium" : "low",
                message: `Filters: RR sweet spot looks like ${range} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)}, n=${n})`,
              });
            }
          }

          // Find best rank range
          const bestRank = Object.entries(rankAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5)
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })[0];

          if (bestRank) {
            const [range, stats] = bestRank;
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (n >= 5 && (wr >= 0.52 || avgPnl > 0)) {
              pushRec("filters", {
                type: "rank",
                priority: n >= 15 ? "medium" : "low",
                message: `Filters: Best rank bucket so far is ${range} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)}, n=${n})`,
              });
            }
          }

          // Profit factor recommendations - only show if we have enough closed trades to analyze
          if (profitFactor < 1.0 && closedTrades >= 10) {
            pushRec("filters", {
              type: "risk",
              priority: "high",
              message: `Profit factor is ${profitFactor.toFixed(2)}. Consider tightening stops or improving entry selection.`,
            });
          }

          // Win rate recommendations - only show if we have enough closed trades to analyze
          if (winRate < 40 && closedTrades >= 10) {
            pushRec("filters", {
              type: "filter",
              priority: "high",
              message: `Win rate is ${winRate.toFixed(1)}%. Consider raising minimum rank threshold or requiring squeeze release.`,
            });
          }

          // Management learning (post-entry): trims + exit reasons
          if (closedTrades >= 5) {
            const closedWithTrim = closed.filter((t) => hasTrimEvent(t));
            const closedNoTrim = closed.filter((t) => !hasTrimEvent(t));

            const summarize = (arr) => {
              const n = arr.length;
              const w = arr.filter((t) => t.status === "WIN").length;
              const l = arr.filter((t) => t.status === "LOSS").length;
              const wr = smoothWinRate(w, l);
              const totalP = arr.reduce((s, t) => s + (t.pnl || 0), 0);
              const avgP = n > 0 ? totalP / n : 0;
              return { n, w, l, wr, avgP };
            };

            const trimStats = summarize(closedWithTrim);
            const noTrimStats = summarize(closedNoTrim);
            if (trimStats.n >= 5 || noTrimStats.n >= 5) {
              const better =
                trimStats.n >= 5 && noTrimStats.n >= 5
                  ? trimStats.avgP - noTrimStats.avgP
                  : 0;
              if (
                trimStats.n >= 5 &&
                noTrimStats.n >= 5 &&
                Math.abs(better) > 1e-9
              ) {
                pushRec("management", {
                  type: "trim_vs_no_trim",
                  priority: "medium",
                  message: `Management: Trades with trims avg $${trimStats.avgP.toFixed(2)} (n=${trimStats.n}) vs no-trim avg $${noTrimStats.avgP.toFixed(2)} (n=${noTrimStats.n}). ${better > 0 ? "Trimming is helping." : "Trimming may be hurting."}`,
                });
              } else if (trimStats.n >= 5 && noTrimStats.n < 5) {
                pushRec("management", {
                  type: "trim_data",
                  priority: "low",
                  message: `Management: Most closed trades include trims (n=${trimStats.n}). Keep logging trims + exits to learn hold/trim improvements.`,
                });
              }
            }

            const exitReasonStats = {};
            closed.forEach((t) => {
              const r = getExitReason(t) || "UNKNOWN";
              if (!exitReasonStats[r])
                exitReasonStats[r] = { n: 0, wins: 0, losses: 0, pnl: 0 };
              exitReasonStats[r].n += 1;
              if (t.status === "WIN") exitReasonStats[r].wins += 1;
              if (t.status === "LOSS") exitReasonStats[r].losses += 1;
              exitReasonStats[r].pnl += t.pnl || 0;
            });

            const topExit = Object.entries(exitReasonStats)
              .filter(([_, s]) => s.n >= 3)
              .sort((a, b) => (b[1].pnl || 0) - (a[1].pnl || 0))[0];

            if (topExit) {
              const [reason, s] = topExit;
              const wr = smoothWinRate(s.wins, s.losses);
              const avgP = s.n > 0 ? (s.pnl || 0) / s.n : 0;
              pushRec("management", {
                type: "exit_reason",
                priority: reason === "SL" ? "high" : "low",
                message: `Management: Exit reason ${reason} avg $${avgP.toFixed(2)} (smoothed win rate ${(wr * 100).toFixed(1)}%, n=${s.n}).`,
              });
            }
          } else {
            pushRec("management", {
              type: "needs_data",
              priority: "low",
              message: `Management: Need more closed trades (currently n=${closedTrades}) to learn trim/exit improvements reliably.`,
            });
          }

          return {
            totalTrades,
            openTrades,
            trimmedTrades,
            closedTrades,
            wins,
            losses,
            winRate,
            totalPnl,
            openPnl,
            avgWin,
            avgLoss,
            profitFactor,
            avgMfePct,
            avgMaePct,
            avgCapturedPct,
            horizonStats,
            signalAnalysis,
            rrAnalysis,
            rankAnalysis,
            recommendations,
          };
        }, [trades]);
      }

      // ─────────────────────────────────────────────────────────────
      // Components
      // ─────────────────────────────────────────────────────────────
      // Format RR display (e.g., "2.10:1" or "1:2.10")
      function formatRR(rr) {
        if (!rr || !Number.isFinite(rr)) return "N/A";
        if (rr >= 1) {
          return `${rr.toFixed(2)}:1`;
        } else {
          return `1:${(1 / rr).toFixed(2)}`;
        }
      }

      // Trade History Component (entry, add entry, trim, exit with full details)
      function TradeHistory({ history = [], fmtUsd: fmt }) {
        const fmtUsd = fmt || (v => (Number.isFinite(Number(v)) ? new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(Number(v)) : "—"));
        if (!history || history.length === 0) {
          return (
            <div className="text-xs text-[var(--tt-text-faint)] italic p-2">
              No history available
            </div>
          );
        }

        const getEventIcon = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "📥";
          if (t === "SCALE_IN" || t === "ADD_ENTRY") return "➕";
          if (t === "TRIM") return "✂️";
          if (t === "EXIT") return "📤";
          return "•";
        };

        const getEventColor = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "text-[var(--tt-accent)]";
          if (t === "SCALE_IN" || t === "ADD_ENTRY") return "text-[var(--tt-text)]";
          if (t === "TRIM") return "text-[var(--tt-text-muted)]";
          if (t === "EXIT") return "text-[var(--tt-negative)]";
          return "text-[var(--tt-text-muted)]";
        };

        return (
          <div className="space-y-2 max-h-[400px] overflow-y-auto">
            {history.map((event, idx) => {
              const eventDate = new Date(event.timestamp);
              const formattedDate = eventDate.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
              });
              const formattedTime = eventDate.toLocaleTimeString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                hour12: true,
              });

              return (
                <div
                  key={idx}
                  className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-3"
                >
                  <div className="flex items-start gap-3">
                    <div className={`text-xl ${getEventColor(event.type)}`}>
                      {getEventIcon(event.type)}
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center justify-between mb-1">
                        <span
                          className={`text-sm font-semibold ${getEventColor(event.type)}`}
                        >
                          {event.type.replace("_", " ")}
                        </span>
                        <span className="text-xs text-[var(--tt-text-faint)]">
                          {formattedDate} {formattedTime}
                        </span>
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mb-2">
                        {event.note}
                      </div>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 text-xs">
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Price:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            ${Number(event.price).toFixed(2)}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Shares:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            {event.shares}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Value:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            ${Number(event.value).toFixed(2)}
                          </span>
                        </div>
                        {event.pnl_realized != null && Number.isFinite(Number(event.pnl_realized)) && (
                          <div className="sm:col-span-2">
                            <span className="text-[var(--tt-text-faint)]">Net P&L:</span>
                            <span className={`ml-1 font-semibold ${Number(event.pnl_realized) >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                              {fmtUsd(Number(event.pnl_realized))}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      // Ledger trade history (date asc): execution timeline with full details (type, date/time, qty, price, value, net P&L)
      function LedgerTradeHistory({ events = [], fmtUsd }) {
        if (!events || events.length === 0) {
          return (
            <div className="text-xs text-[var(--tt-text-faint)] italic p-3">
              No actions yet for this position.
            </div>
          );
        }
        const sorted = [...events].sort((a, b) => (a.ts || 0) - (b.ts || 0));
        const actionLabel = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "Entry";
          if (t === "ADD_ENTRY" || t === "SCALE_IN") return "Add entry";
          if (t === "TRIM") return "Trim";
          if (t === "EXIT") return "Exit";
          return t || "—";
        };
        return (
          <div className="space-y-3 max-h-[400px] overflow-y-auto">
            {sorted.map((ev, idx) => {
              const d = ev.ts != null ? new Date(Number(ev.ts)) : null;
              const dateStr = d ? d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "—";
              const timeStr = d ? d.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit", hour12: true }) : "—";
              const t = ev.trade || {};
              const qty = ev.shares ?? ev.qty ?? (t.shares != null ? t.shares : (t.entry_price > 0 ? Math.round(TRADE_SIZE / t.entry_price) : null));
              const price = ev.price != null ? Number(ev.price) : (ev.type === "ENTRY" || ev.type === "ADD_ENTRY" || ev.type === "SCALE_IN" ? Number(t.entry_price) : ev.type === "EXIT" ? Number(t.exit_price) : null);
              const value = ev.value != null ? Number(ev.value) : (Number.isFinite(price) && Number.isFinite(qty) ? price * qty : null);
              const pnl = ev.pnl_realized != null ? Number(ev.pnl_realized) : null;
              const label = actionLabel(ev.type);
              return (
                <div
                  key={idx}
                  className="rounded-lg p-3 border text-sm"
                  style={{ background: "var(--tt-bg-elevated)", borderColor: "var(--tt-border)" }}
                >
                  <div className="font-medium text-[var(--tt-text)]">
                    {label} · {dateStr} {timeStr}
                  </div>
                  <div className="mt-1.5 grid grid-cols-2 gap-x-4 gap-y-0.5 text-xs text-[var(--tt-text-muted)]">
                    {Number.isFinite(price) && <span>Price: {fmtUsd(price)}</span>}
                    {Number.isFinite(qty) && <span>Qty: {Number(qty).toFixed(FUTURES_SPECS[t?.ticker] ? 0 : 4)}</span>}
                    {Number.isFinite(value) && <span>Value: {fmtUsd(value)}</span>}
                    {Number.isFinite(pnl) && (
                      <span className={pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>
                        Net P&L: {fmtUsd(pnl)}
                      </span>
                    )}
                  </div>
                  {ev.type === "TRIM" && !Number.isFinite(value) && Number(t.trimmed_pct) > 0 && (
                    <div className="mt-1 text-xs text-[var(--tt-text-muted)]">
                      Trimmed {Number(t.trimmed_pct * 100).toFixed(0)}%
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Unified Ticker Detail Right Rail Component
      // Reusable component that shows comprehensive ticker information
      // and optionally trade history if a trade is associated
      // ─────────────────────────────────────────────────────────────
      function TickerDetailRightRail({
        ticker,
        trade = null,
        onClose,
        allLoadedData = null,
        sectors = [],
        rankedTickers = null,
        rankedTickerPositions = null,
        positionEvents = null,
      }) {
        if (!ticker) return null;

        // Helper to get ticker data - prefer trade's ticker data if available, otherwise use ticker prop
        const tickerData =
          trade && trade.tickerData ? trade.tickerData : ticker;
        const tickerSymbol =
          tickerData.ticker || ticker.ticker || (trade ? trade.ticker : null);
        const selectedActivity =
          trade && trade.__activity && typeof trade.__activity === "object"
            ? trade.__activity
            : null;
        const selectedActivityType = selectedActivity
          ? String(selectedActivity.type || "").toUpperCase()
          : null;
        const selectedActivityTs =
          selectedActivity && selectedActivity.ts != null
            ? Number(selectedActivity.ts)
            : null;
        const tradeId = trade
          ? String(trade.trade_id || trade.id || "").trim()
          : "";

        if (!tickerSymbol) return null;

        const prime = isPrimeBubble(tickerData);
        const ent = entryType(tickerData);
        const flags = tickerData.flags || {};
        const phase = Number(tickerData.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(tickerData);
        const triggerItems = (() => {
          const items = [];
          if (Array.isArray(tickerData.triggers)) {
            for (const t of tickerData.triggers) {
              if (typeof t === "string" && t.trim()) items.push(t.trim());
            }
          }
          if (items.length === 0) {
            const trigReason = String(tickerData.trigger_reason || "").trim();
            const trigDir = String(tickerData.trigger_dir || "").trim();
            const trigTf = String(tickerData.trigger_tf || "").trim();
            if (trigReason) {
              items.push(
                trigTf
                  ? `${trigReason}${trigDir ? " (" + trigDir + ")" : ""} [${trigTf}]`
                  : `${trigReason}${trigDir ? " (" + trigDir + ")" : ""}`,
              );
            }
            if (flags.sq30_release) items.push("SQUEEZE_RELEASE_30M");
            if (flags.st_flip_30m) items.push("ST_FLIP_30M");
            if (flags.st_flip_1h) items.push("ST_FLIP_1H");
            if (flags.ema_cross_1h_13_48) items.push("EMA_CROSS_1H_13_48");
            if (flags.buyable_dip_1h_13_48) items.push("BUYABLE_DIP_1H_13_48");
          }
          return Array.from(new Set(items));
        })();
        const tfTech =
          tickerData.tf_tech && typeof tickerData.tf_tech === "object"
            ? tickerData.tf_tech
            : null;
        const tfOrder = [
          { k: "W", label: "W" },
          { k: "D", label: "D" },
          { k: "4H", label: "4H" },
          { k: "1H", label: "1H" },
          { k: "30", label: "30m" },
          { k: "10", label: "10m" },
          { k: "3", label: "3m" },
        ];
        const emaLevels = [5, 13, 21, 48, 89, 200, 233];
        const divIcon = (code) =>
          code === "B" ? "🐂" : code === "S" ? "🐻" : "";
        const phaseDotLabel = (code) => {
          switch (code) {
            case "P100":
              return "↘︎ +100";
            case "P618":
              return "↘︎ +61.8";
            case "N618":
              return "↗︎ -61.8";
            case "N100":
              return "↗︎ -100";
            default:
              return code || "";
          }
        };
        const [bubbleJourney, setBubbleJourney] = useState([]);
        const [bubbleJourneyLoading, setBubbleJourneyLoading] = useState(false);
        const [bubbleJourneyError, setBubbleJourneyError] = useState(null);
        const [railTab, setRailTab] = useState("ANALYSIS"); // ANALYSIS | TECHNICALS | JOURNEY | TRADE_HISTORY

        // Default to Trade History when opened from Trade Tracker (positionEvents), else Analysis
        useEffect(() => {
          setRailTab(positionEvents && positionEvents.length > 0 ? "TRADE_HISTORY" : "ANALYSIS");
        }, [tickerSymbol, positionEvents]);

        // Discord-style decision card (ENTRY/TRIM/EXIT) for selected activity rows.
        const [decisionCard, setDecisionCard] = useState(null);
        const [decisionCardLoading, setDecisionCardLoading] = useState(false);
        const [decisionCardError, setDecisionCardError] = useState(null);

        useEffect(() => {
          const type = selectedActivityType;
          const ts = selectedActivityTs;
          if (!tradeId || !type || !Number.isFinite(ts)) {
            setDecisionCard(null);
            setDecisionCardError(null);
            setDecisionCardLoading(false);
            return;
          }
          let cancelled = false;
          const fetchCard = async () => {
            try {
              setDecisionCardLoading(true);
              setDecisionCardError(null);
              const qs = new URLSearchParams();
              qs.set("type", type);
              qs.set("ts", String(ts));
              const res = await fetch(
                `${API_BASE}/timed/ledger/trades/${encodeURIComponent(tradeId)}/decision-card?${qs.toString()}`,
                { cache: "no-store" },
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok)
                throw new Error(json.error || "decision_card_failed");
              if (!cancelled) setDecisionCard(json);
            } catch (e) {
              if (!cancelled) {
                setDecisionCard(null);
                setDecisionCardError(String(e.message || e));
              }
            } finally {
              if (!cancelled) setDecisionCardLoading(false);
            }
          };
          fetchCard();
          return () => {
            cancelled = true;
          };
        }, [tradeId, selectedActivityType, selectedActivityTs]);

        useEffect(() => {
          const sym = String(tickerSymbol || "")
            .trim()
            .toUpperCase();
          if (!sym) {
            setBubbleJourney([]);
            setBubbleJourneyError(null);
            setBubbleJourneyLoading(false);
            return;
          }
          let cancelled = false;
          const fetchTrail = async () => {
            try {
              setBubbleJourneyLoading(true);
              setBubbleJourneyError(null);
              const res = await fetch(
                `${API_BASE}/timed/trail?ticker=${encodeURIComponent(sym)}`,
                { cache: "no-store" },
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              const raw = Array.isArray(json.trail) ? json.trail : [];
              const withTs = raw
                .map((p) => {
                  const tsRaw =
                    p.ts ?? p.timestamp ?? p.ingest_ts ?? p.ingest_time;
                  const ts =
                    typeof tsRaw === "string"
                      ? new Date(tsRaw).getTime()
                      : Number(tsRaw);
                  if (!Number.isFinite(ts)) return null;
                  return { ...p, __ts_ms: ts };
                })
                .filter(Boolean)
                .sort((a, b) => a.__ts_ms - b.__ts_ms);
              if (!cancelled) setBubbleJourney(withTs);
            } catch (e) {
              if (!cancelled) {
                setBubbleJourney([]);
                setBubbleJourneyError(String(e.message || e));
              }
            } finally {
              if (!cancelled) setBubbleJourneyLoading(false);
            }
          };
          fetchTrail();
          return () => {
            cancelled = true;
          };
        }, [tickerSymbol]);

        const detectedPatterns = useMemo(
          () => detectPatterns(bubbleJourney, flags || {}),
          [bubbleJourney, flags],
        );

        // Convert allLoadedData to array for ranking calculations
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) return allLoadedData;
            return Object.values(allLoadedData).filter(
              (t) => t && typeof t === "object" && t.ticker,
            );
          }
          return [];
        })();

        const baseScore = Number(tickerData.rank) || 0;
        const displayScore = rankScoreForTicker(tickerData);
        // Crash-proofing: right rail renders "Dynamic Score" and expects `dynamicRank`.
        // Use the shared rank-score helper (prefers backend rank_score/dynamicScore).
        const dynamicRank = rankScoreForTicker(tickerData);
        const sortedByRank =
          rankedTickers && rankedTickers.length > 0
            ? rankedTickers
            : getRankedTickers(allLoadedData);
        const rankPosition =
          getRankPositionFromMap(rankedTickerPositions, tickerSymbol) ??
          getRankPositionFromMap(
            Object.fromEntries(
              sortedByRank.map((t, idx) => [
                String(t.ticker || "").toUpperCase(),
                idx + 1,
              ]),
            ),
            tickerSymbol,
          );
        const totalTickersRaw = sortedByRank.length;
        const rankTotal =
          Number.isFinite(Number(tickerData.rank_total)) &&
          Number(tickerData.rank_total) > 0
            ? Number(tickerData.rank_total)
            : totalTickersRaw;
        // Back-compat / crash-proofing: some UI sections referenced `totalTickers`
        // (should be `rankTotal`). Keep an alias to avoid runtime ReferenceError.
        const totalTickers = rankTotal;
        const isInTop40 = rankPosition > 0 && rankPosition <= 40;

        // Determine if this is a futures contract
        const isFuturesDetail =
          FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");
        const pointValueDetail =
          isFuturesDetail && FUTURES_SPECS[tickerSymbol]
            ? FUTURES_SPECS[tickerSymbol].pointValue
            : 1;

        // Trade-specific calculations
        const tradeEntryPrice = trade
          ? Number(
              trade.entryPrice ?? trade.entry_price ?? trade.entryPrice ?? 0,
            )
          : null;
        const tradeSl = trade
          ? Number(trade.sl ?? trade.sl_price ?? trade.slPrice ?? 0)
          : null;
        const tradeTp = trade
          ? Number(trade.tp ?? trade.tp_price ?? trade.tpPrice ?? 0)
          : null;
        // For futures: shares = contracts (always 1), for stocks: calculate from TRADE_SIZE
        const shares = trade
          ? trade.shares ||
            (isFuturesDetail && FUTURES_SPECS[tickerSymbol]
              ? 1
              : TRADE_SIZE / (tradeEntryPrice || 1))
          : null;
        // Prefer live price from ticker data (just fetched) over trade snapshot
        const currentPrice = Number(
          tickerData.price ?? tickerData.currentPrice ?? (trade ? (trade.currentPrice ?? trade.current_price) : null) ?? tradeEntryPrice,
        );
        const trimmedPct = trade ? trade.trimmedPct || 0 : 0;
        const trimmedShares = trade ? shares * trimmedPct : 0;
        const remainingShares = trade ? shares - trimmedShares : null;

        const metricsSource = trade
          ? {
              ...tickerData,
              entryPrice: tradeEntryPrice,
              tp:
                Number.isFinite(tradeTp) && tradeTp > 0
                  ? tradeTp
                  : (trade.tp ?? tickerData.tp),
              sl:
                Number.isFinite(tradeSl) && tradeSl > 0
                  ? tradeSl
                  : (trade.sl ?? tickerData.sl),
              direction: trade.direction,
            }
          : tickerData;
        const horizon = computeHorizonBucket(metricsSource);
        const eta = computeEtaDays(metricsSource);
        const retPct = computeReturnPct(metricsSource);
        const riskPct = computeRiskPct(metricsSource);
        const tpTarget = computeTpTargetPrice(metricsSource);
        const tpLevels = Array.isArray(metricsSource?.tp_levels)
          ? metricsSource.tp_levels
              .map((tp) =>
                typeof tp === "object" && tp?.price != null
                  ? Number(tp.price)
                  : Number(tp),
              )
              .filter((p) => Number.isFinite(p))
          : [];
        const tpList =
          tpLevels.length > 0
            ? tpLevels
                .slice(0, 6)
                .map((p) => p.toFixed(2))
                .join(", ")
            : null;
        const tpMax = computeTpMaxPrice(metricsSource);

        return (
          <div className="w-full h-full flex flex-col" style={{ background: "#0c0f14" }}>
            {/* Scrollable Content Area */}
            <div className="flex-1 overflow-y-auto">
              {/* Floating Header */}
              <div className="sticky top-0 z-30 px-6 py-4 border-b" style={{ background: "#13171e", borderColor: "var(--tt-border)" }}>
                <div className="flex items-center justify-between">
                  <div>
                    <h3 className="text-xl font-bold">
                      {tickerSymbol}
                      {trade ? ` ${trade.direction}` : ""}
                    </h3>
                    {tickerData.price && (
                      <div className="text-sm text-white mt-1">
                        ${Number(tickerData.price).toFixed(2)}
                      </div>
                    )}
                    {(() => {
                      const { dayChg, dayPct, stale, marketOpen } =
                        getDailyChange(tickerData);
                      // During market hours: never show actionable daily change on stale data.
                      // After-hours: show last-known daily change to help analysis, but keep a clear "AH/as of" label.
                      if (
                        stale?.isStale &&
                        (marketOpen || stale?.staleByFlag)
                      ) {
                        return (
                          <div className="text-xs mt-0.5 text-yellow-300">
                            —{" "}
                            <span className="text-yellow-200/80">
                              (stale{stale.ageLabel ? ` ${stale.ageLabel}` : ""}
                              )
                            </span>
                          </div>
                        );
                      }
                      if (!Number.isFinite(dayChg) && !Number.isFinite(dayPct))
                        return null;
                      const sign =
                        Number(dayChg || dayPct || 0) >= 0 ? "+" : "-";
                      const cls =
                        Number(dayChg || dayPct || 0) >= 0
                          ? "text-green-400"
                          : "text-red-400";
                      return (
                        <div className={`text-xs mt-0.5 ${cls}`}>
                          {Number.isFinite(dayPct)
                            ? `${sign}${Math.abs(dayPct).toFixed(2)}%`
                            : "—"}{" "}
                          {Number.isFinite(dayChg)
                            ? `(${sign}${fmtUsd(Math.abs(dayChg))})`
                            : ""}
                          {!marketOpen && (
                            <span className="ml-2 text-[10px] text-[var(--tt-text-muted)]">
                              AH
                              {stale?.ageLabel
                                ? ` • as of ${stale.ageLabel}`
                                : ""}
                            </span>
                          )}
                        </div>
                      );
                    })()}
                  </div>
                  <button
                    onClick={onClose}
                    className="text-[var(--tt-text-muted)] hover:text-white transition-colors text-xl leading-none w-8 h-8 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)]"
                  >
                    ✕
                  </button>
                </div>
                {(() => {
                  const ingestTime =
                    tickerData.ingest_ts ||
                    tickerData.ingest_time ||
                    tickerData.ts;
                  if (!ingestTime) return null;
                  try {
                    const timeValue =
                      typeof ingestTime === "string"
                        ? new Date(ingestTime)
                        : new Date(Number(ingestTime));
                    if (isNaN(timeValue.getTime())) return null;
                    const displayDate = timeValue.toLocaleDateString("en-US", {
                      month: "short",
                      day: "numeric",
                      year: "numeric",
                    });
                    const displayTime = timeValue.toLocaleTimeString("en-US", {
                      hour: "numeric",
                      minute: "2-digit",
                      hour12: true,
                    });
                    return (
                      <div className="mt-2 text-xs flex items-center gap-2">
                        <span className="text-[var(--tt-text-muted)]">Last Ingest:</span>
                        <span className="text-white font-semibold">
                          {displayDate} {displayTime}
                        </span>
                      </div>
                    );
                  } catch {
                    return null;
                  }
                })()}

                {/* Right Rail Tabs — hidden when opened from position card (Trade History only) */}
                {(!positionEvents || positionEvents.length === 0) && (
                  <div className="mt-3 flex items-center gap-2 flex-wrap">
                    {[
                      { k: "ANALYSIS", label: "Analysis" },
                      { k: "TECHNICALS", label: "Technicals" },
                      { k: "JOURNEY", label: "Journey" },
                      {
                        k: "TRADE_HISTORY",
                        label: `Trade History (${(positionEvents && positionEvents.length) || trade?.history?.length || 0})`,
                      },
                    ].map((t) => {
                      const active = railTab === t.k;
                      return (
                        <button
                          key={`rail-tab-${t.k}`}
                          onClick={() => setRailTab(t.k)}
                          className={`px-3 py-1 rounded-lg border text-[11px] font-semibold transition-all ${
                            active
                              ? "border-blue-400 bg-blue-500/20 text-blue-200"
                              : "border-[var(--tt-border)] bg-[var(--tt-bg-surface)] text-[var(--tt-text-muted)] hover:text-white"
                          }`}
                        >
                          {t.label}
                        </button>
                      );
                    })}
                  </div>
                )}
              </div>

              {/* Padded body: when opened from position card, show only Trade Journey; else full content */}
              <div className="p-6 pt-4">
                {positionEvents && positionEvents.length > 0 ? (
                  /* Position card mode — Trade History only */
                  <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                    <div className="text-sm text-[var(--tt-text-muted)] mb-2">Trade Journey</div>
                    {trade ? (
                      <>
                        <div className="grid grid-cols-2 gap-4 text-sm mb-3">
                          <div>
                            <div className="text-[var(--tt-text-muted)] text-xs mb-1">Entry Price</div>
                            <div className="font-semibold text-white text-lg">
                              {Number.isFinite(tradeEntryPrice) ? `$${tradeEntryPrice.toFixed(2)}` : "—"}
                            </div>
                          </div>
                          <div>
                            <div className="text-[var(--tt-text-muted)] text-xs mb-1">Current Price</div>
                            <div className="font-semibold text-yellow-400 text-lg">
                              {Number.isFinite(currentPrice) ? `$${Number(currentPrice).toFixed(2)}` : "—"}
                            </div>
                          </div>
                        </div>
                        <LedgerTradeHistory events={positionEvents} fmtUsd={fmtUsd} />
                      </>
                    ) : (
                      <LedgerTradeHistory events={positionEvents} fmtUsd={fmtUsd} />
                    )}
                  </div>
                ) : (
                  <>
                {/* Discord-style Decision Card (from ledger snapshot at event time) */}
                {trade &&
                  selectedActivityType &&
                  Number.isFinite(selectedActivityTs) && (
                    <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                      <div className="flex items-start justify-between gap-3">
                        <div>
                          <div className="text-sm font-bold">Decision Card</div>
                          <div className="text-xs text-[var(--tt-text-muted)] mt-0.5">
                            {selectedActivityType} •{" "}
                            {new Date(
                              Number(selectedActivityTs),
                            ).toLocaleString()}
                          </div>
                        </div>
                        <div className="text-xs text-[var(--tt-text-faint)]">
                          {tradeId ? `Trade ${tradeId}` : ""}
                        </div>
                      </div>

                      {decisionCardLoading ? (
                        <div className="mt-3 text-xs text-[var(--tt-text-muted)]">
                          Loading reasoning…
                        </div>
                      ) : decisionCardError ? (
                        <div className="mt-3 text-xs text-red-400">
                          Failed to load reasoning: {decisionCardError}
                        </div>
                      ) : decisionCard && decisionCard.card ? (
                        <div className="mt-3 space-y-2">
                          {decisionCard.card.action && (
                            <div className="text-sm font-semibold text-white whitespace-pre-line">
                              {String(decisionCard.card.action)}
                            </div>
                          )}
                          {decisionCard.card.reasons && (
                            <div className="text-xs text-[var(--tt-text)] whitespace-pre-line">
                              {String(decisionCard.card.reasons)}
                            </div>
                          )}
                        </div>
                      ) : (
                        <div className="mt-3 text-xs text-[var(--tt-text-muted)]">
                          No reasoning snapshot found for this event.
                        </div>
                      )}
                    </div>
                  )}

                {/* Sector, Sector Rating */}
                {(() => {
                  const normalizeSectorKey = (sectorName) => {
                    const raw = String(sectorName || "")
                      .trim()
                      .toLowerCase()
                      .replace(/[-_/]+/g, " ")
                      .replace(/&/g, "and")
                      .replace(/\s+/g, " ");
                    if (!raw) return "";
                    const ALIASES = {
                      "health care": "healthcare",
                      healthcare: "healthcare",
                      materials: "basic materials",
                      "basic materials": "basic materials",
                      "non energy minerals": "basic materials",
                      "consumer durables": "consumer discretionary",
                      "consumer non durables": "consumer staples",
                      "consumer cyclical": "consumer discretionary",
                      "consumer discretionary": "consumer discretionary",
                      "consumer defensive": "consumer staples",
                      "consumer staples": "consumer staples",
                      "financial services": "financials",
                      finance: "financials",
                      financials: "financials",
                      technology: "information technology",
                      "technology services": "information technology",
                      "electronic technology": "information technology",
                      "information technology": "information technology",
                      communications: "communication services",
                      "communication services": "communication services",
                      "energy minerals": "energy",
                      energy: "energy",
                      industrials: "industrials",
                      utilities: "utilities",
                      "real estate": "real estate",
                    };
                    return ALIASES[raw] || raw;
                  };

                  const sectorKeyToCanonicalName = (key) => {
                    const K = String(key || "")
                      .trim()
                      .toLowerCase();
                    const CANON = {
                      "consumer discretionary": "Consumer Discretionary",
                      industrials: "Industrials",
                      "information technology": "Information Technology",
                      "communication services": "Communication Services",
                      "basic materials": "Basic Materials",
                      energy: "Energy",
                      financials: "Financials",
                      "real estate": "Real Estate",
                      "consumer staples": "Consumer Staples",
                      healthcare: "Healthcare",
                      utilities: "Utilities",
                    };
                    return CANON[K] || key;
                  };

                  const SECTOR_ETF_MAP = {
                    XLK: "Information Technology",
                    XLF: "Financials",
                    XLY: "Consumer Discretionary",
                    XLP: "Consumer Staples",
                    XLC: "Communication Services",
                    XLI: "Industrials",
                    XLB: "Basic Materials",
                    XLE: "Energy",
                    XLRE: "Real Estate",
                    XLU: "Utilities",
                    XLV: "Healthcare",
                  };

                  const sym = String(tickerSymbol || tickerData?.ticker || "")
                    .trim()
                    .toUpperCase();
                  const tickerSectorRaw =
                    SECTOR_ETF_MAP[sym] ||
                    tickerData.sector ||
                    tickerData.fundamentals?.sector ||
                    "";
                  const sectorKey = normalizeSectorKey(tickerSectorRaw);
                  if (!sectorKey || !sectors.length) return null;

                  const sectorInfo = sectors.find((s) => {
                    const name = s?.sector || s?.name || "";
                    return normalizeSectorKey(name) === sectorKey;
                  });

                  const displaySector =
                    sectorInfo?.sector ||
                    sectorInfo?.name ||
                    sectorKeyToCanonicalName(sectorKey);
                  const rating = String(
                    sectorInfo?.rating || "neutral",
                  ).toLowerCase();
                  const boost =
                    sectorInfo?.boost != null ? Number(sectorInfo.boost) : null;
                  // Match emojis used in the main dashboard filter pills
                  const emoji =
                    rating === "overweight"
                      ? "💪"
                      : rating === "underweight"
                        ? "👎"
                        : "😒";

                  return (
                    <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                      <div className="text-sm text-[var(--tt-text-muted)] mb-2">Sector</div>
                      <div className="flex items-center gap-2 flex-wrap">
                        <span className="text-lg">{emoji}</span>
                        <span className="font-semibold text-white">
                          {displaySector}
                        </span>
                        <span
                          className={`text-xs px-2 py-1 rounded ${
                            rating === "overweight"
                              ? "bg-green-500/20 text-green-400"
                              : rating === "underweight"
                                ? "bg-red-500/20 text-red-400"
                                : "bg-[var(--tt-bg-elevated)] text-[var(--tt-text-muted)]"
                          }`}
                        >
                          {rating.charAt(0).toUpperCase() + rating.slice(1)}
                        </span>
                        {Number.isFinite(boost) && boost !== 0 && (
                          <span className="text-[10px] text-[var(--tt-text-muted)]">
                            Boost {boost > 0 ? `+${boost}` : boost}
                          </span>
                        )}
                      </div>
                    </div>
                  );
                })()}

                {/* Bias / Direction */}
                {(() => {
                  const dir = getDirection(tickerData);
                  return (
                    <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                      <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color}`}
                      >
                        {dir.text === "LONG"
                          ? "📈 LONG"
                          : dir.text === "SHORT"
                            ? "📉 SHORT"
                            : dir.text}
                      </div>
                    </div>
                  );
                })()}

                {/* System Decision + Guidance */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                  <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                    System Decision
                  </div>
                  <div className={`text-sm font-bold ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                    {actionInfo.description}
                  </div>
                </div>

                {/* Triggers */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                  <div className="text-sm text-[var(--tt-text-muted)] mb-2">⚡ Triggers</div>
                  {triggerItems.length > 0 ? (
                    <div className="space-y-1">
                      {triggerItems.slice(0, 10).map((t, idx) => (
                        <div key={idx} className="text-xs text-[var(--tt-text)]">
                          • {t}
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-xs text-[var(--tt-text-muted)]">
                      No trigger signals detected.
                    </div>
                  )}
                </div>

                {/* Timeframes (Per-TF technicals) */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                  <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                    ⏱ Timeframes
                  </div>
                  {tfTech ? (
                    <div className="space-y-2">
                      {tfOrder.map(({ k, label }) => {
                        const row = tfTech[k] || null;
                        const atr = row && row.atr ? row.atr : null;
                        const ema = row && row.ema ? row.ema : null;
                        const ph = row && row.ph ? row.ph : null;
                        const sq = row && row.sq ? row.sq : null;
                        const rsi = row && row.rsi ? row.rsi : null;
                        const vis =
                          ema && Number.isFinite(Number(ema.vis))
                            ? Number(ema.vis)
                            : 0;
                        const sig =
                          ema && Number.isFinite(Number(ema.sig))
                            ? Number(ema.sig)
                            : 0;
                        const sigLabel =
                          sig === 1 ? "Bull" : sig === -1 ? "Bear" : "Neu";
                        const sqIcons =
                          (sq && sq.c ? "🗜️" : "") +
                          (sq && sq.s ? "🧨" : "") +
                          (sq && sq.r ? "⚡️" : "");
                        const atrBand = (() => {
                          if (!atr) return null;
                          const side = Number(atr.s) === -1 ? "-" : "+";
                          const lo = atr.lo != null ? String(atr.lo) : null;
                          const hi = atr.hi != null ? String(atr.hi) : null;
                          if (!lo) return null;
                          return hi ? `${side}${lo}–${hi}` : `${side}${lo}+`;
                        })();
                        return (
                          <div
                            key={k}
                            className="border border-[var(--tt-border)] rounded-lg p-2 bg-[var(--tt-bg-elevated)]"
                          >
                            <div className="flex items-center justify-between">
                              <div className="text-xs font-semibold text-white">
                                {label}
                              </div>
                              <div className="text-[10px] text-[var(--tt-text-muted)] flex items-center gap-2">
                                <span>{sqIcons}</span>
                                <span
                                  className={`font-semibold ${
                                    sig === 1
                                      ? "text-green-400"
                                      : sig === -1
                                        ? "text-red-400"
                                        : "text-[var(--tt-text-muted)]"
                                  }`}
                                >
                                  {sigLabel}
                                </span>
                              </div>
                            </div>
                            <div className="mt-1 text-[10px] text-[var(--tt-text-muted)]">
                              <span className="text-white">
                                {atrBand || "—"}
                              </span>
                              {ema && ema.stack != null ? (
                                <span className="ml-2">stack {ema.stack}</span>
                              ) : null}
                            </div>
                            <div className="mt-1 flex flex-wrap gap-1">
                              {emaLevels.map((n, idx) => {
                                const on = (vis & (1 << idx)) !== 0;
                                return (
                                  <span
                                    key={n}
                                    className={`px-1 py-0.5 rounded text-[10px] border ${
                                      on
                                        ? "bg-green-500/15 border-green-500/30 text-green-300"
                                        : "bg-red-500/10 border-red-500/30 text-red-300"
                                    }`}
                                  >
                                    {n}
                                  </span>
                                );
                              })}
                            </div>
                            <div className="mt-1 text-[10px] text-[var(--tt-text-muted)] flex justify-between">
                              <span>
                                PH {ph && ph.v != null ? ph.v : "—"}{" "}
                                {(ph && Array.isArray(ph.div) ? ph.div : [])
                                  .slice(0, 2)
                                  .map(divIcon)
                                  .filter(Boolean)
                                  .join(" ")}
                              </span>
                              <span>
                                RSI {rsi && rsi.r5 != null ? rsi.r5 : "—"}/
                                {rsi && rsi.r14 != null ? rsi.r14 : "—"}{" "}
                                {(rsi && Array.isArray(rsi.div) ? rsi.div : [])
                                  .slice(0, 2)
                                  .map(divIcon)
                                  .filter(Boolean)
                                  .join(" ")}
                              </span>
                            </div>
                            <div className="mt-1 text-[10px] text-[var(--tt-text-muted)]">
                              {(ph && Array.isArray(ph.dots) ? ph.dots : [])
                                .slice(0, 5)
                                .map(phaseDotLabel)
                                .filter(Boolean)
                                .join("  ")}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  ) : (
                    <div className="text-xs text-[var(--tt-text-muted)]">
                      No per-timeframe technicals available yet.
                    </div>
                  )}
                </div>

                {/* Score, Rank, Breakdown */}
                <div className="space-y-2.5 text-sm mb-4">
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Score</span>
                    <span className="font-semibold text-blue-400 text-lg">
                      {Number.isFinite(displayScore)
                        ? displayScore.toFixed(1)
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Rank</span>
                    <span className="font-semibold">
                      {rankPosition > 0
                        ? `#${rankPosition} of ${rankTotal}`
                        : "—"}
                    </span>
                  </div>
                  {(() => {
                    const breakdown = calculateScoreBreakdown(tickerData);
                    const breakdownComponents = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                    ].filter(Boolean);
                    return breakdownComponents.length > 0 ? (
                      <div className="border-t border-[var(--tt-border)] my-3 pt-3">
                        <div className="text-xs text-[var(--tt-text-muted)] mb-3 font-semibold">
                          Score Breakdown
                        </div>
                        <div className="space-y-1.5">
                          {breakdownComponents.map((comp, idx) => (
                            <div
                              key={idx}
                              className="flex justify-between items-center text-xs"
                            >
                              <span className="text-[var(--tt-text-muted)]">
                                {comp.label}
                              </span>
                              <span className={`font-semibold ${comp.color}`}>
                                {comp.value}
                              </span>
                            </div>
                          ))}
                        </div>
                      </div>
                    ) : null;
                  })()}
                </div>

                {/* RR, SL, Max TP, TP Target, TP Levels */}
                <div className="space-y-2.5 text-sm mb-4">
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">RR</span>
                    <span className="font-semibold">
                      {tickerData.rr ? Number(tickerData.rr).toFixed(2) : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">SL</span>
                    <span className="font-semibold text-red-400">
                      {metricsSource.sl
                        ? `$${Number(metricsSource.sl).toFixed(2)}`
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">TP Max</span>
                    <span className="font-semibold text-green-400">
                      {Number.isFinite(tpMax) ? `$${tpMax.toFixed(2)}` : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">TP Target</span>
                    <span className="font-semibold text-green-400">
                      {Number.isFinite(tpTarget)
                        ? `$${tpTarget.toFixed(2)}`
                        : "—"}
                    </span>
                  </div>
                  {tpLevels.length > 0 && (
                    <div className="text-xs text-[var(--tt-text-muted)]">
                      TP Levels:{" "}
                      {tpLevels
                        .slice(0, 6)
                        .map((p) => p.toFixed(2))
                        .join(", ")}
                    </div>
                  )}
                </div>

                {/* Trade Journey */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                  <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                    Trade Journey
                  </div>
                  {trade ? (
                    <>
                      <div className="grid grid-cols-2 gap-4 text-sm mb-3">
                        <div>
                          <div className="text-[var(--tt-text-muted)] text-xs mb-1">
                            Entry Price
                          </div>
                          <div className="font-semibold text-white text-lg">
                            {Number.isFinite(tradeEntryPrice)
                              ? `$${tradeEntryPrice.toFixed(2)}`
                              : "—"}
                          </div>
                        </div>
                        <div>
                          <div className="text-[var(--tt-text-muted)] text-xs mb-1">
                            Current Price
                          </div>
                          <div className="font-semibold text-yellow-400 text-lg">
                            {Number.isFinite(currentPrice)
                              ? `$${Number(currentPrice).toFixed(2)}`
                              : "—"}
                          </div>
                        </div>
                      </div>
                      {positionEvents && positionEvents.length > 0 ? (
                        <LedgerTradeHistory events={positionEvents} fmtUsd={fmtUsd} />
                      ) : trade.history && trade.history.length > 0 ? (
                        <TradeHistory history={trade.history} />
                      ) : (
                        <div className="text-xs text-[var(--tt-text-muted)]">
                          No trade history for this ticker.
                        </div>
                      )}
                    </>
                  ) : (
                    <div className="text-xs text-[var(--tt-text-muted)]">
                      No trade history for this ticker.
                    </div>
                  )}
                </div>

                {/* Completion, Phase, Dynamic ETA */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[var(--tt-text-muted)]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                    </span>
                  </div>
                  <div className="h-3 bg-[var(--tt-bg-elevated)] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                      }}
                    />
                  </div>
                  <div className="mt-2 flex items-center justify-between text-xs">
                    <span className="text-[var(--tt-text-muted)]">Completion</span>
                    <span className="font-semibold text-white">
                      {tickerData.completion != null
                        ? `${(Number(tickerData.completion) * 100).toFixed(2)}%`
                        : "—"}
                    </span>
                  </div>
                  <div className="mt-1 flex items-center justify-between text-xs">
                    <span className="text-[var(--tt-text-muted)]">Dynamic ETA</span>
                    <span className="font-semibold text-white">
                      {Number.isFinite(eta) ? `${eta.toFixed(1)}d` : "—"}
                    </span>
                  </div>
                </div>

                {/* EMA Cloud Position */}
                {(tickerData.daily_ema_cloud ||
                  tickerData.fourh_ema_cloud ||
                  tickerData.oneh_ema_cloud) && (
                  <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                    <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                      EMA Cloud Position
                    </div>
                    {[
                      "daily_ema_cloud",
                      "fourh_ema_cloud",
                      "oneh_ema_cloud",
                    ].map((key) => {
                      const cloud = tickerData[key];
                      if (!cloud) return null;
                      return (
                        <div
                          key={key}
                          className="text-xs text-[var(--tt-text-muted)] flex justify-between"
                        >
                          <span>
                            {key.replace("_ema_cloud", "").toUpperCase()}
                          </span>
                          <span className="text-white font-semibold">
                            {cloud.position || "—"}
                          </span>
                        </div>
                      );
                    })}
                  </div>
                )}

                {/* TD Sequential */}
                {tickerData.td_sequential && (
                  <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                    <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                      TD Sequential
                    </div>
                    <div className="text-xs text-[var(--tt-text-muted)] flex justify-between">
                      <span>Bullish Prep</span>
                      <span className="text-white font-semibold">
                        {tickerData.td_sequential.bullish_prep_count || 0}/9
                      </span>
                    </div>
                    <div className="text-xs text-[var(--tt-text-muted)] flex justify-between">
                      <span>Bearish Prep</span>
                      <span className="text-white font-semibold">
                        {tickerData.td_sequential.bearish_prep_count || 0}/9
                      </span>
                    </div>
                  </div>
                )}

                {/* RSI & Divergence */}
                {tickerData.rsi && (
                  <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                    <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                      RSI & Divergence
                    </div>
                    <div className="text-xs text-[var(--tt-text-muted)] flex justify-between">
                      <span>RSI</span>
                      <span className="text-white font-semibold">
                        {Number(tickerData.rsi.value || 0).toFixed(2)}
                      </span>
                    </div>
                    <div className="text-xs text-[var(--tt-text-muted)] flex justify-between">
                      <span>Divergence</span>
                      <span className="text-white font-semibold">
                        {tickerData.rsi.divergence?.type || "none"}
                      </span>
                    </div>
                  </div>
                )}

                {/* State, Horizon, Detected Patterns */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                  <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                    State & Horizon
                  </div>
                  <div className="text-xs text-[var(--tt-text-muted)] flex justify-between">
                    <span>State</span>
                    <span className="text-white font-semibold">
                      {tickerData.state || "—"}
                    </span>
                  </div>
                  <div className="text-xs text-[var(--tt-text-muted)] flex justify-between">
                    <span>Horizon</span>
                    <span className="text-white font-semibold">{horizon}</span>
                  </div>
                  {detectedPatterns && detectedPatterns.length > 0 && (
                    <div className="mt-2 text-[10px] text-yellow-300">
                      {detectedPatterns
                        .map((p) => p.description)
                        .slice(0, 3)
                        .join(" • ")}
                    </div>
                  )}
                </div>

                {/* Bubble Journey (15m increments) */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                  <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                    Bubble Journey (15m)
                  </div>
                  {bubbleJourneyLoading ? (
                    <div className="text-xs text-[var(--tt-text-muted)]">Loading trail…</div>
                  ) : bubbleJourneyError ? (
                    <div className="text-xs text-red-400">
                      {bubbleJourneyError}
                    </div>
                  ) : (
                    <div className="space-y-1 max-h-48 overflow-y-auto pr-1">
                      {downsampleByInterval(bubbleJourney, 15 * 60 * 1000)
                        .slice()
                        .reverse()
                        .slice(0, 24)
                        .map((p, idx) => (
                          <div
                            key={`${p.__bucket || p.__ts_ms}-${idx}`}
                            className="text-[10px] text-[var(--tt-text-muted)] flex justify-between"
                          >
                            <span>
                              {Number.isFinite(p.__ts_ms)
                                ? new Date(p.__ts_ms).toLocaleTimeString(
                                    "en-US",
                                    { hour: "numeric", minute: "2-digit" },
                                  )
                                : "—"}
                            </span>
                            <span className="text-white">{p.state || "—"}</span>
                          </div>
                        ))}
                    </div>
                  )}
                </div>

                {/* Quadrant Progression */}
                <QuadrantProgression ticker={tickerData} flags={flags} />

                {/* Action Description */}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[var(--tt-text-muted)]">
                    {actionInfo.description}
                  </div>
                </div>

                {/* Quadrant Progression */}
                <QuadrantProgression ticker={tickerData} flags={flags} />

                {/* Phase indicator */}
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[var(--tt-text-muted)]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                    </span>
                  </div>
                  <div className="h-3 bg-[var(--tt-bg-elevated)] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                      }}
                    />
                  </div>
                </div>

                {/* Score and Ranking */}
                <div className="space-y-2.5 text-sm mb-4">
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Score</span>
                    <span className="font-semibold text-blue-400 text-lg">
                      {baseScore}
                    </span>
                  </div>
                  {rankTotal > 0 && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Rank</span>
                      <span className="font-semibold">
                        {rankPosition > 0
                          ? `#${rankPosition} of ${rankTotal}`
                          : "—"}
                      </span>
                    </div>
                  )}
                  {dynamicRank !== baseScore && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Dynamic Score</span>
                      <span className="font-semibold text-green-400">
                        {dynamicRank}
                      </span>
                    </div>
                  )}
                  {/* Model Score (Worker-provided) */}
                  {(() => {
                    const ml =
                      tickerData?.ml ||
                      tickerData?.model ||
                      tickerData?.model_v1 ||
                      tickerData?.ml_v1 ||
                      null;
                    if (!ml || typeof ml !== "object") return null;
                    const p4h = Number(ml?.p_win_4h ?? ml?.p4h ?? ml?.pWin4h);
                    const ev4h = Number(ml?.ev_4h ?? ml?.ev4h);
                    const p1d = Number(ml?.p_win_1d ?? ml?.p1d ?? ml?.pWin1d);
                    const ev1d = Number(ml?.ev_1d ?? ml?.ev1d);
                    const has4h =
                      Number.isFinite(p4h) || Number.isFinite(ev4h);
                    const has1d =
                      Number.isFinite(p1d) || Number.isFinite(ev1d);
                    if (!has4h && !has1d) return null;
                    const fmtPct = (x) =>
                      Number.isFinite(x) ? `${(x * 100).toFixed(1)}%` : "—";
                    const fmtEv = (x) =>
                      Number.isFinite(x) ? `${x.toFixed(2)}%` : "—";
                    return (
                      <>
                        {has4h && (
                          <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                            <span className="text-[var(--tt-text-muted)]">Model (4h)</span>
                            <span className="font-semibold text-purple-300">
                              pWin {fmtPct(p4h)} • EV {fmtEv(ev4h)}
                            </span>
                          </div>
                        )}
                        {has1d && (
                          <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                            <span className="text-[var(--tt-text-muted)]">Model (1d)</span>
                            <span className="font-semibold text-purple-300">
                              pWin {fmtPct(p1d)} • EV {fmtEv(ev1d)}
                            </span>
                          </div>
                        )}
                      </>
                    );
                  })()}
                  {isInTop40 && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Top 40 Position</span>
                      <span className="font-semibold text-yellow-400">
                        #{rankPosition} of 40
                      </span>
                    </div>
                  )}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(tickerData);
                    const breakdownComponents = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return breakdownComponents.length > 0 ? (
                      <div className="border-t border-[var(--tt-border)] my-3 pt-3">
                        <div className="text-xs text-[var(--tt-text-muted)] mb-3 font-semibold">
                          Score Breakdown
                        </div>
                        <div className="space-y-1.5">
                          {breakdownComponents.map((comp, idx) => (
                            <div
                              key={idx}
                              className="flex justify-between items-center text-xs"
                            >
                              <span className="text-[var(--tt-text-muted)]">
                                {comp.label}
                              </span>
                              <span className={`font-semibold ${comp.color}`}>
                                {comp.value}
                              </span>
                            </div>
                          ))}
                          <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[var(--tt-border)]">
                            <span className="text-[var(--tt-text-muted)] font-semibold">
                              Total Score
                            </span>
                            <span className="text-blue-400 font-bold text-base">
                              {Math.round(breakdown.total)}
                            </span>
                          </div>
                        </div>
                      </div>
                    ) : null;
                  })()}

                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">RR</span>
                    <span className="font-semibold">
                      {tickerData.rr ? Number(tickerData.rr).toFixed(2) : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">State</span>
                    <span className="font-semibold">
                      {tickerData.state || "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">HTF Score</span>
                    <span className="font-semibold">
                      {tickerData.htf_score != null
                        ? Number(tickerData.htf_score).toFixed(2)
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">LTF Score</span>
                    <span className="font-semibold">
                      {tickerData.ltf_score != null
                        ? Number(tickerData.ltf_score).toFixed(2)
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Completion</span>
                    <span className="font-semibold">
                      {tickerData.completion != null
                        ? `${(Number(tickerData.completion) * 100).toFixed(2)}%`
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Price</span>
                    <span className="font-semibold">
                      $
                      {tickerData.price
                        ? Number(tickerData.price).toFixed(2)
                        : "—"}
                    </span>
                  </div>
                </div>

                {/* Fundamental & Valuation Metrics */}
                {tickerData.fundamentals &&
                  (() => {
                    const fund = tickerData.fundamentals;
                    const hasValuationData =
                      fund.pe_ratio !== null ||
                      fund.peg_ratio !== null ||
                      fund.eps_growth_rate !== null;

                    if (!hasValuationData) return null;

                    const valuationSignal = fund.valuation_signal || "fair";
                    const signalColor =
                      valuationSignal === "undervalued"
                        ? "text-green-400"
                        : valuationSignal === "overvalued"
                          ? "text-red-400"
                          : "text-yellow-400";
                    const signalBg =
                      valuationSignal === "undervalued"
                        ? "bg-green-500/20 border-green-500/50"
                        : valuationSignal === "overvalued"
                          ? "bg-red-500/20 border-red-500/50"
                          : "bg-yellow-500/20 border-yellow-500/50";

                    return (
                      <div className="mt-6 pt-6 border-t-2 border-[var(--tt-border)]">
                        <div className="text-sm font-bold text-[var(--tt-text-muted)] mb-4">
                          📊 Fundamental & Valuation
                        </div>

                        {/* Valuation Signal Badge */}
                        {fund.valuation_signal && (
                          <div
                            className={`mb-4 p-3 rounded-lg border-2 ${signalBg}`}
                          >
                            <div className="flex items-center justify-between">
                              <span className="text-xs text-[var(--tt-text-muted)]">
                                Valuation Signal
                              </span>
                              <span
                                className={`font-bold text-sm ${signalColor}`}
                              >
                                {fund.valuation_signal.toUpperCase()}
                              </span>
                            </div>
                            {fund.valuation_confidence && (
                              <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                                Confidence:{" "}
                                <span className="font-semibold">
                                  {fund.valuation_confidence}
                                </span>
                              </div>
                            )}
                            {fund.valuation_reasons &&
                              fund.valuation_reasons.length > 0 && (
                                <div className="mt-2 pt-2 border-t border-current/30">
                                  <div className="text-[10px] text-[var(--tt-text-muted)] mb-1">
                                    Reasons:
                                  </div>
                                  {fund.valuation_reasons.map((reason, idx) => (
                                    <div
                                      key={idx}
                                      className="text-[10px] text-[var(--tt-text-muted)]/80 mb-0.5"
                                    >
                                      • {reason}
                                    </div>
                                  ))}
                                </div>
                              )}
                          </div>
                        )}

                        {/* Basic Metrics */}
                        <div className="space-y-2 text-sm mb-4">
                          {fund.pe_ratio !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                              <span className="text-[var(--tt-text-muted)]">P/E Ratio</span>
                              <span className="font-semibold">
                                {Number(fund.pe_ratio).toFixed(2)}
                              </span>
                            </div>
                          )}
                          {fund.peg_ratio !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                              <span className="text-[var(--tt-text-muted)]">PEG Ratio</span>
                              <span
                                className={`font-semibold ${
                                  fund.peg_ratio < 0.8
                                    ? "text-green-400"
                                    : fund.peg_ratio < 1.0
                                      ? "text-yellow-400"
                                      : fund.peg_ratio > 1.5
                                        ? "text-red-400"
                                        : "text-[var(--tt-text-muted)]"
                                }`}
                              >
                                {Number(fund.peg_ratio).toFixed(2)}
                              </span>
                            </div>
                          )}
                          {fund.eps !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                              <span className="text-[var(--tt-text-muted)]">EPS (TTM)</span>
                              <span className="font-semibold">
                                ${Number(fund.eps).toFixed(2)}
                              </span>
                            </div>
                          )}
                          {fund.eps_growth_rate !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                              <span className="text-[var(--tt-text-muted)]">
                                EPS Growth (Annual)
                              </span>
                              <span
                                className={`font-semibold ${
                                  fund.eps_growth_rate > 20
                                    ? "text-green-400"
                                    : fund.eps_growth_rate > 10
                                      ? "text-yellow-400"
                                      : fund.eps_growth_rate > 0
                                        ? "text-[var(--tt-text-muted)]"
                                        : "text-red-400"
                                }`}
                              >
                                {Number(fund.eps_growth_rate).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {fund.market_cap !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                              <span className="text-[var(--tt-text-muted)]">Market Cap</span>
                              <span className="font-semibold">
                                {fund.market_cap >= 1e12
                                  ? `$${(fund.market_cap / 1e12).toFixed(2)}T`
                                  : fund.market_cap >= 1e9
                                    ? `$${(fund.market_cap / 1e9).toFixed(2)}B`
                                    : fund.market_cap >= 1e6
                                      ? `$${(fund.market_cap / 1e6).toFixed(2)}M`
                                      : `$${fund.market_cap.toLocaleString()}`}
                              </span>
                            </div>
                          )}
                          {fund.industry && (
                            <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                              <span className="text-[var(--tt-text-muted)]">Industry</span>
                              <span className="font-semibold text-xs">
                                {fund.industry}
                              </span>
                            </div>
                          )}
                        </div>

                        {/* Fair Value */}
                        {fund.fair_value_price !== null &&
                          fund.fair_value_price > 0 && (
                            <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                              <div className="text-xs text-[var(--tt-text-muted)] mb-2">
                                Fair Value
                              </div>
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-sm text-[var(--tt-text-muted)]">
                                  Fair Value Price
                                </span>
                                <span className="font-bold text-lg text-blue-400">
                                  ${Number(fund.fair_value_price).toFixed(2)}
                                </span>
                              </div>
                              {fund.premium_discount_pct !== null && (
                                <div className="flex items-center justify-between">
                                  <span className="text-xs text-[var(--tt-text-muted)]">
                                    Premium/Discount
                                  </span>
                                  <span
                                    className={`font-semibold ${
                                      fund.premium_discount_pct < -10
                                        ? "text-green-400"
                                        : fund.premium_discount_pct < 0
                                          ? "text-yellow-400"
                                          : fund.premium_discount_pct > 10
                                            ? "text-red-400"
                                            : "text-[var(--tt-text-muted)]"
                                    }`}
                                  >
                                    {fund.premium_discount_pct > 0 ? "+" : ""}
                                    {Number(fund.premium_discount_pct).toFixed(
                                      1,
                                    )}
                                    %
                                  </span>
                                </div>
                              )}
                              {fund.fair_value_pe &&
                                fund.fair_value_pe.preferred && (
                                  <div className="mt-2 pt-2 border-t border-[var(--tt-border)] text-xs text-[var(--tt-text-muted)]">
                                    Fair P/E:{" "}
                                    <span className="font-semibold">
                                      {Number(
                                        fund.fair_value_pe.preferred,
                                      ).toFixed(2)}
                                    </span>
                                  </div>
                                )}
                            </div>
                          )}

                        {/* Historical P/E Percentiles */}
                        {fund.pe_percentiles && (
                          <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                            <div className="text-xs text-[var(--tt-text-muted)] mb-2">
                              Historical P/E Percentiles
                            </div>
                            <div className="grid grid-cols-2 gap-2 text-xs">
                              {fund.pe_percentiles.p10 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[var(--tt-text-muted)]">10th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p10).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p25 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[var(--tt-text-muted)]">25th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p25).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p50 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[var(--tt-text-muted)]">
                                    50th (Median):
                                  </span>
                                  <span className="font-semibold text-blue-400">
                                    {Number(fund.pe_percentiles.p50).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p75 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[var(--tt-text-muted)]">75th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p75).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p90 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[var(--tt-text-muted)]">90th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p90).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.avg !== null && (
                                <div className="flex justify-between col-span-2 pt-1 border-t border-[var(--tt-border)]">
                                  <span className="text-[var(--tt-text-muted)]">
                                    Average:
                                  </span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.avg).toFixed(1)}
                                  </span>
                                </div>
                              )}
                            </div>
                            {fund.pe_percentile_position && (
                              <div className="mt-2 pt-2 border-t border-[var(--tt-border)] text-xs">
                                <span className="text-[var(--tt-text-muted)]">
                                  Current Position:{" "}
                                </span>
                                <span
                                  className={`font-semibold ${
                                    fund.pe_percentile_position.includes(
                                      "Bottom",
                                    )
                                      ? "text-green-400"
                                      : fund.pe_percentile_position.includes(
                                            "Top",
                                          )
                                        ? "text-red-400"
                                        : "text-[var(--tt-text-muted)]"
                                  }`}
                                >
                                  {fund.pe_percentile_position}
                                </span>
                              </div>
                            )}
                          </div>
                        )}

                        {/* Valuation Boost in Rank */}
                        {tickerData.rank_components &&
                          tickerData.rank_components.valuation_boost !==
                            undefined &&
                          tickerData.rank_components.valuation_boost !== 0 && (
                            <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                              <div className="text-xs text-[var(--tt-text-muted)] mb-1">
                                Rank Components
                              </div>
                              <div className="flex justify-between items-center text-xs">
                                <span className="text-[var(--tt-text-muted)]">
                                  Base Rank
                                </span>
                                <span className="font-semibold">
                                  {tickerData.rank_components.base_rank ||
                                    baseScore}
                                </span>
                              </div>
                              <div className="flex justify-between items-center text-xs mt-1">
                                <span className="text-[var(--tt-text-muted)]">
                                  Valuation Boost
                                </span>
                                <span
                                  className={`font-semibold ${
                                    tickerData.rank_components.valuation_boost >
                                    0
                                      ? "text-green-400"
                                      : "text-red-400"
                                  }`}
                                >
                                  {tickerData.rank_components.valuation_boost >
                                  0
                                    ? "+"
                                    : ""}
                                  {tickerData.rank_components.valuation_boost}
                                </span>
                              </div>
                              <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[var(--tt-border)]">
                                <span className="text-[var(--tt-text-muted)] font-semibold">
                                  Final Rank
                                </span>
                                <span className="font-bold text-blue-400">
                                  {baseScore}
                                </span>
                              </div>
                            </div>
                          )}
                      </div>
                    );
                  })()}
                </>
                )}
              </div>
            </div>

            {/* Fixed Footer */}
            <div className="flex-shrink-0 p-6 pt-4 border-t border-[var(--tt-border)] bg-[var(--tt-bg-elevated)]">
              <a
                href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(tickerSymbol)}`}
                target="_blank"
                rel="noopener noreferrer"
                className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
              >
                📊 Open in TradingView
              </a>
            </div>
          </div>
        );
      }

      function TradeRow({ trade, tickerData, onTickerClick, onTradeClick }) {
        const pnlColor = trade.pnl >= 0 ? "text-green-400" : "text-red-400";
        const statusColor =
          trade.status === "WIN"
            ? "text-green-400"
            : trade.status === "LOSS"
              ? "text-red-400"
              : trade.status === "TP_HIT_TRIM"
                ? "text-blue-400"
                : "text-yellow-400";

        // Determine if this is a futures contract
        const tickerSymbol = String(trade.ticker || "").toUpperCase();
        const isFutures =
          FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");
        const pointValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? FUTURES_SPECS[tickerSymbol].pointValue
            : 1;

        // Metrics derived from latest ticker data (preferred) or trade data
        const metricsSource = tickerData || trade;
        const horizon = computeHorizonBucket(metricsSource);
        const eta = computeEtaDays(metricsSource);
        const retPct = computeReturnPct(metricsSource);
        const riskPct = computeRiskPct(metricsSource);
        const tpTarget = computeTpTargetPrice(metricsSource);
        const avgCorr = Number(metricsSource?.avg_corr);
        const diversity = Number(metricsSource?.diversity_score);
        const exitPrice = Number(trade.exitPrice ?? trade.exit_price);
        const trimPrice = Number(trade.trimPrice ?? trade.trim_price);

        // Calculate position values
        // For futures: shares = contracts (always 1), for stocks: calculate from TRADE_SIZE
        const shares =
          trade.shares ||
          (isFutures && FUTURES_SPECS[tickerSymbol]
            ? 1
            : TRADE_SIZE / (trade.entryPrice || 1));
        const currentPrice = trade.currentPrice || trade.entryPrice;

        // For futures: value calculation is different (contracts * point value * price)
        // For stocks: shares * price
        const marketValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? shares * currentPrice * pointValue
            : shares * currentPrice;
        const entryValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? shares * trade.entryPrice * pointValue
            : shares * trade.entryPrice;
        const trimmedPct = trade.trimmedPct || 0;
        const trimmedShares = shares * trimmedPct;
        const remainingShares = shares - trimmedShares;
        const trimmedValue =
          trimmedShares > 0
            ? isFutures && FUTURES_SPECS[tickerSymbol]
              ? trimmedShares * (trade.tp || currentPrice) * pointValue
              : trimmedShares * (trade.tp || currentPrice)
            : 0;
        const currentMarketValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? remainingShares * currentPrice * pointValue
            : remainingShares * currentPrice;

        // Recalculate P&L using correct futures logic (override stored value)
        // Note: trimmedPct is already declared above (line 1336)
        let recalculatedPnl = 0;
        let recalculatedPnlPct = 0;
        const priceDiff = currentPrice - trade.entryPrice;

        if (trade.direction === "LONG") {
          const hitTP = currentPrice >= trade.tp;
          const hitSL = currentPrice <= trade.sl;

          if (hitTP) {
            if (trimmedPct === 0) {
              // First TP hit - trim 50%
              const tpDiff = trade.tp - trade.entryPrice;
              recalculatedPnl = tpDiff * shares * pointValue * 0.5;
              recalculatedPnlPct =
                ((trade.tp - trade.entryPrice) / trade.entryPrice) * 100;
            } else {
              // Already trimmed - full exit at TP
              const tpDiff = trade.tp - trade.entryPrice;
              recalculatedPnl = tpDiff * shares * pointValue;
              recalculatedPnlPct =
                ((trade.tp - trade.entryPrice) / trade.entryPrice) * 100;
            }
          } else if (hitSL) {
            const slDiff = trade.sl - trade.entryPrice;
            recalculatedPnl = slDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.sl - trade.entryPrice) / trade.entryPrice) * 100;
          } else {
            // Still open - calculate current P&L
            recalculatedPnl = priceDiff * shares * pointValue;
            recalculatedPnlPct =
              ((currentPrice - trade.entryPrice) / trade.entryPrice) * 100;
          }
        } else {
          // SHORT
          const hitTP = currentPrice <= trade.tp;
          const hitSL = currentPrice >= trade.sl;

          if (hitTP) {
            if (trimmedPct === 0) {
              // First TP hit - trim 50%
              const tpDiff = trade.entryPrice - trade.tp;
              recalculatedPnl = tpDiff * shares * pointValue * 0.5;
              recalculatedPnlPct =
                ((trade.entryPrice - trade.tp) / trade.entryPrice) * 100;
            } else {
              // Already trimmed - full exit at TP
              const tpDiff = trade.entryPrice - trade.tp;
              recalculatedPnl = tpDiff * shares * pointValue;
              recalculatedPnlPct =
                ((trade.entryPrice - trade.tp) / trade.entryPrice) * 100;
            }
          } else if (hitSL) {
            const slDiff = trade.entryPrice - trade.sl;
            recalculatedPnl = slDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.entryPrice - trade.sl) / trade.entryPrice) * 100;
          } else {
            // Still open - calculate current P&L
            const shortPriceDiff = trade.entryPrice - currentPrice;
            recalculatedPnl = shortPriceDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.entryPrice - currentPrice) / trade.entryPrice) * 100;
          }
        }

        // Parse entryTime - now uses current time when trade was created (not trigger_ts)
        const entryDate = new Date(trade.entryTime);
        const formattedDate = entryDate.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric",
          year: "numeric",
        });
        const formattedTime = entryDate.toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });

        return (
          <tr
            className="border-b border-[var(--tt-border)] hover:bg-[var(--tt-bg-elevated)] cursor-pointer transition-colors"
            onClick={() => {
              if (onTradeClick) onTradeClick(trade);
              else if (onTickerClick) onTickerClick(trade.ticker);
            }}
          >
            <td className="p-2 text-sm">{trade.ticker}</td>
            <td className="p-2 text-sm">
              <span
                className={`px-2 py-1 rounded text-xs ${
                  trade.direction === "LONG"
                    ? "bg-green-500/20 text-green-400"
                    : "bg-red-500/20 text-red-400"
                }`}
              >
                {trade.direction}
              </span>
            </td>
            <td className="p-2 text-sm">${trade.entryPrice.toFixed(2)}</td>
            <td className="p-2 text-sm">${currentPrice.toFixed(2)}</td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)]">
              <div className="font-semibold text-white">{formattedDate}</div>
              <div className="text-[var(--tt-text-faint)]">{formattedTime}</div>
            </td>
            <td className="p-2 text-sm font-mono">
              {isFutures && FUTURES_SPECS[tickerSymbol] ? (
                <>
                  <div className="text-xs text-[var(--tt-text-muted)]">
                    Total: {shares.toFixed(0)} contract{shares !== 1 ? "s" : ""}
                  </div>
                  {trimmedShares > 0 && (
                    <div className="text-xs text-blue-400">
                      Remaining: {remainingShares.toFixed(2)} contract
                      {remainingShares !== 1 ? "s" : ""}
                    </div>
                  )}
                </>
              ) : (
                <>
                  <div className="text-xs text-[var(--tt-text-muted)]">
                    Total: {shares.toFixed(4)}
                  </div>
                  {trimmedShares > 0 && (
                    <div className="text-xs text-blue-400">
                      Remaining: {remainingShares.toFixed(4)}
                    </div>
                  )}
                </>
              )}
            </td>
            <td className="p-2 text-sm">
              <div className="text-xs text-[var(--tt-text-muted)]">
                Entry: ${entryValue.toFixed(2)}
              </div>
              <div
                className={`font-semibold ${trade.status === "OPEN" || trade.status === "TP_HIT_TRIM" ? "text-yellow-400" : ""}`}
              >
                Current: ${currentMarketValue.toFixed(2)}
              </div>
            </td>
            <td className="p-2 text-sm">
              {trimmedShares > 0 ? (
                <div className="text-xs text-blue-400">
                  <div>${trimmedValue.toFixed(2)}</div>
                  <div className="text-[var(--tt-text-muted)]">
                    ({(trimmedPct * 100).toFixed(0)}%)
                  </div>
                </div>
              ) : (
                <span className="text-xs text-[var(--tt-text-faint)]">-</span>
              )}
            </td>
            <td className="p-2 text-sm">${trade.sl.toFixed(2)}</td>
            <td
              className="p-2 text-sm"
              title={tpList ? `TP Levels: ${tpList}` : ""}
            >
              $
              {Number.isFinite(tpTarget)
                ? tpTarget.toFixed(2)
                : trade.tp.toFixed(2)}
            </td>
            <td className="p-2 text-sm text-green-400">
              {Number.isFinite(retPct) ? `${retPct.toFixed(1)}%` : "—"}
            </td>
            <td className="p-2 text-sm text-red-400">
              {Number.isFinite(riskPct) ? `${riskPct.toFixed(1)}%` : "—"}
            </td>
            <td className="p-2 text-sm">
              {Number.isFinite(eta) ? `${eta.toFixed(1)}d` : "—"}
            </td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)]">{horizon}</td>
            <td className="p-2 text-sm text-[var(--tt-text-muted)]">
              {Number.isFinite(diversity) ? Math.round(diversity) : "—"}
            </td>
            <td className="p-2 text-sm text-[var(--tt-text-muted)]">
              {Number.isFinite(avgCorr) ? avgCorr.toFixed(2) : "—"}
            </td>
            <td className="p-2 text-sm">{formatRR(trade.rr)}</td>
            <td className="p-2 text-sm">{trade.rank}</td>
            <td
              className={`p-2 text-sm font-semibold ${recalculatedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
            >
              ${recalculatedPnl.toFixed(2)}
            </td>
            <td
              className={`p-2 text-sm font-semibold ${recalculatedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
            >
              {recalculatedPnlPct.toFixed(2)}%
            </td>
            <td className={`p-2 text-sm font-semibold ${statusColor}`}>
              <div>
                {trade.status === "TP_HIT_TRIM"
                  ? `TRIMMED (${((trade.trimmedPct || 0) * 100).toFixed(0)}%)`
                  : trade.status || "OPEN"}
              </div>
              {trade.status === "TP_HIT_TRIM" && Number.isFinite(trimPrice) && (
                <div className="text-[10px] text-yellow-300">
                  Trim @ ${trimPrice.toFixed(2)}
                </div>
              )}
              {(trade.status === "WIN" || trade.status === "LOSS") &&
                Number.isFinite(exitPrice) && (
                  <div className="text-[10px] text-purple-300">
                    Exit @ ${exitPrice.toFixed(2)}
                  </div>
                )}
            </td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)] font-mono">
              {trade.scriptVersion || "unknown"}
            </td>
          </tr>
        );
      }

      function AnalyticsPanel({ analytics }) {
        return (
          <div className="space-y-4">
            {/* Overall Stats */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Overall Performance</h3>
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-4">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Total Trades</div>
                  <div className="text-2xl font-bold">
                    {analytics.totalTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Open Trades</div>
                  <div className="text-2xl font-bold text-yellow-400">
                    {analytics.openTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Trimmed Trades</div>
                  <div className="text-2xl font-bold text-blue-400">
                    {analytics.trimmedTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Closed Trades</div>
                  <div className="text-2xl font-bold text-white">
                    {analytics.closedTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Win Rate</div>
                  <div className="text-2xl font-bold text-green-400">
                    {analytics.winRate.toFixed(1)}%
                  </div>
                </div>
              </div>
              <div className="grid grid-cols-2 md:grid-cols-2 gap-4 pt-4 border-t border-[var(--tt-border)]">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Closed P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.totalPnl >= 0
                        ? "text-green-400"
                        : "text-red-400"
                    }`}
                  >
                    ${analytics.totalPnl.toFixed(2)}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Open P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.openPnl >= 0
                        ? "text-green-400"
                        : "text-yellow-400"
                    }`}
                  >
                    ${analytics.openPnl.toFixed(2)}
                  </div>
                </div>
              </div>
              {analytics.totalTrades > 0 && (
                <div className="grid grid-cols-2 md:grid-cols-3 gap-4 pt-4 border-t border-[var(--tt-border)]">
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Avg Win</div>
                    <div className="text-lg font-bold text-green-400">
                      ${analytics.avgWin.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Avg Loss</div>
                    <div className="text-lg font-bold text-red-400">
                      ${analytics.avgLoss.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Profit Factor</div>
                    <div
                      className={`text-lg font-bold ${
                        analytics.profitFactor >= 1.5
                          ? "text-green-400"
                          : analytics.profitFactor >= 1.0
                            ? "text-yellow-400"
                            : "text-red-400"
                      }`}
                    >
                      {analytics.profitFactor.toFixed(2)}
                    </div>
                  </div>
                </div>
              )}
            </div>

            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Excursion & Capture</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg MFE %</div>
                  <div className="text-lg font-bold text-green-400">
                    {analytics.avgMfePct.toFixed(1)}%
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg MAE %</div>
                  <div className="text-lg font-bold text-red-400">
                    {analytics.avgMaePct.toFixed(1)}%
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg Captured %</div>
                  <div className="text-lg font-bold text-blue-400">
                    {analytics.avgCapturedPct.toFixed(1)}%
                  </div>
                </div>
              </div>
            </div>

            {analytics.horizonStats && (
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
                <h3 className="text-lg font-bold mb-4">Horizon Performance</h3>
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead>
                      <tr className="border-b border-[var(--tt-border)] text-left text-xs text-[var(--tt-text-muted)]">
                        <th className="p-2">Horizon</th>
                        <th className="p-2">Trades</th>
                        <th className="p-2">Win %</th>
                        <th className="p-2">Expectancy</th>
                        <th className="p-2">MFE %</th>
                        <th className="p-2">MAE %</th>
                        <th className="p-2">Captured %</th>
                      </tr>
                    </thead>
                    <tbody>
                      {Object.entries(analytics.horizonStats).map(
                        ([key, s]) => (
                          <tr
                            key={key}
                            className="border-b border-[var(--tt-border)]/50"
                          >
                            <td className="p-2 text-xs text-[var(--tt-text-muted)]">
                              {String(key).replace("_", " ")}
                            </td>
                            <td className="p-2">{s.n}</td>
                            <td className="p-2">{s.winRate.toFixed(1)}%</td>
                            <td className="p-2">
                              {Number.isFinite(s.expectancy)
                                ? `$${s.expectancy.toFixed(2)}`
                                : "—"}
                            </td>
                            <td className="p-2">{s.avgMfePct.toFixed(1)}%</td>
                            <td className="p-2">{s.avgMaePct.toFixed(1)}%</td>
                            <td className="p-2">
                              {s.avgCapturedPct.toFixed(1)}%
                            </td>
                          </tr>
                        ),
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            )}

            {/* Self-Learning Recommendations */}
            {(() => {
              const recs = analytics.recommendations || {};
              const filterRecs = Array.isArray(recs.filters)
                ? recs.filters
                : [];
              const mgmtRecs = Array.isArray(recs.management)
                ? recs.management
                : [];
              const hasAny = filterRecs.length + mgmtRecs.length > 0;
              if (!hasAny) return null;

              const renderRec = (rec, idx) => (
                <div
                  key={idx}
                  className={`p-3 rounded-lg border ${
                    rec.priority === "high"
                      ? "bg-yellow-500/10 border-yellow-500/30"
                      : "bg-blue-500/10 border-blue-500/30"
                  }`}
                >
                  <div className="flex items-start gap-2">
                    <span className="text-lg">
                      {rec.priority === "high" ? "⚠️" : "💡"}
                    </span>
                    <div className="flex-1">
                      <div className="text-sm font-semibold">{rec.message}</div>
                    </div>
                  </div>
                </div>
              );

              return (
                <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
                  <h3 className="text-lg font-bold mb-4">
                    🎓 Self-Learning Recommendations
                  </h3>

                  {filterRecs.length > 0 && (
                    <div className="mb-4">
                      <div className="text-xs text-[var(--tt-text-muted)] font-semibold mb-2">
                        Filters (before entry)
                      </div>
                      <div className="space-y-2">
                        {filterRecs.map(renderRec)}
                      </div>
                    </div>
                  )}

                  {mgmtRecs.length > 0 && (
                    <div>
                      <div className="text-xs text-[var(--tt-text-muted)] font-semibold mb-2">
                        Management (after entry)
                      </div>
                      <div className="space-y-2">{mgmtRecs.map(renderRec)}</div>
                    </div>
                  )}
                </div>
              );
            })()}

            {/* Signal Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Signal Performance</h3>
              <div className="space-y-2 max-h-[300px] overflow-y-auto">
                {Object.entries(analytics.signalAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([signals, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={signals}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">
                            {signals || "No Signals"}
                          </div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* RR Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">
                Risk/Reward Performance
              </h3>
              <div className="space-y-2">
                {Object.entries(analytics.rrAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* Rank Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Rank Performance</h3>
              <div className="space-y-2">
                {Object.entries(analytics.rankAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>
          </div>
        );
      }

      function KpiCard({ label, value, sub = null, tone = "neutral" }) {
        const toneBar =
          tone === "green"
            ? "from-green-400 to-emerald-500"
            : tone === "red"
              ? "from-red-400 to-rose-500"
              : tone === "yellow"
                ? "from-yellow-300 to-amber-500"
                : tone === "blue"
                  ? "from-blue-400 to-cyan-400"
                  : "from-[var(--tt-text-faint)] to-[var(--tt-border)]";

        return (
          <div className="relative bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-xl p-3 overflow-hidden">
            <div
              className={`absolute left-0 top-0 bottom-0 w-1 bg-gradient-to-b ${toneBar}`}
            />
            <div className="pl-2">
              <div className="text-[11px] uppercase tracking-wide text-[var(--tt-text-muted)]">
                {label}
              </div>
              <div className="mt-1 text-lg font-bold text-white leading-tight">
                {value}
              </div>
              {sub ? (
                <div className="mt-1 text-[11px] text-[var(--tt-text-faint)]">{sub}</div>
              ) : null}
            </div>
          </div>
        );
      }

      function PerformanceDashboard({ mode, ledgerSummary, analytics }) {
        const isLedger = mode === "ledger";

        const loading = isLedger ? !!ledgerSummary?.loading : false;
        const err = isLedger ? ledgerSummary?.error : null;
        const t = isLedger ? ledgerSummary?.data?.totals : null;

        const totalTrades = isLedger
          ? Number(t?.totalTrades || 0)
          : Number(analytics?.totalTrades || 0);
        const openTrades = isLedger
          ? Number(t?.openTrades || 0)
          : Number(analytics?.openTrades || 0);
        const trimmedTrades = isLedger
          ? 0
          : Number(analytics?.trimmedTrades || 0);
        const closedTrades = isLedger
          ? Number(t?.closedTrades || 0)
          : Number(analytics?.closedTrades || 0);
        const wins = isLedger
          ? Number(t?.wins || 0)
          : Number(analytics?.wins || 0);
        const losses = isLedger
          ? Number(t?.losses || 0)
          : Number(analytics?.losses || 0);
        const winRate = isLedger
          ? Number(t?.winRate || 0)
          : Number(analytics?.winRate || 0);

        const closedPnl = isLedger
          ? Number(t?.closedPnl || 0)
          : Number(analytics?.totalPnl || 0);
        const openPnl = !isLedger ? Number(analytics?.openPnl || 0) : null;

        const avgWin = isLedger
          ? Number(t?.avgWin || 0)
          : Number(analytics?.avgWin || 0);
        const avgLoss = isLedger
          ? Number(t?.avgLoss || 0)
          : Number(analytics?.avgLoss || 0);
        const profitFactor = isLedger
          ? Number(t?.profitFactor || 0)
          : Number(analytics?.profitFactor || 0);
        const expectancy = isLedger
          ? Number(t?.expectancy || 0)
          : closedTrades > 0
            ? closedPnl / closedTrades
            : 0;

        const openCapitalTrades = isLedger
          ? openTrades
          : openTrades + trimmedTrades;
        const openCapital = openCapitalTrades * TRADE_SIZE;
        const totalCapital = totalTrades * TRADE_SIZE;

        const pfLabel =
          Number.isFinite(profitFactor) && profitFactor !== Infinity
            ? profitFactor.toFixed(2)
            : "∞";

        const cards = [
          { label: "Total Trades", value: fmtInt(totalTrades) },
          {
            label: "Open Trades",
            value: fmtInt(openTrades),
            sub: isLedger ? "status ≠ WIN/LOSS" : "no trims yet",
            tone: "yellow",
          },
          ...(!isLedger
            ? [
                {
                  label: "Trimmed Trades",
                  value: fmtInt(trimmedTrades),
                  sub: "partial position left",
                  tone: "blue",
                },
              ]
            : []),
          { label: "Wins", value: fmtInt(wins), tone: "green" },
          { label: "Losses", value: fmtInt(losses), tone: "red" },
          {
            label: "Win Rate",
            value: `${Number.isFinite(winRate) ? winRate.toFixed(1) : "0.0"}%`,
            tone: winRate >= 55 ? "green" : winRate >= 45 ? "yellow" : "red",
          },
          {
            label: "Closed P&L",
            value: fmtUsd(closedPnl),
            sub: `${fmtInt(closedTrades)} closed`,
            tone: closedPnl >= 0 ? "green" : "red",
          },
          ...(!isLedger
            ? [
                {
                  label: "Open P&L",
                  value: fmtUsd(openPnl),
                  sub: "unrealized",
                  tone: (openPnl || 0) >= 0 ? "green" : "yellow",
                },
              ]
            : []),
          { label: "Avg Win", value: fmtUsd(avgWin), tone: "green" },
          { label: "Avg Loss", value: fmtUsd(avgLoss), tone: "red" },
          {
            label: "Profit Factor",
            value: pfLabel,
            sub: "gross wins / gross losses",
            tone:
              profitFactor >= 1.5
                ? "green"
                : profitFactor >= 1.0
                  ? "yellow"
                  : "red",
          },
          {
            label: "Expectancy",
            value: fmtUsd(expectancy),
            sub: "avg per closed trade",
            tone: expectancy >= 0 ? "green" : "red",
          },
          {
            label: "Open Capital",
            value: fmtUsd(openCapital),
            sub: `${fmtUsd(TRADE_SIZE)} model / trade`,
            tone: "blue",
          },
        ];

        return (
          <div className="mb-6 bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
            <div className="flex items-center justify-between gap-3 flex-wrap mb-3">
              <div>
                <div className="text-xs text-[var(--tt-text-muted)]">Dashboard</div>
                <div className="text-lg font-bold">
                  {isLedger ? "Ledger KPIs" : "Legacy KPIs"}
                </div>
              </div>
              <div className="text-xs text-[var(--tt-text-faint)]">
                {isLedger ? "Source: D1 ledger" : "Source: KV + live prices"}
              </div>
            </div>

            {loading ? (
              <div className="text-sm text-[var(--tt-text-muted)]">
                Loading dashboard metrics…
              </div>
            ) : err ? (
              <div className="text-sm text-[var(--tt-negative)]">
                Dashboard unavailable: {err}
              </div>
            ) : (
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">
                {cards.map((c, idx) => (
                  <KpiCard
                    key={`${c.label}-${idx}`}
                    label={c.label}
                    value={c.value}
                    sub={c.sub || null}
                    tone={c.tone || "neutral"}
                  />
                ))}
              </div>
            )}
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Helper Functions for TickerDetails
      // ─────────────────────────────────────────────────────────────

      // Calculate score breakdown (mirrors computeDynamicScore / backend-style scoring)
      function calculateScoreBreakdown(ticker) {
        const htf = Number(ticker?.htf_score) || 0;
        const ltf = Number(ticker?.ltf_score) || 0;
        const phase = Number(ticker?.phase_pct) || 0;
        const rr = Number(ticker?.rr) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker?.flags || {};
        const state = String(ticker?.state || "");
        const ent = entryType(ticker || {});
        const inCorridor = !!ent?.corridor;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;

        const breakdown = {
          base: Number(ticker?.rank) || 50,
          corridor: inCorridor ? 12 : 0,
          corridorAligned: inCorridor && aligned ? 8 : 0,
          squeezeRelease: sqRel && inCorridor ? 10 : 0,
          squeezeOn: sqOn && inCorridor && !sqRel ? 5 : 0,
          rr: rr >= 2.0 ? 8 : rr >= 1.5 ? 5 : rr >= 1.0 ? 2 : 0,
          phase: phase < 0.3 ? 6 : phase < 0.5 ? 3 : phase > 0.7 ? -5 : 0,
          completion: comp < 0.3 ? 5 : comp > 0.8 ? -8 : 0,
          htfStrength: Math.min(8, Math.abs(htf) * 0.15),
          ltfStrength: Math.min(6, Math.abs(ltf) * 0.12),
          phaseZoneChange: phaseZoneChange ? 4 : 0,
        };

        breakdown.total = Math.max(
          0,
          breakdown.base +
            breakdown.corridor +
            breakdown.corridorAligned +
            breakdown.squeezeRelease +
            breakdown.squeezeOn +
            breakdown.rr +
            breakdown.phase +
            breakdown.completion +
            breakdown.htfStrength +
            breakdown.ltfStrength +
            breakdown.phaseZoneChange,
        );

        return breakdown;
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(204 + (174 - 204) * t)}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(174 + (156 - 174) * t)}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(156 + (126 - 156) * t)}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(126 + (76 - 126) * t)}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(76 + (57 - 76) * t)}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }

      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      function completionForSize(ticker) {
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      function computeDynamicRank(ticker) {
        const baseRank = Number(ticker.rank) || 50;
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        let dynamicScore = baseRank;
        if (inCorridor) {
          dynamicScore += 12;
          if (aligned) dynamicScore += 8;
        }
        if (sqRel && inCorridor) dynamicScore += 10;
        if (sqOn && inCorridor && !sqRel) dynamicScore += 5;
        if (rr >= 2.0) dynamicScore += 8;
        else if (rr >= 1.5) dynamicScore += 5;
        else if (rr >= 1.0) dynamicScore += 2;
        if (phase < 0.3) dynamicScore += 6;
        else if (phase < 0.5) dynamicScore += 3;
        else if (phase > 0.7) dynamicScore -= 5;
        if (comp < 0.3) dynamicScore += 5;
        else if (comp > 0.8) dynamicScore -= 8;
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;
        if (phaseZoneChange) dynamicScore += 4;
        return Math.max(0, Math.min(100, Math.round(dynamicScore)));
      }

      function toTickerArray(source) {
        if (!source) return [];
        if (Array.isArray(source)) {
          return source.filter((t) => t && typeof t === "object" && t.ticker);
        }
        if (typeof source === "object") {
          return Object.values(source).filter(
            (t) => t && typeof t === "object" && t.ticker,
          );
        }
        return [];
      }

      function rankScoreForTicker(ticker) {
        const rankScore = Number(ticker?.rank_score);
        if (Number.isFinite(rankScore)) return rankScore;
        const dynamicRank = Number(ticker?.dynamicRank);
        if (Number.isFinite(dynamicRank)) return dynamicRank;
        const dynamicScore = Number(ticker?.dynamicScore);
        if (Number.isFinite(dynamicScore)) return dynamicScore;
        return Number(computeDynamicRank(ticker)) || 0;
      }

      function getRankedTickers(source) {
        const list = toTickerArray(source);
        const withScores = list.map((t) => ({
          ...t,
          __rankPos: Number(t?.rank_position),
          __rankScore: rankScoreForTicker(t),
        }));
        withScores.sort((a, b) => {
          const rankA = Number(a.__rankPos);
          const rankB = Number(b.__rankPos);
          const hasRankA = Number.isFinite(rankA) && rankA > 0;
          const hasRankB = Number.isFinite(rankB) && rankB > 0;
          if (hasRankA && hasRankB) return rankA - rankB;
          if (hasRankA) return -1;
          if (hasRankB) return 1;
          const scoreA = Number(a.__rankScore) || 0;
          const scoreB = Number(b.__rankScore) || 0;
          return scoreB - scoreA;
        });
        return withScores;
      }

      function getRankPositionFromMap(rankPositions, tickerSymbol) {
        if (!rankPositions) return null;
        const sym = String(tickerSymbol || "")
          .trim()
          .toUpperCase();
        if (!sym) return null;
        const pos = Number(rankPositions[sym]);
        return Number.isFinite(pos) && pos > 0 ? pos : null;
      }

      // ─────────────────────────────────────────────────────────────
      // Opportunities Panel (unified: Prime / Eligible / Watch)
      // ─────────────────────────────────────────────────────────────
      function OpportunitiesPanel({
        tickers = [],
        rankPositions = null,
        onSelectTicker,
        defaultView = "prime",
      }) {
        const [view, setView] = React.useState(defaultView); // prime | eligible | watch | all
        const [dir, setDir] = React.useState("ALL"); // ALL | LONG | SHORT
        const [horizon, setHorizon] = React.useState("ALL"); // ALL | SHORT_TERM | SWING | POSITIONAL
        const [query, setQuery] = React.useState("");

        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const formatAge = (t) => {
          const raw = t?.ingest_ts ?? t?.ingest_time ?? t?.ts ?? t?.timestamp;
          if (!raw) return "—";
          let ms = null;
          if (typeof raw === "number" && Number.isFinite(raw)) ms = raw;
          else if (typeof raw === "string") {
            const parsed = new Date(raw).getTime();
            ms = Number.isFinite(parsed) ? parsed : null;
          } else {
            const n = Number(raw);
            ms = Number.isFinite(n) ? n : null;
          }
          if (!ms) return "—";
          const ageMs = Date.now() - ms;
          const ageMin = Math.floor(ageMs / 60000);
          if (ageMin < 60) return `${Math.max(0, ageMin)}m ago`;
          const ageHr = Math.floor(ageMin / 60);
          if (ageHr < 24) return `${ageHr}h ago`;
          const ageDay = Math.floor(ageHr / 24);
          return `${ageDay}d ago`;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isEligible = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);
          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct)
            return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct)
            return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf)
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr)
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const toBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const classify = (t) => {
          const prime = isPrimeBubble(t);
          const eligible = isEligible(t);
          return {
            prime,
            eligible,
            bucket: toBucket(t),
            dir: getDirection(t)?.text || "NEUTRAL",
          };
        };

        const counts = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          let prime = 0;
          let eligible = 0;
          for (const t of list) {
            const c = classify(t);
            if (c.prime) prime++;
            if (c.eligible) eligible++;
          }
          return { prime, eligible, all: list.length };
        }, [tickers]);

        const filtered = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const q = String(query || "")
            .trim()
            .toUpperCase();
          return list
            .map((t) => {
              const c = classify(t);
              const status = c.prime
                ? "prime"
                : c.eligible
                  ? "eligible"
                  : "watch";
              const score = Number(rankScoreForTicker(t) || 0);
              const rp =
                getRankPositionFromMap(
                  rankPositions,
                  String(t?.ticker || "").toUpperCase(),
                ) ?? Number(t?.rank_position);
              return {
                t,
                c,
                status,
                score,
                rp: Number.isFinite(rp) ? rp : null,
              };
            })
            .filter(({ t, c, status }) => {
              if (!t?.ticker) return false;
              if (view !== "all" && status !== view) return false;
              if (dir !== "ALL" && c.dir !== dir) return false;
              if (horizon !== "ALL" && c.bucket !== horizon) return false;
              if (q && !String(t.ticker).toUpperCase().includes(q))
                return false;
              return true;
            })
            .sort((a, b) => {
              const pri = (x) =>
                x.status === "prime" ? 0 : x.status === "eligible" ? 1 : 2;
              const dp = pri(a) - pri(b);
              if (dp !== 0) return dp;
              const ds = (b.score || 0) - (a.score || 0);
              if (ds !== 0) return ds;
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              return String(a.t.ticker).localeCompare(String(b.t.ticker));
            });
        }, [tickers, view, dir, horizon, query, rankPositions]);

        const pill = (label, isActive, onClick) => (
          <button
            onClick={onClick}
            className={`px-2.5 py-1 rounded-lg border text-xs font-semibold transition-all ${
              isActive
                ? "border-blue-400 bg-blue-500/20 text-blue-200"
                : "border-[var(--tt-border)] bg-[var(--tt-bg-surface)] text-[var(--tt-text-muted)] hover:text-white"
            }`}
          >
            {label}
          </button>
        );

        return (
          <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-xl p-3">
            <div className="flex items-start justify-between gap-3 flex-wrap">
              <div>
                <div className="text-sm font-bold text-white">
                  ✨ Opportunities
                </div>
                <div className="text-[10px] text-[var(--tt-text-muted)] mt-0.5">
                  Prime {counts.prime} • Eligible {counts.eligible} • Total{" "}
                  {counts.all}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <input
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  placeholder="Ticker…"
                  className="px-2 py-1 text-xs bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded text-white w-[110px]"
                />
              </div>
            </div>

            <div className="mt-2 flex items-center gap-2 flex-wrap">
              {pill("Prime", view === "prime", () => setView("prime"))}
              {pill("Eligible", view === "eligible", () => setView("eligible"))}
              {pill("Watch", view === "watch", () => setView("watch"))}
              {pill("All", view === "all", () => setView("all"))}
              <div className="w-px h-6 bg-[var(--tt-bg-elevated)] mx-1" />
              {pill("All", dir === "ALL", () => setDir("ALL"))}
              {pill("Long", dir === "LONG", () => setDir("LONG"))}
              {pill("Short", dir === "SHORT", () => setDir("SHORT"))}
              <div className="w-px h-6 bg-[var(--tt-bg-elevated)] mx-1" />
              {pill("Any horizon", horizon === "ALL", () => setHorizon("ALL"))}
              {pill("≤7d", horizon === "SHORT_TERM", () =>
                setHorizon("SHORT_TERM"),
              )}
              {pill("8–30d", horizon === "SWING", () => setHorizon("SWING"))}
              {pill("31d+", horizon === "POSITIONAL", () =>
                setHorizon("POSITIONAL"),
              )}
            </div>

            <div className="mt-3 max-h-[420px] overflow-y-auto space-y-2 pr-1">
              {filtered.length === 0 ? (
                <div className="text-xs text-[var(--tt-text-faint)] p-3">No matches.</div>
              ) : (
                filtered.slice(0, 75).map((item) => {
                  const t = item.t;
                  const c = item.c;
                  const actionInfo = getActionDescription(t);
                  const price = Number(t?.price);
                  const rr = Number(t?.rr);
                  const eta = computeEtaDays(t);
                  const age = formatAge(t);
                  const statusPill =
                    item.status === "prime"
                      ? "bg-yellow-500/15 text-yellow-300 border-yellow-500/40"
                      : item.status === "eligible"
                        ? "bg-green-500/15 text-green-400 border-green-500/40"
                        : "bg-[var(--tt-bg-elevated)] text-[var(--tt-text-muted)] border-[var(--tt-border)]";
                  const dirPill =
                    c.dir === "LONG"
                      ? "bg-green-500/10 text-green-400 border-green-500/30"
                      : c.dir === "SHORT"
                        ? "bg-red-500/10 text-red-400 border-red-500/30"
                        : "bg-[var(--tt-bg-elevated)] text-[var(--tt-text-muted)] border-[var(--tt-border)]";
                  return (
                    <button
                      key={t.ticker}
                      onClick={() => onSelectTicker && onSelectTicker(t.ticker)}
                      className="w-full text-left px-3 py-2 rounded-lg border border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-elevated)] hover:border-[var(--tt-border-strong)] transition-all"
                      title="Open in right rail"
                    >
                      <div className="flex items-start justify-between gap-2">
                        <div className="min-w-0">
                          <div className="flex items-center gap-2 flex-wrap">
                            <div className="font-bold text-white">
                              {t.ticker}
                            </div>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${statusPill}`}
                            >
                              {item.status === "prime"
                                ? "Prime"
                                : item.status === "eligible"
                                  ? "Eligible"
                                  : "Watch"}
                            </span>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${dirPill}`}
                            >
                              {c.dir}
                            </span>
                            {c.bucket && c.bucket !== "UNKNOWN" && (
                              <span className="px-2 py-0.5 rounded border border-[var(--tt-border)] bg-[var(--tt-bg-surface)] text-[10px] text-[var(--tt-text-muted)]">
                                {c.bucket === "SHORT_TERM"
                                  ? "≤7d"
                                  : c.bucket === "SWING"
                                    ? "8–30d"
                                    : "31d+"}
                              </span>
                            )}
                          </div>
                          <div className="mt-0.5 text-[11px] text-[var(--tt-text-muted)] whitespace-nowrap overflow-hidden text-ellipsis">
                            <span className="text-[var(--tt-text-faint)]">
                              {actionInfo.action}
                            </span>
                          </div>
                        </div>

                        <div className="flex-shrink-0 text-right text-[11px]">
                          <div className="text-white">
                            {Number.isFinite(price)
                              ? `$${price.toFixed(2)}`
                              : "—"}
                          </div>
                          <div className="text-[var(--tt-text-faint)]">{age}</div>
                        </div>
                      </div>

                      <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[var(--tt-text-muted)]">
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Score</span>{" "}
                          <span className="text-white font-semibold">
                            {(() => {
                              const s = rankScoreForTicker(t);
                              return Number.isFinite(s) ? s.toFixed(1) : "—";
                            })()}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Rank</span>{" "}
                          <span className="text-white font-semibold">
                            {item.rp != null ? `#${item.rp}` : "—"}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">RR/ETA</span>{" "}
                          <span className="text-white font-semibold">
                            {Number.isFinite(rr) ? rr.toFixed(2) : "—"} /{" "}
                            {eta != null ? `${eta.toFixed(1)}d` : "—"}
                          </span>
                        </div>
                      </div>

                      {(() => {
                        const phaseP = Math.max(
                          0,
                          Math.min(1, Number(t?.phase_pct) || 0),
                        );
                        const compP = completionForSize(t);
                        const phaseColor = phaseToColor(phaseP);
                        const compColor = phaseToColor(compP);
                        const Bar = ({ label, p, color }) => (
                          <div className="flex items-center gap-2">
                            <div className="w-20 text-[10px] text-[var(--tt-text-faint)]">
                              {label}
                            </div>
                            <div className="flex-1 h-1.5 rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] overflow-hidden">
                              <div
                                className="h-full"
                                style={{
                                  width: `${Math.round(p * 100)}%`,
                                  background: color,
                                }}
                              />
                            </div>
                            <div className="w-10 text-right text-[10px] text-[var(--tt-text-muted)]">
                              {Math.round(p * 100)}%
                            </div>
                          </div>
                        );
                        return (
                          <div className="mt-2 space-y-1">
                            <Bar label="Phase" p={phaseP} color={phaseColor} />
                            <Bar
                              label="Completion"
                              p={compP}
                              color={compColor}
                            />
                          </div>
                        );
                      })()}
                    </button>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      function downsampleByInterval(points, intervalMs) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const buckets = new Map();
        points.forEach((p) => {
          const tsRaw = p.__ts_ms ?? p.ts ?? p.ingest_ts ?? p.ingest_time;
          const ts =
            typeof tsRaw === "string"
              ? new Date(tsRaw).getTime()
              : Number(tsRaw);
          if (!Number.isFinite(ts)) return;
          const bucket = Math.floor(ts / intervalMs) * intervalMs;
          const prev = buckets.get(bucket);
          if (!prev || ts > prev.__ts_ms) {
            buckets.set(bucket, { ...p, __ts_ms: ts, __bucket: bucket });
          }
        });
        return Array.from(buckets.values()).sort(
          (a, b) => a.__ts_ms - b.__ts_ms,
        );
      }

      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const isAligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(0)}% completion. Consider taking profits or trimming 50-75% of position.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(0)}% indicates late-cycle conditions. Wait for pullback or trim existing positions.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20",
          };
        }
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock showing Prime setup with exceptional alignment. High-probability setup with strong fundamentals.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. Enter on pullback or break.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase and low completion suggest room to run.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. Wait for better conditions or confirmation signals.`,
          color: "text-[var(--tt-text-muted)]",
          bg: "bg-[var(--tt-bg-elevated)]",
        };
      }

      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK")
          return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL")
          return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR")
          return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK")
          return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map((p) => p.state).filter(Boolean);
        for (let i = 1; i < states.length; i++) {
          if (
            states[i - 1] === "HTF_BULL_LTF_PULLBACK" &&
            states[i] === "HTF_BULL_LTF_BULL"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1→Q2 transition (Bull Entry)",
              quadrant: "Q1→Q2",
              confidence: "HIGH",
            });
          }
          if (
            states[i - 1] === "HTF_BEAR_LTF_PULLBACK" &&
            states[i] === "HTF_BEAR_LTF_BEAR"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4→Q3 transition (Bear Entry)",
              quadrant: "Q4→Q3",
              confidence: "HIGH",
            });
          }
        }
        return patterns;
      }

      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = useState([]);
        const [loading, setLoading] = useState(false);
        const [hasLoaded, setHasLoaded] = useState(false);
        useEffect(() => {
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const res = await fetch(
                  `${API_BASE}/timed/trail?ticker=${encodeURIComponent(ticker.ticker)}`,
                );
                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && Array.isArray(data.trail)) {
                    setTrail(data.trail);
                  }
                }
              } catch (e) {
                console.error("Failed to load trail:", e);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300);
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);
        const sampledTrail = useMemo(
          () => downsampleByInterval(trail, 15 * 60 * 1000),
          [trail],
        );
        const patterns = detectPatterns(sampledTrail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = sampledTrail
          .map((p) => getQuadrantFromState(p.state))
          .filter(Boolean);
        return (
          <div className="mb-4 p-4 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
            <div className="text-sm font-bold mb-3 text-[var(--tt-text-muted)]">
              Quadrant Progression (15m increments)
            </div>
            <div className="grid grid-cols-2 gap-2 mb-4">
              {[1, 2, 4, 3].map((q) => {
                const quad =
                  q === 1
                    ? { q: 1, name: "Q1", label: "Bull Setup", color: "blue" }
                    : q === 2
                      ? {
                          q: 2,
                          name: "Q2",
                          label: "Bull Momentum",
                          color: "green",
                        }
                      : q === 4
                        ? {
                            q: 4,
                            name: "Q4",
                            label: "Bear Setup",
                            color: "orange",
                          }
                        : {
                            q: 3,
                            name: "Q3",
                            label: "Bear Momentum",
                            color: "red",
                          };
                const isActive = currentQuad?.q === quad.q;
                const hasHistory = quadHistory.some(
                  (qh) => qh && qh.q === quad.q,
                );
                return (
                  <div
                    key={q}
                    className={`p-3 rounded-lg border-2 ${
                      isActive
                        ? `border-${quad.color}-400 bg-${quad.color}-500/20`
                        : hasHistory
                          ? `border-${quad.color}-500/50 bg-${quad.color}-500/10`
                          : "border-[var(--tt-border)] bg-[var(--tt-bg-surface)]"
                    }`}
                  >
                    <div className={`text-xs font-bold text-${quad.color}-400`}>
                      {quad.name}: {quad.label}
                    </div>
                  </div>
                );
              })}
            </div>
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[var(--tt-border)]">
                <div className="text-xs font-bold text-yellow-400 mb-2">
                  🎯 Detected Patterns
                </div>
                {patterns.map((pattern, idx) => (
                  <div
                    key={idx}
                    className="p-2 rounded border bg-yellow-500/20 border-yellow-400/50 mb-2"
                  >
                    <div className="text-xs font-bold text-white">
                      {pattern.description}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      }

      function TickerDetails({ ticker, onClose, allLoadedData = null }) {
        if (!ticker) return null;
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) return allLoadedData;
            return Object.values(allLoadedData).filter(
              (t) => t && typeof t === "object" && t.ticker,
            );
          }
          return [];
        })();
        const baseScore = Number(ticker.rank) || 0;
        const displayScore = rankScoreForTicker(ticker);
        const dynamicRank = computeDynamicRank(ticker);
        const allTickersWithRank = allLoadedTickersArray.map((t) => ({
          ...t,
          dynamicRank: computeDynamicRank(t),
        }));
        const sortedByDynamic = [...allTickersWithRank].sort(
          (a, b) => b.dynamicRank - a.dynamicRank,
        );
        const rankPosition =
          sortedByDynamic.findIndex(
            (t) =>
              String(t.ticker || "").toUpperCase() ===
              String(ticker.ticker || "").toUpperCase(),
          ) + 1;
        const totalTickers = allLoadedTickersArray.length;
        return (
          <div className="w-full h-full flex flex-col">
            <div className="w-full h-full flex flex-col slide-in-right shadow-2xl rounded-xl border-2" style={{ background: "#0c0f14", borderColor: "var(--tt-border)" }}>
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button
                    onClick={onClose}
                    className="text-[var(--tt-text-muted)] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)]"
                  >
                    ✕
                  </button>
                </div>
                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      🚀 MOMENTUM ELITE 🚀
                    </div>
                  </div>
                )}
                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500">
                    ⭐ PRIME SETUP ⭐
                  </div>
                )}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                      <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color}`}
                      >
                        {dir.text === "LONG"
                          ? "📈 LONG"
                          : dir.text === "SHORT"
                            ? "📉 SHORT"
                            : dir.text}
                      </div>
                    </div>
                  );
                })()}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[var(--tt-text-muted)]">
                    {actionInfo.description}
                  </div>
                </div>
                <QuadrantProgression ticker={ticker} flags={flags} />
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[var(--tt-text-muted)]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                    </span>
                  </div>
                  <div className="h-3 bg-[var(--tt-bg-elevated)] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                      }}
                    />
                  </div>
                </div>
                <div className="space-y-2.5 text-sm">
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Score</span>
                    <span className="font-semibold text-blue-400 text-lg">
                      {Number.isFinite(displayScore)
                        ? displayScore.toFixed(1)
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Rank</span>
                    <span className="font-semibold">
                      {rankPosition > 0
                        ? `#${rankPosition} of ${totalTickers}`
                        : "—"}
                    </span>
                  </div>
                  {dynamicRank !== baseScore && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Dynamic Score</span>
                      <span className="font-semibold text-green-400">
                        {dynamicRank}
                      </span>
                    </div>
                  )}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const components = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(1)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(1)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return (
                      <div className="mt-4 pt-4 border-t border-[var(--tt-border)]">
                        <div className="text-xs text-[var(--tt-text-muted)] mb-3 font-semibold">
                          Score Breakdown
                        </div>
                        <div className="space-y-1.5">
                          {components.map((comp, idx) => (
                            <div
                              key={idx}
                              className="flex justify-between items-center text-xs"
                            >
                              <span className="text-[var(--tt-text-muted)]">
                                {comp.label}
                              </span>
                              <span className={`font-semibold ${comp.color}`}>
                                {comp.value}
                              </span>
                            </div>
                          ))}
                          <div className="flex justify-between items-center pt-2 mt-2 border-t border-[var(--tt-border)]/50">
                            <span className="text-[var(--tt-text-muted)] font-semibold">
                              Total Score
                            </span>
                            <span className="font-bold text-lg text-blue-400">
                              {Math.round(breakdown.total)}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">State</span>
                    <span className="font-semibold">{ticker.state || "—"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Completion</span>
                    <span className="font-semibold">
                      {Math.round(completionForSize(ticker) * 100)}%
                    </span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                        {ent.side}
                      </span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Current Price</span>
                    <span className="font-semibold text-lg">
                      {ticker.price
                        ? `$${Number(ticker.price).toFixed(2)}`
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">TP (Primary)</span>
                    <span className="font-semibold">
                      {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">SL</span>
                    <span className="font-semibold">
                      {ticker.sl ? Number(ticker.sl).toFixed(2) : "—"}
                    </span>
                  </div>
                </div>
                {(flags.sq30_on ||
                  flags.sq30_release ||
                  flags.phase_dot ||
                  flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[var(--tt-text-muted)] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && (
                        <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                          🧨 Squeeze ON
                        </span>
                      )}
                      {flags.sq30_release && (
                        <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                          ⚡ Squeeze Release
                        </span>
                      )}
                      {flags.phase_dot && (
                        <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                          Phase Dot
                        </span>
                      )}
                      {flags.phase_zone_change && (
                        <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                          Zone Change
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </div>
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[var(--tt-border)] bg-[var(--tt-bg-elevated)]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(ticker.ticker)}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  📊 Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // TickerDetailsLoader - Loads ticker data and passes to unified component
      // ─────────────────────────────────────────────────────────────
      const TickerDetailsLoader = ({
        tickerSymbol,
        trade = null,
        onClose,
        allLoadedData = null,
        sectors = [],
        rankedTickers = null,
        rankedTickerPositions = null,
        positionEvents = null,
      }) => {
        const [tickerData, setTickerData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              const res = await fetch(
                `${API_BASE}/timed/latest?ticker=${encodeURIComponent(tickerSymbol)}`,
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok || !json.data) {
                throw new Error(json.error || "Ticker not found");
              }
              setTickerData(json.data || json.latestData);
            } catch (err) {
              console.error("Failed to fetch ticker:", err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };
          fetchTicker();
        }, [tickerSymbol]);

        if (loading) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[var(--tt-bg-surface)]">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[var(--tt-text-muted)]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }

        if (error || !tickerData) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[var(--tt-bg-surface)]">
              <div className="text-center">
                <div className="text-red-400 mb-2">
                  Failed to load {tickerSymbol}
                </div>
                <div className="text-[var(--tt-text-muted)] text-sm mb-4">
                  {error || "No data available"}
                </div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-elevated)] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }

        return (
          <TickerDetailRightRail
            ticker={tickerData}
            trade={trade}
            onClose={onClose}
            allLoadedData={allLoadedData}
            sectors={sectors}
            rankedTickers={rankedTickers}
            rankedTickerPositions={rankedTickerPositions}
            positionEvents={positionEvents}
          />
        );
      };

      // ─────────────────────────────────────────────────────────────
      // Welcome Modal Component - Dashboard Guide (Trading Concepts)
      // ─────────────────────────────────────────────────────────────
      function DashboardWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Timed Trading! 🎯",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  This dashboard helps you find high-quality trading setups by
                  combining multiple timeframes and technical indicators.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎓 How to Use This Guide
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    Click "Next" to learn about each concept, or use the
                    navigation dots to jump to any section. You can always
                    reopen this guide from the navigation bar.
                  </p>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ✨ Quick Start
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">green zones</strong> (Q1 &
                      Q2) for LONG setups
                    </li>
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">red zones</strong> (Q3 &
                      Q4) for SHORT setups
                    </li>
                    <li>Click on any bubble to see detailed information</li>
                    <li>Use filters to narrow down the best opportunities</li>
                  </ol>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding the Quadrants 📊",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The chart is divided into <strong>4 quadrants</strong> based
                  on two scores:
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                    <h3 className="text-green-400 font-semibold mb-2">
                      HTF Score (Y-axis)
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      <strong className="text-white">Higher Timeframe</strong> -
                      Shows the overall trend direction.
                      <br />• Positive = Bullish trend
                      <br />• Negative = Bearish trend
                    </p>
                  </div>
                  <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                    <h3 className="text-blue-400 font-semibold mb-2">
                      LTF Score (X-axis)
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      <strong className="text-white">Lower Timeframe</strong> -
                      Shows entry timing.
                      <br />• Positive = Momentum/Continuation
                      <br />• Negative = Pullback/Setup
                    </p>
                  </div>
                </div>
                <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-3">
                    The 4 Quadrants:
                  </h3>
                  <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q1: Long Setup 📈
                      </div>
                      <div className="text-[var(--tt-text-muted)]">
                        HTF Bull + LTF Pullback
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Best entry zone for LONG trades
                      </div>
                    </div>
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q2: Long Momentum 🚀
                      </div>
                      <div className="text-[var(--tt-text-muted)]">HTF Bull + LTF Bull</div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q3: Short Momentum 📉
                      </div>
                      <div className="text-[var(--tt-text-muted)]">HTF Bear + LTF Bear</div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q4: Short Setup 🔻
                      </div>
                      <div className="text-[var(--tt-text-muted)]">
                        HTF Bear + LTF Pullback
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Best entry zone for SHORT trades
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Prime Setups ⭐",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  <strong className="text-yellow-400">Prime Setups</strong> are
                  the highest-quality opportunities. They have a ⭐ icon and
                  appear with a green glow.
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    Prime Setup Criteria:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Rank ≥ 75</strong> - High
                      overall quality score
                    </li>
                    <li>
                      <strong className="text-white">Risk/Reward ≥ 1.5</strong>{" "}
                      - Good profit potential vs risk
                    </li>
                    <li>
                      <strong className="text-white">Completion ≤ 40%</strong> -
                      Still early in the move
                    </li>
                    <li>
                      <strong className="text-white">In Corridor</strong> -
                      Valid entry zone
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    💡 How to Find Prime Setups:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"Prime Only"</strong>{" "}
                      filter button
                    </li>
                    <li>Look for bubbles with ⭐ icons and green borders</li>
                    <li>Click on a bubble to see detailed entry/exit levels</li>
                    <li>Check the Risk/Reward ratio - higher is better!</li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Tip:</strong> Prime
                    setups are rare but offer the best risk/reward. Focus on Q1
                    (Long Setup) and Q4 (Short Setup) quadrants for the best
                    entries.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "In Corridor 🎯",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The <strong className="text-cyan-400">Corridor</strong> is a
                  specific zone where entries are considered valid and safe.
                </p>
                <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                  <h3 className="text-cyan-400 font-semibold mb-2">
                    What is a Corridor?
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                    A corridor is a narrow band on the chart where price action
                    is optimal for entry. Think of it as a "sweet spot" where
                    the setup is most likely to succeed.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Long Corridor 📈
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        HTF Score &gt; 0<br />
                        LTF Score: -8 to +12
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Short Corridor 📉
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        HTF Score &lt; 0<br />
                        LTF Score: -12 to +8
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How to Use Corridor Filter:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"In Corridor"</strong>{" "}
                      filter button
                    </li>
                    <li>This shows only tickers in valid entry zones</li>
                    <li>These are the safest setups to trade</li>
                    <li>
                      Combine with "Prime Only" for the best opportunities
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">
                      Why Corridors Matter:
                    </strong>{" "}
                    Tickers outside corridors may be too early, too late, or in
                    unfavorable conditions. Corridor entries have the highest
                    probability of success.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "TD Sequential (TD9) 🔢",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  <strong className="text-purple-400">TD Sequential</strong> is
                  a powerful indicator that identifies potential reversal
                  points.
                </p>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    What is TD9?
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                    TD Sequential counts consecutive bars in one direction. When
                    it reaches <strong className="text-white">9</strong>, it
                    signals potential exhaustion and reversal.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        TD9 Bullish 📈
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        Signals potential <strong>bottom</strong> and upward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for LONG entries
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        TD9 Bearish 📉
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        Signals potential <strong>top</strong> and downward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for SHORT entries or exit
                        LONGs
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🔢 How to Use TD9 Filter:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"TD9 Setup"</strong> filter
                      button
                    </li>
                    <li>This shows only tickers with active TD9 signals</li>
                    <li>
                      TD9 signals are strongest when combined with other
                      factors:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>
                          In the correct quadrant (Q1 for bullish, Q4 for
                          bearish)
                        </li>
                        <li>In corridor</li>
                        <li>With good Risk/Reward</li>
                      </ul>
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Pro Tip:</strong> TD9
                    signals are most powerful at extremes. If you see a TD9
                    signal in Q1 (Long Setup) or Q4 (Short Setup), it's a strong
                    confirmation of a reversal setup.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Squeeze Indicators 🧨⚡",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The <strong className="text-yellow-400">Squeeze</strong>{" "}
                  indicator shows when volatility is building up, like a spring
                  being compressed before release.
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                    <h3 className="text-yellow-400 font-semibold mb-2 flex items-center gap-2">
                      🧨 In Squeeze
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                      Volatility is{" "}
                      <strong className="text-white">compressed</strong> - price
                      is consolidating.
                    </p>
                    <div className="text-xs text-[var(--tt-text-muted)] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        Energy is building up
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Watch
                        closely - a big move is coming
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Wait for squeeze release
                      </div>
                    </div>
                  </div>
                  <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                    <h3 className="text-cyan-400 font-semibold mb-2 flex items-center gap-2">
                      ⚡ Squeeze Release
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                      Volatility has{" "}
                      <strong className="text-white">exploded</strong> - price
                      is breaking out.
                    </p>
                    <div className="text-xs text-[var(--tt-text-muted)] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        The spring has released!
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Strong
                        momentum signal
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Enter on pullback or breakout
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How to Use Squeeze Filters:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">
                        "In Squeeze" Filter:
                      </strong>{" "}
                      Shows tickers where volatility is building. These are good
                      to watch but wait for release before entering.
                    </div>
                    <div>
                      <strong className="text-white">
                        "Squeeze Release" Filter:
                      </strong>{" "}
                      Shows tickers where the squeeze has fired. These often
                      have strong momentum - combine with Prime filter for best
                      results.
                    </div>
                  </div>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    💡 Best Practices:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">
                        Squeeze Release + Prime Setup
                      </strong>{" "}
                      = Very strong signal
                    </li>
                    <li>
                      <strong className="text-white">
                        Squeeze Release + In Corridor
                      </strong>{" "}
                      = High probability entry
                    </li>
                    <li>
                      <strong className="text-white">In Squeeze</strong> =
                      Prepare but don't enter yet
                    </li>
                    <li>
                      Look for squeeze release in the direction of the HTF trend
                    </li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together 🎓",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  Now that you understand the concepts, here's a{" "}
                  <strong className="text-yellow-400">
                    step-by-step workflow
                  </strong>{" "}
                  to find great setups:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    📋 Your Trading Workflow:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Step 1: Choose Your Direction
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • For LONG trades: Focus on Q1 (Long Setup) quadrant
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • For SHORT trades: Focus on Q4 (Short Setup) quadrant
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 2: Apply Quality Filters
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Click "Prime Only" to see only high-quality setups
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Click "In Corridor" to ensure valid entry zones
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 3: Look for Confirmation Signals
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • TD9 Setup: Strong reversal signal
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Squeeze Release ⚡: Strong momentum
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Momentum Elite 🚀: Best fundamentals
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 4: Analyze the Setup
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Click on a bubble to see details
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Check Risk/Reward ratio (aim for ≥ 1.5)
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Verify entry price, stop loss, and take profit levels
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 5: Execute Your Trade
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Enter at the suggested entry price
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Set stop loss at the SL level
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Target the TP levels (consider trimming at first TP)
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ⭐ The Perfect Setup Checklist:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>
                      ✅ In the correct quadrant (Q1 for LONG, Q4 for SHORT)
                    </div>
                    <div>✅ Prime Setup (⭐ icon)</div>
                    <div>✅ In Corridor</div>
                    <div>✅ Risk/Reward ≥ 1.5</div>
                    <div>✅ Completion ≤ 40% (still early)</div>
                    <div>
                      ✅ TD9 signal OR Squeeze Release (bonus confirmation)
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Remember:</strong> Not
                    every setup will have all these factors. Use your judgment
                    and risk management. Start with paper trading if you're new!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[var(--tt-bg-base)] border-2 border-[var(--tt-border)] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[var(--tt-border)] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[var(--tt-bg-elevated)]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[var(--tt-text-muted)] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[var(--tt-border)] p-4 flex items-center justify-between bg-[var(--tt-bg-surface)]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[var(--tt-border)] text-[var(--tt-text-muted)] opacity-50 cursor-not-allowed"
                      : "border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-hover)] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[var(--tt-text-muted)]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Trading! 🚀
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Welcome Modal Component - Simulated Trades Guide
      // ─────────────────────────────────────────────────────────────
      function TrackerWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Trade Tracker! 📊",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  The Trade Tracker automatically simulates trades based on
                  alerts from the main dashboard, helping you learn which setups
                  work best.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How It Works:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      When an alert fires from TradingView, a simulated trade is
                      automatically created
                    </li>
                    <li>
                      Each trade uses a{" "}
                      <strong className="text-white">
                        $1,000 position size
                      </strong>
                    </li>
                    <li>
                      Trades are tracked in real-time with live P&L updates
                    </li>
                    <li>
                      When price hits Stop Loss or Take Profit, the trade closes
                      automatically
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ✨ What You'll Learn:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>Which setups have the best win rate</li>
                    <li>How different Risk/Reward ratios perform</li>
                    <li>Which model versions work best</li>
                    <li>Performance by rank, sector, and other factors</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Note:</strong> These are
                    simulated trades for learning purposes only. Always do your
                    own research before making real trades!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding Trade Statuses 🏷️",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  Each trade has a <strong>status</strong> that tells you its
                  current state:
                </p>
                <div className="grid grid-cols-1 gap-3">
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>🟢 OPEN</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade is active and being tracked. P&L updates in
                      real-time as price moves. The trade will close when it
                      hits Stop Loss or Take Profit.
                    </p>
                  </div>
                  <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                    <div className="font-bold text-blue-400 mb-2 flex items-center gap-2">
                      <span>🔵 TP_HIT_TRIM</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      First Take Profit level was hit! The system automatically
                      trimmed (sold) part of the position to lock in profits.
                      The remaining position stays open to target higher TP
                      levels.
                    </p>
                  </div>
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>✅ WIN</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade closed profitably! Either hit a Take Profit level or
                      was manually closed in profit. Check the trade history to
                      see the exit details.
                    </p>
                  </div>
                  <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                    <div className="font-bold text-red-400 mb-2 flex items-center gap-2">
                      <span>❌ LOSS</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade hit Stop Loss and closed at a loss. This is normal -
                      not every trade wins! Review what went wrong to improve
                      future setups.
                    </p>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Tip:</strong> Click on
                    any trade row to see detailed information including entry
                    price, stop loss, take profit levels, and full trade
                    history.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Reading the Trade Table 📋",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The trade table shows all your simulated trades. Here's what
                  each column means:
                </p>
                <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                  <div className="space-y-3 text-sm">
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Ticker
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        The stock or futures contract symbol
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Direction
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        LONG (buy) or SHORT (sell)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Entry Price
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Price when the trade was opened
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Current Price
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Live market price (updates every 30 seconds)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Profit or Loss in dollars.{" "}
                        <span className="text-green-400">Green = profit</span>,
                        <span className="text-red-400"> red = loss</span>
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L %
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Profit or Loss as a percentage
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Shares/Contracts
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        For stocks: number of shares (based on $1,000 position).
                        For futures: number of contracts (usually 1)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Status
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Current trade status (OPEN, WIN, LOSS, etc.)
                      </span>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    💡 Pro Tips:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      Click any trade row to see detailed information and trade
                      history
                    </li>
                    <li>
                      Use the version filter to compare different model versions
                    </li>
                    <li>
                      Open trades show live P&L that updates automatically
                    </li>
                    <li>Closed trades show final P&L and exit reason</li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "How P&L is Calculated 💰",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  Understanding how profit and loss is calculated helps you
                  interpret the results:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    📈 For Stocks:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">Position Size:</strong>{" "}
                      $1,000 per trade
                    </div>
                    <div>
                      <strong className="text-white">Shares:</strong> $1,000 ÷
                      Entry Price
                    </div>
                    <div>
                      <strong className="text-white">P&L (LONG):</strong>{" "}
                      (Current Price - Entry Price) × Shares
                    </div>
                    <div>
                      <strong className="text-white">P&L (SHORT):</strong>{" "}
                      (Entry Price - Current Price) × Shares
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    📊 For Futures:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">Contracts:</strong> Usually
                      1 contract per trade
                    </div>
                    <div>
                      <strong className="text-white">Point Value:</strong> Each
                      futures contract has a point value:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>NQ1! (Nasdaq): $20 per point</li>
                        <li>ES1! (S&P 500): $50 per point</li>
                        <li>Other futures vary</li>
                      </ul>
                    </div>
                    <div>
                      <strong className="text-white">P&L:</strong> (Price
                      Change) × Contracts × Point Value
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2">
                    🎯 Example:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>
                      <strong className="text-white">Stock Trade:</strong> AAPL
                      at $150 entry, $155 current
                    </div>
                    <div className="ml-4">
                      Shares: $1,000 ÷ $150 = 6.67 shares
                    </div>
                    <div className="ml-4">
                      P&L: ($155 - $150) × 6.67 ={" "}
                      <span className="text-green-400">+$33.35</span>
                    </div>
                    <div className="mt-2">
                      <strong className="text-white">Futures Trade:</strong>{" "}
                      NQ1! at 15,000 entry, 15,100 current
                    </div>
                    <div className="ml-4">
                      Price Change: 15,100 - 15,000 = 100 points
                    </div>
                    <div className="ml-4">
                      P&L: 100 × 1 × $20 ={" "}
                      <span className="text-green-400">+$2,000</span>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Tracking & Analytics 📊",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The Trade Tracker provides powerful analytics to help you
                  learn:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    📈 Performance Metrics:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Win Rate:</strong>{" "}
                      Percentage of winning trades
                    </li>
                    <li>
                      <strong className="text-white">Total P&L:</strong> Sum of
                      all profits and losses
                    </li>
                    <li>
                      <strong className="text-white">Average Win/Loss:</strong>{" "}
                      Average profit per win vs loss
                    </li>
                    <li>
                      <strong className="text-white">Best/Worst Trade:</strong>{" "}
                      Your biggest winners and losers
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🔍 Filter by Version:
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-2">
                    Use the "Model Version" dropdown to compare performance
                    across different versions of the trading model. This helps
                    you see which improvements work best.
                  </p>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-white">Tip:</strong> Newer versions
                    often include improvements, but older versions may have
                    proven track records.
                  </p>
                </div>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    📊 Daily Summary:
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    Click "View Daily Summary" to see performance breakdowns by:
                  </p>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1 mt-2">
                    <li>Rank ranges (which ranked setups perform best)</li>
                    <li>Risk/Reward ratios (which RR ratios win more)</li>
                    <li>Quadrants (which chart zones are most profitable)</li>
                    <li>Overall statistics and insights</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Remember:</strong> The
                    goal is to learn which setups work best. Review your wins
                    and losses regularly to improve your trading strategy!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together 🎓",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  Here's your{" "}
                  <strong className="text-yellow-400">workflow</strong> for
                  using the Trade Tracker:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    📋 Daily Workflow:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Monitor Open Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check the "Open Trades" section regularly
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Watch P&L update in real-time
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Click trades to see detailed information
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Review Closed Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check "Closed Trades" to see final results
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Review trade history to understand what happened
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Learn from both wins and losses
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Analyze Performance
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Use the version filter to compare models
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Check daily summary for insights
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Look for patterns in winning vs losing trades
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Improve Your Strategy
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Focus on setups with high win rates
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Avoid setups that consistently lose
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Adjust filters on the main dashboard based on results
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ⭐ Key Takeaways:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>✅ Trades are created automatically from alerts</div>
                    <div>✅ Each trade uses $1,000 position size</div>
                    <div>✅ P&L updates in real-time for open trades</div>
                    <div>✅ Trades close automatically at SL or TP</div>
                    <div>✅ Use analytics to learn which setups work best</div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">
                      Ready to start tracking?
                    </strong>{" "}
                    The Trade Tracker refreshes every 30 seconds to show the
                    latest trades and updates. Click "Start Tracking!" to begin!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[var(--tt-bg-base)] border-2 border-[var(--tt-border)] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[var(--tt-border)] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[var(--tt-bg-elevated)]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[var(--tt-text-muted)] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[var(--tt-border)] p-4 flex items-center justify-between bg-[var(--tt-bg-surface)]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[var(--tt-border)] text-[var(--tt-text-muted)] opacity-50 cursor-not-allowed"
                      : "border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-hover)] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[var(--tt-text-muted)]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Tracking! 🚀
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Paper portfolio proof section (extracted from IIFE to fix Babel parse error)
      function PaperPortfolioProofSection({
        paperPortfolio,
        ledgerRangeDays,
        ledgerClosedTrades,
        setLedgerTab,
        setSelectedTicker,
        setSelectedTrade,
      }) {
        const pp = paperPortfolio ?? {};
        const p = pp.data?.portfolio || {};
        const ex = pp.data?.executions || {};
        const byDay =
          ex.byDay && typeof ex.byDay === "object" ? ex.byDay : {};
        const proof = pp.data?.proof;
        const proofByDay =
          proof && typeof proof.byDay === "object" ? proof.byDay : null;
        const openPos = Array.isArray(p.openPositions) ? p.openPositions : [];
        const dayKeyUtc = (ts) => {
          const d = new Date(Number(ts));
          if (!Number.isFinite(d.getTime())) return null;
          return d.toISOString().slice(0, 10);
        };
        const daysBackKeys = (n) => {
          const keys = [];
          for (let i = 0; i < n; i++) {
            const d = new Date();
            d.setUTCDate(d.getUTCDate() - i);
            keys.push(d.toISOString().slice(0, 10));
          }
          return keys;
        };
        const windowDays = Math.max(1, Number(ledgerRangeDays) || 7);
        const windowKeys = daysBackKeys(Math.min(60, windowDays));
        const entryByTradeId = new Map();
        const allEvents = [];
        for (const k of Object.keys(byDay)) {
          const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
          for (const e of arr) allEvents.push(e);
        }
        for (const e of allEvents) {
          const type = String(e?.type || "").toUpperCase();
          const tradeId = String(e?.trade_id || "");
          if (!tradeId || type !== "ENTRY") continue;
          const entryPrice = Number(e?.price);
          const direction = String(e?.direction || "").toUpperCase();
          if (
            Number.isFinite(entryPrice) &&
            (direction === "LONG" || direction === "SHORT")
          ) {
            entryByTradeId.set(tradeId, {
              entryPrice,
              direction,
              entryShares: Number.isFinite(Number(e?.shares)) ? Number(e?.shares) : null,
              entryTs: Number.isFinite(Number(e?.ts)) ? Number(e.ts) : null,
            });
          }
        }
        const pnlForEvent = (e) => {
          const type = String(e?.type || "").toUpperCase();
          if (type !== "TRIM" && type !== "EXIT") return null;
          const meta = entryByTradeId.get(String(e?.trade_id || ""));
          if (!meta) return null;
          const price = Number(e?.price);
          const shares = Number(e?.shares);
          if (!Number.isFinite(price) || !Number.isFinite(shares)) return null;
          const sign = meta.direction === "SHORT" ? -1 : 1;
          return (price - meta.entryPrice) * shares * sign;
        };
        const summarizeKeys = (keys) => {
          const out = { entries: 0, trims: 0, exits: 0, realizedPnl: 0, wins: 0, losses: 0 };
          const closedByTradeId = new Map();
          for (const k of keys) {
            const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
            for (const e of arr) {
              const type = String(e?.type || "").toUpperCase();
              if (type === "ENTRY") out.entries += 1;
              if (type === "TRIM") out.trims += 1;
              if (type === "EXIT") out.exits += 1;
              const pnl = pnlForEvent(e);
              if (Number.isFinite(pnl)) {
                out.realizedPnl += pnl;
                if (type === "EXIT" && e?.trade_id)
                  closedByTradeId.set(String(e.trade_id), pnl);
              }
            }
          }
          for (const pnl of closedByTradeId.values()) {
            if (Number.isFinite(pnl) && pnl !== 0) pnl > 0 ? (out.wins += 1) : (out.losses += 1);
          }
          const denom = out.wins + out.losses;
          out.winRate = denom > 0 ? (out.wins / denom) * 100 : null;
          out.closedTrades = denom;
          return out;
        };
        const summarizeOpen = () => {
          let unreal = 0;
          const rows = [];
          for (const pos of openPos) {
            const direction = String(pos?.direction || "").toUpperCase();
            const sign = direction === "SHORT" ? -1 : 1;
            const avgEntry = Number(pos?.avgEntry);
            const mark = Number(pos?.mark);
            const shares = Number(pos?.shares);
            if (!Number.isFinite(avgEntry) || !Number.isFinite(mark) || !Number.isFinite(shares)) continue;
            unreal += (mark - avgEntry) * shares * sign;
            rows.push({ ...pos, __unreal: (mark - avgEntry) * shares * sign });
          }
          rows.sort((a, b) => Number(b.__unreal) - Number(a.__unreal));
          return { unrealizedPnl: unreal, rows };
        };
        const today = summarizeKeys([new Date().toISOString().slice(0, 10)]);
        const week = summarizeKeys(daysBackKeys(7));
        const windowSum = summarizeKeys(windowKeys);
        const open = summarizeOpen();
        return (
          <div className="space-y-4">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 text-sm">
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Today</div>
                <div className="font-bold">{fmtInt(today.entries)} entries / {fmtInt(today.exits)} exits</div>
                <div className={today.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(today.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Week</div>
                <div className="font-bold">{fmtInt(week.closedTrades)} closed</div>
                <div className={week.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(week.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Window ({windowDays}d)</div>
                <div className="font-bold">{fmtInt(windowSum.closedTrades)} closed</div>
                <div className={windowSum.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(windowSum.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Open</div>
                <div className="font-bold">{fmtInt(openPos.length)} positions</div>
                <div className={open.unrealizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(open.unrealizedPnl)}</div>
              </div>
            </div>
            <div className="text-xs text-[var(--tt-text-muted)]">
              <button type="button" onClick={() => setLedgerTab && setLedgerTab("trades")} className="text-[var(--tt-accent)] hover:underline">
                Open Trades tab for full detail →
              </button>
            </div>
          </div>
        );
      }

      // Date range slider: start and end date thumbs, default full range
      function DateRangeSlider({ range, onRangeChange, sliderDays = 90 }) {
        const trackRef = useRef(null);
        const [dragging, setDragging] = useState(null); // 'start' | 'end'

        const minDate = (() => {
          const d = new Date();
          d.setDate(d.getDate() - sliderDays);
          d.setHours(0, 0, 0, 0);
          return d.getTime();
        })();
        const maxDate = (() => {
          const d = new Date();
          d.setHours(23, 59, 59, 999);
          return d.getTime();
        })();

        const rangeMs = maxDate - minDate;
        const startPct = Math.max(0, Math.min(100, ((range.start.getTime() - minDate) / rangeMs) * 100));
        const endPct = Math.max(0, Math.min(100, ((range.end.getTime() - minDate) / rangeMs) * 100));

        const moveToX = useCallback(
          (clientX, which) => {
            const el = trackRef.current;
            if (!el) return;
            const rect = el.getBoundingClientRect();
            const pct = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            const t = minDate + (pct / 100) * rangeMs;
            const d = new Date(t);
            if (which === "start") {
              const endTs = range.end.getTime();
              d.setTime(Math.min(d.getTime(), endTs));
              onRangeChange({ start: d, end: range.end });
            } else {
              const startTs = range.start.getTime();
              d.setTime(Math.max(d.getTime(), startTs));
              onRangeChange({ start: range.start, end: d });
            }
          },
          [minDate, rangeMs, range, onRangeChange],
        );

        useEffect(() => {
          if (!dragging) return;
          const onMove = (e) => moveToX(e.clientX, dragging);
          const onUp = () => setDragging(null);
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onUp);
          return () => {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onUp);
          };
        }, [dragging, moveToX]);

        const fmt = (d) => d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
        return (
          <div className="flex items-center gap-3">
            <div className="flex flex-col gap-1">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Start</div>
              <div className="text-xs font-medium text-[var(--tt-text)]">{fmt(range.start)}</div>
            </div>
            <div className="relative flex-1 min-w-[200px] max-w-[340px] h-6 flex items-center" ref={trackRef}>
              <div className="absolute inset-0 rounded-full bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)]" />
              <div
                className="absolute h-full rounded-full bg-[var(--tt-accent)]/30"
                style={{ left: `${startPct}%`, width: `${endPct - startPct}%` }}
              />
              <div
                role="slider"
                aria-label="Start date"
                tabIndex={0}
                className="absolute w-4 h-4 rounded-full border-2 border-[var(--tt-accent)] bg-[var(--tt-bg-surface)] cursor-ew-resize touch-none"
                style={{ left: `calc(${startPct}% - 8px)`, top: "50%", transform: "translateY(-50%)" }}
                onMouseDown={() => setDragging("start")}
              />
              <div
                role="slider"
                aria-label="End date"
                tabIndex={0}
                className="absolute w-4 h-4 rounded-full border-2 border-[var(--tt-accent)] bg-[var(--tt-bg-surface)] cursor-ew-resize touch-none"
                style={{ left: `calc(${endPct}% - 8px)`, top: "50%", transform: "translateY(-50%)" }}
                onMouseDown={() => setDragging("end")}
              />
            </div>
            <div className="flex flex-col gap-1">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">End</div>
              <div className="text-xs font-medium text-[var(--tt-text)]">{fmt(range.end)}</div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Main App
      // ─────────────────────────────────────────────────────────────
      function App() {
        const { data, loading, refreshing, error, lastUpdate, refetch } =
          useTickerData();
        const {
          trades,
          loading: tradesLoading,
          refreshing: tradesRefreshing,
          error: tradesError,
          addTrade,
          updateTrade,
          refetch: refetchTrades,
        } = useSimulatedTrades();
        const { sectors } = useSectors();

        // Welcome Guide state
        const [showWelcomeDashboard, setShowWelcomeDashboard] = useState(false);
        const [showWelcomeTracker, setShowWelcomeTracker] = useState(() => {
          const hasSeenWelcome = localStorage.getItem(
            "timedTrading_welcomeSeen",
          );
          return !hasSeenWelcome;
        });

        const handleWelcomeDashboardClose = () => {
          setShowWelcomeDashboard(false);
        };

        const handleWelcomeTrackerClose = () => {
          setShowWelcomeTracker(false);
          localStorage.setItem("timedTrading_welcomeSeen", "true");
        };

        // Version filter state
        const [selectedVersion, setSelectedVersion] = useState("all");
        const [horizonFilter, setHorizonFilter] = useState("ALL");

        // Unified experience: D1-backed Trade Journey (single mode)
        const trackerMode = "ledger";
        // Make Proof the default landing view (high-signal summary).
        // Single view: no Proof/Trades/Alerts tabs
        const [accountChartRange, setAccountChartRange] = useState("1D"); // 1D | 5D | 10D | 30D | 1Y
        const [expandedPositionTicker, setExpandedPositionTicker] = useState(null); // ticker for expanded card
        const initialLedgerTicker = (() => {
          try {
            const t =
              new URLSearchParams(window.location.search).get("ticker") || "";
            return String(t).trim().toUpperCase();
          } catch {
            return "";
          }
        })();
        const [ledgerTickerFilter, setLedgerTickerFilter] =
          useState(initialLedgerTicker);
        const [ledgerStatusFilter, setLedgerStatusFilter] = useState("all");
        // Date range for Trade Tracker: start and end (default Feb 2 = first trade)
        const SLIDER_RANGE_DAYS = 90;
        const [ledgerDateRange, setLedgerDateRange] = useState(() => {
          const end = new Date();
          end.setHours(23, 59, 59, 999);
          const start = new Date(end.getFullYear(), 1, 2); // Feb 2 (month 1 = February)
          start.setHours(0, 0, 0, 0);
          if (start.getTime() > end.getTime()) start.setFullYear(start.getFullYear() - 1);
          return { start, end };
        });
        const [ledgerIncludeEvidence, setLedgerIncludeEvidence] =
          useState(true);

        const ledgerRangeDays = useMemo(() => {
          const a = ledgerDateRange.start.getTime();
          const b = ledgerDateRange.end.getTime();
          return Math.max(1, Math.round((b - a) / (24 * 60 * 60 * 1000)));
        }, [ledgerDateRange]);

        const windowLabel = useMemo(() => {
          const days = ledgerRangeDays;
          return days === 1 ? "Today" : `Last ${days}d`;
        }, [ledgerRangeDays]);

        // P&L by ticker: computed at component level so Engine calibration / P&L section (outside paperPortfolio IIFE) can use it.
        const pnlByTickerWindow = useMemo(() => {
          const pp = paperPortfolio ?? {};
          const openPos = Array.isArray(pp.data?.portfolio?.openPositions)
            ? pp.data.portfolio.openPositions
            : [];
          const byDay = pp.data?.executions?.byDay && typeof pp.data.executions.byDay === "object"
            ? pp.data.executions.byDay
            : {};
          const windowDays = Math.max(1, Number(ledgerRangeDays) || 7);
          const daysBackKeys = (n) => {
            const keys = [];
            for (let i = 0; i < n; i++) {
              const d = new Date();
              d.setUTCDate(d.getUTCDate() - i);
              keys.push(d.toISOString().slice(0, 10));
            }
            return keys;
          };
          const windowKeys = daysBackKeys(Math.min(60, windowDays));

          const entryByTradeId = new Map();
          for (const k of Object.keys(byDay)) {
            const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
            for (const e of arr) {
              const type = String(e?.type || "").toUpperCase();
              const tradeId = String(e?.trade_id || "");
              if (!tradeId || type !== "ENTRY") continue;
              const entryPrice = Number(e?.price);
              const entryShares = Number(e?.shares);
              const entryTs = Number(e?.ts);
              const direction = String(e?.direction || "").toUpperCase();
              if (Number.isFinite(entryPrice) && (direction === "LONG" || direction === "SHORT")) {
                entryByTradeId.set(tradeId, { entryPrice, direction, entryShares: Number.isFinite(entryShares) ? entryShares : null, entryTs: Number.isFinite(entryTs) ? entryTs : null });
              }
            }
          }
          const pnlForEvent = (e) => {
            const type = String(e?.type || "").toUpperCase();
            if (type !== "TRIM" && type !== "EXIT") return null;
            const tradeId = String(e?.trade_id || "");
            const meta = tradeId ? entryByTradeId.get(tradeId) : null;
            if (!meta) return null;
            const price = Number(e?.price);
            const shares = Number(e?.shares);
            if (!Number.isFinite(price) || !Number.isFinite(shares)) return null;
            const sign = meta.direction === "SHORT" ? -1 : 1;
            return (price - meta.entryPrice) * shares * sign;
          };

          const fromTape = () => {
            const realized = new Map();
            for (const k of windowKeys) {
              const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
              for (const e of arr) {
                const pnl = pnlForEvent(e);
                if (!Number.isFinite(pnl) || pnl === 0) continue;
                const tkr = String(e?.ticker || "").toUpperCase();
                if (!tkr) continue;
                realized.set(tkr, (realized.get(tkr) || 0) + pnl);
              }
            }
            const unreal = new Map();
            for (const pos of openPos) {
              const tkr = String(pos?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const direction = String(pos?.direction || "").toUpperCase();
              const sign = direction === "SHORT" ? -1 : 1;
              const avgEntry = Number(pos?.avgEntry);
              const mark = Number(pos?.mark);
              const shares = Number(pos?.shares);
              if (!Number.isFinite(avgEntry) || !Number.isFinite(mark) || !Number.isFinite(shares)) continue;
              const pnl = (mark - avgEntry) * shares * sign;
              if (!Number.isFinite(pnl) || pnl === 0) continue;
              unreal.set(tkr, (unreal.get(tkr) || 0) + pnl);
            }
            const tickers = new Set([...realized.keys(), ...unreal.keys()]);
            const rows = Array.from(tickers)
              .map((ticker) => ({
                ticker,
                realized: Number(realized.get(ticker) || 0),
                unrealized: Number(unreal.get(ticker) || 0),
                total: Number(realized.get(ticker) || 0) + Number(unreal.get(ticker) || 0),
              }))
              .filter((r) => Number.isFinite(r.total) && r.total !== 0);
            rows.sort((a, b) => Math.abs(b.total) - Math.abs(a.total));
            const maxAbs = rows.reduce((m, r) => Math.max(m, Math.abs(r.total)), 0);
            return { rows, maxAbs };
          };

          let out = fromTape();
          if (out.rows.length === 0 && ((Array.isArray(ledgerClosedTrades) && ledgerClosedTrades.length > 0) || openPos.length > 0)) {
            const realized = new Map();
            for (const t of ledgerClosedTrades || []) {
              const tkr = String(t?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const pnl = Number(t?.pnl);
              if (!Number.isFinite(pnl)) continue;
              realized.set(tkr, (realized.get(tkr) || 0) + pnl);
            }
            const unreal = new Map();
            for (const pos of openPos) {
              const tkr = String(pos?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const dir = String(pos?.direction || "").toUpperCase();
              const sign = dir === "SHORT" ? -1 : 1;
              const avg = Number(pos?.avgEntry);
              const mark = Number(pos?.mark);
              const sh = Number(pos?.shares);
              if (!Number.isFinite(avg) || !Number.isFinite(mark) || !Number.isFinite(sh)) continue;
              unreal.set(tkr, (unreal.get(tkr) || 0) + (mark - avg) * sh * sign);
            }
            const tickers = new Set([...realized.keys(), ...unreal.keys()]);
            const rows = Array.from(tickers)
              .map((ticker) => {
                const r = Number(realized.get(ticker) || 0);
                const u = Number(unreal.get(ticker) || 0);
                return { ticker, realized: r, unrealized: u, total: r + u };
              })
              .filter((r) => Number.isFinite(r.total) && r.total !== 0);
            rows.sort((a, b) => Math.abs(b.total) - Math.abs(a.total));
            const maxAbs = rows.reduce((m, r) => Math.max(m, Math.abs(r.total)), 0);
            out = { rows, maxAbs };
          }
          return out;
        }, [paperPortfolio?.data, ledgerClosedTrades, ledgerRangeDays]);

        const startOfDay = (d) => {
          const x = new Date(d);
          x.setHours(0, 0, 0, 0);
          return x;
        };
        const endOfDay = (d) => {
          const x = new Date(d);
          x.setHours(23, 59, 59, 999);
          return x;
        };
        const ledgerSince = useMemo(
          () => startOfDay(ledgerDateRange.start).getTime(),
          [ledgerDateRange.start],
        );
        const ledgerUntil = useMemo(
          () => endOfDay(ledgerDateRange.end).getTime(),
          [ledgerDateRange.end],
        );

        const ledgerTrades = useLedgerTrades({
          ticker: ledgerTickerFilter.trim(),
          status: ledgerStatusFilter,
          since: ledgerSince,
          until: ledgerUntil,
          pageSize: 200,
        });
        const ledgerAlerts = useLedgerAlerts({
          ticker: ledgerTickerFilter.trim(),
          since: ledgerSince,
          until: ledgerUntil,
          pageSize: 200,
        });
        const ledgerSummary = useLedgerSummary({
          since: ledgerSince,
          until: ledgerUntil,
        });
        const paperPortfolio = usePaperPortfolio();
        // Legacy "Trade Detail" right rail removed; use unified ticker right rail instead.

        const rankedTickers = useMemo(() => {
          return getRankedTickers(data);
        }, [data]);

        const rankedTickerPositions = useMemo(() => {
          const map = {};
          rankedTickers.forEach((t, idx) => {
            const sym = String(t.ticker || "")
              .trim()
              .toUpperCase();
            const pos = Number(t?.rank_position);
            const rankPos = Number.isFinite(pos) && pos > 0 ? pos : idx + 1;
            if (sym && map[sym] == null) {
              map[sym] = rankPos;
            }
          });
          return map;
        }, [rankedTickers]);

        const ledgerFilteredTrades = useMemo(() => {
          const lt = ledgerTrades ?? {};
          const items = Array.isArray(lt.items) ? lt.items : [];
          if (horizonFilter === "ALL") return items;
          return items.filter((t) => {
            const sym = String(t.ticker || "").toUpperCase();
            const live = data && (data[sym] || data[t.ticker]);
            const key = computeHorizonKey(live || t);
            return key === horizonFilter;
          });
        }, [ledgerTrades?.items, horizonFilter, data]);

        const ledgerOpenTrades = useMemo(
          () =>
            ledgerFilteredTrades.filter(
              (t) => t.status !== "WIN" && t.status !== "LOSS",
            ),
          [ledgerFilteredTrades],
        );

        const ledgerClosedTrades = useMemo(
          () =>
            ledgerFilteredTrades.filter(
              (t) => t.status === "WIN" || t.status === "LOSS",
            ),
          [ledgerFilteredTrades],
        );

        const ledgerActivityDays = useMemo(() => {
          const events = [];
          const dayKeyFor = (ts) => {
            const d = new Date(Number(ts));
            if (!Number.isFinite(d.getTime())) return "unknown";
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, "0");
            const dd = String(d.getDate()).padStart(2, "0");
            return `${yyyy}-${mm}-${dd}`;
          };

          for (const t of ledgerFilteredTrades) {
            const entryTs = tsToMs(t.entry_ts);
            if (entryTs != null) {
              events.push({
                ts: entryTs,
                type: "ENTRY",
                trade: t,
                price: Number(t.entry_price),
              });
            }
            const trimTsRaw = t.trim_ts ?? t.updated_at ?? t.exit_ts ?? t.entry_ts;
            if (
              (t.status === "TP_HIT_TRIM" || Number(t.trimmed_pct) > 0) &&
              trimTsRaw != null &&
              Number.isFinite(Number(trimTsRaw))
            ) {
              const trimTs = tsToMs(trimTsRaw) ?? Number(trimTsRaw);
              events.push({
                ts: trimTs,
                type: "TRIM",
                trade: t,
                price: null,
              });
            }
            const exitTs = tsToMs(t.exit_ts);
            if (
              (t.status === "WIN" || t.status === "LOSS") &&
              exitTs != null
            ) {
              events.push({
                ts: exitTs,
                type: "EXIT",
                trade: t,
                price: Number(t.exit_price),
              });
            }
          }

          const groups = new Map();
          for (const ev of events) {
            const key = dayKeyFor(ev.ts);
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(ev);
          }

          const keys = Array.from(groups.keys()).sort((a, b) =>
            a < b ? 1 : -1,
          );
          return keys.map((key) => {
            const items = groups.get(key) || [];
            items.sort((a, b) => b.ts - a.ts);
            const stats = items.reduce(
              (acc, ev) => {
                if (ev.type === "ENTRY") acc.entries += 1;
                if (ev.type === "TRIM") acc.trims += 1;
                if (ev.type === "EXIT") acc.exits += 1;
                if (ev.type === "EXIT")
                  acc.closedPnl += Number(ev.trade.pnl || 0);
                return acc;
              },
              { entries: 0, trims: 0, exits: 0, closedPnl: 0 },
            );
            const label =
              key === "unknown"
                ? "Unknown date"
                : new Date(`${key}T00:00:00`).toLocaleDateString(undefined, {
                    weekday: "short",
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                  });
            return { key, label, events: items, stats };
          });
        }, [ledgerFilteredTrades]);

        const ledgerClosedByTicker = useMemo(() => {
          const groups = new Map();
          for (const t of ledgerClosedTrades) {
            const key = String(t.ticker || "").toUpperCase();
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(t);
          }
          const tickers = Array.from(groups.keys()).sort((a, b) =>
            a.localeCompare(b),
          );
          return tickers.map((ticker) => {
            const trades = groups.get(ticker) || [];
            trades.sort(
              (a, b) => Number(b.exit_ts || 0) - Number(a.exit_ts || 0),
            );
            const totalPnl = trades.reduce(
              (sum, t) => sum + Number(t.pnl || 0),
              0,
            );
            return { ticker, trades, totalPnl };
          });
        }, [ledgerClosedTrades]);

        const portfolioSummary = useMemo(() => {
          let netPnl = 0;
          let totalGain = 0;
          let totalLoss = 0;
          for (const t of ledgerFilteredTrades) {
            const pnl = Number(t.pnl);
            if (!Number.isFinite(pnl)) continue;
            netPnl += pnl;
            if (pnl >= 0) totalGain += pnl;
            else totalLoss += pnl;
          }
          return {
            netPnl,
            totalGain,
            totalLoss,
            totalTrades: ledgerFilteredTrades.length,
          };
        }, [ledgerFilteredTrades]);

        const getPositionMetrics = (trade, live) => {
          const sym = String(trade.ticker || "").toUpperCase();
          const isFutures = FUTURES_SPECS[sym] || sym.endsWith("1!");
          const pointValue =
            isFutures && FUTURES_SPECS[sym] ? FUTURES_SPECS[sym].pointValue : 1;
          const entryPrice = Number(trade.entry_price ?? trade.entryPrice ?? 0);
          const shares =
            trade.shares ||
            (isFutures ? 1 : entryPrice > 0 ? TRADE_SIZE / entryPrice : 0);
          const current = Number(live?.price);
          const direction = String(trade.direction || "").toUpperCase();
          const signed = direction === "SHORT" ? -1 : 1;
          const pnlOpen =
            Number.isFinite(current) &&
            Number.isFinite(entryPrice) &&
            entryPrice
              ? (current - entryPrice) * shares * pointValue * signed
              : null;
          const retOpenPct =
            Number.isFinite(current) &&
            Number.isFinite(entryPrice) &&
            entryPrice
              ? ((current - entryPrice) / entryPrice) * 100 * signed
              : null;
          return {
            isFutures,
            pointValue,
            entryPrice,
            shares,
            current,
            pnlOpen,
            retOpenPct,
          };
        };

        // Aggregate metrics when same ticker has multiple open entries (e.g. two ENTRY events)
        const getAggregatedPositionMetrics = (trades, live) => {
          if (!trades || trades.length === 0) return null;
          if (trades.length === 1) return getPositionMetrics(trades[0], live);
          const sym = String(trades[0].ticker || "").toUpperCase();
          const isFutures = FUTURES_SPECS[sym] || sym.endsWith("1!");
          const pointValue = isFutures && FUTURES_SPECS[sym] ? FUTURES_SPECS[sym].pointValue : 1;
          const current = Number(live?.price);
          let totalShares = 0;
          let costBasis = 0;
          let pnlOpen = 0;
          for (const t of trades) {
            const entryPrice = Number(t.entry_price ?? t.entryPrice ?? 0);
            const shares = t.shares || (isFutures ? 1 : entryPrice > 0 ? TRADE_SIZE / entryPrice : 0);
            const direction = String(t.direction || "").toUpperCase();
            const signed = direction === "SHORT" ? -1 : 1;
            totalShares += shares;
            costBasis += entryPrice * shares;
            if (Number.isFinite(current) && entryPrice > 0) {
              pnlOpen += (current - entryPrice) * shares * pointValue * signed;
            }
          }
          const entryPrice = totalShares > 0 ? costBasis / totalShares : 0;
          const direction = String(trades[0].direction || "").toUpperCase();
          const signed = direction === "SHORT" ? -1 : 1;
          const retOpenPct = costBasis > 0 && Number.isFinite(current)
            ? ((current - entryPrice) / entryPrice) * 100 * signed
            : null;
          return {
            isFutures,
            pointValue,
            entryPrice,
            shares: totalShares,
            current,
            pnlOpen: Number.isFinite(current) ? pnlOpen : null,
            retOpenPct,
          };
        };

        // Range in ms for account chart (1D, 5D, 10D, 30D, 1Y)
        const accountChartRangeMs = useMemo(() => {
          const day = 24 * 60 * 60 * 1000;
          const map = { "1D": 1 * day, "5D": 5 * day, "10D": 10 * day, "30D": 30 * day, "1Y": 365 * day };
          return map[accountChartRange] ?? 1 * day;
        }, [accountChartRange]);

        // Overall account value over time (Robinhood-style line chart data), filtered by accountChartRange
        const portfolioChartPoints = useMemo(() => {
          const points = [{ ts: 0, value: 0 }];
          const closed = ledgerFilteredTrades.filter(
            (t) => t.status === "WIN" || t.status === "LOSS",
          );
          const sorted = [...closed].sort(
            (a, b) => (tsToMs(a.exit_ts) ?? 0) - (tsToMs(b.exit_ts) ?? 0),
          );
          let running = 0;
          for (const t of sorted) {
            const exitTs = tsToMs(t.exit_ts);
            if (exitTs == null) continue;
            running += Number(t.pnl) || 0;
            points.push({ ts: exitTs, value: running });
          }
          const openPnl = ledgerOpenTrades.reduce((sum, t) => {
            const m = getPositionMetrics(
              t,
              data && (data[t.ticker] || data[String(t.ticker).toUpperCase()]),
            );
            return sum + (Number(m.pnlOpen) || 0);
          }, 0);
          points.push({
            ts: Date.now(),
            value: running + openPnl,
          });
          return points;
        }, [
          ledgerFilteredTrades,
          ledgerOpenTrades,
          data,
        ]);

        // Filter chart points to selected time frame; add start-of-range point for clean line
        const portfolioChartPointsInRange = useMemo(() => {
          const now = Date.now();
          const start = now - accountChartRangeMs;
          const sorted = [...portfolioChartPoints].sort((a, b) => a.ts - b.ts);
          const beforeStart = sorted.filter((p) => p.ts <= start);
          const startValue = beforeStart.length > 0 ? beforeStart[beforeStart.length - 1].value : 0;
          const inRange = sorted.filter((p) => p.ts >= start);
          if (inRange.length === 0) return [{ ts: start, value: startValue }, { ts: now, value: startValue }];
          const firstInRange = inRange[0];
          const withStart = firstInRange.ts > start
            ? [{ ts: start, value: startValue }, ...inRange]
            : inRange;
          return withStart;
        }, [portfolioChartPoints, accountChartRangeMs]);

        // Positions with trade history in asc time order (Robinhood-style)
        // Group open trades by ticker so multiple entries (e.g. AEHR 36 + 35) aggregate qty and P&L
        const positionsWithHistory = useMemo(() => {
          const byTicker = new Map();
          for (const t of ledgerFilteredTrades) {
            const ticker = String(t.ticker || "").toUpperCase();
            if (!ticker) continue;
            const entryTs = tsToMs(t.entry_ts);
            if (entryTs != null) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              byTicker.get(ticker).push({
                ts: entryTs,
                type: "ENTRY",
                trade: t,
                price: Number(t.entry_price),
              });
            }
            const trimTs = tsToMs(t.trim_ts ?? t.updated_at ?? t.exit_ts ?? t.entry_ts);
            if (
              (t.status === "TP_HIT_TRIM" || Number(t.trimmed_pct) > 0) &&
              trimTs != null
            ) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              const trimPrice = Number(t.trim_price ?? t.trimPrice ?? t.tp ?? t.tp_price) || null;
              byTicker.get(ticker).push({
                ts: trimTs,
                type: "TRIM",
                trade: t,
                price: Number.isFinite(trimPrice) ? trimPrice : null,
              });
            }
            const exitTs = tsToMs(t.exit_ts);
            if (
              (t.status === "WIN" || t.status === "LOSS") &&
              exitTs != null
            ) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              byTicker.get(ticker).push({
                ts: exitTs,
                type: "EXIT",
                trade: t,
                price: Number(t.exit_price),
              });
            }
          }
          const openByTicker = new Map();
          for (const t of ledgerOpenTrades) {
            const ticker = String(t.ticker || "").toUpperCase();
            if (!ticker) continue;
            if (!openByTicker.has(ticker)) openByTicker.set(ticker, []);
            openByTicker.get(ticker).push(t);
          }
          const result = [];
          for (const [ticker, trades] of openByTicker) {
            const live = data && (data[ticker] || data[trades[0].ticker]);
            const metrics = getAggregatedPositionMetrics(trades, live);
            const events = (byTicker.get(ticker) || []).sort(
              (a, b) => a.ts - b.ts,
            );
            result.push({
              ticker,
              isOpen: true,
              qty: metrics.shares,
              entryPrice: metrics.entryPrice,
              mktValue:
                Number.isFinite(metrics.current) && Number.isFinite(metrics.shares)
                  ? metrics.current * metrics.shares
                  : null,
              current: metrics.current,
              pnlOpen: metrics.pnlOpen,
              retOpenPct: metrics.retOpenPct,
              trade: trades[0],
              events,
            });
          }
          for (const [ticker, events] of byTicker) {
            if (openByTicker.has(ticker)) continue;
            const sorted = events.sort((a, b) => a.ts - b.ts);
            const lastTrade = sorted.length
              ? sorted[sorted.length - 1].trade
              : null;
            result.push({
              ticker,
              isOpen: false,
              qty: null,
              entryPrice: lastTrade
                ? Number(lastTrade.entry_price ?? lastTrade.entryPrice)
                : null,
              mktValue: null,
              current: null,
              pnlOpen: null,
              trade: lastTrade,
              events: sorted,
            });
          }
          result.sort((a, b) => a.ticker.localeCompare(b.ticker));
          return result;
        }, [ledgerFilteredTrades, ledgerOpenTrades, data]);

        const openPositionCards = useMemo(
          () => positionsWithHistory.filter((p) => p.isOpen),
          [positionsWithHistory],
        );

        // Daily summary state
        const [dailySummary, setDailySummary] = useState(null);
        const [summaryLoading, setSummaryLoading] = useState(false);
        const [showSummary, setShowSummary] = useState(false);

        // Selected ticker for detail view
        const [selectedTicker, setSelectedTicker] = useState(null);

        // Selected trade for right rail; positionEvents for Trade Tracker history
        const [selectedTrade, setSelectedTrade] = useState(null);
        const [selectedPositionEvents, setSelectedPositionEvents] = useState(null);

        // Trade Tracker date range filter
        const [tradeDateRange, setTradeDateRange] = useState({
          startDate: (() => {
            const today = new Date();
            return today.toISOString().split("T")[0];
          })(),
          endDate: (() => {
            const today = new Date();
            return today.toISOString().split("T")[0];
          })(),
        });

        // Get unique versions from trades (for dropdown)
        const availableVersions = useMemo(() => {
          const versionSet = new Set(
            trades.map((t) => t.scriptVersion || "unknown").filter(Boolean),
          );
          return Array.from(versionSet).sort().reverse(); // Most recent first
        }, [trades]);

        // Filter trades by version (client-side), de-dupe only exact duplicates, and sort alphabetically
        const filteredTrades = useMemo(() => {
          let filtered =
            selectedVersion === "all"
              ? trades
              : trades.filter(
                  (t) => (t.scriptVersion || "unknown") === selectedVersion,
                );

          // Remove duplicates: keep the most recent trade for each exact trade key
          // (Ticker + Direction + EntryTime/Id). This prevents accidental collapsing of real historical trades.
          const tradeMap = new Map();
          filtered.forEach((trade) => {
            const entryKey =
              trade.entryTime ||
              trade.entryTs ||
              trade.trigger_ts ||
              trade.id ||
              "";
            const key = `${trade.ticker}_${trade.direction}_${entryKey}`;
            const existing = tradeMap.get(key);
            if (!existing) {
              tradeMap.set(key, trade);
            } else {
              // Keep the most recent one (by entryTime)
              const existingTime = new Date(existing.entryTime || 0).getTime();
              const currentTime = new Date(trade.entryTime || 0).getTime();
              if (currentTime > existingTime) {
                tradeMap.set(key, trade);
              }
            }
          });

          // Convert back to array and sort alphabetically by ticker
          filtered = Array.from(tradeMap.values());
          filtered.sort((a, b) => {
            const tickerA = String(a.ticker || "").toUpperCase();
            const tickerB = String(b.ticker || "").toUpperCase();
            return tickerA.localeCompare(tickerB);
          });

          return filtered;
        }, [trades, selectedVersion]);

        // Keep Current Price fresh by overriding open/trimmed trades with latest ticker prices.
        // Trades returned by the Worker can lag between runs; this makes the UI reflect latest ingested prices.
        const filteredTradesWithLivePrices = useMemo(() => {
          if (!Array.isArray(filteredTrades)) return [];
          return filteredTrades.map((t) => {
            const symRaw = t?.ticker;
            if (!symRaw) return t;
            const sym = String(symRaw).toUpperCase();
            const live = (data && (data[sym] || data[symRaw])) || null;
            const livePrice =
              live && live.price != null ? Number(live.price) : NaN;
            const isOpenLike =
              t.status === "OPEN" || !t.status || t.status === "TP_HIT_TRIM";
            if (!isOpenLike || !Number.isFinite(livePrice)) return t;
            const next = {
              ...t,
              currentPrice: livePrice,
              _uiPriceTs: live.ts || live.ingest_ts || null,
            };

            // Recompute P&L using latest price so the UI always reflects the latest move.
            // This does not change status; the Worker remains the source of truth for state transitions.
            const tickerSymbol = String(next.ticker || "").toUpperCase();
            const isFutures =
              FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");
            const pointValue =
              isFutures && FUTURES_SPECS[tickerSymbol]
                ? FUTURES_SPECS[tickerSymbol].pointValue
                : 1;
            const entryPrice = Number(next.entryPrice);
            const tp = Number(next.tp);
            const sl = Number(next.sl);
            const currentPrice = Number(next.currentPrice);
            const trimmedPct = Number(next.trimmedPct) || 0;
            const shares =
              next.shares ||
              (isFutures && FUTURES_SPECS[tickerSymbol]
                ? 1
                : TRADE_SIZE / (entryPrice || 1));

            if (
              Number.isFinite(entryPrice) &&
              Number.isFinite(tp) &&
              Number.isFinite(sl) &&
              Number.isFinite(currentPrice) &&
              Number.isFinite(shares)
            ) {
              let pnl = 0;
              let pnlPct = 0;

              if (next.direction === "LONG") {
                const hitTP = currentPrice >= tp;
                const hitSL = currentPrice <= sl;
                if (hitTP) {
                  const tpDiff = tp - entryPrice;
                  pnl =
                    tpDiff * shares * pointValue * (trimmedPct === 0 ? 0.5 : 1);
                  pnlPct = ((tp - entryPrice) / entryPrice) * 100;
                } else if (hitSL) {
                  const slDiff = sl - entryPrice;
                  pnl = slDiff * shares * pointValue;
                  pnlPct = ((sl - entryPrice) / entryPrice) * 100;
                } else {
                  const priceDiff = currentPrice - entryPrice;
                  pnl = priceDiff * shares * pointValue;
                  pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;
                }
              } else if (next.direction === "SHORT") {
                const hitTP = currentPrice <= tp;
                const hitSL = currentPrice >= sl;
                if (hitTP) {
                  const tpDiff = entryPrice - tp;
                  pnl =
                    tpDiff * shares * pointValue * (trimmedPct === 0 ? 0.5 : 1);
                  pnlPct = ((entryPrice - tp) / entryPrice) * 100;
                } else if (hitSL) {
                  const slDiff = entryPrice - sl;
                  pnl = slDiff * shares * pointValue;
                  pnlPct = ((entryPrice - sl) / entryPrice) * 100;
                } else {
                  const priceDiff = entryPrice - currentPrice;
                  pnl = priceDiff * shares * pointValue;
                  pnlPct = ((entryPrice - currentPrice) / entryPrice) * 100;
                }
              }

              next.pnl = pnl;
              next.pnlPct = pnlPct;
            }

            return next;
          });
        }, [filteredTrades, data]);

        const tradesForDisplay = useMemo(() => {
          if (!Array.isArray(filteredTradesWithLivePrices)) return [];
          if (horizonFilter === "ALL") return filteredTradesWithLivePrices;
          return filteredTradesWithLivePrices.filter((t) => {
            const sym = String(t.ticker || "").toUpperCase();
            const live = data && (data[sym] || data[t.ticker]);
            const key = computeHorizonKey(live || t);
            return key === horizonFilter;
          });
        }, [filteredTradesWithLivePrices, data, horizonFilter]);

        const analytics = useTradeAnalytics(filteredTradesWithLivePrices);

        // Trade simulation is handled by Worker - just refresh trades periodically
        useEffect(() => {
          // Initial fetch on mount
          refetchTrades();

          // Refresh trades every 30 seconds to get latest updates from Worker
          const refreshInterval = setInterval(() => {
            refetchTrades();
          }, 30000);

          return () => clearInterval(refreshInterval);
        }, [refetchTrades]);

        // Fetch daily summary
        const fetchDailySummary = useCallback(async () => {
          setSummaryLoading(true);
          try {
            const res = await fetch(`${API_BASE}/timed/ai/daily-summary`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) {
              setDailySummary(json);
              setShowSummary(true);
            } else {
              throw new Error(json.error || "Failed to fetch summary");
            }
          } catch (err) {
            console.error("Daily summary error:", err);
            alert(`Failed to fetch daily summary: ${err.message}`);
          } finally {
            setSummaryLoading(false);
          }
        }, []);

        const openTrades = tradesForDisplay.filter(
          (t) => t.status === "OPEN" || !t.status || t.status === "TP_HIT_TRIM",
        );
        const closedTrades = tradesForDisplay.filter(
          (t) => t.status === "WIN" || t.status === "LOSS",
        );

        return (
          <div className="tt-root">
            <div className="min-h-screen px-5 py-8" style={{ background: "var(--tt-bg-base)" }}>
              <div className="w-full mx-auto">
                {/* Header — minimal */}
                <header className="flex items-center justify-between gap-4 flex-wrap mb-8">
                  <div className="flex items-center gap-4">
                    <a
                      href="index-react.html"
                      className="text-[var(--tt-text-muted)] hover:text-[var(--tt-text)] text-sm transition-colors"
                      title="Back to Dashboard"
                    >
                      ← Dashboard
                    </a>
                    <h1 className="text-xl font-semibold tracking-tight text-[var(--tt-text)]">
                      Trade Tracker
                    </h1>
                  </div>
                  <div className="flex items-center gap-4 flex-wrap">
                    <DateRangeSlider
                      range={ledgerDateRange}
                      onRangeChange={setLedgerDateRange}
                      sliderDays={SLIDER_RANGE_DAYS}
                    />
                    {(loading || tradesLoading) && (
                      <div className="loading-spinner" />
                    )}
                    {lastUpdate && (
                      <span className="text-xs text-[var(--tt-text-faint)]">
                        Updated {lastUpdate.toLocaleTimeString()}
                        {(refreshing || tradesRefreshing) && " · refreshing…"}
                      </span>
                    )}
                    <button
                      onClick={() => { refetch(); refetchTrades(); }}
                      className="tt-pill tt-pill-active text-[13px]"
                    >
                      Refresh
                    </button>
                    <button
                      type="button"
                      onClick={async () => {
                        try {
                          const res = await fetch(`${API_BASE}/timed/trades?source=positions`, { cache: "no-store" });
                          const json = await res.json();
                          if (!res.ok || !json.ok) throw new Error(json.error || res.statusText);
                          const blob = new Blob([JSON.stringify({ exported: new Date().toISOString(), trades: json.trades || [], count: json.count }, null, 2)], { type: "application/json" });
                          const a = document.createElement("a");
                          a.href = URL.createObjectURL(blob);
                          a.download = `timed-positions-${new Date().toISOString().slice(0, 10)}.json`;
                          a.click();
                          URL.revokeObjectURL(a.href);
                        } catch (e) {
                          console.error("Export failed:", e);
                        }
                      }}
                      className="tt-pill tt-pill-inactive text-[13px]"
                      title="Export positions (reconciliation)"
                    >
                      Export
                    </button>
                  </div>
                </header>

                {/* Single view: account value ($100k baseline) + open position cards (wider content when no rail) */}
                <div className="flex gap-4 items-start">
                  <div className={`flex-1 min-w-0 max-w-full ${selectedTicker || selectedTrade ? "mr-[470px]" : ""}`}>
                    {(ledgerTrades ?? {}).loading ? (
                      <div className="text-sm text-[var(--tt-text-muted)] py-8">Loading…</div>
                    ) : (ledgerTrades ?? {}).error ? (
                      <div className="text-sm text-[var(--tt-negative)] py-4">Ledger unavailable: {(ledgerTrades ?? {}).error}</div>
                    ) : (
                      <div className="space-y-6">
                        {/* Account value: $100k baseline + up/down + line chart */}
                        <div className="tt-card overflow-hidden p-6">
                          <div className="flex gap-6 items-stretch flex-wrap">
                            <div className="flex flex-col justify-center min-w-0">
                              <p className="tt-label mb-0.5">Account value</p>
                              <p className="text-2xl font-semibold tracking-tight text-[var(--tt-text)]">
                                {fmtUsd(BASELINE_ACCOUNT + (portfolioChartPointsInRange.length > 0 ? portfolioChartPointsInRange[portfolioChartPointsInRange.length - 1].value : 0))}
                              </p>
                              {(() => {
                                const pnl = portfolioChartPointsInRange.length > 0 ? portfolioChartPointsInRange[portfolioChartPointsInRange.length - 1].value : 0;
                                const pct = BASELINE_ACCOUNT ? (pnl / BASELINE_ACCOUNT) * 100 : 0;
                                return (
                                  <p className={`text-sm font-medium mt-1 ${pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                                    {pnl >= 0 ? "Up" : "Down"} {fmtUsd(Math.abs(pnl))} ({pct >= 0 ? "+" : ""}{pct.toFixed(2)}%)
                                  </p>
                                );
                              })()}
                              <p className="text-xs text-[var(--tt-text-faint)] mt-0.5">Starting point {fmtUsd(BASELINE_ACCOUNT)}</p>
                            </div>
                            <div className="flex-1 min-w-[180px] h-[72px] flex items-center" aria-hidden="true">
                              {portfolioChartPointsInRange.length >= 2 ? (() => {
                                const pts = portfolioChartPointsInRange;
                                const vals = pts.map((p) => BASELINE_ACCOUNT + p.value);
                                const minV = Math.min(...vals);
                                const maxV = Math.max(...vals);
                                const rangeV = maxV - minV || 1;
                                const pad = 2;
                                const w = 180;
                                const h = 68;
                                const x = (i) => (pts.length <= 1 ? 0 : (i / (pts.length - 1)) * (w - 2 * pad) + pad);
                                const y = (v) => h - pad - ((v - minV) / rangeV) * (h - 2 * pad);
                                const d = pts.map((p, i) => `${i === 0 ? "M" : "L"} ${x(i)} ${y(BASELINE_ACCOUNT + p.value)}`).join(" ");
                                return (
                                  <svg width="100%" height="100%" viewBox={`0 0 ${w} ${h}`} preserveAspectRatio="none" className="overflow-visible">
                                    <defs>
                                      <linearGradient id="tt-chart-gradient" x1="0" y1="0" x2="0" y2="1">
                                        <stop offset="0%" stopColor="var(--tt-accent)" stopOpacity="0.35" />
                                        <stop offset="100%" stopColor="var(--tt-accent)" stopOpacity="0" />
                                      </linearGradient>
                                    </defs>
                                    <path fill="url(#tt-chart-gradient)" d={`${d} L ${x(pts.length - 1)} ${h} L ${x(0)} ${h} Z`} />
                                    <path fill="none" stroke="var(--tt-accent)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" d={d} />
                                  </svg>
                                );
                              })() : (
                                <span className="text-xs text-[var(--tt-text-faint)]">No history yet</span>
                              )}
                            </div>
                          </div>
                        </div>

                        {/* Open positions — Kanban-style cards: LONG (3 cols) | SHORT (3 cols); same layout as pipeline lane cards */}
                        {openPositionCards.length > 0 ? (
                          (() => {
                            const longPositions = openPositionCards.filter((p) => String(p.trade?.direction || "").toUpperCase() === "LONG");
                            const shortPositions = openPositionCards.filter((p) => String(p.trade?.direction || "").toUpperCase() === "SHORT");
                            const dirPillLong = "bg-green-500/10 text-green-400 border-green-500/30";
                            const dirPillShort = "bg-red-500/10 text-red-400 border-red-500/30";
                            const renderCard = (pos) => {
                              const dir = String(pos.trade?.direction || "LONG").toUpperCase();
                              const isLong = dir === "LONG";
                              const tickerData = data && (data[pos.ticker] || data[pos.ticker?.toUpperCase?.()]);
                              const completion = completionForSize(tickerData || {});
                              const completionPct = Math.min(100, Math.max(0, completion * 100));
                              const fillBg = isLong ? "bg-green-500/25" : "bg-red-500/25";
                              const daily = getDailyChange(tickerData || {});
                              const dayPct = daily.dayPct;
                              let cardBg = "bg-[var(--tt-bg-elevated)]";
                              if (Number.isFinite(dayPct)) {
                                if (dayPct > 0) {
                                  if (dayPct >= 3) cardBg = "bg-emerald-500/20";
                                  else if (dayPct >= 1) cardBg = "bg-emerald-500/15";
                                  else cardBg = "bg-emerald-500/10";
                                } else {
                                  if (dayPct <= -3) cardBg = "bg-rose-500/20";
                                  else if (dayPct <= -1) cardBg = "bg-rose-500/15";
                                  else cardBg = "bg-rose-500/10";
                                }
                              }
                              return (
                                <button
                                  key={pos.ticker}
                                  type="button"
                                  onClick={() => {
                                    setSelectedTicker(pos.ticker);
                                    setSelectedTrade(pos.trade);
                                    const match = trades.find(t => (t.id || t.trade_id) === pos.trade?.id);
                                    const events = (match?.history?.length ? match.history : pos.events || pos.trade?.history || []);
                                    setSelectedPositionEvents(Array.isArray(events) ? events : []);
                                  }}
                                  className={`w-full text-left px-3 py-2 rounded-lg border border-[var(--tt-border)] ${cardBg} hover:border-[var(--tt-border-strong)] transition-all overflow-hidden relative`}
                                  title="Open in right rail"
                                >
                                  {/* Left-to-right TP progress fill (Kanban-style subtle) */}
                                  <div className={`absolute inset-y-0 left-0 ${fillBg}`} style={{ width: `${completionPct}%` }} aria-hidden="true" />
                                  <div className="relative z-10">
                                    <div className="flex items-start justify-between gap-2">
                                      <div className="min-w-0">
                                        <div className="flex items-center gap-2 flex-wrap">
                                          <div className="font-bold text-white">{pos.ticker}</div>
                                          <span className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${isLong ? dirPillLong : dirPillShort}`}>
                                            {dir}
                                          </span>
                                        </div>
                                        <div className="mt-0.5 text-[11px] text-[var(--tt-text-muted)]">
                                          Entry {pos.entryPrice != null ? fmtUsd(pos.entryPrice) : "—"} → Current {pos.current != null ? fmtUsd(pos.current) : "—"}
                                        </div>
                                      </div>
                                      <div className="flex-shrink-0 text-right text-[11px]">
                                        <div className={(pos.pnlOpen ?? 0) >= 0 ? "text-green-400 font-semibold" : "text-red-400 font-semibold"}>
                                          {pos.pnlOpen != null ? fmtUsd(pos.pnlOpen) : "—"}
                                        </div>
                                        <div className="text-[var(--tt-text-faint)]">
                                          {pos.retOpenPct != null ? `${pos.retOpenPct >= 0 ? "+" : ""}${pos.retOpenPct.toFixed(2)}%` : "—"}
                                        </div>
                                      </div>
                                    </div>
                                    <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[var(--tt-text-muted)]">
                                      <div>
                                        <span className="text-[var(--tt-text-faint)]">Net P&L</span>{" "}
                                        <span className={`font-semibold ${(pos.pnlOpen ?? 0) >= 0 ? "text-green-400" : "text-red-400"}`}>
                                          {pos.pnlOpen != null ? fmtUsd(pos.pnlOpen) : "—"}
                                        </span>
                                      </div>
                                      <div>
                                        <span className="text-[var(--tt-text-faint)]">Qty</span>{" "}
                                        <span className="text-white font-semibold">
                                          {pos.qty != null ? Number(pos.qty).toFixed(FUTURES_SPECS[pos.ticker] ? 0 : 4) : "—"}
                                        </span>
                                      </div>
                                      <div>
                                        <span className="text-[var(--tt-text-faint)]">TP</span>{" "}
                                        <span className="text-white font-semibold">{completionPct.toFixed(0)}%</span>
                                      </div>
                                    </div>
                                    <div className="mt-1 flex items-center gap-2">
                                      <div className="w-14 text-[10px] text-[var(--tt-text-faint)]">TP progress</div>
                                      <div className="flex-1 h-1.5 rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] overflow-hidden">
                                        <div className={`h-full ${isLong ? "bg-green-500/70" : "bg-red-500/70"}`} style={{ width: `${completionPct}%` }} />
                                      </div>
                                      <div className="w-8 text-right text-[10px] text-[var(--tt-text-muted)]">{completionPct.toFixed(0)}%</div>
                                    </div>
                                  </div>
                                </button>
                              );
                            };
                            return (
                              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                                <div>
                                  <h2 className="text-sm font-semibold text-emerald-400/90 mb-3">LONG</h2>
                                  <div className="grid gap-3 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3">
                                    {longPositions.length > 0 ? longPositions.map(renderCard) : <p className="text-xs text-[var(--tt-text-faint)] col-span-full">No long positions</p>}
                                  </div>
                                </div>
                                <div>
                                  <h2 className="text-sm font-semibold text-rose-400/90 mb-3">SHORT</h2>
                                  <div className="grid gap-3 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3">
                                    {shortPositions.length > 0 ? shortPositions.map(renderCard) : <p className="text-xs text-[var(--tt-text-faint)] col-span-full">No short positions</p>}
                                  </div>
                                </div>
                              </div>
                            );
                          })()
                        ) : (
                          <div className="tt-card p-6 text-center text-[var(--tt-text-muted)] text-sm">
                            No open positions in this range.
                          </div>
                        )}
                      </div>
                    )}
                  </div>

                  {/* Right rail — Trades History when opened from a position card */}
                  {(selectedTicker || selectedTrade) && (
                    <div className="fixed right-0 top-0 w-[450px] h-screen z-40 slide-in-right shadow-2xl overflow-y-auto" style={{ background: "#0c0f14", borderLeft: "1px solid var(--tt-border)" }}>
                      <TickerDetailsLoader
                        tickerSymbol={selectedTrade ? selectedTrade.ticker : selectedTicker}
                        trade={selectedTrade}
                        positionEvents={selectedPositionEvents}
                        onClose={() => {
                          setSelectedTrade(null);
                          setSelectedTicker(null);
                          setSelectedPositionEvents(null);
                        }}
                        allLoadedData={data}
                        sectors={sectors}
                        rankedTickers={rankedTickers}
                        rankedTickerPositions={rankedTickerPositions}
                      />
                    </div>
                  )}
                </div>
              </div>
            </div>

                {/* Daily Summary Modal */}
                {showSummary && dailySummary && (
                  <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-6 max-w-3xl w-full max-h-[90vh] overflow-y-auto">
                      <div className="flex items-center justify-between mb-4">
                        <h2 className="text-2xl font-bold">
                          📊 Daily Summary -{" "}
                          {new Date(
                            dailySummary.stats.date,
                          ).toLocaleDateString()}
                        </h2>
                        <button
                          onClick={() => setShowSummary(false)}
                          className="text-[var(--tt-text-muted)] hover:text-white text-xl"
                        >
                          ✕
                        </button>
                      </div>

                      {/* Stats Grid */}
                      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            New Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.newTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Closed Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.closedTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Trimmed Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.trimmedTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">Win Rate</div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.winRate >= 50 ? "text-green-400" : "text-red-400"}`}
                          >
                            {dailySummary.stats.winRate}%
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Closed P&L
                          </div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.closedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                          >
                            ${dailySummary.stats.closedPnl}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">Open P&L</div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.openPnl >= 0 ? "text-green-400" : "text-yellow-400"}`}
                          >
                            ${dailySummary.stats.openPnl}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Total P&L
                          </div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                          >
                            ${dailySummary.stats.totalPnl}
                          </div>
                        </div>
                      </div>

                      {/* AI Summary */}
                      <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-6 mb-4">
                        <h3 className="text-xl font-bold mb-4 flex items-center gap-2">
                          <span className="text-2xl">🤖</span>
                          <span>AI Analysis & Recommendations</span>
                        </h3>
                        <div className="text-sm text-[var(--tt-text)] leading-relaxed">
                          {(() => {
                            // Enhanced markdown renderer
                            const renderMarkdown = (text) => {
                              const parts = [];
                              let currentIndex = 0;

                              // Split by double newlines for paragraphs
                              const paragraphs = text.split(/\n\n+/);

                              return paragraphs.map((paragraph, pIdx) => {
                                if (!paragraph.trim()) return null;

                                // Headers (## or ###)
                                const headerMatch = paragraph
                                  .trim()
                                  .match(/^(#{2,3})\s+(.+)$/m);
                                if (headerMatch) {
                                  const level = headerMatch[1].length;
                                  const content = headerMatch[2];
                                  return React.createElement(
                                    level === 2 ? "h2" : "h3",
                                    {
                                      key: pIdx,
                                      className:
                                        level === 2
                                          ? "text-lg font-bold mt-6 mb-3 text-white border-b border-[var(--tt-border)] pb-2 first:mt-0"
                                          : "text-base font-semibold mt-4 mb-2 text-white",
                                    },
                                    content,
                                  );
                                }

                                // Lists (bulleted or numbered)
                                if (
                                  paragraph.trim().match(/^[-*•]\s+/m) ||
                                  paragraph.trim().match(/^\d+\.\s+/m)
                                ) {
                                  const listItems = paragraph
                                    .split("\n")
                                    .filter((l) => l.trim());
                                  const isOrdered = listItems[0]
                                    ?.trim()
                                    .match(/^\d+\./);

                                  return React.createElement(
                                    isOrdered ? "ol" : "ul",
                                    {
                                      key: pIdx,
                                      className:
                                        "list-none space-y-2 my-3 ml-4",
                                    },
                                    listItems.map((item, iIdx) => {
                                      const cleanItem = item
                                        .replace(/^[-*•]\s+/, "")
                                        .replace(/^\d+\.\s+/, "");
                                      return React.createElement(
                                        "li",
                                        {
                                          key: iIdx,
                                          className: "flex items-start gap-2",
                                        },
                                        [
                                          React.createElement(
                                            "span",
                                            {
                                              key: "bullet",
                                              className:
                                                "text-blue-400 mt-1.5 flex-shrink-0",
                                            },
                                            isOrdered ? `${iIdx + 1}.` : "•",
                                          ),
                                          React.createElement("span", {
                                            key: "content",
                                            className: "flex-1",
                                            dangerouslySetInnerHTML: {
                                              __html:
                                                formatInlineMarkdown(cleanItem),
                                            },
                                          }),
                                        ],
                                      );
                                    }),
                                  );
                                }

                                // Regular paragraph
                                return React.createElement(
                                  "div",
                                  {
                                    key: pIdx,
                                    className: "mb-4 last:mb-0",
                                  },
                                  paragraph.split("\n").map((line, lIdx) => {
                                    if (!line.trim()) {
                                      return React.createElement("br", {
                                        key: lIdx,
                                      });
                                    }

                                    // Check for special formatting patterns
                                    const isBoldLine =
                                      line.match(/^\*\*(.+)\*\*$/);
                                    if (isBoldLine) {
                                      return React.createElement(
                                        "p",
                                        {
                                          key: lIdx,
                                          className:
                                            "font-semibold text-white mb-2",
                                        },
                                        isBoldLine[1],
                                      );
                                    }

                                    // Check for emoji-prefixed lines (opportunities, warnings, etc.)
                                    const emojiMatch = line.match(
                                      /^([🎯⚠️📊💡🚀]+)\s+(.+)$/,
                                    );
                                    if (emojiMatch) {
                                      const emoji = emojiMatch[1];
                                      const content = emojiMatch[2];
                                      const bgColor = emoji.includes("🎯")
                                        ? "bg-blue-500/10 border-blue-500/30"
                                        : emoji.includes("⚠️")
                                          ? "bg-yellow-500/10 border-yellow-500/30"
                                          : emoji.includes("📊")
                                            ? "bg-purple-500/10 border-purple-500/30"
                                            : emoji.includes("💡")
                                              ? "bg-green-500/10 border-green-500/30"
                                              : "bg-[var(--tt-bg-elevated)]/50 border-[var(--tt-border)]";

                                      return React.createElement(
                                        "div",
                                        {
                                          key: lIdx,
                                          className: `flex items-start gap-3 p-3 rounded-lg border ${bgColor} mb-2`,
                                        },
                                        [
                                          React.createElement(
                                            "span",
                                            {
                                              key: "emoji",
                                              className:
                                                "text-xl flex-shrink-0",
                                            },
                                            emoji,
                                          ),
                                          React.createElement("div", {
                                            key: "content",
                                            className: "flex-1",
                                            dangerouslySetInnerHTML: {
                                              __html:
                                                formatInlineMarkdown(content),
                                            },
                                          }),
                                        ],
                                      );
                                    }

                                    return React.createElement("p", {
                                      key: lIdx,
                                      className: "mb-2 leading-relaxed",
                                      dangerouslySetInnerHTML: {
                                        __html:
                                          formatInlineMarkdown(line) ||
                                          "&nbsp;",
                                      },
                                    });
                                  }),
                                );
                              });
                            };

                            // Format inline markdown (bold, code, links, etc.)
                            const formatInlineMarkdown = (text) => {
                              let formatted = text;

                              // Bold (**text**)
                              formatted = formatted.replace(
                                /\*\*(.+?)\*\*/g,
                                '<strong class="font-semibold text-white">$1</strong>',
                              );

                              // Inline code (`code`)
                              formatted = formatted.replace(
                                /`([^`]+)`/g,
                                '<code class="bg-[var(--tt-bg-elevated)] px-1.5 py-0.5 rounded text-xs font-mono text-blue-300">$1</code>',
                              );

                              // Links [text](url) - not common in AI responses but good to have
                              formatted = formatted.replace(
                                /\[([^\]]+)\]\(([^)]+)\)/g,
                                '<a href="$2" class="text-blue-400 hover:text-blue-300 underline" target="_blank" rel="noopener noreferrer">$1</a>',
                              );

                              // Ticker symbols (uppercase 2-5 letter codes)
                              formatted = formatted.replace(
                                /\b([A-Z]{2,5})\b/g,
                                '<span class="font-semibold text-blue-300">$1</span>',
                              );

                              // Numbers with $ (prices)
                              formatted = formatted.replace(
                                /\$(\d+\.?\d*)/g,
                                '<span class="text-green-400 font-medium">$$1</span>',
                              );

                              // Percentages
                              formatted = formatted.replace(
                                /(\d+\.?\d*)%/g,
                                '<span class="text-yellow-400 font-medium">$1%</span>',
                              );

                              // RR ratios (X:1 or 1:X)
                              formatted = formatted.replace(
                                /(\d+\.?\d*):1/g,
                                '<span class="text-purple-400 font-medium">$1:1</span>',
                              );

                              // Table separators (|)
                              formatted = formatted.replace(
                                /\|/g,
                                '<span class="text-[var(--tt-text-faint)] mx-1">|</span>',
                              );

                              return formatted;
                            };

                            return renderMarkdown(dailySummary.summary);
                          })()}
                        </div>
                      </div>

                      {/* Performance Breakdown */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                          <h4 className="text-sm font-semibold mb-2">
                            Performance by Rank
                          </h4>
                          <div className="space-y-1 text-xs">
                            {Object.entries(
                              dailySummary.stats.rankAnalysis || {},
                            ).map(([range, stats]) => (
                              <div key={range} className="flex justify-between">
                                <span className="text-[var(--tt-text-muted)]">{range}:</span>
                                <span
                                  className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                                >
                                  {stats.wins}W/{stats.losses}L ($
                                  {stats.totalPnl.toFixed(2)})
                                </span>
                              </div>
                            ))}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                          <h4 className="text-sm font-semibold mb-2">
                            Performance by RR
                          </h4>
                          <div className="space-y-1 text-xs">
                            {Object.entries(
                              dailySummary.stats.rrAnalysis || {},
                            ).map(([range, stats]) => (
                              <div key={range} className="flex justify-between">
                                <span className="text-[var(--tt-text-muted)]">{range}:</span>
                                <span
                                  className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                                >
                                  {stats.wins}W/{stats.losses}L ($
                                  {stats.totalPnl.toFixed(2)})
                                </span>
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
          </div>
        );
      }

      // Error boundary so render errors show in UI instead of blank screen
      class TrackerErrorBoundary extends React.Component {
        state = { error: null };
        static getDerivedStateFromError(err) {
          return { error: err };
        }
        componentDidCatch(err, info) {
          console.error("Tracker render error:", err, info);
        }
        render() {
          if (this.state.error) {
            return (
              <div className="p-10 text-center font-sans" style={{ color: "var(--tt-text)" }}>
                <h2 className="text-[var(--tt-negative)]">Trade Tracker failed to load</h2>
                <p style={{ marginTop: 16 }}>{this.state.error.message}</p>
                <pre style={{ textAlign: "left", marginTop: 16, padding: 16, background: "var(--tt-bg-surface)", overflow: "auto", fontSize: 12 }}>
                  {this.state.error.stack}
                </pre>
              </div>
            );
          }
          return this.props.children;
        }
      }

      try {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          throw new Error("React or ReactDOM not loaded");
        }
        const rootElement = document.getElementById("root");
        if (!rootElement) {
          throw new Error("Root element not found");
        }
        const root = ReactDOM.createRoot ? ReactDOM.createRoot(rootElement) : null;
        const app = (
          <TrackerErrorBoundary>
            <App />
          </TrackerErrorBoundary>
        );
        if (root) {
          root.render(app);
        } else {
          ReactDOM.render(app, rootElement);
        }
      } catch (error) {
        console.error("Error rendering app:", error);
        const root = document.getElementById("root");
        if (root) {
          root.innerHTML = `
          <div className="p-10 text-center" style={{ color: "var(--tt-text)" }}>
            <h2 className="text-[var(--tt-negative)]">Error Loading Trade Tracker</h2>
            <p>${error.message}</p>
            <p style="margin-top: 20px; color: var(--tt-text-muted);">Check the browser console (F12) for details.</p>
          </div>`;
        }
      }
    </script>
  </body>
</html>
