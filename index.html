<!doctype html>
<!-- UI_VERSION: 2026-01-04-corridors-trails-flash-mobile -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Timed Trading â€” Bubble Quadrant</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    :root { --bg:#0b1020; --card:#121a33; --text:#e7ecff; --muted:#93a4d6; --line:#26325f; --good:#2ecc71; --bad:#e74c3c; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    header { padding:14px 18px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .title { font-weight:900; letter-spacing:.2px; }
    .pill { background:var(--card); border:1px solid var(--line); border-radius:999px; padding:8px 12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .pill label { font-size:12px; color:var(--muted); }
    select,input { background:#0f1630; color:var(--text); border:1px solid var(--line); border-radius:10px; padding:8px 10px; }
    input[type="checkbox"] { transform: scale(1.1); }
    .btn { cursor:pointer; background:#1a2550; border:1px solid var(--line); color:var(--text);
           border-radius:12px; padding:9px 12px; font-weight:800; }
    .btn:active { transform: translateY(1px); }
    .muted { color:var(--muted); font-size:12px; }
    main { padding:14px 18px; }
    .grid { display:grid; grid-template-columns: 1fr 380px; gap:12px; align-items:start; }
    #chart { width:100%; height:78vh; border:1px solid var(--line); border-radius:16px; background:var(--card); }
    .side { border:1px solid var(--line); border-radius:16px; background:var(--card); padding:12px; }
    .side h3 { margin:8px 0 10px 0; font-size:14px; color:var(--text); }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { padding:6px 10px; border:1px solid var(--line); border-radius:999px; cursor:pointer; font-size:12px; color:var(--muted); }
    .tab.active { color:var(--text); background:#0f1630; }
    .list { margin-top:10px; display:flex; flex-direction:column; gap:8px; max-height:30vh; overflow:auto; }
    .item { border:1px solid var(--line); border-radius:12px; padding:8px; cursor:pointer; }
    .row { display:flex; justify-content:space-between; gap:8px; }
    .k { color:var(--muted); font-size:12px; }
    .v { font-size:12px; }
    .badge { border:1px solid var(--line); border-radius:999px; padding:2px 8px; font-size:12px; color:var(--muted); }
    .good { color: var(--good); }
    .bad { color: var(--bad); }
    .details { margin-top:10px; border-top:1px solid var(--line); padding-top:10px; }
    a { color:#a8b6ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .hr { border-top:1px solid var(--line); margin:10px 0; }
    .tradeCard { border:1px solid var(--line); border-radius:12px; padding:10px; background:#0f1630; }
    .tradeTitle { font-weight:900; }
    .pillRow { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .chip { border:1px solid var(--line); border-radius:999px; padding:3px 8px; font-size:12px; color:var(--text); background:rgba(255,255,255,0.03); }

    /* Mobile */
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
      #chart { height: 62vh; }
      .side { position: relative; }
    }
  </style>
</head>

<body>
  <header>
    <div class="title">Timed Trading â€” Bubble Quadrant</div>

    <div class="pill">
      <label>Data</label>
      <select id="endpoint">
        <option value="https://timed-trading-ingest.shashant.workers.dev/timed/all">/timed/all</option>
      </select>
    </div>

    <div class="pill">
      <label>Search</label>
      <input id="search" placeholder="Ticker (e.g., SPY, MES1!)" />
    </div>

    <div class="pill">
      <label>Show</label>
      <label class="muted"><input type="checkbox" id="q1" checked> Q1</label>
      <label class="muted"><input type="checkbox" id="q2" checked> Q2</label>
      <label class="muted"><input type="checkbox" id="q3" checked> Q3</label>
      <label class="muted"><input type="checkbox" id="q4" checked> Q4</label>
    </div>

    <div class="pill">
      <label>Completion â‰¤</label>
      <select id="compMax">
        <option value="1.01">100%</option>
        <option value="0.80">80%</option>
        <option value="0.60">60%</option>
        <option value="0.40">40%</option>
        <option value="0.25">25%</option>
      </select>
    </div>

    <div class="pill">
      <label>RR â‰¥</label>
      <select id="rrMin">
        <option value="0">Any</option>
        <option value="1">1.0</option>
        <option value="1.5" selected>1.5</option>
        <option value="2">2.0</option>
        <option value="3">3.0</option>
      </select>
    </div>

    <div class="pill">
      <label>Rank â‰¥</label>
      <select id="rankMin">
        <option value="0">Any</option>
        <option value="50">50</option>
        <option value="60">60</option>
        <option value="70" selected>70</option>
        <option value="80">80</option>
      </select>
    </div>

    <div class="pill">
      <label>Swap axes</label>
      <label class="muted"><input type="checkbox" id="swapAxes"> Y=LTF / X=HTF</label>
    </div>

    <div class="pill">
      <label>Auto-refresh</label>
      <select id="refreshSec">
        <option value="0">Off</option>
        <option value="15">15s</option>
        <option value="30" selected>30s</option>
        <option value="60">60s</option>
      </select>
    </div>

    <button class="btn" id="refreshBtn">Refresh</button>
    <div class="muted" id="status"></div>

    <div class="muted" style="width:100%;">
      Entry corridors shaded. Flash = ðŸ§¨ squeeze ON inside corridor. âš¡ = squeeze release. Click selects + shows trail + trade card.
    </div>
  </header>

  <main>
    <div class="grid">
      <div id="chart"></div>

      <div class="side" id="sidePanel">
        <div class="tabs">
          <div class="tab active" id="tabLong">Top Long (Q1â†’Q2)</div>
          <div class="tab" id="tabShort">Top Short (Q4â†’Q3)</div>
          <div class="tab" id="tabSetup">Top Setups (Q1/Q4)</div>
        </div>

        <div class="list" id="topList"></div>

        <div class="details" id="details">
          <h3>Selected</h3>
          <div class="muted">Click a bubble or a list item.</div>
        </div>
      </div>
    </div>
  </main>

<script>
  window.addEventListener("error", (e) => {
    console.error(e);
    const msg = `[JS ERROR] ${e.message}\n${e.filename}:${e.lineno}:${e.colno}`;
    const pre = document.createElement("pre");
    pre.style.padding = "16px";
    pre.style.whiteSpace = "pre-wrap";
    pre.style.color = "#fff";
    pre.style.background = "#111";
    pre.textContent = msg;
    document.body.innerHTML = "";
    document.body.appendChild(pre);
  });

  const el = (id) => document.getElementById(id);
  const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
  function on(id, evt, handler) { const node = el(id); if (!node) return; node.addEventListener(evt, handler); }

  // Corridor definition (in score space)
  // Long corridor: HTF > 0 and LTF in [-8, +12] (pullback resolving)
  // Short corridor: HTF < 0 and LTF in [-12, +8] (pullback resolving)
  const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
  const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };

  // Trail behavior
  const ALWAYS_ON_TRAIL_FOR_CORRIDOR = true; // always show faint trail when in corridor
  const TRAIL_MAX_POINTS = 8;

  // Flash behavior: ONLY when squeeze is ON and inside corridor
  const FLASH_PERIOD_MS = 900;

  // Label behavior
  const LABEL_SIZE_THRESHOLD = 28;

  // Staleness fade
  const STALE_WARN_MIN = 30;
  const STALE_MAX_MIN = 240;

  function quadrantFromState(s) {
    if (s === "HTF_BULL_LTF_PULLBACK") return "Q1";
    if (s === "HTF_BULL_LTF_BULL") return "Q2";
    if (s === "HTF_BEAR_LTF_BEAR") return "Q3";
    if (s === "HTF_BEAR_LTF_PULLBACK") return "Q4";
    return "Q?";
  }

  function stalenessOpacity(tsMs) {
    if (!tsMs || typeof tsMs !== "number") return 0.65;
    const ageMin = (Date.now() - tsMs) / 60000;
    if (ageMin <= STALE_WARN_MIN) return 0.92;
    const t = clamp((ageMin - STALE_WARN_MIN) / Math.max(1, (STALE_MAX_MIN - STALE_WARN_MIN)), 0, 1);
    return 0.92 - t * 0.74;
  }

  function fmtNum(v, d=2) {
    const n = Number(v);
    if (!Number.isFinite(n)) return "â€”";
    return n.toFixed(d);
  }
  function fmtPct01(v) {
    const n = Number(v);
    if (!Number.isFinite(n)) return "â€”";
    return `${Math.round(n*100)}%`;
  }

  // Completion used for bubble sizing:
  // Prefer TP progress when trigger_price + tp exist; otherwise fallback to payload completion.
  function completionForSize(d) {
    const c = Number(d.completion);
    const trig = Number(d.trigger_price);
    const tp = Number(d.tp);
    const px = Number(d.price);

    if ([trig, tp, px].every(Number.isFinite) && tp !== trig) {
      const prog = (px - trig) / (tp - trig);
      return clamp(Math.abs(prog), 0, 1);
    }
    return Number.isFinite(c) ? clamp(c, 0, 1) : 0;
  }

  function bubbleSize(d) {
    const c = completionForSize(d);
    return 10 + c * 40;
  }

  function tvUrlForTicker(ticker) {
    const q = encodeURIComponent(ticker);
    return `https://www.tradingview.com/chart/?symbol=${q}`;
  }

  function isLongCorridor(htf, ltf) {
    return (htf > 0) && (ltf >= LONG_CORRIDOR.ltfMin) && (ltf <= LONG_CORRIDOR.ltfMax);
  }
  function isShortCorridor(htf, ltf) {
    return (htf < 0) && (ltf >= SHORT_CORRIDOR.ltfMin) && (ltf <= SHORT_CORRIDOR.ltfMax);
  }

  function entryType(d) {
    const h = Number(d.htf_score), l = Number(d.ltf_score);
    if (!Number.isFinite(h) || !Number.isFinite(l)) return { corridor:false, side:null };
    if (isLongCorridor(h, l)) return { corridor:true, side:"LONG" };
    if (isShortCorridor(h, l)) return { corridor:true, side:"SHORT" };
    return { corridor:false, side:null };
  }

  function whyString(d) {
    const reasons = Array.isArray(d.reasons) ? d.reasons : [];
    const trig = d.trigger_reason ? `${d.trigger_reason}${d.trigger_dir ? " ("+d.trigger_dir+")" : ""}` : "";
    const corridor = entryType(d);
    const corridorWhy = corridor.corridor ? (corridor.side==="LONG" ? "Entry corridor (Q1â†’Q2)" : "Entry corridor (Q4â†’Q3)") : "";
    const bits = [corridorWhy, trig].filter(Boolean);
    return bits.length ? bits.join(" | ") : (reasons[0] || "â€”");
  }

  function hoverText(t, d) {
    const flags = d.flags || {};
    const ageMin = (Date.now() - (d.ts || Date.now())) / 60000;
    const corridor = entryType(d);

    return [
      `<b>${t}</b>`,
      `State: ${d.state || ""} (${quadrantFromState(d.state)})`,
      corridor.corridor ? `<b>${corridor.side} corridor</b>` : `Not in entry corridor`,
      `Why: ${whyString(d)}`,
      `Rank: ${d.rank ?? "â€”"} | RR: ${d.rr != null ? fmtNum(d.rr,2) : "â€”"}`,
      `HTF: ${fmtNum(d.htf_score,2)} | LTF: ${fmtNum(d.ltf_score,2)}`,
      `Bubble completion (TP-based): ${fmtPct01(completionForSize(d))}`,
      `Phase: ${fmtPct01(d.phase_pct)}`,
      `Age: ${Number.isFinite(ageMin) ? ageMin.toFixed(1)+"m" : "â€”"} | Staleness: ${d.staleness || "â€”"}`,
      `Trigger: ${fmtNum(d.trigger_price,2)} | Price: ${fmtNum(d.price,2)}`,
      `SL: ${fmtNum(d.sl,2)} | TP: ${fmtNum(d.tp,2)} | ETA: ${d.eta_days != null ? fmtNum(d.eta_days,1)+"d" : "â€”"}`,
      `Flags: sq_on=${!!flags.sq30_on}, sq_rel=${!!flags.sq30_release}, phase_dot=${!!flags.phase_dot}`
    ].join("<br>");
  }

  async function fetchJSON(url) {
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error(`Fetch failed ${res.status}`);
    return await res.json();
  }

  async function fetchAll() {
    const url = el("endpoint").value;
    const json = await fetchJSON(url);
    if (!json.ok) throw new Error("API not ok");
    return json.data || {};
  }

  async function fetchTop(bucket, n=10) {
    const base = "https://timed-trading-ingest.shashant.workers.dev/timed/top";
    const url = `${base}?bucket=${encodeURIComponent(bucket)}&n=${n}`;
    const json = await fetchJSON(url);
    if (!json.ok) throw new Error("top API not ok");
    return json.data || [];
  }

  async function fetchTrail(ticker) {
    const base = "https://timed-trading-ingest.shashant.workers.dev/timed/trail";
    const url = `${base}?ticker=${encodeURIComponent(ticker)}`;
    const json = await fetchJSON(url);
    if (!json.ok) return [];
    const trail = json.trail || [];
    return trail.slice(-TRAIL_MAX_POINTS);
  }

  function applyFilters(dataObj) {
    const search = el("search").value.trim().toUpperCase();
    const compMax = Number(el("compMax").value);
    const rrMin = Number(el("rrMin").value);
    const rankMin = Number(el("rankMin").value);
    const swap = el("swapAxes").checked;

    const allow = new Set();
    if (el("q1").checked) allow.add("HTF_BULL_LTF_PULLBACK");
    if (el("q2").checked) allow.add("HTF_BULL_LTF_BULL");
    if (el("q3").checked) allow.add("HTF_BEAR_LTF_BEAR");
    if (el("q4").checked) allow.add("HTF_BEAR_LTF_PULLBACK");

    const out = [];
    for (const [ticker, d] of Object.entries(dataObj)) {
      if (!d) continue;
      const T = String(ticker||"").toUpperCase();
      if (search && !T.includes(search)) continue;
      if (!allow.has(d.state)) continue;

      const cs = completionForSize(d);
      if (cs > compMax) continue;

      const rr = (d.rr != null) ? Number(d.rr) : null;
      if (rrMin > 0 && !(rr != null && rr >= rrMin)) continue;

      const rk = Number(d.rank || 0);
      if (rankMin > 0 && rk < rankMin) continue;

      out.push({ ticker: T, ...d, _swap: swap });
    }
    return out;
  }

  let clickHandlerBound = false;
  let selectedTicker = null;
  let selectedTrail = null;
  let currentTab = "long";
  let refreshTimer = null;

  // Flash state
  function flashAlpha() {
    const t = Date.now() % FLASH_PERIOD_MS;
    return 0.35 + 0.55 * (0.5 + 0.5 * Math.sin((t / FLASH_PERIOD_MS) * 2 * Math.PI)); // 0.35..0.9
  }

  // Entry corridor shapes
  function corridorShapes(swapAxes) {
    // Without swap: x=LTF, y=HTF
    // With swap: x=HTF, y=LTF
    const shapes = [];
    if (!swapAxes) {
      // Long corridor: y>0, x in [-8,+12]
      shapes.push({
        type:"rect", xref:"x", yref:"y",
        x0: LONG_CORRIDOR.ltfMin, x1: LONG_CORRIDOR.ltfMax,
        y0: 0, y1: 50,
        fillcolor:"rgba(46,204,113,0.10)", line:{width:0}
      });
      // Short corridor: y<0, x in [-12,+8]
      shapes.push({
        type:"rect", xref:"x", yref:"y",
        x0: SHORT_CORRIDOR.ltfMin, x1: SHORT_CORRIDOR.ltfMax,
        y0: -50, y1: 0,
        fillcolor:"rgba(231,76,60,0.10)", line:{width:0}
      });
    } else {
      // Swapped: x=HTF, y=LTF
      shapes.push({
        type:"rect", xref:"x", yref:"y",
        x0: 0, x1: 50,
        y0: LONG_CORRIDOR.ltfMin, y1: LONG_CORRIDOR.ltfMax,
        fillcolor:"rgba(46,204,113,0.10)", line:{width:0}
      });
      shapes.push({
        type:"rect", xref:"x", yref:"y",
        x0: -50, x1: 0,
        y0: SHORT_CORRIDOR.ltfMin, y1: SHORT_CORRIDOR.ltfMax,
        fillcolor:"rgba(231,76,60,0.10)", line:{width:0}
      });
    }
    // Outer frame
    shapes.push({ type:"rect", xref:"x", yref:"y", x0:-50, x1:50, y0:-50, y1:50, line:{color:"#3a4aa0", width:1}, fillcolor:"rgba(0,0,0,0)" });
    return shapes;
  }

  function render(points, faintTrailsByTicker) {
    if (!window.Plotly) throw new Error("Plotly failed to load (CDN blocked).");
    const swap = points[0]?._swap ?? false;

    // Main marker trace
    const X=[], Y=[], H=[], sizes=[], colors=[], opacities=[], labels=[], lws=[], lcs=[], custom=[];
    for (const p of points) {
      const h = Number(p.htf_score), l = Number(p.ltf_score);
      const x = swap ? h : l;
      const y = swap ? l : h;

      const compS = completionForSize(p);
      const size = 10 + compS * 40;
      const phase = Number.isFinite(Number(p.phase_pct)) ? Number(p.phase_pct) : 0;
      const baseAlpha = stalenessOpacity(p.ts);

      const flags = p.flags || {};
      const sqRel = !!flags.sq30_release;
      const sqOn  = !!flags.sq30_on;

      const ent = entryType(p);
      const inCorridor = ent.corridor;

      // Stroke
      const lw = sqRel ? 6 : (sqOn ? 4 : 1);
      const lc = sqRel ? "rgba(0,255,255,0.95)" : (sqOn ? "rgba(255,215,0,0.95)" : "rgba(255,255,255,0.35)");

      // Flash: only if sqOn AND in corridor
      const alpha = (sqOn && inCorridor) ? Math.min(1, flashAlpha()) : baseAlpha;

      const showLabel = (size >= LABEL_SIZE_THRESHOLD) || sqRel;
      const sqEmoji = sqRel ? "âš¡" : (sqOn ? "ðŸ§¨" : "");
      const lbl = showLabel ? `${p.ticker}${sqEmoji ? " " + sqEmoji : ""}` : "";

      X.push(x); Y.push(y);
      H.push(hoverText(p.ticker, p));
      sizes.push(size);
      colors.push(phase);
      opacities.push(alpha);
      labels.push(lbl);
      lws.push(lw);
      lcs.push(lc);
      custom.push({ ticker:p.ticker, tv:tvUrlForTicker(p.ticker) });
    }

    const traces = [{
      name:"bubbles",
      type:"scatter",
      mode:"markers+text",
      x: X, y: Y,
      text: labels,
      textposition:"top center",
      textfont:{ size:12, color:"rgba(231,236,255,0.9)" },
      hoverinfo:"text",
      hovertext: H,
      customdata: custom,
      marker:{
        size: sizes,
        color: colors,
        colorscale:"Turbo",
        cmin:0, cmax:1,
        showscale:true,
        colorbar:{ title:"Phase %" },
        opacity: opacities,
        line:{ width:lws, color:lcs }
      }
    }];

    // Always-on faint trails for corridor names (optional)
    if (ALWAYS_ON_TRAIL_FOR_CORRIDOR && faintTrailsByTicker) {
      for (const [tk, tr] of Object.entries(faintTrailsByTicker)) {
        if (!tr || tr.length < 2) continue;
        traces.push({
          name:`trail_${tk}`,
          type:"scatter",
          mode:"lines+markers",
          x: tr.map(p => swap ? (p.htf_score ?? 0) : (p.ltf_score ?? 0)),
          y: tr.map(p => swap ? (p.ltf_score ?? 0) : (p.htf_score ?? 0)),
          line:{ width:1, color:"rgba(180,200,255,0.25)" },
          marker:{ size:4, color:"rgba(180,200,255,0.35)" },
          hoverinfo:"skip",
          showlegend:false
        });
      }
    }

    // Selected trail (strong)
    if (selectedTrail && selectedTrail.length >= 2) {
      const tx = selectedTrail.map(p => swap ? (p.htf_score ?? 0) : (p.ltf_score ?? 0));
      const ty = selectedTrail.map(p => swap ? (p.ltf_score ?? 0) : (p.htf_score ?? 0));
      const n = tx.length;
    
      // Gradient sizes + opacities (oldest -> newest)
      const sizes = Array.from({length:n}, (_,i) => 5 + (i/(n-1))*8); // 5..13
      const alphas = Array.from({length:n}, (_,i) => 0.25 + (i/(n-1))*0.75); // 0.25..1.0
      const colors = alphas.map(a => `rgba(180,200,255,${a.toFixed(3)})`);
    
      // Symbols: oldest hollow circle, newest star, middle dots
      const symbols = Array.from({length:n}, (_,i) =>
        i === 0 ? "circle-open" : (i === n-1 ? "star" : "circle")
      );
    
      // 1) line (no markers)
      traces.push({
        name:"selected_trail_line",
        type:"scatter",
        mode:"lines",
        x: tx, y: ty,
        line:{ width:3, color:"rgba(180,200,255,0.65)" },
        hoverinfo:"skip",
        showlegend:false
      });
    
      // 2) points (gradient + start/end markers)
      traces.push({
        name:"selected_trail_pts",
        type:"scatter",
        mode:"markers+text",
        x: tx, y: ty,
        // Optional numeric labels (uncomment if you want 1..N):
        // text: selectedTrail.map((_,i)=> String(i+1)),
        // textposition: "bottom center",
        // textfont: { size: 11, color: "rgba(180,200,255,0.9)" },
        marker:{
          size: sizes,
          color: colors,
          symbol: symbols,
          line: { width: 1, color: "rgba(255,255,255,0.45)" }
        },
        hoverinfo:"skip",
        showlegend:false
      });
    }

    const xTitle = swap ? "HTF Score" : "LTF Score";
    const yTitle = swap ? "LTF Score" : "HTF Score";

    const layout = {
      paper_bgcolor:"rgba(0,0,0,0)",
      plot_bgcolor:"rgba(0,0,0,0)",
      margin:{ l:55, r:24, t:20, b:55 },
      xaxis:{ title:xTitle, range:[-50,50], zeroline:true, zerolinecolor:"#9aa7d8", gridcolor:"#26325f" },
      yaxis:{ title:yTitle, range:[-50,50], zeroline:true, zerolinecolor:"#9aa7d8", gridcolor:"#26325f" },
      shapes: corridorShapes(swap),
      annotations:[
        { x:-35, y: 42, xref:"x", yref:"y", text: swap ? "HTF<0 / LTF>0 zone" : "Q1 Prep", showarrow:false, font:{color:"#93a4d6", size:12} },
        { x: 35, y: 42, xref:"x", yref:"y", text: swap ? "Bull aligned" : "Q2 Bull", showarrow:false, font:{color:"#93a4d6", size:12} },
        { x:-35, y:-45, xref:"x", yref:"y", text: swap ? "Bear aligned" : "Q3 Bear", showarrow:false, font:{color:"#93a4d6", size:12} },
        { x: 35, y:-45, xref:"x", yref:"y", text: swap ? "HTF>0 / LTF<0 zone" : "Q4 Pullback", showarrow:false, font:{color:"#93a4d6", size:12} }
      ]
    };

    Plotly.react("chart", traces, layout, { responsive:true, displayModeBar:true });

    if (!clickHandlerBound) {
      el("chart").on("plotly_click", (evt) => {
        const p = evt?.points?.[0];
        const cd = p?.customdata;
        if (!cd?.ticker) return;
        window.open(cd.tv, "_blank", "noopener,noreferrer");
        selectTicker(cd.ticker);
      });
      clickHandlerBound = true;
    }
  }

  function setActiveTab(which) {
    ["tabLong","tabShort","tabSetup"].forEach(id => el(id).classList.remove("active"));
    el(which).classList.add("active");
  }

  function renderList(items) {
    const list = el("topList");
    list.innerHTML = "";
    items.forEach(d => {
      const t = (d.ticker || d.symbol || d.contract || "â€”").toUpperCase();
      const rr = (d.rr != null) ? Number(d.rr).toFixed(2) : "â€”";
      const comp = fmtPct01(completionForSize(d));
      const ph = d.phase_pct != null ? Math.round(Number(d.phase_pct)*100) + "%" : "â€”";
      const sq = d.flags?.sq30_release ? "âš¡" : (d.flags?.sq30_on ? "ðŸ§¨" : "");
      const corridor = entryType(d);
      const corridorTag = corridor.corridor ? (corridor.side==="LONG" ? "LONG corridor" : "SHORT corridor") : "â€”";
      const why = whyString(d);

      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="row">
          <div><b>${t}</b> ${sq} <span class="badge">Rank ${d.rank ?? "â€”"}</span></div>
          <div class="badge">RR ${rr}</div>
        </div>
        <div class="row" style="margin-top:6px;">
          <div class="k">Trade</div><div class="v">${corridorTag}</div>
        </div>
        <div class="row">
          <div class="k">Comp</div><div class="v">${comp}</div>
          <div class="k">Phase</div><div class="v">${ph}</div>
        </div>
        <div class="row">
          <div class="k">Why</div><div class="v">${why}</div>
        </div>
      `;
      div.addEventListener("click", () => selectTicker(t));
      list.appendChild(div);
    });
  }

  async function selectTicker(ticker) {
    selectedTicker = ticker;
    const details = el("details");
    details.innerHTML = `<h3>Selected</h3><div class="muted">Loading ${ticker}â€¦</div>`;

    const latest = await fetchJSON(`https://timed-trading-ingest.shashant.workers.dev/timed/latest?ticker=${encodeURIComponent(ticker)}`);
    const d = latest.data || null;
    selectedTrail = await fetchTrail(ticker);

    if (!d) {
      details.innerHTML = `<h3>Selected</h3><div class="muted">No data for ${ticker}</div>`;
      return;
    }

    const ent = entryType(d);
    const side = ent.side || (d.state === "HTF_BULL_LTF_BULL" ? "LONG" : d.state === "HTF_BEAR_LTF_BEAR" ? "SHORT" : "â€”");
    const why = whyString(d);

    details.innerHTML = `
      <h3>${ticker}</h3>

      <div class="tradeCard">
        <div class="tradeTitle">${ent.corridor ? (side==="LONG" ? "LONG ENTRY SETUP" : "SHORT ENTRY SETUP") : "CONTEXT / MONITOR"}</div>
        <div class="muted" style="margin-top:6px;">${why}</div>

        <div class="pillRow">
          <span class="chip">Dir: ${side}</span>
          <span class="chip">Rank: ${d.rank ?? "â€”"}</span>
          <span class="chip">RR: ${d.rr != null ? fmtNum(d.rr,2) : "â€”"}</span>
          <span class="chip">ETA: ${d.eta_days != null ? fmtNum(d.eta_days,1)+"d" : "â€”"}</span>
        </div>

        <div class="hr"></div>

        <div class="row"><div class="k">Trigger</div><div class="v">${fmtNum(d.trigger_price,2)} (${d.trigger_reason||"â€”"} ${d.trigger_dir?`/${d.trigger_dir}`:""})</div></div>
        <div class="row"><div class="k">Price now</div><div class="v">${fmtNum(d.price,2)}</div></div>
        <div class="row"><div class="k">Stop (SL)</div><div class="v">${fmtNum(d.sl,2)}</div></div>
        <div class="row"><div class="k">Target (TP)</div><div class="v">${fmtNum(d.tp,2)}</div></div>
        <div class="row"><div class="k">Bubble size</div><div class="v">${fmtPct01(completionForSize(d))} toward TP</div></div>

        <div class="hr"></div>

        <div class="row"><div class="k">HTF/LTF</div><div class="v">${fmtNum(d.htf_score,2)} / ${fmtNum(d.ltf_score,2)}</div></div>
        <div class="row"><div class="k">Phase</div><div class="v">${fmtPct01(d.phase_pct)}</div></div>
        <div class="row"><div class="k">Open TV</div><div class="v"><a href="${tvUrlForTicker(ticker)}" target="_blank" rel="noopener noreferrer">TradingView</a></div></div>
      </div>
    `;

    await refresh(); // re-render with selectedTrail
  }

  async function buildFaintTrails(points) {
    // Faint trails only for corridor entries (avoid clutter)
    const out = {};
    const corridorTickers = points
      .filter(p => entryType(p).corridor)
      .map(p => p.ticker);

    // limit to avoid too many requests on big watchlists
    const MAX = 18;
    const take = corridorTickers.slice(0, MAX);

    await Promise.all(take.map(async (t) => {
      try { out[t] = await fetchTrail(t); } catch { /* ignore */ }
    }));

    return out;
  }

  async function refresh() {
    const s = el("status");
    try {
      if (s) s.textContent = "Loadingâ€¦";
      const dataObj = await fetchAll();
      const points = applyFilters(dataObj);

      // build faint trails for corridor entries
      const faint = await buildFaintTrails(points);

      render(points, faint);

      // Side lists
      const top = await fetchTop(currentTab, 10);
      renderList(top);

      if (s) s.textContent = `Loaded ${points.length} tickers â€¢ ${new Date().toLocaleTimeString()}`;
    } catch (e) {
      console.error(e);
      if (s) s.textContent = `Error: ${e.message}`;
    }
  }

  function resetAutoRefresh() {
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = null;
    const sec = Number(el("refreshSec").value);
    if (sec > 0) refreshTimer = setInterval(() => refresh(), sec * 1000);
  }

  // Tabs map to worker buckets
  // long = Q2, short = Q3, setup = Q1/Q4
  function tabBucket() {
    if (currentTab === "long") return "long";
    if (currentTab === "short") return "short";
    return "setup";
  }

  on("refreshBtn","click", ()=> refresh());
  on("refreshSec","change", ()=> { resetAutoRefresh(); refresh(); });

  ["search","q1","q2","q3","q4","compMax","rrMin","rankMin","swapAxes"].forEach(id => on(id,"input", ()=> refresh()));

  on("tabLong","click", ()=>{ currentTab="long"; setActiveTab("tabLong"); refresh(); });
  on("tabShort","click",()=>{ currentTab="short"; setActiveTab("tabShort"); refresh(); });
  on("tabSetup","click",()=>{ currentTab="setup"; setActiveTab("tabSetup"); refresh(); });

  resetAutoRefresh();
  refresh();
</script>
</body>
</html>
