// ============================================================================
//  AutoPilot Phoenix v2.0.0 - CLEAN (Easy to Debug & Tune)
//  Shashant Jasani
//  Phoenix_v2_Clean
//
//  STREAMLINED VERSION:
//  - Only essential, actively-used filters
//  - Simple, readable debug labels (failures only)
//  - All v2 features: Score, ORB, Regime, TD9 Quality, ST Matrix, Mean Reversion
// ============================================================================

//@version=6
strategy("Phoenixv2",
    overlay=true,
    process_orders_on_close=true,
    calc_on_every_tick=false,
    max_labels_count=500, max_lines_count=500,
    default_qty_type=strategy.fixed,
    default_qty_value=1)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  0) SMALL UTILS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
toFixed(x) => str.tostring(x, format.mintick)

f_to_tick(p) =>
   math.round(p / syminfo.mintick) * syminfo.mintick

f_px_from_ticks(px, ticks) =>
   f_to_tick(px + ticks * syminfo.mintick)

tfStr(tf) =>
   tf == "Chart" ? timeframe.period : tf

f_fmt_dec(x, dec) =>
   dec <= 0 ?
        str.tostring(math.round(x)) :
        str.tostring(math.round(x * math.pow(10, dec)) / math.pow(10, dec))

ticks2px(n) => n * syminfo.mintick

ticks(n) => n * syminfo.mintick

clamp(x, lo, hi) => math.max(lo, math.min(hi, x))

sec(tf, expr) =>
   request.security(syminfo.tickerid, tfStr(tf), expr, barmerge.gaps_off, barmerge.lookahead_off)

f_label_replace(oldLabel, y, txt, isUp, bg, txtc) =>
   if not na(oldLabel)
       label.delete(oldLabel)
   label.new(bar_index, y, txt,        xloc=xloc.bar_index, yloc=yloc.price,        style=isUp ? label.style_label_up : label.style_label_down,        color=bg, textcolor=txtc)

f_dbg_kv(_k, _v) => _k + ": " + _v + "\n"

f_dbg_label(_isLong, _y, _txt, _bg, _maxChars) =>
   label.new(
     bar_index, _y,
     str.substring(_txt, 0, _maxChars),
     xloc=xloc.bar_index, yloc=yloc.price,
     style=_isLong ? label.style_label_down : label.style_label_up,
     size=size.tiny,
     color=_bg, textcolor=color.white
   )

// Simple RSI-on-TF helper (used by Fuse exits)
rsi_on_tf(tf, len) =>
   _tf = tf=="Chart" ? timeframe.period : tf
   request.security(syminfo.tickerid, _tf, ta.rsi(close, len),        barmerge.gaps_off, barmerge.lookahead_off)

// Bracket IDs for exit engine
const string BRACKET_L_ID = "BRACKET_L"
const string BRACKET_S_ID = "BRACKET_S"

// ============================================================================
//  DEBUG & TELEMETRY: WHY_NO_ENTRY + Ready Pings (unchanged)
// ============================================================================

groupDebug = "â”â” M) Debug Labels"

dbgShowFailures = input.bool(false, "Show why entry failed", group=groupDebug,
   tooltip="Shows label at cross with reasons why entry was rejected")
dbgShowExitReason = input.bool(false, "Show exit reason", group=groupDebug,
   tooltip="Shows label at exit with reason for exit")

// Legacy debug flags (kept for compatibility, but not in UI)
dbgSendInfo = false
dbgPlotTTLTFScore = false

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  VISUALS: Chart appearance settings
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupVisuals = "â”â” N) Visual Settings"

orbHighColor = input.color(color.new(color.orange, 70), "ORB High line color", group=groupVisuals)
orbLowColor = input.color(color.new(color.orange, 70), "ORB Low line color", group=groupVisuals)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  A) GLOBAL ENVIRONMENT & ROUTING (Phoenix plumbing)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupEnv = "â”â” A) Global Environment & Routing"

useLiveEnv          = input.bool(false, "LIVE? (else DEMO)", group=groupEnv)
alertTag            = input.string("PHOENIX_v1.1.0", "Alert Tag", group=groupEnv)
tvApiKey            = input.string("DolphinVomy!", "API Key", group=groupEnv)
orderContract       = input.string("MES1!", "Contract", group=groupEnv)
orderQty            = input.float(10, "Fixed Qty (fallback)", group=groupEnv)
tif                 = input.string("GTC", "TIF", options=["Day","GTC"], group=groupEnv)
autoFlag            = input.bool(true, "Automated (sent by strategy)", group=groupEnv)

enableWebhookAlerts = input.bool(true, "Webhook OPEN/CLOSE", group=groupEnv)
enableWebhookAmends = input.bool(true, "Webhook AMENDs", group=groupEnv)
enableInfoAlerts    = input.bool(true, "INFO Alerts", group=groupEnv)
dedupOpenPerBar     = input.bool(true, "Dedup OPENs per side per bar", group=groupEnv)

infoPingMode = input.string("On Load", "Ready alert cadence",    options=["Off","On Load","Once/Day","On Position Change","Every Bar (debug)"],    group=groupEnv)

envEmoji = useLiveEnv ? "ðŸŸ¢LIVE" : "ðŸ”´DEMO"

// Webhook JSON helpers (Phoenix schema)
f_evt_id_ctx(_action, _ctx, _seq) =>
   _sym = orderContract
   alertTag
     + "|" + (useLiveEnv ? "live" : "demo")
     + "|" + _sym
     + "|" + timeframe.period
     + "|" + _action
     + "|" + _ctx
     + "|" + str.tostring(nz(_seq, 0))
     + "|" + str.tostring(time)
     + "|" + str.tostring(bar_index)

f_json_open(_symbol,_side,_qty,_stop,_tp,_intended,_reason,_tpTF,_phaseTF,_posSeq) =>
   _tpStr = na(_tp) ? "null" : toFixed(_tp)
   _pos   = _side=="BUY" ? "LONG" : "SHORT"
   "{" +
     "\"env\":\"" + (useLiveEnv?"live":"demo") + "\"," +
     "\"apiKey\":\"" + tvApiKey + "\"," +
     "\"note\":\"" + envEmoji + "\"," +
     "\"tag\":\"" + alertTag + "\"," +
     "\"contract\":\"" + _symbol + "\"," +
     "\"action\":\"OPEN\"," +
     "\"side\":\"" + _side + "\"," +
     "\"position\":\"" + _pos + "\"," +
     "\"qty\":" + str.tostring(_qty) + "," +
     "\"stopPrice\":" + toFixed(_stop) + "," +
     "\"takeProfitPrice\":" + _tpStr + "," +
     (str.length(_reason)>0 ? "\"reason\":\"" + str.replace_all(_reason,"\"","'") + "\"," : "") +
     "\"timeInForce\":\"" + tif + "\"," +
     "\"isAutomated\":" + (autoFlag?"true":"false") + "," +
     "\"bar_time\":" + str.tostring(time) + "," +
     "\"bar_index\":" + str.tostring(bar_index) + "," +
     "\"timeframe\":\"" + timeframe.period + "\"," +
     "\"price\":" + toFixed(close) + "," +
     "\"intendedPrice\":" + toFixed(_intended) + "," +
     "\"tpTF\":\"" + _tpTF + "\"," +
     "\"phaseTF\":\"" + _phaseTF + "\"," +
     "\"posSeq\":" + str.tostring(_posSeq) + "," +
     "\"eventId\":\"" + f_evt_id_ctx("OPEN", _side, _posSeq) + "\"}"

f_json_close(_symbol,_side,_qty,_px,_reason,_posSeq) =>
   _pos = _side=="SELL" ? "LONG" : _side=="BUY_TO_COVER" ? "SHORT" : "UNKNOWN"
   "{" +
     "\"env\":\"" + (useLiveEnv?"live":"demo") + "\"," +
     "\"apiKey\":\"" + tvApiKey + "\"," +
     "\"note\":\"" + envEmoji + "\"," +
     "\"tag\":\"" + alertTag + "\"," +
     "\"contract\":\"" + _symbol + "\"," +
     "\"action\":\"CLOSE\"," +
     "\"side\":\"" + _side + "\"," +
     "\"position\":\"" + _pos + "\"," +
     "\"qty\":" + str.tostring(_qty) + "," +
     "\"price\":" + toFixed(_px) + "," +
     "\"reason\":\"" + str.replace_all(_reason,"\"","'") + "\"," +
     "\"timeInForce\":\"" + tif + "\"," +
     "\"isAutomated\":" + (autoFlag?"true":"false") + "," +
     "\"bar_time\":" + str.tostring(time) + "," +
     "\"bar_index\":" + str.tostring(bar_index) + "," +
     "\"timeframe\":\"" + timeframe.period + "\"," +
     "\"posSeq\":" + str.tostring(_posSeq) + "," +
     "\"eventId\":\"" + f_evt_id_ctx("CLOSE", _side, _posSeq) + "\"}"

f_json_amend(_symbol,_what,_newPrice,_posSeq) =>
   "{" +
     "\"env\":\"" + (useLiveEnv?"live":"demo") + "\"," +
     "\"apiKey\":\"" + tvApiKey + "\"," +
     "\"note\":\"" + envEmoji + "\"," +
     "\"tag\":\"" + alertTag + "\"," +
     "\"contract\":\"" + _symbol + "\"," +
     "\"action\":\"AMEND\"," +
     "\"what\":\"" + _what + "\"," +
     "\"newPrice\":" + toFixed(_newPrice) + "," +
     "\"timeInForce\":\"" + tif + "\"," +
     "\"isAutomated\":" + (autoFlag?"true":"false") + "," +
     "\"bar_time\":" + str.tostring(time) + "," +
     "\"bar_index\":" + str.tostring(bar_index) + "," +
     "\"timeframe\":\"" + timeframe.period + "\"," +
     "\"posSeq\":" + str.tostring(_posSeq) + "," +
     "\"eventId\":\"" + f_evt_id_ctx("AMEND", _what, _posSeq) + "\"}"

f_json_info(_t) =>
   "{" +
     "\"env\":\"" + (useLiveEnv?"live":"demo") + "\"," +
     "\"apiKey\":\"" + tvApiKey + "\"," +
     "\"note\":\"" + envEmoji + "\"," +
     "\"tag\":\"" + alertTag + "\"," +
     "\"action\":\"INFO\"," +
     "\"text\":\"" + str.replace_all(_t, "\"", "'") + "\"," +
     "\"eventId\":\"" + f_evt_id_ctx("INFO", "-", 0) + "\"}"

f_send_open(_s,_side,_q,_st,_tp,_int,_why,_tpTF,_phTF,_seq) =>
   var int _lastBuyBar  = na
   var int _lastSellBar = na
   _isBuy       = (_side == "BUY")
   _lastSideBar = _isBuy ? _lastBuyBar : _lastSellBar
   _okThisBar   = not dedupOpenPerBar or na(_lastSideBar) or _lastSideBar != bar_index
   if enableWebhookAlerts and _okThisBar
       alert(f_json_open(_s,_side,_q,_st,_tp,_int,_why,_tpTF,_phTF,_seq), alert.freq_once_per_bar_close)
       if _isBuy
           _lastBuyBar := bar_index
       else
           _lastSellBar := bar_index

f_send_close(_s,_side,_q,_px,_why,_seq) =>
   if enableWebhookAlerts
       alert(f_json_close(_s,_side,_q,_px,_why,_seq), alert.freq_once_per_bar_close)

f_send_amend(_s,_what,_np,_seq) =>
   if enableWebhookAmends
       alert(f_json_amend(_s,_what,_np,_seq), alert.freq_once_per_bar_close)

f_send_info(_t) =>
   if enableInfoAlerts
       alert(f_json_info(_t), alert.freq_once_per_bar_close)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  A1) SESSION & WINDOWS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ============================================================================
//  ENTRY SIDE â€” Inputs & Logic
//  A) Session / Time windows
//  B) Core EMAs / ATR / Sizing
//  C) HTF EMA & SuperTrend (bias + slope)
//  D) Saty Phase (context only)
//  E) Entry Engine (proximity, ATR, ADX, TD, candles, cloud)
//  F) RSI Entry & Divergence Filters
//  G) R:R Gate
// ============================================================================

groupDTF   = "ENTRY: A1) Session & Time Windows"

useDayTimeFilter = input.bool(true, "Enable Day & Time windows (entries only)", group=groupDTF)

tradeMon = input.bool(true,  "Mon", group=groupDTF, inline="dow")
tradeTue = input.bool(true,  "Tue", group=groupDTF, inline="dow")
tradeWed = input.bool(true,  "Wed", group=groupDTF, inline="dow")
tradeThu = input.bool(true,  "Thu", group=groupDTF, inline="dow")
tradeFri = input.bool(true,  "Fri", group=groupDTF, inline="dow")
tradeSat = input.bool(false, "Sat", group=groupDTF, inline="dow")
tradeSun = input.bool(false, "Sun", group=groupDTF, inline="dow")

win1Enable = input.bool(true, "Window 1", group=groupDTF, inline="w1")
win1Sess   = input.session("0630-0900", "", group=groupDTF, inline="w1")
win2Enable = input.bool(true, "Window 2", group=groupDTF, inline="w2")
win2Sess   = input.session("0900-1100", "", group=groupDTF, inline="w2")
win3Enable = input.bool(true, "Window 3", group=groupDTF, inline="w3")
win3Sess   = input.session("1200-1415", "", group=groupDTF, inline="w3")
win4Enable = input.bool(true, "Window 4", group=groupDTF, inline="w4")
win4Sess   = input.session("1500-1600", "", group=groupDTF, inline="w4")
win5Enable = input.bool(false, "Window 5", group=groupDTF, inline="w5")
win5Sess   = input.session("0000-0000", "", group=groupDTF, inline="w5")

sessTZ = input.string("America/New_York", "Session Timezone", group=groupDTF)
_inSess(sess) => not na(time(timeframe.period, sess, sessTZ))

selDays = (tradeMon?1:0)+(tradeTue?1:0)+(tradeWed?1:0)+(tradeThu?1:0)+(tradeFri?1:0)+(tradeSat?1:0)+(tradeSun?1:0)
dow     = dayofweek(time)
dayOK   = selDays==0 ? true :
         (dow==dayofweek.monday    and tradeMon) or
         (dow==dayofweek.tuesday   and tradeTue) or
         (dow==dayofweek.wednesday and tradeWed) or
         (dow==dayofweek.thursday  and tradeThu) or
         (dow==dayofweek.friday    and tradeFri) or
         (dow==dayofweek.saturday  and tradeSat) or
         (dow==dayofweek.sunday    and tradeSun)

selWins = (win1Enable?1:0)+(win2Enable?1:0)+(win3Enable?1:0)+(win4Enable?1:0)+(win5Enable?1:0)
timeOK  = selWins==0 ? true : ((win1Enable and _inSess(win1Sess)) or (win2Enable and _inSess(win2Sess)) or (win3Enable and _inSess(win3Sess)) or (win4Enable and _inSess(win4Sess)) or (win5Enable and _inSess(win5Sess)))

entriesWindowOK = (not useDayTimeFilter) or (dayOK and timeOK)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  B) CORE EMAs, ATR, SIZING (series below in H)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupCore  = "ENTRY: B) Core EMAs & ATR"


emaFastLen  = input.int(4,  "Fast EMA",          group=groupCore)
emaSlowLen  = input.int(48, "Slow EMA",          group=groupCore)
emaMidLen   = input.int(13, "Mid EMA (context)", group=groupCore)
exitEmaLen  = input.int(7,  "Exit EMA (exits)",  group=groupCore)
atrLen      = input.int(14, "ATR Length (core)", group=groupCore)
backtestQty = input.int(10, "Backtest Qty", minval=1, group=groupCore)

// Additional EMA Cross Options
useEma8Cross  = input.bool(false, "Enable 8 EMA / 48 EMA cross", group=groupCore)
useEma13Cross = input.bool(false, "Enable 13 EMA / 48 EMA cross", group=groupCore)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// X1b) RSI(5) Divergence Mirror (ATR Levels v1.9 semantics)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupPhaseRSI   = "â”â” X1b) RSI(5) Divergence Mirror (debug)"
phaseRSI_enable = input.bool(false, "Enable RSI(5) divergence mirror", group=groupPhaseRSI)

// Use EXACT same RSI(5) as ATR Levels â†’ ta.rsi with len=5
rsi5_len   = 5
rsi5_fast  = ta.rsi(close, rsi5_len)

// Divergence window (exactly from ATR Levels / RSI indicator)
int   rsi5_lookbackRight = 5
int   rsi5_lookbackLeft  = 5
int   rsi5_rangeUpper    = 60
int   rsi5_rangeLower    = 5

rsi5_inRange(bool cond) =>
   _bars = ta.barssince(cond)
   rsi5_rangeLower <= _bars and _bars <= rsi5_rangeUpper

// Mirror the ATR Levels divergence state variables
bool  rsi5_plFound   = false
bool  rsi5_phFound   = false
bool  rsi5_bullCond  = false
bool  rsi5_bearCond  = false

float rsi5_rsiLBR = rsi5_fast[rsi5_lookbackRight]

if phaseRSI_enable
   // Regular Bullish: price LL, RSI HL
   rsi5_plFound := not na(ta.pivotlow(rsi5_fast, rsi5_lookbackLeft, rsi5_lookbackRight))
   float lowLBR     = low[rsi5_lookbackRight]
   bool  inRangePL  = rsi5_inRange(rsi5_plFound[1])
   bool  rsi5_HL    = rsi5_rsiLBR > ta.valuewhen(rsi5_plFound, rsi5_rsiLBR, 1) and inRangePL
   bool  priceLL    = lowLBR < ta.valuewhen(rsi5_plFound, lowLBR, 1)
   rsi5_bullCond    := priceLL and rsi5_HL and rsi5_plFound

   // Regular Bearish: price HH, RSI LH
   rsi5_phFound := not na(ta.pivothigh(rsi5_fast, rsi5_lookbackLeft, rsi5_lookbackRight))
   float highLBR    = high[rsi5_lookbackRight]
   bool  inRangePH  = rsi5_inRange(rsi5_phFound[1])
   bool  rsi5_LH    = rsi5_rsiLBR < ta.valuewhen(rsi5_phFound, rsi5_rsiLBR, 1) and inRangePH
   bool  priceHH    = highLBR > ta.valuewhen(rsi5_phFound, highLBR, 1)
   rsi5_bearCond    := priceHH and rsi5_LH and rsi5_phFound



// NOTE: in ATR Levels the emojis are placed on the pivot bar via:
// label.new(bar_index - lookbackRight, ...)
// To mirror that exactly, we use offset = -lookbackRight.

groupSize  = "ENTRY: B1) Position Sizing"


sizingMode   = input.string("Fixed Qty", "Mode", options=["Fixed Qty","% of Equity","Risk per Trade ($)"], group=groupSize)
acctEquity   = input.float(25000.0, "Equity (for calc)", group=groupSize)
minQty       = input.float(1, "Min qty", group=groupSize)
maxQty       = input.float(1000, "Max qty", group=groupSize)
tickValue    = input.float(1.25, "Tick value ($/tick)", group=groupSize)
roundLot     = input.float(1.0, "Round to lot", group=groupSize)
pctOfEquity  = input.float(5.0, "% of equity (notional)", minval=0.0, maxval=100.0, group=groupSize)
riskPerTrade = input.float(125.0, "Risk $", minval=0.0, group=groupSize)
useComputedQtyForWebhook = input.bool(false, "Webhook uses computed qty (else Fixed Qty)", group=groupSize)

f_clamp(x, lo, hi) => math.max(lo, math.min(hi,x))
f_round_to(x, lot) => lot <= 0 ? x : math.round(x / lot) * lot

f_qty_from_pct_equity(_c) =>
   raw = (acctEquity * pctOfEquity * 0.01) / math.max(_c, syminfo.mintick)
   f_clamp(f_round_to(raw, roundLot), minQty, maxQty)

f_qty_from_risk(_e, _s) =>
   _tr = math.abs(_e - _s) / syminfo.mintick
   _tr <= 0 ?
        minQty :
        f_clamp(f_round_to(riskPerTrade / math.max(_tr * tickValue, 1e-9), roundLot), minQty, maxQty)

f_compute_qty(_e,_s) =>
   sizingMode=="Fixed Qty"   ? backtestQty :    sizingMode=="% of Equity" ? f_qty_from_pct_equity(_e) :                                f_qty_from_risk(_e,_s)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  C) TIMEFRAMES, HTF EMA, SUPERTREND
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupTF    = "ENTRY: C) Timeframes & HTF Context"


useHTFRouting = input.bool(true, "Use LTF for entries (vs chart)", group=groupTF)
ltfTF         = input.string("3", "LTF (entries)", options=["1","3","5"], group=groupTF)
tpCalcTF      = input.string("D", "TP / context TF", options=["3","5","10","15","30","60","240","540","D"], group=groupTF)

// HTF EMA Bias
groupHTFEMA= "ENTRY: C1) HTF EMA Bias"


htfEMA_Enable         = input.bool(true,  "Enable HTF EMA bias", group=groupHTFEMA)
htfEMA_TF             = input.string("10", "HTF TF", options=["Chart","1","2","3","5","10","15","30","60","240","540","D"], group=groupHTFEMA)
htfEMA_Len            = input.int(8, "HTF EMA length", minval=1, group=groupHTFEMA)
htfEMA_Mode           = input.string("Long above / Short below", "Rule", options=["Long above / Short below","Long below / Short above"], group=groupHTFEMA)
htfEMA_ApplyToEntries = input.bool(true, "Apply as entry bias gate", group=groupHTFEMA)

htfEMA_val  = htfEMA_Enable ? sec(htfEMA_TF, ta.ema(close, htfEMA_Len)) : na
htfClose    = htfEMA_Enable ? sec(htfEMA_TF, close)                      : na
htfReady    = htfEMA_Enable and not na(htfEMA_val) and not na(htfClose)
htfAbove    = htfReady and (htfClose >= htfEMA_val)
htfBelow    = htfReady and (htfClose <= htfEMA_val)

htfLongOK_raw  = (not htfEMA_Enable) or (not htfReady) or (htfEMA_Mode=="Long above / Short below" ? htfAbove : htfBelow)
htfShortOK_raw = (not htfEMA_Enable) or (not htfReady) or (htfEMA_Mode=="Long above / Short below" ? htfBelow : htfAbove)

htfBiasPersistBars = input.int(1, "HTF bias must persist â‰¥ N bars", minval=0, group=groupHTFEMA)
var int _htfAboveCnt = 0
var int _htfBelowCnt = 0
_htfAboveCnt := htfAbove ? nz(_htfAboveCnt[1]) + 1 : 0
_htfBelowCnt := htfBelow ? nz(_htfBelowCnt[1]) + 1 : 0

htfPersistLongOK  = (not htfEMA_ApplyToEntries) or (htfEMA_Mode=="Long above / Short below" ? (_htfAboveCnt >= htfBiasPersistBars) : (_htfBelowCnt >= htfBiasPersistBars))
htfPersistShortOK = (not htfEMA_ApplyToEntries) or (htfEMA_Mode=="Long above / Short below" ? (_htfBelowCnt >= htfBiasPersistBars) : (_htfAboveCnt >= htfBiasPersistBars))

// SuperTrend
groupST    = "ENTRY: C2) SuperTrend Bias"

stAtrPeriod = input.int(10,  "ATR Length", minval=1, group=groupST)
stFactor    = input.float(3, "Factor",     minval=0.01, step=0.01, group=groupST)

[stLine_raw, stDir_raw] = ta.supertrend(stFactor, stAtrPeriod)
stLine = barstate.isfirst ? na : stLine_raw
stUpTrend   = stDir_raw < 0
stDownTrend = stDir_raw > 0
stNotFlat   = not na(stLine) and stLine != nz(stLine[1])

stBiasLong  = stUpTrend
stBiasShort = stDownTrend
useSTEntryBias = input.bool(false, "Use ST bias as entry gate", group=groupST)


stSlopeUp   = not na(stLine) and stLine > nz(stLine[1])
stSlopeDown = not na(stLine) and stLine < nz(stLine[1])

stSupportLong  = stSlopeUp   and close > stLine
stSupportShort = stSlopeDown and close < stLine

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  C3) MTF SuperTrend Gates (Entries)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupMTFst    = "ENTRY: E7) MTF SuperTrend Gates"
// Simple helper: ST direction on a given TF using ta.supertrend
f_st_dir_series(_factor, _atrLen) =>
   [_, dir] = ta.supertrend(_factor, _atrLen)
   dir

f_st_dir_tf(string tf, float factor, int atrLen) =>
   request.security(
        syminfo.tickerid,
        tf,
        f_st_dir_series(factor, atrLen),
        barmerge.gaps_off,
        barmerge.lookahead_off)

// ST line on a given TF (for slope/non-flat checks)
f_st_line_series(_factor, _atrLen) =>
   [line, _] = ta.supertrend(_factor, _atrLen)
   line

f_st_line_tf(string tf, float factor, int atrLen) =>
   request.security(
        syminfo.tickerid,
        tf,
        f_st_line_series(factor, atrLen),
        barmerge.gaps_off,
        barmerge.lookahead_off)

// --- Inputs (default to 10/3 like your core ST) ---
mtfST_use_1m   = input.bool(true, "Use 1m ST gate",  group=groupMTFst, inline="1m")
mtfST_use_10m  = input.bool(false, "Use 10m ST gate", group=groupMTFst, inline="10m")
mtfST_agg_mode = input.string("All", "Aggregation", options=["Any","All"], group=groupMTFst)

mtfST_1m_hardGate = input.bool(true, "1m ST: HARD gate requires slope+nonflat", group=groupMTFst)

// V2: Flat Tolerance - allow 1m ST to be flat for N bars after directional flip
mtfST_1m_flatTolerance = input.int(3, "1m ST: max flat bars after flip", minval=0, maxval=10, group=groupMTFst,
   tooltip="After 1m ST flips to correct direction, allow it to be flat for up to N bars. 0=no tolerance (strict). 3=allows consolidation after flip.")

// 1m ST params + slope criteria
mtfST_1m_atr   = input.int(10, "1m ATR", minval=1, group=groupMTFst, inline="1mP")
mtfST_1m_fac   = input.float(3.0, "1m Factor", step=0.1, group=groupMTFst, inline="1mP")

mtfST_1m_useSlope   = input.bool(true,  "1m: require slope/non-flat", group=groupMTFst, inline="1mS")
mtfST_1m_minSlopeTk = input.int(8,     "min slope ticks",             group=groupMTFst, inline="1mS")
mtfST_1m_minBars    = input.int(1,     "bars â‰¥", minval=1,            group=groupMTFst, inline="1mS")

// 10m ST (direction only for now)
mtfST_10m_atr  = input.int(10, "10m ATR", minval=1, group=groupMTFst, inline="10mP")
mtfST_10m_fac  = input.float(3.0, "10m Factor", step=0.1, group=groupMTFst, inline="10mP")

// Fetch directions
mtfST_1m_dir  = mtfST_use_1m  ? f_st_dir_tf("1",  mtfST_1m_fac,  mtfST_1m_atr)  : na
mtfST_10m_dir = mtfST_use_10m ? f_st_dir_tf("10", mtfST_10m_fac, mtfST_10m_atr) : na

// Fetch 1m ST line for slope / non-flat checks
mtfST_1m_line = mtfST_use_1m ? f_st_line_tf("1", mtfST_1m_fac, mtfST_1m_atr) : na

// 1m ST non-flat + slope in ticks/bar
mtfST_1m_notFlat = not mtfST_use_1m or (not na(mtfST_1m_line) and mtfST_1m_line != nz(mtfST_1m_line[1]))
mtfST_1m_slopeTk = mtfST_use_1m and not na(mtfST_1m_line) and not na(mtfST_1m_line[1]) ?
                  (mtfST_1m_line - mtfST_1m_line[1]) / syminfo.mintick : 0.0

// 1m ST slope run-length (up / down)
var int mtfST_1m_upRun = 0
var int mtfST_1m_dnRun = 0
mtfST_1m_upRun := mtfST_use_1m and mtfST_1m_slopeTk >  mtfST_1m_minSlopeTk ? nz(mtfST_1m_upRun[1]) + 1 : 0
mtfST_1m_dnRun := mtfST_use_1m and mtfST_1m_slopeTk < -mtfST_1m_minSlopeTk ? nz(mtfST_1m_dnRun[1]) + 1 : 0

mtfST_1m_strongUp   = not mtfST_use_1m or not mtfST_1m_useSlope or (mtfST_1m_upRun >= mtfST_1m_minBars)
mtfST_1m_strongDown = not mtfST_use_1m or not mtfST_1m_useSlope or (mtfST_1m_dnRun >= mtfST_1m_minBars)

// V2: Track flat bars after directional flip (for flat tolerance)
var int mtfST_1m_flatBarsLong = 0   // Consecutive flat bars while directionally correct (down for longs)
var int mtfST_1m_flatBarsShort = 0  // Consecutive flat bars while directionally correct (up for shorts)

// Reset flat counter if ST slopes OR changes direction
if mtfST_use_1m
   // For LONG (need ST dir < 0, i.e. uptrend)
   if mtfST_1m_dir < 0
       // Directionally correct
       if mtfST_1m_notFlat
           mtfST_1m_flatBarsLong := 0  // Reset: ST is moving
       else
           mtfST_1m_flatBarsLong := nz(mtfST_1m_flatBarsLong[1]) + 1  // Increment: ST is flat
   else
       mtfST_1m_flatBarsLong := 0  // Wrong direction: reset

   // For SHORT (need ST dir > 0, i.e. downtrend)
   if mtfST_1m_dir > 0
       // Directionally correct
       if mtfST_1m_notFlat
           mtfST_1m_flatBarsShort := 0  // Reset: ST is moving
       else
           mtfST_1m_flatBarsShort := nz(mtfST_1m_flatBarsShort[1]) + 1  // Increment: ST is flat
   else
       mtfST_1m_flatBarsShort := 0  // Wrong direction: reset

// Apply flat tolerance: allow entry if flat but within tolerance window
mtfST_1m_flatOK_Long = not mtfST_use_1m or mtfST_1m_notFlat or (mtfST_1m_flatBarsLong <= mtfST_1m_flatTolerance)
mtfST_1m_flatOK_Short = not mtfST_use_1m or mtfST_1m_notFlat or (mtfST_1m_flatBarsShort <= mtfST_1m_flatTolerance)

// Longs want 1m uptrend + slope (or flat tolerance)
mtfST_1m_up = not mtfST_use_1m or (mtfST_1m_dir < 0 and mtfST_1m_flatOK_Long and mtfST_1m_strongUp)
mtfST_1m_dn = not mtfST_use_1m or (mtfST_1m_dir > 0 and mtfST_1m_flatOK_Short and mtfST_1m_strongDown)

// 10m ST: simple directional bias (no slope for now)
mtfST_10m_up = not mtfST_use_10m or (mtfST_10m_dir < 0)
mtfST_10m_dn = not mtfST_use_10m or (mtfST_10m_dir > 0)

mtfST_1m_gateLong  = not mtfST_use_1m or (mtfST_1m_dir < 0 and mtfST_1m_flatOK_Long and mtfST_1m_strongUp)
mtfST_1m_gateShort = not mtfST_use_1m or (mtfST_1m_dir > 0 and mtfST_1m_flatOK_Short and mtfST_1m_strongDown)

mtfST_1m_gateLong_final  = not mtfST_1m_hardGate ? (not mtfST_use_1m or (mtfST_1m_dir < 0)) : mtfST_1m_gateLong
mtfST_1m_gateShort_final = not mtfST_1m_hardGate ? (not mtfST_use_1m or (mtfST_1m_dir > 0)) : mtfST_1m_gateShort

// Aggregate: "All" = all enabled TFs must agree, "Any" = at least one
mtfLongOK =
    (not mtfST_use_1m and not mtfST_use_10m) ? true :
    mtfST_agg_mode=="All"
        ? (mtfST_1m_up  and mtfST_10m_up)
        : (mtfST_1m_up  or  mtfST_10m_up)

mtfShortOK =
    (not mtfST_use_1m and not mtfST_use_10m) ? true :
    mtfST_agg_mode=="All"
        ? (mtfST_1m_dn  and mtfST_10m_dn)
        : (mtfST_1m_dn  or  mtfST_10m_dn)



// SuperTrend slope strength filter (entries)
useSTSlopeEntryFilter = input.bool(true, "Use ST slope for entries", group=groupST)
stSlopeMinTicks       = input.int(4, "Min ST slope (ticks/bar)", minval=0, group=groupST)
stSlopeBarsNeeded     = input.int(1, "ST slope bars (â‰¥)", minval=1, group=groupST)

// Per-bar raw slope in ticks
stSlopeTicks = na(stLine) or na(stLine[1]) ? 0.0 : (stLine - stLine[1]) / syminfo.mintick

// Run-length of strong up/down slope
var int stSlopeUpRun  = 0
var int stSlopeDownRun = 0
stSlopeUpRun  := stSlopeTicks >  stSlopeMinTicks  ? nz(stSlopeUpRun[1])  + 1 : 0
stSlopeDownRun:= stSlopeTicks < -stSlopeMinTicks  ? nz(stSlopeDownRun[1]) + 1 : 0

// â€œStrongâ€ slope conditions for entries
stStrongUp   = (not useSTSlopeEntryFilter) or (stSlopeUpRun  >= stSlopeBarsNeeded)
stStrongDown = (not useSTSlopeEntryFilter) or (stSlopeDownRun >= stSlopeBarsNeeded)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  D) SATY PIVOT RIBBON (PHASE & COMPRESSION)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupSaty  = "ENTRY: D) Saty Pivot Oscillator (Context/Exits)"

_saty_pivot(tf) => request.security(syminfo.tickerid, tfStr(tf), ta.ema(close, 21), barmerge.gaps_off, barmerge.lookahead_off)
_saty_atr14(tf) => request.security(syminfo.tickerid, tfStr(tf), ta.atr(14),        barmerge.gaps_off, barmerge.lookahead_off)

_saty_raw(tf) =>
   _p = _saty_pivot(tf), _a = _saty_atr14(tf)
   _a == 0 ? 0.0 : ((close - _p) / (3.0 * _a)) * 100.0

_saty_osc(tf) =>
   request.security(syminfo.tickerid, tfStr(tf), ta.ema(_saty_raw(tf), 3), barmerge.gaps_off, barmerge.lookahead_off)

_saty_compressed(tf) =>
   _pivot = _saty_pivot(tf)
   _a     = _saty_atr14(tf)
   _bbo   = request.security(syminfo.tickerid, tfStr(tf), 2.0 * ta.stdev(close, 21), barmerge.gaps_off, barmerge.lookahead_off)
   _bup   = _pivot + _bbo
   _bdn   = _pivot - _bbo
   _ctUp  = _pivot + (2.0 * _a)
   _ctDn  = _pivot - (2.0 * _a)
   _exUp  = _pivot + (1.854 * _a)
   _exDn  = _pivot - (1.854 * _a)
   _above = close >= _pivot
   _compression     = _above ? (_bup - _ctUp) : (_ctDn - _bdn)
   _inExpansionZone = _above ? (_bup - _exUp) : (_exDn - _bdn)
   _expanding       = request.security(syminfo.tickerid, tfStr(tf), nz(_compression[1]) <= _compression, barmerge.gaps_off, barmerge.lookahead_off)
   not (_expanding and _inExpansionZone > 0) and _compression <= 0

phaseTF_select = input.string("3", "Phase TF (exits)", options=["Chart","1","3","5","10","15","30","60","240","540","D"], group=groupSaty)
phaseTF  = tfStr(phaseTF_select)
satyOsc  = _saty_osc(phaseTF)
isCompressed = _saty_compressed(phaseTF)

comp_chart = _saty_compressed(tfStr("Chart"))
comp_1m    = _saty_compressed("1")
comp_3m    = _saty_compressed("3")
// Exact Saty Phase Oscillator on chart TF (matches ATR Levels v1.9)
po_pivot_chart = ta.ema(close, 21)
po_atr_chart   = ta.atr(14)
po_raw_chart   = ((close - po_pivot_chart) / (3.0 * po_atr_chart)) * 100.0
satyOsc_chart  = ta.ema(po_raw_chart, 3)



// â”€â”€ Phase-leave events (chart TF, matches ATR Levels v1.9 PO dots)
phaseExitLongAbs  = input.float(61.8,"Phase Exit |phase| (+)",step=0.1,minval=0.0,group=groupSaty)
phaseExitShortAbs = input.float(61.8,"Phase Exit |phase| (-)",step=0.1,minval=0.0,group=groupSaty)

// "Leaving distribution / accumulation" flags (used for arming exits)
leaving_distribution = nz(satyOsc_chart[1]) >=  phaseExitLongAbs  and satyOsc_chart <  phaseExitLongAbs     // longs
leaving_accumulation = nz(satyOsc_chart[1]) <= -phaseExitShortAbs and satyOsc_chart > -phaseExitShortAbs    // shorts

// Extra: leaving Â±100 (extreme Phase bands)
leaving_extreme_up   = nz(satyOsc_chart[1]) >= 100  and satyOsc_chart < 100
leaving_extreme_down = nz(satyOsc_chart[1]) <= -100 and satyOsc_chart > -100

// Phase "dot" events (either 61.8 or 100 band leave)
phaseDotLong  = leaving_distribution or leaving_extreme_up      // longs: coming off +61.8/+100
phaseDotShort = leaving_accumulation or leaving_extreme_down    // shorts: coming off -61.8/-100

groupAddOns = "ENTRY: E8) Optional Add-Ons (Base)"

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  STRUCTURE VALIDATION â€” Enhanced Entry Quality Checks
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupStructure = "ENTRY: E9) Structure Validation"
useStructureCheck = input.bool(true, "Enable structure validation", group=groupStructure)
requirePhaseDotPrior = input.bool(true, "Require Phase dot prior to cross", group=groupStructure)
phaseDotLookbackBars = input.int(65, "Phase dot lookback bars", minval=1, maxval=200, group=groupStructure)
require1mSTSupport = input.bool(false, "Require 1m ST supportive", group=groupStructure)
require1mSTSlope = input.bool(false, "Require 1m ST sloping by X ticks", group=groupStructure)
require1mSTSlopeTicks = input.int(4, "1m ST min slope (ticks/bar)", minval=0, group=groupStructure)
require1mSTSlopeBars = input.int(1, "1m ST slope bars (â‰¥)", minval=1, group=groupStructure)
require3mSTSupport = input.bool(true, "Require 3m ST supportive", group=groupStructure)
require3mSTSlope = input.bool(false, "Require 3m ST sloping by X ticks", group=groupStructure)
require3mSTSlopeTicks = input.int(4, "3m ST min slope (ticks/bar)", minval=0, group=groupStructure)
require3mSTSlopeBars = input.int(1, "3m ST slope bars (â‰¥)", minval=1, group=groupStructure)
requireTD9 = input.bool(false, "Require recent TD9 prior to cross", group=groupStructure)
td9LookbackBars = input.int(30, "TD9 lookback bars", minval=1, maxval=200, group=groupStructure)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Add-On #5: Last Phase Dot Bias (apply separately to Base/Late)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useLastDotBias_Base  = input.bool(true, "Add-On #5a: Last-dot bias (BASE entries)", group=groupAddOns)
useLastDotBias_Late  = input.bool(false, "Add-On #5b: Last-dot bias (LATE entries)", group=groupAddOns)
lastDotExpiryBars    = input.int(30, "Last-dot expires after N bars (0=never)", minval=0, maxval=2000, group=groupAddOns)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Add-On #6: LTF Score Validation (Base & Late entries)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useLTFScoreValidation = input.bool(false, "Add-On #6: LTF Score validation", group=groupAddOns)
ltfScoreNearZeroThreshold = input.float(8.0, "Near-zero threshold (Â±points)", step=0.5, minval=0.0, maxval=30.0, group=groupAddOns, tooltip="Score within this range of 0 is considered 'near zero' (neutral/breakout zone)")
ltfScoreRequireCrossForLong = input.bool(false, "Longs: Require cross above 0 (strict)", group=groupAddOns, tooltip="If enabled, longs require score to cross above 0. If disabled, score > 0 or near zero is acceptable.")
ltfScoreRequireCrossForShort = input.bool(false, "Shorts: Require cross below 0 (strict)", group=groupAddOns, tooltip="If enabled, shorts require score to cross below 0. If disabled, score < 0 or near zero is acceptable.")
ltfScoreAllowExhaustion = input.bool(true, "Allow exhaustion signals (slope-based)", group=groupAddOns, tooltip="If enabled: Shorts allowed when score declining above threshold (long exhaustion). Longs allowed when score rising below -threshold (short exhaustion).")

// Golden Gate settings (matching TimedTrading_Lab)
useGoldenGate = input.bool(true, "Include Golden Gate in LTF score", group=groupAddOns)
ggATRmult = input.float(0.382, "GG ATR mult (PC Â± mult*ATRd)", group=groupAddOns, step=0.001)
ggDistanceMode = input.bool(true, "Distance-based GG (vs binary cross)", group=groupAddOns)
momLen_ltf = input.int(20, "Momentum len (linreg)", group=groupAddOns, minval=5)
sqLen_ltf = input.int(20, "Squeeze length", group=groupAddOns, minval=5)
ttBbMult = input.float(2.0, "TT Lab: BB stdev mult (Squeeze)", group=groupAddOns, step=0.1, minval=0.1)
ttKcMult = input.float(1.5, "TT Lab: KC ATR mult (Squeeze)", group=groupAddOns, step=0.1, minval=0.1)
ttUseSessionAwareLTFWeights = input.bool(true, "TT Lab: Session-aware LTF weights", group=groupAddOns, tooltip="Matches TimedTrading_Lab. During RTH (9-16 ET), adjusts LTF weights (30m up, 3m down) then re-normalizes.")
ttUseAssetAdaptiveLTF = input.bool(true, "TT Lab: Asset-adaptive LTF timeframes", group=groupAddOns, tooltip="Matches TimedTrading_Lab intent. If enabled, will auto-select 30/10/3 for futures and 60/15/5 for non-futures.")
ttLtfTf30 = input.string("30", "TT Lab LTF #1 TF", group=groupAddOns)
ttLtfTf10 = input.string("10", "TT Lab LTF #2 TF", group=groupAddOns)
ttLtfTf3  = input.string("3",  "TT Lab LTF #3 TF", group=groupAddOns)
ttW30 = input.float(0.60, "TT Lab LTF 30m base weight", group=groupAddOns, minval=0, maxval=1)
ttW10 = input.float(0.30, "TT Lab LTF 10m base weight", group=groupAddOns, minval=0, maxval=1)
ttW3  = input.float(0.10, "TT Lab LTF 3m base weight",  group=groupAddOns, minval=0, maxval=1)
ttStLen = input.int(10, "TT Lab ST ATR Length", group=groupAddOns, minval=1)
ttStFac = input.float(3.0, "TT Lab ST Factor", group=groupAddOns, minval=0.1, step=0.1)

// Helper function for prevBoolSeries (matching TimedTrading_Lab)
prevBoolSeries_ltf(b) => bar_index > 0 ? b[1] : false

// TimedTrading_Lab helpers (session + asset detection)
tt_is_crypto() =>
   ticker = syminfo.ticker
   str.contains(ticker, "USD") or str.contains(ticker, "USDT") or str.contains(ticker, "BTC") or str.contains(ticker, "ETH")
tt_is_futures() =>
   str.contains(syminfo.ticker, "1!")
tt_is_forex() =>
   str.contains(syminfo.ticker, "DXY") or str.contains(syminfo.ticker, "EUR") or str.contains(syminfo.ticker, "GBP")
tt_is_rth() =>
   hour(time, "America/New_York") >= 9 and hour(time, "America/New_York") < 16

tt_pick_ltf_tfs() =>
   if not ttUseAssetAdaptiveLTF
       [ttLtfTf30, ttLtfTf10, ttLtfTf3]
   else if tt_is_futures()
       ["30", "10", "3"]
   else
       // Default mapping for non-futures (crypto/forex/equities)
       ["60", "15", "5"]

tt_session_adjusted_ltf_weights(w30_base, w10_base, w3_base) =>
   if not ttUseSessionAwareLTFWeights or not tt_is_rth()
       [w30_base, w10_base, w3_base]
   else
       // RTH: favor 30m, reduce 3m (TimedTrading_Lab default)
       w30_adj = w30_base * 1.15
       w10_adj = w10_base * 1.0
       w3_adj  = w3_base  * 0.7
       total = w30_adj + w10_adj + w3_adj
       if total > 0
           [w30_adj / total, w10_adj / total, w3_adj / total]
       else
           [w30_base, w10_base, w3_base]

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Track last Phase dot direction
//  lastDotDir = +1 â†’ last dot was TOP (phaseDotLong)   â†’ Shorts favored
//  lastDotDir = -1 â†’ last dot was BOTTOM (phaseDotShort) â†’ Longs favored
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var int lastDotDir = 0
var int lastDotBar = na

if phaseDotLong
   lastDotDir := 1
   lastDotBar := bar_index
if phaseDotShort
   lastDotDir := -1
   lastDotBar := bar_index



dotFresh = (lastDotExpiryBars <= 0) ? true : (not na(lastDotBar) and (bar_index - lastDotBar <= lastDotExpiryBars))

// Directional permissions (BASE)
lastDotOK_Long_Base  = (not useLastDotBias_Base) or (lastDotDir == 0) or (not dotFresh) or (lastDotDir == -1)
lastDotOK_Short_Base = (not useLastDotBias_Base) or (lastDotDir == 0) or (not dotFresh) or (lastDotDir ==  1)

// Directional permissions (LATE)
lastDotOK_Long_Late  = (not useLastDotBias_Late) or (lastDotDir == 0) or (not dotFresh) or (lastDotDir == -1)
lastDotOK_Short_Late = (not useLastDotBias_Late) or (lastDotDir == 0) or (not dotFresh) or (lastDotDir ==  1)




// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  E) ENTRY ENGINE â€” TRIGGERS & FILTERS (SIMPLE PHOENIX v1 LOGIC)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupEntry = "ENTRY: E) Triggers & Filters"

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  E0a) Impulse Bar (Displacement) Entry Block
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupImpulse = "ENTRY: E0a) Impulse Bar Block"

impulseBlockEnable   = input.bool(false,  "Block entries on impulse bars", group=groupImpulse)
impulseAtrMult       = input.float(1.6, "Range â‰¥ ATR Ã—", step=0.1, group=groupImpulse)
impulseBodyTicksMin  = input.int(0,      "Body â‰¥ ticks (0=off)", minval=0, group=groupImpulse)
impulseLookbackBars  = input.int(1,      "Also block if impulse within last N bars", minval=0, maxval=10, group=groupImpulse)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  E0) ARMED ENTRY WINDOW (Cross â†’ Arm â†’ Wait for confirmation)
//      + Optional EMA reclaim requirement
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupArm = "ENTRY: E0) Armed Entry Window"

useArmWindow      = input.bool(true, "Use armed entry window (after cross)", group=groupArm)
armBars           = input.int(1, "Arm lasts N bars", minval=1, group=groupArm)

// Optional: require reclaim of a chosen EMA before entry
// Optional: require reclaim of a chosen EMA before entry
armUseEmaReclaim  = input.bool(true, "Require EMA reclaim (base + late)", group=groupArm)
armEmaSrc         = input.string("Custom", "Reclaim EMA", options=["EMA21","EMA13","EMA8","EMA5","Custom"], group=groupArm)
armEmaLenCustom   = input.int(5, "Custom EMA len", minval=1, group=groupArm)

useProximityToEMA = input.bool(false,"Proximity-to-EMA (chase guard)",group=groupEntry)
proxAnchor        = input.string("Custom","Prox anchor",options=["Exit","Fast","Custom"],group=groupEntry)
proxCustomLen     = input.int(3,"Custom EMA length",minval=1,group=groupEntry)
proxMaxTicks      = input.int(16,"Max ticks from EMA",minval=0,group=groupEntry)

useNClosesBeyondEMA = input.bool(false,"Require N closes beyond EMA",group=groupEntry)
beyondEMA_len       = input.int(8,"Beyond EMA length",minval=1,group=groupEntry)
beyondEMA_consecN   = input.int(1,"Consecutive closes",minval=0,group=groupEntry)
beyondEMA_tolTicks  = input.int(6,"Tolerance ticks",minval=0,group=groupEntry)

useCooldown  = input.bool(false, "Cooldown after exit (bars)", group=groupEntry)
cooldownBars = input.int(1, "Cooldown bars", minval=1, group=groupEntry)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Post-Abort Cooldown (surgical)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useAbortCooldown     = input.bool(true, "After EARLY_PHASE_DOT_ABORT: cooldown", group=groupAddOns)
abortCooldownBars    = input.int(5, "Abort cooldown bars", minval=0, maxval=100, group=groupAddOns)
abortCooldownLateOnly= input.bool(true, "Abort cooldown applies to LATE only", group=groupAddOns)


// â”€â”€ Directional cooldown state (supports flips)
var int lastExitBarL = na
var int lastExitBarS = na

var int lastAbortBar = na
abortCooldownOK = not useAbortCooldown or na(lastAbortBar) or (bar_index - lastAbortBar > abortCooldownBars)

closedThisBar = barstate.isconfirmed and (strategy.closedtrades > nz(strategy.closedtrades[1]))
if closedThisBar
   int _i = strategy.closedtrades - 1
   float _sz = strategy.closedtrades.size(_i)  // >0 long, <0 short
   if _sz > 0
       lastExitBarL := bar_index
   if _sz < 0
       lastExitBarS := bar_index

// Flip intent (allows flip even if a trade closed this bar)
flipToLong  = barstate.isconfirmed and (strategy.position_size < 0)
flipToShort = barstate.isconfirmed and (strategy.position_size > 0)

// Cooldown gates per direction
cooldownLongOK =
    (not useCooldown) ? true :
    (flipToLong) ? true :
    (not closedThisBar) and (na(lastExitBarL) or (bar_index - lastExitBarL >= cooldownBars))

cooldownShortOK =
    (not useCooldown) ? true :
    (flipToShort) ? true :
    (not closedThisBar) and (na(lastExitBarS) or (bar_index - lastExitBarS >= cooldownBars))

useChaseGuard      = input.bool(false,  "Chase Guard",group=groupEntry)
maxChaseTicksFromX = input.int (25, "Max ticks from cross price",minval=1,group=groupEntry)
maxChaseBarsFromX  = input.int (5,  "Only within N bars of cross",minval=1,group=groupEntry)

// ADX/Chop/ATR
groupEntryADX = "ENTRY: E1) ADX / Chop / ATR"

useADXStrength   = input.bool(false,"ADX filter",group=groupEntryADX)
adxLen           = input.int(10,"ADX length",group=groupEntryADX)
adxSmoothing     = input.int(9,"ADX smoothing",group=groupEntryADX)
adxMin           = input.float(16.0,"ADX min",step=0.5,group=groupEntryADX)
adxRiseBars      = input.int(1,"ADX rising bars (â‰¥)",minval=0,group=groupEntryADX)

useChopCounter   = input.bool(false,"Chop counter",group=groupEntryADX)
chopLookbackBars = input.int(15,"Chop lookback",minval=5,group=groupEntryADX)
chopMaxCrosses   = input.int(3,"Max FS crosses in window",minval=0,group=groupEntryADX)

useATRfloor   = input.bool(true,"ATR floor (Base)",group=groupEntryADX)
atrFloorTicks = input.int(10,"ATR floor ticks (Base)",minval=0,group=groupEntryADX)
atrFloorMode  = input.string("Adaptive","ATR floor mode",options=["Hard","Soft (waive if ADX strong)","Adaptive"],group=groupEntryADX)
atrAdaptiveLB = input.int(300,"Adaptive lookback (bars)",minval=10,group=groupEntryADX)
atrAdaptivePct= input.float(0.8,"Adaptive pct of mean",step=0.05,minval=0.1,maxval=1.5,group=groupEntryADX)

// Late Entry ATR floor (separate from base)
useATRfloorLate   = input.bool(true,"ATR floor (Late Entry)",group=groupEntryADX,
   tooltip="Enable ATR floor check for late entries. Can be set independently from base entries.")
atrFloorTicksLate = input.int(5,"ATR floor ticks (Late)",minval=0,group=groupEntryADX,
   tooltip="Minimum ATR for late entries. Often lower than base since structure already confirmed. Set to 0 to allow any volatility.")

// TD Entry gating
groupTDEntry  = "ENTRY: E2) TD Prep / Lead-Up Gates"
tdxGateEntries       = input.bool(true,  "Gate entries near TD Prep", group=groupTDEntry)
tdxPrepBlockWindow   = input.int (2,     "Block if within N of Prep len", minval=0, group=groupTDEntry)
tdxGateLeadEntries   = input.bool(false,  "Gate entries near TD Lead-Up", group=groupTDEntry)
tdxLeadBlockWindow   = input.int (2,     "Block if within N of Lead-Up len", minval=0, group=groupTDEntry)
tdxPrepLen           = input.int(9,  "Prep length",minval=2,group=groupTDEntry)
tdxPrepCompare       = input.int(15, "Prep compare offset",minval=1,group=groupTDEntry)
tdxLeadLen           = input.int(13, "Lead-Up length",minval=2,group=groupTDEntry)
tdxLeadCompare       = input.int(10, "Lead-Up compare offset",minval=1,group=groupTDEntry)

// Candle context & cloud
groupCandleCtx= "ENTRY: E3) Candle Context & Cloud"
useWickBiasFilter = input.bool(false,"Wick-bias veto",group=groupCandleCtx)
wickBiasBodyMult  = input.float(1.0,"Min wick>body Ã—",step=0.1,minval=0.5,group=groupCandleCtx)
requireBearishForShort = input.bool(false, "Shorts require bearish", group=groupCandleCtx)
requireBullishForLong  = input.bool(false, "Longs require bullish",  group=groupCandleCtx)
requirePriceSideOfFast = input.bool(false, "Price on correct FS side", group=groupCandleCtx)
cloudEntryMode         = input.string("TrendOnly","Cloud gate (5â€“9â€“21)",options=["Off","TrendOnly"],group=groupCandleCtx)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  E8) OPTIONAL ADD-ONS (Base entries only)
//  1) ST distance filter (avoid structurally late/extended base entries)
//  2) Rejection confirmation (avoid weak acceptance candles)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Add-On #6: Absorption Bubbles veto (opposing direction)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useAbsorbVeto_Base   = input.bool(false, "Add-On #6a: Absorption veto (BASE entries)", group=groupAddOns)
useAbsorbVeto_Late   = input.bool(false, "Add-On #6b: Absorption veto (LATE entries)", group=groupAddOns)
absLimitFactor       = input.float(0.5, "Absorption Threshold (scaledVol â‰¥)", step=0.1, minval=0.1, group=groupAddOns)
absLookbackPeriod    = input.int(100, "Absorption vol stdev lookback", minval=10, group=groupAddOns)
absRecentBars        = input.int(2, "Absorption counts if within last N bars", minval=0, maxval=20, group=groupAddOns)



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Add-On #4a: Phase Level Filter (prevent entries at extremes)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useAddOn_PhaseLevel = input.bool(false, "Add-On #4a: Phase level filter (entry)", group=groupAddOns,
   tooltip="Block entries when Phase at extreme levels (distribution/accumulation zones)")
phaseMaxLong  = input.float(61.8, "Phase max for LONGS", step=0.1, minval=0.0, maxval=200.0, group=groupAddOns,
   tooltip="No longs if Phase > this level (avoid entering in distribution)")
phaseMaxShort = input.float(-61.8, "Phase max for SHORTS", step=0.1, minval=-200.0, maxval=0.0, group=groupAddOns,
   tooltip="No shorts if Phase < this level (avoid entering in accumulation)")

// Phase level gates
phaseLevelOK_Long  = (not useAddOn_PhaseLevel) or (satyOsc_chart <= phaseMaxLong)
phaseLevelOK_Short = (not useAddOn_PhaseLevel) or (satyOsc_chart >= phaseMaxShort)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Add-On #4b: Phase slope veto (Base entries only)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useAddOn_PhaseSlope = input.bool(false, "Add-On #4b: Phase slope veto (entry)", group=groupAddOns)
phaseSlopeBarsEntry = input.int(2, "Phase slope lookback bars", minval=1, maxval=10, group=groupAddOns)

useAddOn_STDistance = input.bool(false, "Add-On #1: ST distance filter", group=groupAddOns)
stDistMode          = input.string("Ticks", "ST distance mode", options=["Ticks","ATRx"], group=groupAddOns)
stDistMaxTicks      = input.int(16, "Max dist from ST (ticks)", minval=1, group=groupAddOns)
stDistMaxATRx       = input.float(0.8, "Max dist from ST (Ã—ATR)", minval=0.1, step=0.05, group=groupAddOns)

useAddOn_Rejection  = input.bool(false, "Add-On #2: Rejection confirm", group=groupAddOns)
rejMode             = input.string("Wick", "Rejection mode", options=["Wick","EMA Reclaim","Either"], group=groupAddOns)
rejWickBodyMult     = input.float(1.2, "Wick â‰¥ Body Ã—", minval=0.5, step=0.1, group=groupAddOns)
rejEmaSrc           = input.string("EMA8", "Reclaim EMA", options=["EMA8","EMA13","EMA21"], group=groupAddOns)
rejNeedBullCloseL   = input.bool(false, "Long: require bullish close", group=groupAddOns)
rejNeedBearCloseS   = input.bool(false, "Short: require bearish close", group=groupAddOns)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Add-On #4 logic: Phase slope veto
//  - Block LONG if Phase is falling
//  - Block SHORT if Phase is rising
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
phaseSlopeDown_entry = ta.falling(satyOsc_chart, phaseSlopeBarsEntry)
phaseSlopeUp_entry   = ta.rising (satyOsc_chart, phaseSlopeBarsEntry)

phaseEntryOK_Long  = (not useAddOn_PhaseSlope) or (not phaseSlopeDown_entry)
phaseEntryOK_Short = (not useAddOn_PhaseSlope) or (not phaseSlopeUp_entry)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Add-On #3: PDZ proximity veto (Base entries only)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useAddOn_PDZProx     = input.bool(false, "Add-On #3: PDZ proximity veto", group=groupAddOns)
pdzProxTicks         = input.int(8, "PDZ proximity buffer (ticks)", minval=0, group=groupAddOns)
pdzProxMode          = input.string("Block inside+near", "PDZ veto mode", options=["Block inside only","Block inside+near"], group=groupAddOns)

// Optional: only apply when PDZ is on the â€œprofit-takingâ€ side
pdzProxOnlyProfitSide = input.bool(true, "Only when PDZ is profit-side", group=groupAddOns)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  E4) RSI Entry Filter (independent of exit RSI)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupRsiEntry = "ENTRY: E4) RSI Entry Filter"

useRsiEntryFilter = input.bool(false, "Gate entries by RSI zone", group=groupRsiEntry)
rsiEntryTF        = input.string("Chart", "RSI TF", options = ["Chart","1","3","5","10","15","60","D"], group=groupRsiEntry)
rsiEntryLen       = input.int(5, "RSI length", minval=2, group=groupRsiEntry)

// Longs: only when RSI is between these
rsiEntryLongMin   = input.float(15.0, "Long: RSI â‰¥", step=0.1, group=groupRsiEntry)
rsiEntryLongMax   = input.float(80.0, "Long: RSI â‰¤", step=0.1, group=groupRsiEntry)

// Shorts: only when RSI is between these
rsiEntryShortMin  = input.float(20.0, "Short: RSI â‰¥", step=0.1, group=groupRsiEntry)
rsiEntryShortMax  = input.float(85.0, "Short: RSI â‰¤", step=0.1, group=groupRsiEntry)

rsiEntry = rsi_on_tf(rsiEntryTF, rsiEntryLen)

rsiEntryLongOK  = not useRsiEntryFilter or (not na(rsiEntry) and rsiEntry >= rsiEntryLongMin and rsiEntry <= rsiEntryLongMax)
rsiEntryShortOK = not useRsiEntryFilter or (not na(rsiEntry) and rsiEntry >= rsiEntryShortMin and rsiEntry <= rsiEntryShortMax)

// RSI(5) Divergence Entry Filter (global, not just when in a trade)
groupRsiDivEntry = "ENTRY: E5) RSI(5) Div Entry Filter"


useRsiDivEntryFilter = input.bool(true, "Block entries near fresh RSI(5) divergence", group=groupRsiDivEntry)
rsiDivBlockBars      = input.int(8, "Block entries for N bars after pivot", minval=1, group=groupRsiDivEntry)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Global RSI(5) divergence state â€” used for entries & exits
//  - lastBullDivBar / lastBearDivBar are the *pivot* (emoji) bars
//  - phaseRSI_BullDiv / BearDiv are true on those pivot bars
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var int lastBullDivBar = na
var int lastBearDivBar = na

if phaseRSI_enable
   if rsi5_bullCond
       lastBullDivBar := bar_index - rsi5_lookbackRight
   if rsi5_bearCond
       lastBearDivBar := bar_index - rsi5_lookbackRight


// Exit signals: true on the *detection* bar (same timing as RSI script)
// Exits will fire where the RSI panel shows the "Bull"/"Bear" tags
phaseRSI_BullDiv = phaseRSI_enable and rsi5_bullCond
phaseRSI_BearDiv = phaseRSI_enable and rsi5_bearCond

// Entry filter helpers: "recent divergence" window (global)
barsSinceBearDiv = na(lastBearDivBar) ? 1e9 : bar_index - lastBearDivBar
barsSinceBullDiv = na(lastBullDivBar) ? 1e9 : bar_index - lastBullDivBar

recentBearDiv = useRsiDivEntryFilter and (barsSinceBearDiv <= rsiDivBlockBars)
recentBullDiv = useRsiDivEntryFilter and (barsSinceBullDiv <= rsiDivBlockBars)





// R:R gate
groupRR       = "ENTRY: G) Risk / Reward Gate"

useRRFilter       = input.bool(false,"Require min R:R",group=groupRR)
minRR             = input.float(2.0,"Min R:R â‰¥",step=0.05,minval=0.5,group=groupRR)
riskPointsDefault = input.float(7.0,"Default Risk (points)",step=0.25,group=groupRR)
riskTicksDefault  = math.round(riskPointsDefault / syminfo.mintick)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  H) SERIES â€” EMAs, ATR, TD QUICK COUNTS, ENTRY PRIMITIVES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
emaMid  = ta.ema(close, emaMidLen)
emaExit = ta.ema(close, exitEmaLen)
atr     = ta.atr(atrLen)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  V2: ORB (3min Opening Range Breakout) Context
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Request first 3min bar of the day (session timezone) for ORB levels
// This provides context: are we above, below, or within the opening range?
[orb3m_high_raw, orb3m_low_raw] = request.security(syminfo.tickerid, "3", [high, low],
   barmerge.gaps_off, barmerge.lookahead_on)

// Track the first bar's range for the day
var float orb3m_high = na
var float orb3m_low = na
var int orb3m_bar = na

// Detect new day using session timezone (not exchange timezone)
// This ensures ORB resets at midnight in the configured timezone (e.g., EST)
newDay_sessionTZ = ta.change(time("D", "", sessTZ))

// Reset ORB on new day (using session timezone)
if newDay_sessionTZ != 0 or na(orb3m_bar)
   orb3m_high := orb3m_high_raw
   orb3m_low := orb3m_low_raw
   orb3m_bar := bar_index

// ORB position context (not gates, just awareness)
orb_aboveRange = not na(orb3m_high) and close > orb3m_high
orb_belowRange = not na(orb3m_low) and close < orb3m_low
orb_insideRange = not na(orb3m_high) and not na(orb3m_low) and close >= orb3m_low and close <= orb3m_high

// Visual: Plot ORB levels for reference
plot(orb3m_high, "ORB 3m High", color=orbHighColor, linewidth=1, style=plot.style_line)
plot(orb3m_low, "ORB 3m Low", color=orbLowColor, linewidth=1, style=plot.style_line)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  V2: REGIME STRUCTURE (Higher Highs/Higher Lows vs Lower Highs/Lower Lows)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Track swing structure to determine trend regime
// HH/HL = Uptrend â†’ favor longs, defer exits
// LH/LL = Downtrend â†’ favor shorts, defer exits
// Used for both entry filters and exit deferral logic

// Inputs
groupRegime = "V2: Regime Structure"
regimeEnable = input.bool(true, "Enable Regime Structure tracking", group=groupRegime)
regimeSwingLength = input.int(15, "Swing pivot length (bars)", minval=5, maxval=50, group=groupRegime,
   tooltip="Number of bars left/right to identify swing highs/lows")
regimeMinSwings = input.int(2, "Min swings to confirm regime", minval=2, maxval=5, group=groupRegime,
   tooltip="How many swing points needed to confirm HH/HL or LH/LL trend")

// Detect swing highs and lows using ta.pivothigh/pivotlow
swingHigh = ta.pivothigh(high, regimeSwingLength, regimeSwingLength)
swingLow = ta.pivotlow(low, regimeSwingLength, regimeSwingLength)

// Track last N swing highs and lows
var array<float> recentSwingHighs = array.new_float(0)
var array<float> recentSwingLows = array.new_float(0)
var array<int> recentSwingHighBars = array.new_int(0)
var array<int> recentSwingLowBars = array.new_int(0)

// Update arrays when new swings detected
if not na(swingHigh)
   array.unshift(recentSwingHighs, swingHigh)
   array.unshift(recentSwingHighBars, bar_index)
   if array.size(recentSwingHighs) > 5
       array.pop(recentSwingHighs)
       array.pop(recentSwingHighBars)

if not na(swingLow)
   array.unshift(recentSwingLows, swingLow)
   array.unshift(recentSwingLowBars, bar_index)
   if array.size(recentSwingLows) > 5
       array.pop(recentSwingLows)
       array.pop(recentSwingLowBars)

// Determine regime: HH/HL (uptrend) or LH/LL (downtrend)
regimeIsUptrend = false
regimeIsDowntrend = false
regimeIsNeutral = true

if regimeEnable and array.size(recentSwingHighs) >= regimeMinSwings and array.size(recentSwingLows) >= regimeMinSwings
   // Check for Higher Highs and Higher Lows (Uptrend)
   higherHighs = true
   higherLows = true

   for i = 1 to math.min(array.size(recentSwingHighs) - 1, regimeMinSwings - 1)
       if array.get(recentSwingHighs, i - 1) <= array.get(recentSwingHighs, i)
           higherHighs := false

   for i = 1 to math.min(array.size(recentSwingLows) - 1, regimeMinSwings - 1)
       if array.get(recentSwingLows, i - 1) <= array.get(recentSwingLows, i)
           higherLows := false

   // Check for Lower Highs and Lower Lows (Downtrend)
   lowerHighs = true
   lowerLows = true

   for i = 1 to math.min(array.size(recentSwingHighs) - 1, regimeMinSwings - 1)
       if array.get(recentSwingHighs, i - 1) >= array.get(recentSwingHighs, i)
           lowerHighs := false

   for i = 1 to math.min(array.size(recentSwingLows) - 1, regimeMinSwings - 1)
       if array.get(recentSwingLows, i - 1) >= array.get(recentSwingLows, i)
           lowerLows := false

   // Determine regime
   if higherHighs and higherLows
       regimeIsUptrend := true
       regimeIsNeutral := false
   else if lowerHighs and lowerLows
       regimeIsDowntrend := true
       regimeIsNeutral := false

// Regime signals for entries and exits
regimeFavorsLong = regimeIsUptrend or regimeIsNeutral
regimeFavorsShort = regimeIsDowntrend or regimeIsNeutral

// Visual: Plot swing points for debugging
plotshape(not na(swingHigh) and regimeEnable, "Swing High", shape.triangledown, location.abovebar,
   color.new(regimeIsUptrend ? color.green : regimeIsDowntrend ? color.red : color.gray, 30), size=size.tiny)
plotshape(not na(swingLow) and regimeEnable, "Swing Low", shape.triangleup, location.belowbar,
   color.new(regimeIsUptrend ? color.green : regimeIsDowntrend ? color.red : color.gray, 30), size=size.tiny)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  V2: ST SLOPE MATRIX (Multi-Timeframe SuperTrend Context)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Track SuperTrend slope and direction across multiple timeframes
// Provides context: Opposing + Sloping = High Risk, Supportive + Sloping = Best

// Inputs
groupSTMatrix = "V2: ST Slope Matrix"
stMatrixEnable = input.bool(true, "Enable ST Slope Matrix", group=groupSTMatrix)
stMatrixMinSlopeTicks = input.int(2, "Min slope (ticks) to consider 'sloping'", minval=0, maxval=20, group=groupSTMatrix)

// We already have 1m ST from mtfST section, let's get 3m, 5m, 10m
// 1m ST (already calculated)
st1m_line_matrix = mtfST_1m_line
st1m_dir_matrix = mtfST_1m_dir

// 3m ST (use ltfTF which defaults to "3")
st3m_line_matrix = f_st_line_tf("3", 3.0, 10)
st3m_dir_matrix = f_st_dir_tf("3", 3.0, 10)

// 5m ST
st5m_line_matrix = f_st_line_tf("5", 3.0, 10)
st5m_dir_matrix = f_st_dir_tf("5", 3.0, 10)

// 10m ST
st10m_line_matrix = f_st_line_tf("10", 3.0, 10)
st10m_dir_matrix = f_st_dir_tf("10", 3.0, 10)

// Calculate slopes in ticks
st1m_slope_matrix = not na(st1m_line_matrix) and not na(st1m_line_matrix[1]) ? (st1m_line_matrix - st1m_line_matrix[1]) / syminfo.mintick : 0.0
st3m_slope_matrix = not na(st3m_line_matrix) and not na(st3m_line_matrix[1]) ? (st3m_line_matrix - st3m_line_matrix[1]) / syminfo.mintick : 0.0
st5m_slope_matrix = not na(st5m_line_matrix) and not na(st5m_line_matrix[1]) ? (st5m_line_matrix - st5m_line_matrix[1]) / syminfo.mintick : 0.0
st10m_slope_matrix = not na(st10m_line_matrix) and not na(st10m_line_matrix[1]) ? (st10m_line_matrix - st10m_line_matrix[1]) / syminfo.mintick : 0.0

// Determine slope status (flat vs sloping)
st1m_isSloping = math.abs(st1m_slope_matrix) >= stMatrixMinSlopeTicks
st3m_isSloping = math.abs(st3m_slope_matrix) >= stMatrixMinSlopeTicks
st5m_isSloping = math.abs(st5m_slope_matrix) >= stMatrixMinSlopeTicks
st10m_isSloping = math.abs(st10m_slope_matrix) >= stMatrixMinSlopeTicks

// Determine directional support for LONGS (need ST dir < 0 = uptrend)
st1m_supportsLong = st1m_dir_matrix < 0
st3m_supportsLong = st3m_dir_matrix < 0
st5m_supportsLong = st5m_dir_matrix < 0
st10m_supportsLong = st10m_dir_matrix < 0

// Determine directional support for SHORTS (need ST dir > 0 = downtrend)
st1m_supportsShort = st1m_dir_matrix > 0
st3m_supportsShort = st3m_dir_matrix > 0
st5m_supportsShort = st5m_dir_matrix > 0
st10m_supportsShort = st10m_dir_matrix > 0

// ST Matrix Signals:
// Opposing + Sloping = â›” High caution
// Opposing + Flat = âš ï¸ Neutral
// Supportive + Flat = âœ… OK
// Supportive + Sloping = ðŸš€ Best

st1m_statusLong = st1m_supportsLong ? (st1m_isSloping ? "ðŸš€" : "âœ…") : (st1m_isSloping ? "â›”" : "âš ï¸")
st3m_statusLong = st3m_supportsLong ? (st3m_isSloping ? "ðŸš€" : "âœ…") : (st3m_isSloping ? "â›”" : "âš ï¸")
st5m_statusLong = st5m_supportsLong ? (st5m_isSloping ? "ðŸš€" : "âœ…") : (st5m_isSloping ? "â›”" : "âš ï¸")
st10m_statusLong = st10m_supportsLong ? (st10m_isSloping ? "ðŸš€" : "âœ…") : (st10m_isSloping ? "â›”" : "âš ï¸")

st1m_statusShort = st1m_supportsShort ? (st1m_isSloping ? "ðŸš€" : "âœ…") : (st1m_isSloping ? "â›”" : "âš ï¸")
st3m_statusShort = st3m_supportsShort ? (st3m_isSloping ? "ðŸš€" : "âœ…") : (st3m_isSloping ? "â›”" : "âš ï¸")
st5m_statusShort = st5m_supportsShort ? (st5m_isSloping ? "ðŸš€" : "âœ…") : (st5m_isSloping ? "â›”" : "âš ï¸")
st10m_statusShort = st10m_supportsShort ? (st10m_isSloping ? "ðŸš€" : "âœ…") : (st10m_isSloping ? "â›”" : "âš ï¸")

// Aggregate: Count how many are favorable (supportive + sloping)
stMatrix_favorableLong = (st1m_supportsLong and st1m_isSloping ? 1 : 0) + (st3m_supportsLong and st3m_isSloping ? 1 : 0) + (st5m_supportsLong and st5m_isSloping ? 1 : 0) + (st10m_supportsLong and st10m_isSloping ? 1 : 0)

stMatrix_favorableShort = (st1m_supportsShort and st1m_isSloping ? 1 : 0) + (st3m_supportsShort and st3m_isSloping ? 1 : 0) + (st5m_supportsShort and st5m_isSloping ? 1 : 0) + (st10m_supportsShort and st10m_isSloping ? 1 : 0)

// Count opposing + sloping (high risk)
stMatrix_opposingLong = (not st1m_supportsLong and st1m_isSloping ? 1 : 0) + (not st3m_supportsLong and st3m_isSloping ? 1 : 0) + (not st5m_supportsLong and st5m_isSloping ? 1 : 0) + (not st10m_supportsLong and st10m_isSloping ? 1 : 0)

stMatrix_opposingShort = (not st1m_supportsShort and st1m_isSloping ? 1 : 0) + (not st3m_supportsShort and st3m_isSloping ? 1 : 0) + (not st5m_supportsShort and st5m_isSloping ? 1 : 0) + (not st10m_supportsShort and st10m_isSloping ? 1 : 0)

// Overall ST Matrix score (-4 to +4, where +4 = all favorable, -4 = all opposing)
stMatrixScoreLong = stMatrix_favorableLong - stMatrix_opposingLong
stMatrixScoreShort = stMatrix_favorableShort - stMatrix_opposingShort

// Context signals (can be used for entry/exit filters)
stMatrixGreenLight_Long = stMatrixScoreLong >= 2  // At least 2 favorable, minimal opposing
stMatrixGreenLight_Short = stMatrixScoreShort >= 2
stMatrixRedFlag_Long = stMatrix_opposingLong >= 2  // 2+ opposing + sloping = danger
stMatrixRedFlag_Short = stMatrix_opposingShort >= 2

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Absorption Bubbles (signal-only port)
//  validUp = selling absorption (upper wick zone)  â†’ opposes LONG
//  validDn = buying absorption (lower wick zone)   â†’ opposes SHORT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
volData   = volume
midPrice  = (high + low) / 2.0
volStdev  = ta.stdev(volData, absLookbackPeriod)
scaledVol = (volStdev == 0) ? 0.0 : (volData / volStdev)

// Wick zones
topWick    = high
topBody    = math.max(open, close)
lowBody    = math.min(open, close)
bottomWick = low

upperZone = midPrice >= topBody and midPrice <= topWick
lowerZone = midPrice <= lowBody and midPrice >= bottomWick

absSellNow = (scaledVol >= absLimitFactor) and upperZone   // â€œselling absorptionâ€ bubble
absBuyNow  = (scaledVol >= absLimitFactor) and lowerZone   // â€œbuying absorptionâ€ bubble

// Calculate barssince on every bar for consistency
barsSinceAbsSell = ta.barssince(absSellNow)
barsSinceAbsBuy = ta.barssince(absBuyNow)

absSellRecent = absRecentBars <= 0 ? absSellNow : (barsSinceAbsSell >= 0 and barsSinceAbsSell <= absRecentBars)
absBuyRecent  = absRecentBars <= 0 ? absBuyNow  : (barsSinceAbsBuy  >= 0 and barsSinceAbsBuy  <= absRecentBars)

// Veto rules (opposing direction)
absOK_Long_Base  = (not useAbsorbVeto_Base) or (not absSellRecent)   // block LONG if sell-absorption present
absOK_Short_Base = (not useAbsorbVeto_Base) or (not absBuyRecent)    // block SHORT if buy-absorption present

absOK_Long_Late  = (not useAbsorbVeto_Late) or (not absSellRecent)
absOK_Short_Late = (not useAbsorbVeto_Late) or (not absBuyRecent)


// â”€â”€ Impulse bar detection (uses chart TF bars)
barRange = high - low
barBody  = math.abs(close - open)

impulseRatio = (atr > 0) ? (barRange / atr) : na

isImpulseByATR  = impulseBlockEnable and (atr > 0) and (barRange >= atr * impulseAtrMult)
isImpulseByBody = impulseBlockEnable and (impulseBodyTicksMin > 0) and (barBody >= impulseBodyTicksMin * syminfo.mintick)

isImpulseBar = isImpulseByATR or isImpulseByBody

// â€œRecently impulsedâ€ (block entries for N bars after an impulse bar)
barsSinceImpulse = ta.barssince(isImpulseBar)
impulseRecent = impulseBlockEnable and (impulseLookbackBars > 0) and (barsSinceImpulse >= 0) and (barsSinceImpulse <= impulseLookbackBars)

// Final gate
impulseOK = (not impulseBlockEnable) or (not isImpulseBar and not impulseRecent)

ema5  = ta.ema(close, 5)
ema9  = ta.ema(close, 9)
ema21 = ta.ema(close, 21)

ema8  = ta.ema(close, 8)

// Reclaim EMA (used by base armed window + Late ST Recovery)
armEma =
    armEmaSrc=="EMA21" ? ema21 :
    armEmaSrc=="EMA13" ? ta.ema(close, 13) :
    armEmaSrc=="EMA8"  ? ema8 :
    armEmaSrc=="EMA5"  ? ema5 :
                         ta.ema(close, armEmaLenCustom)





// TD quick counts (for entry gating + exits)
var int _tdx_bull_prep_e = 0
var int _tdx_bear_prep_e = 0
_tdx_bull_prep_e := close < close[tdxPrepCompare] ? (nz(_tdx_bull_prep_e[1]) + 1) : 0
_tdx_bear_prep_e := close > close[tdxPrepCompare] ? (nz(_tdx_bear_prep_e[1]) + 1) : 0

var int _tdx_bull_lead_e = 0
var int _tdx_bear_lead_e = 0
_tdx_bull_lead_e := close < low[tdxLeadCompare]  ? (nz(_tdx_bull_lead_e[1]) + 1) : 0
_tdx_bear_lead_e := close > high[tdxLeadCompare] ? (nz(_tdx_bear_lead_e[1]) + 1) : 0

var bool nearBearPrep = false
var bool nearBullPrep = false
nearBearPrep := tdxGateEntries and (_tdx_bear_prep_e >= (tdxPrepLen - tdxPrepBlockWindow))
nearBullPrep := tdxGateEntries and (_tdx_bull_prep_e >= (tdxPrepLen - tdxPrepBlockWindow))

var bool nearBullLead = false
var bool nearBearLead = false
nearBullLead := tdxGateLeadEntries and (_tdx_bull_lead_e >= (tdxLeadLen - tdxLeadBlockWindow))
nearBearLead := tdxGateLeadEntries and (_tdx_bear_lead_e >= (tdxLeadLen - tdxLeadBlockWindow))

// Crosses - Primary 4/48 EMA
crossUp_FastSlow  = ta.crossover(emaFast, emaSlow)
crossDn_FastSlow  = ta.crossunder(emaFast, emaSlow)
crossAny_FastSlow = ta.cross(emaFast, emaSlow)

// Additional EMA Crosses (8/48, 13/48, and 21/48)
crossUp_Ema8Slow  = useEma8Cross ? ta.crossover(ema8, emaSlow) : false
crossDn_Ema8Slow  = useEma8Cross ? ta.crossunder(ema8, emaSlow) : false
crossUp_Ema13Slow = useEma13Cross ? ta.crossover(emaMid, emaSlow) : false
crossDn_Ema13Slow = useEma13Cross ? ta.crossunder(emaMid, emaSlow) : false
crossUp_Ema21Slow = ta.crossover(ema21, emaSlow)  // Always track 21/48 cross for late entry triggers
crossDn_Ema21Slow = ta.crossunder(ema21, emaSlow)

// Combined cross signals (any enabled cross)
anyCrossUp = crossUp_FastSlow or crossUp_Ema8Slow or crossUp_Ema13Slow
anyCrossDn = crossDn_FastSlow or crossDn_Ema8Slow or crossDn_Ema13Slow

emaF_ltf = useHTFRouting ? sec(ltfTF, ta.ema(close, emaFastLen)) : emaFast
emaS_ltf = useHTFRouting ? sec(ltfTF, ta.ema(close, emaSlowLen)) : emaSlow
ltfCrossU = useHTFRouting ? ta.crossover(emaF_ltf, emaS_ltf)  : anyCrossUp
ltfCrossD = useHTFRouting ? ta.crossunder(emaF_ltf, emaS_ltf) : anyCrossDn

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Entry-side PDZ (lightweight copy) for PDZ-proximity veto
//  (kept separate so entries can reference it before exit section)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pdzEntry_len = input.int(100, "PDZ len (entry filter)", group=groupAddOns)
pdzEntry_pct = input.float(2.0, "PDZ % (entry filter)", step=0.1, group=groupAddOns)

var float pdzE_legTop = na
var float pdzE_legBot = na

_pdzE_newTop = ta.change(ta.highest(high, pdzEntry_len)) > 0
_pdzE_newBot = ta.change(ta.lowest (low,  pdzEntry_len)) < 0

if _pdzE_newTop
   pdzE_legTop := high[pdzEntry_len]
   pdzE_legBot := high[pdzEntry_len]

if _pdzE_newBot
   pdzE_legBot := low[pdzEntry_len]
   pdzE_legTop := low[pdzEntry_len]

if not na(pdzE_legTop) and not na(pdzE_legBot)
   pdzE_legTop := math.max(pdzE_legTop, high)
   pdzE_legBot := math.min(pdzE_legBot, low)

// Premium / Discount bands (same math as your exit PDZ block)
pdzE_premTop = pdzE_legTop
pdzE_premBot = na(pdzE_legTop) or na(pdzE_legBot) ? na :
              pdzE_legTop*(1.0-pdzEntry_pct*0.01) + pdzE_legBot*(pdzEntry_pct*0.01)

pdzE_discBot = pdzE_legBot
pdzE_discTop = na(pdzE_legTop) or na(pdzE_legBot) ? na :
              pdzE_legBot*(1.0-pdzEntry_pct*0.01) + pdzE_legTop*(pdzEntry_pct*0.01)

// â€œInside zone now?â€
inPremEntry = not na(pdzE_premBot) and high >= pdzE_premBot
inDiscEntry = not na(pdzE_discTop) and low  <= pdzE_discTop

// â€œNear zone edge?â€ (buffer)
pdzBufPx = pdzProxTicks * syminfo.mintick
nearPremEntry = not na(pdzE_premBot) and close >= (pdzE_premBot - pdzBufPx)
nearDiscEntry = not na(pdzE_discTop) and close <= (pdzE_discTop + pdzBufPx)

// Profit-side notion:
// - Longs: PDZ premium is typically where upside gets sold into
// - Shorts: PDZ discount is typically where downside gets bought
profitSideLong  = true
profitSideShort = true

pdzVetoLong =
    useAddOn_PDZProx and
    (not pdzProxOnlyProfitSide or profitSideLong) and
    (pdzProxMode=="Block inside only" ? inPremEntry : (inPremEntry or nearPremEntry))

pdzVetoShort =
    useAddOn_PDZProx and
    (not pdzProxOnlyProfitSide or profitSideShort) and
    (pdzProxMode=="Block inside only" ? inDiscEntry : (inDiscEntry or nearDiscEntry))

pdzProxOK_Long  = not pdzVetoLong
pdzProxOK_Short = not pdzVetoShort

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  E6) LATE ENTRY â€” ST RECOVERY (Option A)
//  Cross happens, base did NOT enter -> arm.
//  Wait until BOTH 1m+3m ST are favorable, snapshot anchors.
//  Require BOTH ST lines to move â‰¥ N ticks from anchors.
//  Then require reclaim EMA side -> late entry.
//  Cancel on opposing cross or arm timeout.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupLateST = "ENTRY: E6) Late Entry â€” ST Recovery"

lateST_enable        = input.bool(true, "Enable ST-Recovery late entry", group=groupLateST)
lateST_armBars       = input.int(8, "Late arm window bars (base)", minval=1, group=groupLateST)
lateST_stMoveMode    = input.string("Both", "ST move requirement", options=["Both", "Either", "1m Only", "3m Only"], group=groupLateST,
   tooltip="Both: 1m AND 3m must move. Either: 1m OR 3m must move. Only: Just that timeframe.")
lateST_1mMoveTicks   = input.int(8, "1m ST move threshold (ticks)", minval=0, group=groupLateST,
   tooltip="Minimum ticks 1m ST must move. 0 = allow flat/no movement")
lateST_3mMoveTicks   = input.int(8, "3m ST move threshold (ticks)", minval=0, group=groupLateST,
   tooltip="Minimum ticks 3m ST must move. 0 = allow flat/no movement")
lateST_graceBars     = input.int(3, "Grace bars if ST de-aligns", minval=0, group=groupLateST)
lateST_reclaimConsec = input.int(1, "Reclaim EMA consec closes", minval=0, maxval=5, group=groupLateST)
lateST_onlyIfFlat    = input.bool(true, "Only late-enter if flat/not-in-direction", group=groupLateST)

lateST_use1mConfirm   = input.bool(true, "Late: use 1m ST as CONFIRM (not gate)", group=groupLateST)
lateST_retestEmaLen   = input.int(21, "Late: Retest EMA length (custom)", minval=1, maxval=200, group=groupLateST,
   tooltip="Custom EMA to define retest threshold. Price must touch (wick) this level to confirm pullback.")
lateST_retestNeed     = input.bool(true, "Late: Require retest (touch threshold)", group=groupLateST,
   tooltip="Require price to wick/touch the retest EMA before allowing late entry")
lateST_retestUseWick  = input.bool(false, "Late: Retest on wick (vs close)", group=groupLateST,
   tooltip="If ON: wick touch counts (more flexible). If OFF: close must breach (stricter)")
lateST_chartStMustHold= input.bool(true, "Late: Chart ST must not flip against", group=groupLateST)
lateST_ema5Consec     = input.int(1, "Late: EMA5 reclaim consec closes", minval=1, maxval=5, group=groupLateST)

// NEW: â€œEMA5 must improve vs crossâ€ filter (reduces fakeouts when arm window is longer)
lateST_ema5MustImprove = input.bool(true,  "Late: EMA5 must improve vs cross", group=groupLateST)
lateST_ema5ImproveTicks = input.int(12, "Late: EMA5 improve â‰¥ ticks (0=any)", minval=0, group=groupLateST)
lateST_ema5SlopeBars    = input.int(1, "Late: EMA5 slope bars (0=off)", minval=0, maxval=10, group=groupLateST)
lateST_useEma5Slope = input.bool(true, "Late: EMA5 slope check (uses slope bars)", group=groupLateST)

// Store EMA5 at the moment we arm (proxy for â€œcross momentâ€ in late logic)
var float lateEma5AtArm_L = na
var float lateEma5AtArm_S = na

// â”€â”€ V2 CLEAN: Structure Confirmation Path (21/48 EMA cross) - OPTIONAL â”€â”€
lateST_useStructureConfirm = input.bool(false, "Structure Confirm (21/48 cross)", group=groupLateST, tooltip="If armed on rejected cross, allow entry when 21 EMA crosses 48 EMA (structure proving itself). Bypasses strict timing/slope checks.")
lateST_structBypassRetest = input.bool(false, "Structure: Bypass retest requirement", group=groupLateST, tooltip="If 21/48 cross happens, treat it as a valid retest (structure IS the confirmation). Recommended: ON")
lateST_structExtendWindow = input.bool(false, "Structure: Extend arm to 20 bars", group=groupLateST, tooltip="If structure confirm enabled, extend arm window to catch delayed structure setups")
lateST_structRequireZone = input.bool(false, "Structure: Require zone held (above/below 48)", group=groupLateST, tooltip="Price must stay above 48 EMA for longs (below for shorts) - confirms structure held without collapse")
lateST_structRequire3mST = input.bool(false, "Structure: Require 3m ST supportive", group=groupLateST, tooltip="3m ST must flip to correct direction before structure entry fires")
lateST_structSkip1mST = input.bool(true, "Structure: Skip 1m ST requirement", group=groupLateST, tooltip="If structure confirmed, ignore 1m ST gate (allows entry on structure alone)")

// Track 21/48 EMA cross for structure confirmation
var bool struct21x48_armed_L = false
var bool struct21x48_armed_S = false
var int struct21x48_bar_L = na
var int struct21x48_bar_S = na

// Use 1m + LTF(=3m default) SuperTrend line/dir (reuse your existing helpers)
st1m_dir  = f_st_dir_tf("1", mtfST_1m_fac, mtfST_1m_atr)
st1m_line = f_st_line_tf("1", mtfST_1m_fac, mtfST_1m_atr)

// Use your LTF as â€œ3m STâ€ (defaults to 3). If you change ltfTF, late module follows.
st3m_dir  = f_st_dir_tf(ltfTF, mtfST_1m_fac, mtfST_1m_atr)
st3m_line = f_st_line_tf(ltfTF, mtfST_1m_fac, mtfST_1m_atr)

// Calculate custom retest EMA
lateRetestEma = ta.ema(close, lateST_retestEmaLen)

// V2 CLEAN: Detect 21/48 EMA crosses for structure confirmation
ema21_cross_above_48 = ta.crossover(ema21, emaSlow)   // 48 = emaSlow
ema21_cross_below_48 = ta.crossunder(ema21, emaSlow)

// Track when 21/48 cross happened (for structure confirmation)
if barstate.isconfirmed and ema21_cross_above_48
   struct21x48_armed_L := true
   struct21x48_bar_L := bar_index

if barstate.isconfirmed and ema21_cross_below_48
   struct21x48_armed_S := true
   struct21x48_bar_S := bar_index

chartStOk_Long  = (not lateST_chartStMustHold) or stBiasLong
chartStOk_Short = (not lateST_chartStMustHold) or stBiasShort
// Favorable definition: correct direction + NOT moving against us.
// Flat ST is OK during consolidation; breakout will create the movement we measure via anchors.
stFavLong_1m  = (st1m_dir < 0) and (st1m_line >= nz(st1m_line[1]))
stFavLong_3m  = (st3m_dir < 0) and (st3m_line >= nz(st3m_line[1]))
stFavShort_1m = (st1m_dir > 0) and (st1m_line <= nz(st1m_line[1]))
stFavShort_3m = (st3m_dir > 0) and (st3m_line <= nz(st3m_line[1]))

bothFavLong  = stFavLong_1m  and stFavLong_3m
bothFavShort = stFavShort_1m and stFavShort_3m

// Base-miss proxy (ST-gated): Cross happened but ST wasn't in-shape yet.
// This avoids referencing longEntry_raw/shortEntry_raw before they exist.
baseMissLong_onCross  = ltfCrossU and (not stStrongUp or not stNotFlat or (useSTEntryBias and not stBiasLong))
baseMissShort_onCross = ltfCrossD and (not stStrongDown or not stNotFlat or (useSTEntryBias and not stBiasShort))

// Late state
var bool lateArmedL = false
var bool lateArmedS = false
var int  lateUntilL = na
var int  lateUntilS = na

var float st1m_anchor_L = na
var float st3m_anchor_L = na
var float st1m_anchor_S = na
var float st3m_anchor_S = na

var int badFavCntL = 0
var int badFavCntS = 0

var bool lateRetestSeenL = false
var bool lateRetestSeenS = false

// Late signals built in E6 (structure only). Core/session gates are applied later.
bool lateSignalLong_raw  = false
bool lateSignalShort_raw = false

// Helper: consec closes on reclaim side
var int reclaimRunL = 0
var int reclaimRunS = 0
reclaimRunL := close > armEma ? nz(reclaimRunL[1]) + 1 : 0
reclaimRunS := close < armEma ? nz(reclaimRunS[1]) + 1 : 0
reclaimOK_L = (not armUseEmaReclaim) or (lateST_reclaimConsec <= 0 ? (close > armEma) : (reclaimRunL >= lateST_reclaimConsec))
reclaimOK_S = (not armUseEmaReclaim) or (lateST_reclaimConsec <= 0 ? (close < armEma) : (reclaimRunS >= lateST_reclaimConsec))

// Cancel conditions by position direction (optional safety)
lateFlatOrNotLong  = not lateST_onlyIfFlat or (strategy.position_size <= 0)
lateFlatOrNotShort = not lateST_onlyIfFlat or (strategy.position_size >= 0)

// Arm on cross when base missed
if barstate.isconfirmed and lateST_enable
   if baseMissLong_onCross
       lateArmedL := true
       lateUntilL := bar_index + lateST_armBars

       // Capture EMA5 at arm (represents â€œat cross / decision momentâ€)
       lateEma5AtArm_L := ema5

       // cancel opposite
       lateArmedS := false
       lateUntilS := na
       st1m_anchor_L := na
       st3m_anchor_L := na
       badFavCntL := 0
       lateRetestSeenL := false

   if baseMissShort_onCross
       lateArmedS := true

       // V2 CLEAN: Extend arm window if structure confirm enabled
       _extendedWindow = (lateST_useStructureConfirm and lateST_structExtendWindow) ? 20 : lateST_armBars
       lateUntilS := bar_index + _extendedWindow

       // Capture EMA5 at arm (represents "at cross / decision moment")
       lateEma5AtArm_S := ema5

       // cancel opposite
       lateArmedL := false
       lateUntilL := na
       st1m_anchor_S := na
       st3m_anchor_S := na
       badFavCntS := 0
       lateRetestSeenS := false

       // Reset structure cross tracking
       struct21x48_armed_S := false
       struct21x48_bar_S := na

// Cancel on opposing cross immediately
if barstate.isconfirmed and lateST_enable
   if ltfCrossD
       lateArmedL := false
       lateUntilL := na
       st1m_anchor_L := na
       st3m_anchor_L := na
       badFavCntL := 0
       lateRetestSeenL := false
       lateEma5AtArm_L := na
   if ltfCrossU
       lateArmedS := false
       lateUntilS := na
       st1m_anchor_S := na
       st3m_anchor_S := na
       badFavCntS := 0
       lateRetestSeenS := false
       lateEma5AtArm_S := na

// Expire window
if lateArmedL and not na(lateUntilL) and bar_index > lateUntilL
   lateArmedL := false
   lateUntilL := na
   st1m_anchor_L := na
   st3m_anchor_L := na
   badFavCntL := 0
   lateRetestSeenL := false
   lateEma5AtArm_L := na

if lateArmedS and not na(lateUntilS) and bar_index > lateUntilS
   lateArmedS := false
   lateUntilS := na
   st1m_anchor_S := na
   st3m_anchor_S := na
   badFavCntS := 0
   lateRetestSeenS := false
   lateEma5AtArm_S := na

// Anchor when BOTH become favorable (first time)
if barstate.isconfirmed and lateArmedL and lateFlatOrNotLong
   if na(st1m_anchor_L) and na(st3m_anchor_L) and bothFavLong
       st1m_anchor_L := st1m_line
       st3m_anchor_L := st3m_line
       badFavCntL := 0
   else
       // "De-align" = either TF flips against our direction. Flat is fine.
       stAgainstLong  = (st1m_dir > 0) or (st3m_dir > 0)
       stAgainstShort = (st1m_dir < 0) or (st3m_dir < 0)

       // After we have anchors, only count "against" bars.
       badFavCntL := (not na(st1m_anchor_L) and stAgainstLong)  ? nz(badFavCntL[1]) + 1 : 0
       if badFavCntL > lateST_graceBars
           st1m_anchor_L := na
           st3m_anchor_L := na
           badFavCntL := 0

       badFavCntS := (not na(st1m_anchor_S) and stAgainstShort) ? nz(badFavCntS[1]) + 1 : 0
       if badFavCntS > lateST_graceBars
           st1m_anchor_S := na
           st3m_anchor_S := na
           badFavCntS := 0

if barstate.isconfirmed and lateArmedS and lateFlatOrNotShort
   if na(st1m_anchor_S) and na(st3m_anchor_S) and bothFavShort
       st1m_anchor_S := st1m_line
       st3m_anchor_S := st3m_line
       badFavCntS := 0
   else
       badFavCntS := (not bothFavShort and not na(st1m_anchor_S)) ? nz(badFavCntS[1]) + 1 : 0
       if badFavCntS > lateST_graceBars
           st1m_anchor_S := na
           st3m_anchor_S := na
           badFavCntS := 0

// Move thresholds with flexible mode (Both/Either/Only)
st1m_moved_L = not na(st1m_anchor_L) ? ((st1m_line - st1m_anchor_L) / syminfo.mintick) : 0.0
st3m_moved_L = not na(st3m_anchor_L) ? ((st3m_line - st3m_anchor_L) / syminfo.mintick) : 0.0
st1m_moved_S = not na(st1m_anchor_S) ? ((st1m_anchor_S - st1m_line) / syminfo.mintick) : 0.0
st3m_moved_S = not na(st3m_anchor_S) ? ((st3m_anchor_S - st3m_line) / syminfo.mintick) : 0.0

st1m_moveOk_L = st1m_moved_L >= lateST_1mMoveTicks
st3m_moveOk_L = st3m_moved_L >= lateST_3mMoveTicks
st1m_moveOk_S = st1m_moved_S >= lateST_1mMoveTicks
st3m_moveOk_S = st3m_moved_S >= lateST_3mMoveTicks

moveOk_L =
    not na(st1m_anchor_L) and not na(st3m_anchor_L) and
    (lateST_stMoveMode == "Both" ? (st1m_moveOk_L and st3m_moveOk_L) :
     lateST_stMoveMode == "Either" ? (st1m_moveOk_L or st3m_moveOk_L) :
     lateST_stMoveMode == "1m Only" ? st1m_moveOk_L :
     st3m_moveOk_L)  // "3m Only"

moveOk_S =
    not na(st1m_anchor_S) and not na(st3m_anchor_S) and
    (lateST_stMoveMode == "Both" ? (st1m_moveOk_S and st3m_moveOk_S) :
     lateST_stMoveMode == "Either" ? (st1m_moveOk_S or st3m_moveOk_S) :
     lateST_stMoveMode == "1m Only" ? st1m_moveOk_S :
     st3m_moveOk_S)  // "3m Only"

// Final late entry signals (fire once; the entry execution block will consume)
// Late-entry reclaim is explicitly EMA5 (your stated premise).
lateReclaimOK_L = (not armUseEmaReclaim) or (close > ema5)
lateReclaimOK_S = (not armUseEmaReclaim) or (close < ema5)

// Retest = price moves back toward risk
// If useWick: wick touch counts (low < EMA for longs, high > EMA for shorts)
// If not useWick: close must breach (close < EMA for longs, close > EMA for shorts)
retestAgainst_Long  = lateST_retestUseWick ? (low < lateRetestEma) : (close < lateRetestEma)
retestAgainst_Short = lateST_retestUseWick ? (high > lateRetestEma) : (close > lateRetestEma)

// Track if retest happened AFTER we armed
if lateArmedL and retestAgainst_Long
   lateRetestSeenL := true
if not lateArmedL
   lateRetestSeenL := false

if lateArmedS and retestAgainst_Short
   lateRetestSeenS := true
if not lateArmedS
   lateRetestSeenS := false

var int ema5UpRun = 0
var int ema5DnRun = 0
ema5UpRun := close > ema5 ? nz(ema5UpRun[1]) + 1 : 0
ema5DnRun := close < ema5 ? nz(ema5DnRun[1]) + 1 : 0

ema5ReclaimOK_L = ema5UpRun >= lateST_ema5Consec
ema5ReclaimOK_S = ema5DnRun >= lateST_ema5Consec

confirm1m_Long  = (not lateST_use1mConfirm) or (st1m_dir < 0)
confirm1m_Short = (not lateST_use1mConfirm) or (st1m_dir > 0)

// EMA5 must have progressed since LATE ARM (this is the correct â€œcross momentâ€ for Late)
improvePx = lateST_ema5ImproveTicks * syminfo.mintick

ema5Improved_Long =
    (not lateST_ema5MustImprove) or
    (not na(lateEma5AtArm_L) and ema5 >= (lateEma5AtArm_L + improvePx))

ema5Improved_Short =
    (not lateST_ema5MustImprove) or
    (not na(lateEma5AtArm_S) and ema5 <= (lateEma5AtArm_S - improvePx))

// Optional: EMA5 slope confirmation (compute every bar to avoid Pine short-circuit warnings)
ema5Rise_raw = ta.rising(ema5, math.max(lateST_ema5SlopeBars, 1))
ema5Fall_raw = ta.falling(ema5, math.max(lateST_ema5SlopeBars, 1))

ema5SlopeOK_Long  = (not lateST_useEma5Slope) or (lateST_ema5SlopeBars <= 0) or ema5Rise_raw
ema5SlopeOK_Short = (not lateST_useEma5Slope) or (lateST_ema5SlopeBars <= 0) or ema5Fall_raw

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  V2 CLEAN: STRUCTURE CONFIRMATION PATH
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Alternative late entry path: 21/48 EMA cross confirms structure is proving itself

bool structConfirmLong = false
bool structConfirmShort = false

if lateST_enable and lateST_useStructureConfirm and lateArmedL
   // Check if 21/48 cross happened while armed
   _struct21x48_recent_L = struct21x48_armed_L and not na(struct21x48_bar_L) and (bar_index - struct21x48_bar_L <= 3)

   // Check zone held: price stayed above 48 EMA (didn't collapse)
   _zoneHeld_L = (not lateST_structRequireZone) or (close > emaSlow)

   // Check 3m ST flipped supportive
   _st3mOK_L = (not lateST_structRequire3mST) or (st3m_dir < 0)

   // Check 1m ST (skip if configured)
   _st1mOK_L = lateST_structSkip1mST or (st1m_dir < 0)

   // Structure confirmation signal
   structConfirmLong := _struct21x48_recent_L and _zoneHeld_L and _st3mOK_L and _st1mOK_L and chartStOk_Long and lateFlatOrNotLong

if lateST_enable and lateST_useStructureConfirm and lateArmedS
   // Check if 21/48 cross happened while armed
   _struct21x48_recent_S = struct21x48_armed_S and not na(struct21x48_bar_S) and (bar_index - struct21x48_bar_S <= 3)

   // Check zone held: price stayed below 48 EMA (didn't collapse)
   _zoneHeld_S = (not lateST_structRequireZone) or (close < emaSlow)

   // Check 3m ST flipped supportive
   _st3mOK_S = (not lateST_structRequire3mST) or (st3m_dir > 0)

   // Check 1m ST (skip if configured)
   _st1mOK_S = lateST_structSkip1mST or (st1m_dir > 0)

   // Structure confirmation signal
   structConfirmShort := _struct21x48_recent_S and _zoneHeld_S and _st3mOK_S and _st1mOK_S and chartStOk_Short and lateFlatOrNotShort

// V2 CLEAN: SMART RETEST LOGIC
// If structure confirmed (21/48 cross) AND bypass enabled, skip retest requirement (structure IS the retest)
// Otherwise, use normal retest requirement
structBypassOK_Long  = lateST_structBypassRetest and structConfirmLong
structBypassOK_Short = lateST_structBypassRetest and structConfirmShort

retestOK_Long  = (not lateST_retestNeed) or lateRetestSeenL or structBypassOK_Long
retestOK_Short = (not lateST_retestNeed) or lateRetestSeenS or structBypassOK_Short

// V2 CLEAN: TWO PATHS TO LATE ENTRY
// Path 1: Original strict checks (EMA5 reclaim, improvement, slope, retest)
// NOTE: retest now bypassed if structure confirmed (21/48 cross)
lateSignal_Path1_Long = lateST_enable and lateArmedL and lateFlatOrNotLong and chartStOk_Long and confirm1m_Long and retestOK_Long and ema5ReclaimOK_L and ema5Improved_Long and ema5SlopeOK_Long
lateSignal_Path1_Short = lateST_enable and lateArmedS and lateFlatOrNotShort and chartStOk_Short and confirm1m_Short and retestOK_Short and ema5ReclaimOK_S and ema5Improved_Short and ema5SlopeOK_Short

// Path 2: Structure confirmation (21/48 cross) - bypasses strict checks
lateSignal_Path2_Long = structConfirmLong
lateSignal_Path2_Short = structConfirmShort

// Combined: Either path triggers late entry
lateSignalLong_raw := lateSignal_Path1_Long or lateSignal_Path2_Long
lateSignalShort_raw := lateSignal_Path1_Short or lateSignal_Path2_Short
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ARM STATE (base armed window)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var bool armedL    = false
var bool armedS    = false
var int  armUntilL = na
var int  armUntilS = na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Arm logic: when cross happens, arm for N bars
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if barstate.isconfirmed
   if useArmWindow and ltfCrossU
       armedL    := true
       armUntilL := bar_index + armBars
       // clear opposite arm
       armedS    := false
       armUntilS := na

   if useArmWindow and ltfCrossD
       armedS    := true
       armUntilS := bar_index + armBars
       // clear opposite arm
       armedL    := false
       armUntilL := na

// Expire arms
if armedL and not na(armUntilL) and bar_index > armUntilL
   armedL    := false
   armUntilL := na

if armedS and not na(armUntilS) and bar_index > armUntilS
   armedS    := false
   armUntilS := na

// Separation & chop
minSepTicks_base = input.int(2,"Min sep (ticks)",minval=0,group=groupEntryADX)
minSepAtrMult    = input.float(0.15,"Min sep (Ã—ATR)",step=0.01,minval=0.0,group=groupEntryADX)
sepMode          = input.string("Ticks","Sep mode",options=["Ticks","ATRx"],group=groupEntryADX)

sepAbs_ltf = math.abs(emaF_ltf - emaS_ltf)
sepAbs_base= math.abs(emaFast - emaSlow)
sepThresh  = sepMode=="Ticks" ? (minSepTicks_base*syminfo.mintick) : (minSepAtrMult*atr)
sepOK_base = sepAbs_base >= sepThresh
ltfSepOK   = sepAbs_ltf >= sepThresh

crossAnyF   = crossAny_FastSlow ? 1.0 : 0.0
cumCrosses  = ta.cum(crossAnyF)
crossesLast = cumCrosses - nz(cumCrosses[chopLookbackBars],0)
chopOK      = not useChopCounter or (crossesLast <= chopMaxCrosses)

// ADX / ATR floor
[diPlus, diMinus, adxVal] = ta.dmi(adxLen, adxSmoothing)
adxRising_raw = ta.rising(adxVal, math.max(adxRiseBars,1))
adxUp         = adxRiseBars<=0 ? true : adxRising_raw
adxOK_raw     = not useADXStrength or ((adxVal>=adxMin) and adxUp)

atrTicks    = atr / syminfo.mintick
atrMean     = ta.sma(atrTicks, atrAdaptiveLB)
atrDynFloor = math.round(atrMean * atrAdaptivePct)
atrHardOK   = atrTicks >= atrFloorTicks
adxSoftOK_forATR = (adxVal >= math.max(adxMin, 22)) and adxUp
atrSoftOK   = atrHardOK or (useADXStrength and adxSoftOK_forATR)
atrAdptOK   = atrTicks >= math.max(atrFloorTicks, atrDynFloor)
atrOK_raw   = not useATRfloor ? true :
             atrFloorMode=="Hard"     ? atrHardOK :
             atrFloorMode=="Adaptive" ? atrAdptOK :
                                        atrSoftOK

// Late entry ATR floor (separate, simpler check - just hard floor)
atrHardOK_Late = atrTicks >= atrFloorTicksLate
atrOK_late = not useATRfloorLate ? true : atrHardOK_Late

// N>EMA
emaBeyond = ta.ema(close, beyondEMA_len)
tolPx     = beyondEMA_tolTicks * syminfo.mintick
condLongBeyond  = close >  emaBeyond + tolPx
condShortBeyond = close <  emaBeyond - tolPx
var int consecBeyond_Long  = 0
var int consecBeyond_Short = 0
consecBeyond_Long  := condLongBeyond  ? nz(consecBeyond_Long[1])  + 1 : 0
consecBeyond_Short := condShortBeyond ? nz(consecBeyond_Short[1]) + 1 : 0
nBeyond_Long  = not useNClosesBeyondEMA or beyondEMA_consecN<=0 or (consecBeyond_Long  >= beyondEMA_consecN)
nBeyond_Short = not useNClosesBeyondEMA or beyondEMA_consecN<=0 or (consecBeyond_Short >= beyondEMA_consecN)

// Proximity
proxLen       = proxAnchor=="Exit" ? exitEmaLen : proxAnchor=="Fast" ? emaFastLen : proxCustomLen
proxEMA       = ta.ema(close, proxLen)
proxDistTicks = math.abs(close - proxEMA) / syminfo.mintick
proxOK        = not useProximityToEMA or (proxDistTicks <= proxMaxTicks)

// Candle context
body__  = math.abs(close - open)
upperW  = high - math.max(open, close)
lowerW  = math.min(open, close) - low
wickBiasBull = (lowerW>upperW) and (lowerW>wickBiasBodyMult*body__)
wickBiasBear = (upperW>lowerW) and (upperW>wickBiasBodyMult*body__)
wickBiasOK_Long  = not useWickBiasFilter or not wickBiasBear
wickBiasOK_Short = not useWickBiasFilter or not wickBiasBull
barDirOK_Long    = (not requireBullishForLong)  or (close>=open)
barDirOK_Short   = (not requireBearishForShort) or (close<=open)
priceSideOK_Long  = (not requirePriceSideOfFast) or (close>emaFast)
priceSideOK_Short = (not requirePriceSideOfFast) or (close<emaFast)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Optional Add-Ons calculations
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// --- Add-On #1: ST distance ---
stDistTicks = (not na(stLine)) ? (math.abs(close - stLine) / syminfo.mintick) : 1e9
stDistOK =
    (not useAddOn_STDistance) ? true :
    stDistMode == "Ticks"
        ? (stDistTicks <= stDistMaxTicks)
        : (atr > 0 and (math.abs(close - stLine) <= atr * stDistMaxATRx))

// --- Add-On #2: Rejection confirmation ---
rejWickLong  = lowerW >= body__ * rejWickBodyMult
rejWickShort = upperW >= body__ * rejWickBodyMult

rejEma = rejEmaSrc == "EMA21" ? ema21 : rejEmaSrc == "EMA13" ? emaMid : ema8

rejEmaLong  = close > rejEma
rejEmaShort = close < rejEma

rejLongOK_raw = rejMode == "Wick"       ? rejWickLong  : rejMode == "EMA Reclaim"? rejEmaLong   : (rejWickLong or rejEmaLong)

rejShortOK_raw = rejMode == "Wick"       ? rejWickShort : rejMode == "EMA Reclaim"? rejEmaShort  : (rejWickShort or rejEmaShort)

rejLongOK  = (not useAddOn_Rejection) ? true : (rejLongOK_raw  and (not rejNeedBullCloseL or close >= open))
rejShortOK = (not useAddOn_Rejection) ? true : (rejShortOK_raw and (not rejNeedBearCloseS or close <= open))

// Final add-on gates (Base entries only)
addOnsOK_Long  = phaseLevelOK_Long and stDistOK and rejLongOK and pdzProxOK_Long
addOnsOK_Short = phaseLevelOK_Short and stDistOK and rejShortOK and pdzProxOK_Short

// Cloud
cloudBull = ema5>ema9 and ema9>ema21
cloudBear = ema5<ema9 and ema9<ema21
cloudEntryOK_Long  = cloudEntryMode=="Off" or cloudBull
cloudEntryOK_Short = cloudEntryMode=="Off" or cloudBear

// Session score (purely: are we inside Day/Time windows?)
sessionScore = entriesWindowOK ? 1.0 : 0.0

// Session gate is purely Day/Time windows in v1
sessionOK_Long  = entriesWindowOK
sessionOK_Short = entriesWindowOK



crossForGuardU = useHTFRouting ? ltfCrossU : crossUp_FastSlow
crossForGuardD = useHTFRouting ? ltfCrossD : crossDn_FastSlow
crossPxUp  = ta.valuewhen(crossForGuardU, close, 0)
crossPxDn  = ta.valuewhen(crossForGuardD, close, 0)
barsSinceUp = ta.barssince(crossForGuardU)
barsSinceDn = ta.barssince(crossForGuardD)
ticksFrom(px) => math.abs(close-px)/syminfo.mintick
chaseOK_Long  = not useChaseGuard or (not na(crossPxUp)  and barsSinceUp<=maxChaseBarsFromX  and ticksFrom(crossPxUp)<=maxChaseTicksFromX)
chaseOK_Short = not useChaseGuard or (not na(crossPxDn) and barsSinceDn<=maxChaseBarsFromX and ticksFrom(crossPxDn)<=maxChaseTicksFromX)


// Simple (non-eased) pass flags for debug telemetry
sepPassL  = ltfSepOK
sepPassS  = ltfSepOK

proxPassL = not useProximityToEMA or proxOK
proxPassS = not useProximityToEMA or proxOK

atrPassL  = not useATRfloor or atrOK_raw
atrPassS  = not useATRfloor or atrOK_raw

adxPassL  = not useADXStrength or adxOK_raw
adxPassS  = not useADXStrength or adxOK_raw

nPassL    = not useNClosesBeyondEMA or nBeyond_Long
nPassS    = not useNClosesBeyondEMA or nBeyond_Short





// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  I) RISK / REWARD GATE (ATR 61.8/100 + SUPERTREND)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_rr_day_ATR() =>
   _ATRd = request.security(syminfo.tickerid,"D",ta.atr(14),barmerge.gaps_off,barmerge.lookahead_off)
   _PCd  = request.security(syminfo.tickerid,"D",close[1],  barmerge.gaps_off,barmerge.lookahead_off)
   [_ATRd,_PCd]

_rr_tp_long(_ep) =>
   [_ATRd,_PCd] = _rr_day_ATR()
   _c1 = _PCd + 0.618*_ATRd
   _c2 = _PCd + 1.000*_ATRd
   float _atrCand = na
   if _c1>_ep and _c2>_ep
       _atrCand := math.min(_c1,_c2)
   else
       _atrCand := _c1>_ep ? _c1 : _c2>_ep ? _c2 : na
   float _stCand = na
   if stBiasLong and not na(stLine) and stLine>_ep
       _stCand := stLine
   float _res = na
   if not na(_atrCand) and _atrCand>_ep
       _res := _atrCand
   if not na(_stCand) and _stCand>_ep
       _res := na(_res)?_stCand:math.min(_res,_stCand)
   _res

_rr_tp_short(_ep) =>
   [_ATRd,_PCd] = _rr_day_ATR()
   _c1 = _PCd - 0.618*_ATRd
   _c2 = _PCd - 1.000*_ATRd
   float _atrCand = na
   if _c1<_ep and _c2<_ep
       _atrCand := math.max(_c1,_c2)
   else
       _atrCand := _c1<_ep ? _c1 : _c2<_ep ? _c2 : na
   float _stCand = na
   if stBiasShort and not na(stLine) and stLine<_ep
       _stCand := stLine
   float _res = na
   if not na(_atrCand) and _atrCand<_ep
       _res := _atrCand
   if not na(_stCand) and _stCand<_ep
       _res := na(_res)?_stCand:math.max(_res,_stCand)
   _res

rr_long() =>
   _ep = f_to_tick(close)
   _sl = _ep - riskTicksDefault*syminfo.mintick
   _tp = _rr_tp_long(_ep)
   _risk = math.abs(_ep-_sl)
   _gain = na(_tp)?na:math.abs(_tp-_ep)
   _risk<=0 or na(_gain)?0.0:_gain/_risk

rr_short() =>
   _ep = f_to_tick(close)
   _sl = _ep + riskTicksDefault*syminfo.mintick
   _tp = _rr_tp_short(_ep)
   _risk = math.abs(_ep-_sl)
   _gain = na(_tp)?na:math.abs(_ep-_tp)
   _risk<=0 or na(_gain)?0.0:_gain/_risk

var float rrLongVal  = na
var float rrShortVal = na
rrLongVal  := rr_long()
rrShortVal := rr_short()

rrOK_Long  = not useRRFilter or rrLongVal>=minRR
rrOK_Short = not useRRFilter or rrShortVal>=minRR

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LATE ENTRY â€” APPLY CORE + SESSION GATES (finalize lateEntryLong/Short)
//  Must be AFTER core vars (sep/prox/atr/adx/cloud/chase/rr/etc) exist.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lateSession_Long  = entriesWindowOK
lateSession_Short = entriesWindowOK

lateCoreFilter_Long =
    ltfSepOK and
    (not useProximityToEMA or proxOK) and
    atrOK_late and
    (not useADXStrength or adxOK_raw) and
    (not useNClosesBeyondEMA or nBeyond_Long) and
    wickBiasOK_Long and
    barDirOK_Long and
    priceSideOK_Long and
    cloudEntryOK_Long and
    rrOK_Long and
    (not recentBearDiv)

lateCoreFilter_Short =
    ltfSepOK and
    (not useProximityToEMA or proxOK) and
    atrOK_late and
    (not useADXStrength or adxOK_raw) and
    (not useNClosesBeyondEMA or nBeyond_Short) and
    wickBiasOK_Short and
    barDirOK_Short and
    priceSideOK_Short and
    cloudEntryOK_Short and
    rrOK_Short and
    (not recentBullDiv)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LTF Score Validation (must be before late entry logic)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TimedTrading_Lab daily anchors (PCd/ATRd) + Golden Gate bands
tt_daily_anchors() =>
   [close[1], ta.atr(14)]
[tt_PCd, tt_ATRd] = request.security(syminfo.tickerid, "D", tt_daily_anchors(), barmerge.gaps_off, barmerge.lookahead_off)
tt_GGup = tt_PCd + ggATRmult * tt_ATRd
tt_GGdn = tt_PCd - ggATRmult * tt_ATRd

// Helper: LTF score calculation (reuses compression and slope from existing calculations)
// Accepts compression, slope, Golden Gate, and squeeze state as parameters to avoid duplicate requests
// OPTIMIZED: Accepts pre-calculated close and EMAs to reduce requests
// LTF Score calculation - EXACTLY matching TimedTrading_Lab logic
f_get_ltf_score_simple(tf, atrDaily, pcDaily, ggUp, ggDn, stSlopeUp, stSlopeDn, isCompressed, ggDist, ggUpCross, ggDnCross, sqOn, sqRelease, mom, momStd, volRatio, rsi, atrRatio, _close, _e21, _e48, _e5, _e13, _stLine, _stDir) =>
   // Trigger (squeeze release + momentum) - EXACT match
   _relDir = sqRelease ? (mom >= 0 ? 1 : -1) : 0
   _momStrength = (momStd > 0) ? math.min(1.5, math.abs(mom) / momStd) : 1.0
   _trig = sqRelease ? (_relDir == 1 ? 8.0 : -8.0) * _momStrength : 0.0

   // DISTANCE-BASED GOLDEN GATE (vs binary cross) - EXACT match
   _gg = 0.0
   if useGoldenGate
       if ggDistanceMode
           // Distance-based scoring
           if ggDist > 0.8
               _gg += 6.0
           if ggDist < 0.2
               _gg -= 4.0
           // Proximity bonus
           if math.abs(_close - ggUp) < atrDaily * 0.1
               _gg += 2.0
           if math.abs(_close - ggDn) < atrDaily * 0.1
               _gg -= 2.0
       else
           // Binary cross (original)
           _gg += ggUpCross ? 8.0 : 0.0
           _gg += ggDnCross ? -8.0 : 0.0
   _trigger = _trig + _gg

   // Alignment - EXACT match
   _align = (_close >= _e21 ? 6.0 : -6.0) + (_close >= _e48 ? 6.0 : -6.0)
   _bullStack = (_e5 > _e13) and (_e13 > _e21) and (_e21 > _e48)
   _bearStack = (_e5 < _e13) and (_e13 < _e21) and (_e21 < _e48)
   _align += (_bullStack ? 3.0 : _bearStack ? -3.0 : 0.0)

   // GRADUATED SUPERTREND SUPPORT (distance-based) - EXACT match
   _stDist = atrRatio > 0 ? math.abs(_close - _stLine) / (atrRatio * atrDaily) : 999
   _stSupport = 0.0
   if _stDir < 0 and stSlopeUp and _close > _stLine
       _stSupport := 10.0 * math.max(0, 1.0 - _stDist / 2.0)  // Fade with distance
   if _stDir > 0 and stSlopeDn and _close < _stLine
       _stSupport := -10.0 * math.max(0, 1.0 - _stDist / 2.0)

   // RSI MEAN REVERSION COMPONENT - EXACT match
   _meanRev = rsi > 70 ? -4.0 : (rsi < 30 ? 4.0 : 0.0)

   // Guard (compression/squeeze) - EXACT match
   _guard = (sqOn ? -3.0 : 0.0) + (isCompressed ? -2.0 : 0.0)

   // Full score: trigger + alignment + ST support + meanRev + guard - EXACT match
   math.max(-50, math.min(50, _trigger + _align + _stSupport + _meanRev + _guard))

// TimedTrading_Lab v2.5.0 LTF score (direct port).
// Note: We compute `release` and `stSlopeUp/Dn` from the passed series to match the indicator.
f_ltf_from_bundle_tt(px, sqOn, sqRelease, mom, momStd, ggUpCross, ggDnCross, ggDist, e21, e48, e5, e13, stLine, stDir, stSlopeUp, stSlopeDn, comp, rsi, atrRatio, ATRd, GGup, GGdn) =>
   // Trigger (release is computed inside the TF bundle, matching TimedTrading_Lab)
   relDir = sqRelease ? (mom >= 0 ? 1 : -1) : 0
   momStrength = (momStd > 0) ? math.min(1.5, math.abs(mom) / momStd) : 1.0
   trig = sqRelease ? (relDir == 1 ? 8.0 : -8.0) * momStrength : 0.0

   // Golden Gate
   gg = 0.0
   if useGoldenGate
       if ggDistanceMode
           if ggDist > 0.8
               gg += 6.0
           if ggDist < 0.2
               gg -= 4.0
           if math.abs(px - GGup) < ATRd * 0.1
               gg += 2.0
           if math.abs(px - GGdn) < ATRd * 0.1
               gg -= 2.0
       else
           gg += ggUpCross ? 8.0 : 0.0
           gg += ggDnCross ? -8.0 : 0.0
   trigger = trig + gg

   // Alignment
   align = (px >= e21 ? 6.0 : -6.0) + (px >= e48 ? 6.0 : -6.0)
   bullStack = (e5 > e13) and (e13 > e21) and (e21 > e48)
   bearStack = (e5 < e13) and (e13 < e21) and (e21 < e48)
   align += (bullStack ? 3.0 : bearStack ? -3.0 : 0.0)

   // SuperTrend support (distance-faded)
   stDist = atrRatio > 0 ? math.abs(px - stLine) / (atrRatio * ATRd) : 999
   stSupport = 0.0
   if stDir < 0 and stSlopeUp and px > stLine
       stSupport := 10.0 * math.max(0, 1.0 - stDist / 2.0)
   if stDir > 0 and stSlopeDn and px < stLine
       stSupport := -10.0 * math.max(0, 1.0 - stDist / 2.0)

   // Mean reversion
   meanRev = rsi > 70 ? -4.0 : (rsi < 30 ? 4.0 : 0.0)

   // Guard
   guard = (sqOn ? -3.0 : 0.0) + (comp ? -2.0 : 0.0)

   math.max(-50, math.min(50, trigger + align + stSupport + meanRev + guard))

// Helper functions for LTF score calculation (must be defined outside if blocks)
// Bundle function to get all LTF data in one request.security call (matching TimedTrading_Lab)
// Bundle computed INSIDE the TF so release/cross match TimedTrading behavior
f_ltf_bundle(tfStr, _sqLen, _momLen, _PCd, _GGup, _GGdn) =>
   _close = close
   _e5 = ta.ema(close, 5)
   _e13 = ta.ema(close, 13)
   _e21 = ta.ema(close, 21)
   _e48 = ta.ema(close, 48)
   [_stLine, _stDir] = ta.supertrend(ttStFac, ttStLen)
   _stSlopeUp = _stLine > _stLine[1]
   _stSlopeDn = _stLine < _stLine[1]

   // Squeeze
   _basis = ta.sma(close, _sqLen)
   _dev = ttBbMult * ta.stdev(close, _sqLen)
   _bbU = _basis + _dev
   _bbL = _basis - _dev
   _atrKC = ta.atr(_sqLen)
   _kcU = _basis + ttKcMult * _atrKC
   _kcL = _basis - ttKcMult * _atrKC
   _sqOn = (_bbU < _kcU) and (_bbL > _kcL)
   _sqPrev = bar_index > 0 ? _sqOn[1] : false
   _sqRelease = _sqPrev and not _sqOn

   // Momentum
   _mom = ta.linreg(close - ta.sma(close, _momLen), _momLen, 0)
   _momStd = ta.stdev(_mom, 20)

   // Volume ratio
   _vol = volume
   _volSma = ta.sma(_vol, 20)
   _volRatio = _volSma > 0 ? _vol / _volSma : 1.0

   // RSI
   _rsi = ta.rsi(close, 14)

   // ATR ratio
   _atr14 = ta.atr(14)
   _atrSma = ta.sma(_atr14, 20)
   _atrRatio = _atrSma > 0 ? _atr14 / _atrSma : 1.0

   // Compression (simplified - using existing logic)
   _piv = ta.ema(close, 21)
   _a14 = ta.atr(14)
   _bbo = 2.0 * ta.stdev(close, 21)
   _bup = _piv + _bbo
   _bdn = _piv - _bbo
   _ctU = _piv + (2.0 * _a14)
   _ctD = _piv - (2.0 * _a14)
   _exU = _piv + (1.854 * _a14)
   _exD = _piv - (1.854 * _a14)
   _above = close >= _piv
   _comp = _above ? (_bup - _ctU) : (_ctD - _bdn)
   _inExp = _above ? (_bup - _exU) : (_exD - _bdn)
   _expanding = bar_index > 0 ? (_comp[1] <= _comp) : false
   _compressed = (not (_expanding and _inExp > 0)) and (_comp <= 0)

   // IMPORTANT: GG crosses computed on TF stream
   _ggUpCross = ta.crossover(_close, _GGup)
   _ggDnCross = ta.crossunder(_close, _GGdn)
   // GG distance (TimedTrading_Lab)
   _ggDist = 0.5
   _span = (_GGup - _GGdn)
   if _span > 0
       _ggDist := math.max(0, math.min(1,
            _close >= _PCd ? ((_close - _GGdn) / _span) : ((_GGup - _close) / _span)
       ))

   [_close, _e5, _e13, _e21, _e48, _stLine, _stDir, _stSlopeUp, _stSlopeDn, _sqOn, _sqRelease, _mom, _momStd, _volRatio, _rsi, _atrRatio, _compressed, _ggUpCross, _ggDnCross, _ggDist]

_calc_squeeze(tfStr, sqLen) =>
   _basis = request.security(syminfo.tickerid, tfStr, ta.sma(close, sqLen), barmerge.gaps_off, barmerge.lookahead_off)
   _dev = request.security(syminfo.tickerid, tfStr, 2.0 * ta.stdev(close, sqLen), barmerge.gaps_off, barmerge.lookahead_off)
   _atrKC = request.security(syminfo.tickerid, tfStr, ta.atr(sqLen), barmerge.gaps_off, barmerge.lookahead_off)
   _bbU = _basis + _dev
   _bbL = _basis - _dev
   _kcU = _basis + 1.5 * _atrKC
   _kcL = _basis - 1.5 * _atrKC
   _sqOn = (_bbU < _kcU) and (_bbL > _kcL)
   _sqOnPrev = request.security(syminfo.tickerid, tfStr, _sqOn[1], barmerge.gaps_off, barmerge.lookahead_off)
   [_sqOn, _sqOnPrev and not _sqOn]

// Get LTF scores from multiple timeframes (weighted average like TimedTrading_Lab)
float ltfScorePrevForDelta = na
float ltfScoreDeltaPrev = na
var bool sq30Prev_ltf = false

// Initialize defaults (will be overwritten if validation is enabled)
ltfScore30m = 0.0
ltfScore10m = 0.0
ltfScore3m = 0.0
ltfScoreCombined = 0.0
ltfScoreCrossAboveZero = false
ltfScoreCrossBelowZero = false
ltfScoreNearZero = false

// Compute TT LTF score bundle if needed by any LTF-score-based gate(s) OR logger/debug
if useLTFScoreValidation or dbgPlotTTLTFScore
   // Resolve LTF timeframes + weights (TimedTrading_Lab match)
   [_tf30, _tf10, _tf3] = tt_pick_ltf_tfs()
   [w30_adj, w10_adj, w3_adj] = tt_session_adjusted_ltf_weights(ttW30, ttW10, ttW3)

   // Get bundle data for each timeframe (TimedTrading_Lab match)
   [_close30m, _e5_30m, _e13_30m, _e21_30m, _e48_30m, st30m_line, st30m_dir, st30m_slopeUp, st30m_slopeDn, _sq30m_on_raw, _sq30m_release, _mom30m, _mom30mStd, _volR30m, _rsi30m, _atrR30m, comp_30m, _ggUpCross30m, _ggDnCross30m, _ggDist30m] =
        request.security(syminfo.tickerid, _tf30, f_ltf_bundle(_tf30, sqLen_ltf, momLen_ltf, tt_PCd, tt_GGup, tt_GGdn), barmerge.gaps_off, barmerge.lookahead_off)
   [_close10m, _e5_10m, _e13_10m, _e21_10m, _e48_10m, st10m_line_ltf, st10m_dir_ltf, st10m_slopeUp, st10m_slopeDn, _sq10m_on_raw, _sq10m_release, _mom10m, _mom10mStd, _volR10m, _rsi10m, _atrR10m, comp_10m, _ggUpCross10m, _ggDnCross10m, _ggDist10m] =
        request.security(syminfo.tickerid, _tf10, f_ltf_bundle(_tf10, sqLen_ltf, momLen_ltf, tt_PCd, tt_GGup, tt_GGdn), barmerge.gaps_off, barmerge.lookahead_off)
   [_close3m, _e5_3m, _e13_3m, _e21_3m, _e48_3m, st3m_line_ltf, st3m_dir_ltf, st3m_slopeUp, st3m_slopeDn, _sq3m_on_raw, _sq3m_release, _mom3m, _mom3mStd, _volR3m, _rsi3m, _atrR3m, _comp_3m, _ggUpCross3m, _ggDnCross3m, _ggDist3m] =
        request.security(syminfo.tickerid, _tf3, f_ltf_bundle(_tf3, sqLen_ltf, momLen_ltf, tt_PCd, tt_GGup, tt_GGdn), barmerge.gaps_off, barmerge.lookahead_off)

   // Squeeze series (release is computed inside the TF bundle to match TimedTrading_Lab)
   _sq30m_on = _sq30m_on_raw
   _sq10m_on = _sq10m_on_raw
   _sq3m_on  = _sq3m_on_raw

   // Calculate LTF scores for each timeframe (TimedTrading_Lab match)
   ltfScore30m := f_ltf_from_bundle_tt(_close30m, _sq30m_on, _sq30m_release, _mom30m, _mom30mStd, _ggUpCross30m, _ggDnCross30m, _ggDist30m, _e21_30m, _e48_30m, _e5_30m, _e13_30m, st30m_line, st30m_dir, st30m_slopeUp, st30m_slopeDn, comp_30m, _rsi30m, _atrR30m, tt_ATRd, tt_GGup, tt_GGdn)
   ltfScore10m := f_ltf_from_bundle_tt(_close10m, _sq10m_on, _sq10m_release, _mom10m, _mom10mStd, _ggUpCross10m, _ggDnCross10m, _ggDist10m, _e21_10m, _e48_10m, _e5_10m, _e13_10m, st10m_line_ltf, st10m_dir_ltf, st10m_slopeUp, st10m_slopeDn, comp_10m, _rsi10m, _atrR10m, tt_ATRd, tt_GGup, tt_GGdn)
   ltfScore3m  := f_ltf_from_bundle_tt(_close3m,  _sq3m_on,  _sq3m_release,  _mom3m,  _mom3mStd,  _ggUpCross3m,  _ggDnCross3m,  _ggDist3m,  _e21_3m,  _e48_3m,  _e5_3m,  _e13_3m,  st3m_line_ltf,  st3m_dir_ltf,  st3m_slopeUp,  st3m_slopeDn,  _comp_3m,  _rsi3m,  _atrR3m,  tt_ATRd, tt_GGup, tt_GGdn)

   // Weighted LTF score (TimedTrading_Lab match) + clamp
   ltfScoreCombined := clamp(ltfScore30m * w30_adj + ltfScore10m * w10_adj + ltfScore3m * w3_adj, -50, 50)

   // "Prev" should match TimedTrading_Lab: previous bar's LTF score.
   ltfScorePrevForDelta := na(ltfScoreCombined[1]) ? ltfScoreCombined : ltfScoreCombined[1]
   ltfScoreDeltaPrev := ltfScoreCombined - ltfScorePrevForDelta

   // Track LTF score for cross detection (near zero check moved to validation logic)
   ltfScoreCrossAboveZero := ltfScorePrevForDelta <= 0.0 and ltfScoreCombined > 0.0
   ltfScoreCrossBelowZero := ltfScorePrevForDelta >= 0.0 and ltfScoreCombined < 0.0

// LTF Score validation for entries
// When disabled, always allow entries. When enabled, check conditions.
ltfScoreOK_Long = true
ltfScoreOK_Short = true

if useLTFScoreValidation
   // Ensure ltfScoreCombined is valid (not na)
   _scoreValid = not na(ltfScoreCombined)

   // Determine if score is "near zero" (within threshold - neutral/breakout zone)
   // This should be calculated FIRST before slope calculations
   ltfScoreNearZero := _scoreValid and (math.abs(ltfScoreCombined) <= ltfScoreNearZeroThreshold)

   // Track score slope/direction for additional context (prevâ†’now delta)
   ltfScoreSlope = _scoreValid and not na(ltfScoreDeltaPrev) ? ltfScoreDeltaPrev : 0.0
   ltfScoreRising = ltfScoreSlope > 0
   ltfScoreFalling = ltfScoreSlope < 0

   // Exhaustion signals: Score moving in our favor but hasn't crossed zero yet
   // Short exhaustion: Score declining but still above threshold (long exhaustion - good for shorts)
   ltfScoreShortExhaustion = _scoreValid and ltfScoreAllowExhaustion and ltfScoreFalling and (ltfScoreCombined > ltfScoreNearZeroThreshold)
   // Long exhaustion: Score rising but still below -threshold (short exhaustion - good for longs)
   ltfScoreLongExhaustion = _scoreValid and ltfScoreAllowExhaustion and ltfScoreRising and (ltfScoreCombined < -ltfScoreNearZeroThreshold)

   // Longs: Favorable if:
   // 1. Score is above zero (bullish regime), OR
   // 2. Score is near zero (within threshold - could be breakout), OR
   // 3. Score is crossing above zero (especially favorable), OR
   // 4. Score is rising below -threshold (short exhaustion - reversal opportunity)
   // If strict mode enabled, require cross above 0
   if ltfScoreRequireCrossForLong
       ltfScoreOK_Long := _scoreValid and ltfScoreCrossAboveZero
   else
       ltfScoreOK_Long := _scoreValid and ((ltfScoreCombined > 0) or ltfScoreNearZero or ltfScoreCrossAboveZero or ltfScoreLongExhaustion)

   // Shorts: Favorable if:
   // 1. Score is below zero (bearish regime), OR
   // 2. Score is near zero (within threshold - could be breakout), OR
   // 3. Score is crossing below zero (especially favorable), OR
   // 4. Score is declining above threshold (long exhaustion - reversal opportunity)
   // If strict mode enabled, require cross below 0
   if ltfScoreRequireCrossForShort
       ltfScoreOK_Short := _scoreValid and ltfScoreCrossBelowZero
   else
       ltfScoreOK_Short := _scoreValid and ((ltfScoreCombined < 0) or ltfScoreNearZero or ltfScoreCrossBelowZero or ltfScoreShortExhaustion)

// Late uses 1m ST as confirm-only (already handled in lateSignal*_raw),
// but still obeys RSI entry filter, chase guard, HTF bias, session, impulse, cooldown.
lateCore_Long =
    lateSession_Long and
    rsiEntryLongOK and
    chaseOK_Long and
    lateCoreFilter_Long and
    (not htfEMA_ApplyToEntries or htfPersistLongOK) and
    ltfScoreOK_Long

lateCore_Short =
    lateSession_Short and
    rsiEntryShortOK and
    chaseOK_Short and
    lateCoreFilter_Short and
    (not htfEMA_ApplyToEntries or htfPersistShortOK) and
    ltfScoreOK_Short

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  J) SCORE-BASED BYPASS FLAGS (DISABLED v1 - TELEMETRY ONLY)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
htfBiasL = not htfEMA_ApplyToEntries or htfPersistLongOK
htfBiasS = not htfEMA_ApplyToEntries or htfPersistShortOK

failed_Sep_L   = not ltfSepOK
failed_Sep_S   = not ltfSepOK
failed_Prox    = useProximityToEMA and not proxOK
failed_ATR     = useATRfloor and not atrOK_raw
failed_Chop    = useChopCounter and not chopOK
failed_ADX     = useADXStrength and not adxOK_raw

// No score-based bypass in v1
bypass_Long  = false
bypass_Short = false

// EMA reclaim conditions (only relevant when armed entry is enabled)
reclaimOK_Long  = (not armUseEmaReclaim) or (close > armEma)
reclaimOK_Short = (not armUseEmaReclaim) or (close < armEma)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  STRUCTURE VALIDATION â€” Enhanced Entry Quality Checks
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Track Phase dots for lookback
var int lastPhaseDotLongBar = na
var int lastPhaseDotShortBar = na

if phaseDotLong
   lastPhaseDotLongBar := bar_index
if phaseDotShort
   lastPhaseDotShortBar := bar_index

// Check if Phase dot occurred prior to cross (within lookback window)
phaseDotPrior_Long = not requirePhaseDotPrior or (not na(lastPhaseDotShortBar) and (bar_index - lastPhaseDotShortBar <= phaseDotLookbackBars))
phaseDotPrior_Short = not requirePhaseDotPrior or (not na(lastPhaseDotLongBar) and (bar_index - lastPhaseDotLongBar <= phaseDotLookbackBars))

// Track TD9 occurrences (TD Sequential Prep reaching 9)
// Use entry-side TD counts (tdxPrepLen defaults to 9)
var int lastTD9BullishBar = na
var int lastTD9BearishBar = na

// TD9 occurs when prep count transitions TO 9 (tdxPrepLen)
// Only trigger when it first reaches 9, not while it stays at 9
td9Bullish = _tdx_bull_prep_e == tdxPrepLen and nz(_tdx_bull_prep_e[1]) < tdxPrepLen
td9Bearish = _tdx_bear_prep_e == tdxPrepLen and nz(_tdx_bear_prep_e[1]) < tdxPrepLen

if td9Bullish
   lastTD9BullishBar := bar_index
if td9Bearish
   lastTD9BearishBar := bar_index

// Check if TD9 occurred prior to cross (within lookback window)
// For LONG: need bullish TD9 (supportive of upward move)
// For SHORT: need bearish TD9 (supportive of downward move)
td9Prior_Long = not requireTD9 or (not na(lastTD9BullishBar) and (bar_index - lastTD9BullishBar <= td9LookbackBars))
td9Prior_Short = not requireTD9 or (not na(lastTD9BearishBar) and (bar_index - lastTD9BearishBar <= td9LookbackBars))

// 3m ST check for base entries (similar to late entry logic)
st3m_dir_base  = f_st_dir_tf(ltfTF, mtfST_1m_fac, mtfST_1m_atr)
st3m_line_base = f_st_line_tf(ltfTF, mtfST_1m_fac, mtfST_1m_atr)
st3m_slopeUp_base = not na(st3m_line_base) and st3m_line_base > nz(st3m_line_base[1])
st3m_slopeDn_base = not na(st3m_line_base) and st3m_line_base < nz(st3m_line_base[1])

// 3m ST supportive with slope
st3mSupportive_Long = not require3mSTSupport or (st3m_dir_base < 0 and (st3m_slopeUp_base or st3m_slopeUp_base[1] or st3m_slopeUp_base[2]))
st3mSupportive_Short = not require3mSTSupport or (st3m_dir_base > 0 and (st3m_slopeDn_base or st3m_slopeDn_base[1] or st3m_slopeDn_base[2]))

// 1m ST check (already exists via mtfST_1m_gateLong_final, but add explicit check)
st1mSupportive_Long = not require1mSTSupport or mtfST_1m_gateLong_final
st1mSupportive_Short = not require1mSTSupport or mtfST_1m_gateShort_final

// 1m ST slope check (for structure validation)
var int st1m_slopeUpRun_struct = 0
var int st1m_slopeDnRun_struct = 0
st1m_slopeTicks_struct = mtfST_use_1m and not na(mtfST_1m_line) and not na(mtfST_1m_line[1]) ?
                        (mtfST_1m_line - mtfST_1m_line[1]) / syminfo.mintick : 0.0
st1m_slopeUpRun_struct := require1mSTSlope and mtfST_use_1m and st1m_slopeTicks_struct > require1mSTSlopeTicks ? nz(st1m_slopeUpRun_struct[1]) + 1 : 0
st1m_slopeDnRun_struct := require1mSTSlope and mtfST_use_1m and st1m_slopeTicks_struct < -require1mSTSlopeTicks ? nz(st1m_slopeDnRun_struct[1]) + 1 : 0
st1mSlopeOK_Long = not require1mSTSlope or (mtfST_use_1m and st1m_slopeUpRun_struct >= require1mSTSlopeBars)
st1mSlopeOK_Short = not require1mSTSlope or (mtfST_use_1m and st1m_slopeDnRun_struct >= require1mSTSlopeBars)

// 3m ST slope check (for structure validation)
var int st3m_slopeUpRun_struct = 0
var int st3m_slopeDnRun_struct = 0
st3m_slopeTicks_struct = not na(st3m_line_base) and not na(st3m_line_base[1]) ?
                        (st3m_line_base - st3m_line_base[1]) / syminfo.mintick : 0.0
st3m_slopeUpRun_struct := require3mSTSlope and st3m_slopeTicks_struct > require3mSTSlopeTicks ? nz(st3m_slopeUpRun_struct[1]) + 1 : 0
st3m_slopeDnRun_struct := require3mSTSlope and st3m_slopeTicks_struct < -require3mSTSlopeTicks ? nz(st3m_slopeDnRun_struct[1]) + 1 : 0
st3mSlopeOK_Long = not require3mSTSlope or (st3m_slopeUpRun_struct >= require3mSTSlopeBars)
st3mSlopeOK_Short = not require3mSTSlope or (st3m_slopeDnRun_struct >= require3mSTSlopeBars)

// FVG support check (use current close or cross price if available)
var float crossPriceLong = na
var float crossPriceShort = na
if ltfCrossU
   crossPriceLong := close
if ltfCrossD
   crossPriceShort := close

// Combined structure validation
structureOK_Long = not useStructureCheck or (phaseDotPrior_Long and st1mSupportive_Long and st3mSupportive_Long and td9Prior_Long)
structureOK_Short = not useStructureCheck or (phaseDotPrior_Short and st1mSupportive_Short and st3mSupportive_Short and td9Prior_Short)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  V2: CROSS QUALITY SCORE (0-100) - Good Cross vs Bad Cross
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupCrossScore = "V2: Cross Quality Score"
crossScoreEnable = input.bool(true, "Enable Cross Quality Score", group=groupCrossScore)
crossScoreMode = input.string("Score + Filters", "Entry Mode", options=["Score-Based", "Full Filters", "Score + Filters"], group=groupCrossScore,
   tooltip="Score-Based: Only score. Full Filters: All filters. Score + Filters: Both must pass (RECOMMENDED).")
crossScoreThreshold = input.int(60, "Min score for Base Entry", minval=0, maxval=100, group=groupCrossScore)
crossScorePullbackThreshold = input.int(40, "Min score for Pullback Entry", minval=0, maxval=100, group=groupCrossScore)

// Cross Quality Score (calculated at each cross)
var float crossScoreLong = 0.0
var float crossScoreShort = 0.0

// Calculate volume SMA once per bar (fixes Pine Script warning)
volSMA = ta.sma(volume, 20)

if ltfCrossU
   // BASE (30 points)
   _sepScore = math.min(10, (math.abs(emaFast - emaSlow) / (atr * 0.5)) * 10)
   _volScore = volume > volSMA ? 10 : volume > volSMA * 0.8 ? 5 : 0
   _notExtended = close < ema5 + (atr * 2) ? 10 : close < ema5 + (atr * 3) ? 5 : 0
   // CONTEXT (40 points)
   _st1mScore = st1m_supportsLong ? (st1m_isSloping ? 10 : 5) : 0
   _st3mScore = st3m_supportsLong ? (st3m_isSloping ? 10 : 5) : 0
   _st10mScore = st10m_supportsLong ? 10 : 0
   _orbScore = orb_aboveRange ? 10 : orb_insideRange ? 5 : 0
   // CONFIRMATION (30 points)
   _regimeScore = regimeIsUptrend ? 15 : regimeIsNeutral ? 8 : 0
   _followThrough = close > open and close > close[1] ? 15 : close > open ? 8 : 0
   crossScoreLong := _sepScore + _volScore + _notExtended + _st1mScore + _st3mScore + _st10mScore + _orbScore + _regimeScore + _followThrough

if ltfCrossD
   // BASE (30 points)
   _sepScore = math.min(10, (math.abs(emaFast - emaSlow) / (atr * 0.5)) * 10)
   _volScore = volume > volSMA ? 10 : volume > volSMA * 0.8 ? 5 : 0
   _notExtended = close > ema5 - (atr * 2) ? 10 : close > ema5 - (atr * 3) ? 5 : 0
   // CONTEXT (40 points)
   _st1mScore = st1m_supportsShort ? (st1m_isSloping ? 10 : 5) : 0
   _st3mScore = st3m_supportsShort ? (st3m_isSloping ? 10 : 5) : 0
   _st10mScore = st10m_supportsShort ? 10 : 0
   _orbScore = orb_belowRange ? 10 : orb_insideRange ? 5 : 0
   // CONFIRMATION (30 points)
   _regimeScore = regimeIsDowntrend ? 15 : regimeIsNeutral ? 8 : 0
   _followThrough = close < open and close < close[1] ? 15 : close < open ? 8 : 0
   crossScoreShort := _sepScore + _volScore + _notExtended + _st1mScore + _st3mScore + _st10mScore + _orbScore + _regimeScore + _followThrough

// Score gates
crossScoreOK_BaseLong = (not crossScoreEnable) or (crossScoreLong >= crossScoreThreshold)
crossScoreOK_BaseShort = (not crossScoreEnable) or (crossScoreShort >= crossScoreThreshold)
crossScoreOK_PullbackLong = (not crossScoreEnable) or (crossScoreLong >= crossScorePullbackThreshold)
crossScoreOK_PullbackShort = (not crossScoreEnable) or (crossScoreShort >= crossScorePullbackThreshold)

// Visual: Show score on cross bars
plotchar(ltfCrossU and crossScoreEnable, "L Score", "â–²", location.belowbar,
   color.new(crossScoreLong >= 80 ? color.green : crossScoreLong >= 60 ? color.yellow : crossScoreLong >= 40 ? color.orange : color.red, 0), size=size.tiny)
plotchar(ltfCrossD and crossScoreEnable, "S Score", "â–¼", location.abovebar,
   color.new(crossScoreShort >= 80 ? color.green : crossScoreShort >= 60 ? color.yellow : crossScoreShort >= 40 ? color.orange : color.red, 0), size=size.tiny)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  K) FINAL ENTRY FLAGS (RESTRUCTURED CORE LOGIC)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Primary trigger: either immediate cross, OR armed window still active
longTrigger = ltfCrossU or (useArmWindow and armedL)
shortTrigger = ltfCrossD or (useArmWindow and armedS)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  CORE CHECKS (Always Required)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. Session Window
coreSessionOK_Long = sessionOK_Long
coreSessionOK_Short = sessionOK_Short

// 2. HTF Bias (only if enabled)
coreHTFBiasOK_Long = not htfEMA_Enable or htfLongOK_raw
coreHTFBiasOK_Short = not htfEMA_Enable or htfShortOK_raw

// 3. ATR Floor (only if enabled)
coreATROK_Long = not useATRfloor or atrPassL
coreATROK_Short = not useATRfloor or atrPassS

// 4. Separation (always checked)
coreSepOK_Long = sepPassL
coreSepOK_Short = sepPassS

// Combine core checks
coreChecksOK_Long = coreSessionOK_Long and coreHTFBiasOK_Long and coreATROK_Long and coreSepOK_Long
coreChecksOK_Short = coreSessionOK_Short and coreHTFBiasOK_Short and coreATROK_Short and coreSepOK_Short

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  CONDITIONAL CHECKS (Only if Enabled)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. 1m ST Supportive
cond1mSTSupportOK_Long = not require1mSTSupport or st1mSupportive_Long
cond1mSTSupportOK_Short = not require1mSTSupport or st1mSupportive_Short

// 2. 1m ST Sloping By X Ticks
cond1mSTSlopeOK_Long = not require1mSTSlope or st1mSlopeOK_Long
cond1mSTSlopeOK_Short = not require1mSTSlope or st1mSlopeOK_Short

// 3. 3m ST Supportive
cond3mSTSupportOK_Long = not require3mSTSupport or st3mSupportive_Long
cond3mSTSupportOK_Short = not require3mSTSupport or st3mSupportive_Short

// 4. 3m ST Sloping By X Ticks
cond3mSTSlopeOK_Long = not require3mSTSlope or st3mSlopeOK_Long
cond3mSTSlopeOK_Short = not require3mSTSlope or st3mSlopeOK_Short

// 5. Require Phase Dot prior to Cross
condPhaseDotOK_Long = not requirePhaseDotPrior or phaseDotPrior_Long
condPhaseDotOK_Short = not requirePhaseDotPrior or phaseDotPrior_Short

// 6. LTF Score Validation
condLTFScoreOK_Long = not useLTFScoreValidation or ltfScoreOK_Long
condLTFScoreOK_Short = not useLTFScoreValidation or ltfScoreOK_Short

// 7. LTF Score Momentum (prev bar delta)
condLTFScoreMomentumOK_Long = true
condLTFScoreMomentumOK_Short = true

// 8. Use Armed Entry Window / Reclaim
condArmWindowOK_Long = not useArmWindow or (not armedL or reclaimOK_Long)
condArmWindowOK_Short = not useArmWindow or (not armedS or reclaimOK_Short)

// Combine conditional checks
condChecksOK_Long = cond1mSTSupportOK_Long and cond1mSTSlopeOK_Long and cond3mSTSupportOK_Long and cond3mSTSlopeOK_Long and condPhaseDotOK_Long and condLTFScoreOK_Long and condLTFScoreMomentumOK_Long and condArmWindowOK_Long
condChecksOK_Short = cond1mSTSupportOK_Short and cond1mSTSlopeOK_Short and cond3mSTSupportOK_Short and cond3mSTSlopeOK_Short and condPhaseDotOK_Short and condLTFScoreOK_Short and condLTFScoreMomentumOK_Short and condArmWindowOK_Short

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  FINAL CORE ENTRY LOGIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
baseLong_core0 = longTrigger and coreChecksOK_Long and condChecksOK_Long
baseShort_core0 = shortTrigger and coreChecksOK_Short and condChecksOK_Short

baseLong_core = baseLong_core0
baseShort_core = baseShort_core0


// Core Phoenix entry filters wired in
coreFilter_Long =     sepPassL and     proxPassL and     atrPassL and     adxPassL and     nPassL and     wickBiasOK_Long and     barDirOK_Long and     priceSideOK_Long and     cloudEntryOK_Long and     rrOK_Long and     (not recentBearDiv)   // optional: block longs soon after bear RSI div

coreFilter_Short =     sepPassS and     proxPassS and     atrPassS and     adxPassS and     nPassS and     wickBiasOK_Short and     barDirOK_Short and     priceSideOK_Short and     cloudEntryOK_Short and     rrOK_Short and     (not recentBullDiv)   // optional: block shorts soon after bull RSI div

baseLong_filters  =
    sessionOK_Long and
    rsiEntryLongOK and
    mtfLongOK and
    mtfST_1m_gateLong_final and
    coreFilter_Long and
    addOnsOK_Long and
    phaseLevelOK_Long and
    phaseEntryOK_Long  and
    lastDotOK_Long_Base and
    absOK_Long_Base and
    ltfScoreOK_Long and
    (abortCooldownLateOnly ? true : abortCooldownOK)

baseShort_filters =
    sessionOK_Short and
    rsiEntryShortOK and
    mtfShortOK and
    mtfST_1m_gateShort_final and
    coreFilter_Short and
    addOnsOK_Short and
    phaseLevelOK_Short and
    phaseEntryOK_Short and
    lastDotOK_Short_Base and
    absOK_Short_Base and
    ltfScoreOK_Short and
    (abortCooldownLateOnly ? true : abortCooldownOK)

longEntry_raw  = baseLong_core  and baseLong_filters  and impulseOK
shortEntry_raw = baseShort_core and baseShort_filters and impulseOK

// V2: Apply Cross Quality Score based on mode
longEntry_base = longEntry_raw
shortEntry_base = shortEntry_raw

if crossScoreEnable
   if crossScoreMode == "Score-Based"
       // Score only (bypass filters, use only score + session + impulse)
       longEntry_base := ltfCrossU and crossScoreOK_BaseLong and impulseOK and sessionOK_Long
       shortEntry_base := ltfCrossD and crossScoreOK_BaseShort and impulseOK and sessionOK_Short
   else if crossScoreMode == "Score + Filters"
       // Hybrid: Score AND filters (both must pass)
       longEntry_base := longEntry_raw and crossScoreOK_BaseLong
       shortEntry_base := shortEntry_raw and crossScoreOK_BaseShort
   // "Full Filters" mode: keep longEntry_raw (no score modification)

// Base entry signals
longEntry  = longEntry_base
shortEntry = shortEntry_base


if htfEMA_ApplyToEntries
   longEntry  := longEntry  and htfPersistLongOK
   shortEntry := shortEntry and htfPersistShortOK


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  V2: MEAN REVERSION ENTRY (Pullback to 13-21 EMA Cloud)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// After a cross, price pulls back to test the EMA cloud (13-21 EMA).
// Entry on reclaim of 21 EMA with tight SL.

// Inputs
groupMeanRev = "ENTRY: V2) Mean Reversion (Pullback)"
meanRevEnable = input.bool(false, "Enable Mean Reversion Entry", group=groupMeanRev,
   tooltip="After EMA cross, wait for pullback to 13-21 EMA cloud, then enter on 21 EMA reclaim.")
meanRevArmBars = input.int(10, "Arm window (bars after cross)", minval=3, maxval=20, group=groupMeanRev)
meanRevReclaimConsec = input.int(1, "Reclaim 21 EMA: consec closes", minval=1, maxval=3, group=groupMeanRev)
meanRevRequireCloud = input.bool(true, "Require price to touch 13-21 EMA cloud", group=groupMeanRev,
   tooltip="If true, price must touch the 13-21 EMA range before reclaim triggers. If false, any 21 EMA reclaim after cross works.")
meanRevRequireST = input.bool(true, "Require 1m/3m ST still supportive", group=groupMeanRev)
meanRevRequireStack = input.bool(true, "Require Fast EMA still above/below Slow EMA", group=groupMeanRev,
   tooltip="EMA stack must remain intact (no opposing cross)")

// ARM state for mean reversion
var bool meanRevArmedL = false
var bool meanRevArmedS = false
var int meanRevUntilL = na
var int meanRevUntilS = na
var bool meanRevCloudTouchedL = false
var bool meanRevCloudTouchedS = false

// Track consecutive closes above/below 21 EMA for reclaim
var int meanRevReclaimRunL = 0
var int meanRevReclaimRunS = 0

// Check if price is in/touching 13-21 EMA cloud
// emaMid is the 13 EMA, ema21 already exists
inCloudOrTouch_L = (close >= emaMid and close <= ema21) or (low <= ema21 and low >= emaMid)
inCloudOrTouch_S = (close <= emaMid and close >= ema21) or (high >= ema21 and high <= emaMid)

// Arm on cross (same as base cross)
if barstate.isconfirmed and meanRevEnable
   if ltfCrossU and not meanRevArmedL
       meanRevArmedL := true
       meanRevUntilL := bar_index + meanRevArmBars
       meanRevCloudTouchedL := false
   if ltfCrossD and not meanRevArmedS
       meanRevArmedS := true
       meanRevUntilS := bar_index + meanRevArmBars
       meanRevCloudTouchedS := false

   // Cancel on opposing cross
   if ltfCrossD
       meanRevArmedL := false
       meanRevUntilL := na
       meanRevCloudTouchedL := false
       meanRevReclaimRunL := 0
   if ltfCrossU
       meanRevArmedS := false
       meanRevUntilS := na
       meanRevCloudTouchedS := false
       meanRevReclaimRunS := 0

   // Cancel on timeout
   if meanRevArmedL and not na(meanRevUntilL) and bar_index > meanRevUntilL
       meanRevArmedL := false
       meanRevUntilL := na
       meanRevCloudTouchedL := false
       meanRevReclaimRunL := 0
   if meanRevArmedS and not na(meanRevUntilS) and bar_index > meanRevUntilS
       meanRevArmedS := false
       meanRevUntilS := na
       meanRevCloudTouchedS := false
       meanRevReclaimRunS := 0

// Track cloud touch while armed
if meanRevArmedL and inCloudOrTouch_L
   meanRevCloudTouchedL := true
if meanRevArmedS and inCloudOrTouch_S
   meanRevCloudTouchedS := true

// Track reclaim (consecutive closes above/below 21 EMA)
meanRevReclaimRunL := close > ema21 ? nz(meanRevReclaimRunL[1]) + 1 : 0
meanRevReclaimRunS := close < ema21 ? nz(meanRevReclaimRunS[1]) + 1 : 0

// Mean Reversion conditions
meanRevCloudOK_L = (not meanRevRequireCloud) or meanRevCloudTouchedL
meanRevCloudOK_S = (not meanRevRequireCloud) or meanRevCloudTouchedS

meanRevReclaimOK_L = meanRevReclaimRunL >= meanRevReclaimConsec
meanRevReclaimOK_S = meanRevReclaimRunS >= meanRevReclaimConsec

meanRevST_L = (not meanRevRequireST) or (mtfST_1m_gateLong_final and st3mSupportive_Long)
meanRevST_S = (not meanRevRequireST) or (mtfST_1m_gateShort_final and st3mSupportive_Short)

meanRevStack_L = (not meanRevRequireStack) or (emaFast > emaSlow)
meanRevStack_S = (not meanRevRequireStack) or (emaFast < emaSlow)

// Final Mean Reversion entry signals (V2: add cross score check for pullback threshold)
meanRevEntryLong = meanRevEnable and meanRevArmedL and meanRevCloudOK_L and meanRevReclaimOK_L and meanRevST_L and meanRevStack_L and sessionOK_Long and impulseOK and cooldownLongOK and crossScoreOK_PullbackLong
meanRevEntryShort = meanRevEnable and meanRevArmedS and meanRevCloudOK_S and meanRevReclaimOK_S and meanRevST_S and meanRevStack_S and sessionOK_Short and impulseOK and cooldownShortOK and crossScoreOK_PullbackShort

// Consume mean rev state on entry
if barstate.isconfirmed and meanRevEntryLong
   meanRevArmedL := false
   meanRevUntilL := na
   meanRevCloudTouchedL := false
   meanRevReclaimRunL := 0

if barstate.isconfirmed and meanRevEntryShort
   meanRevArmedS := false
   meanRevUntilS := na
   meanRevCloudTouchedS := false
   meanRevReclaimRunS := 0

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  COMBINED ENTRY SIGNALS
//  - Base = Momentum at cross
//  - Late = ST recovery after missed base
//  - MeanRev = Pullback to cloud and reclaim
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
baseLongEntrySignal  = longEntry
baseShortEntrySignal = shortEntry

// Final LATE entries (single source of truth)
lateEntryLong  = lateST_enable and lateSignalLong_raw  and lateCore_Long  and impulseOK and cooldownLongOK and lastDotOK_Long_Late  and absOK_Long_Late  and abortCooldownOK
lateEntryShort = lateST_enable and lateSignalShort_raw and lateCore_Short and impulseOK and cooldownShortOK and lastDotOK_Short_Late and absOK_Short_Late and abortCooldownOK

// Combined entry signals (BASE OR LATE OR MEANREV)
// Priority: Base > MeanRev > Late (most aggressive to most patient)
longEntrySignal  = baseLongEntrySignal or
                  (meanRevEntryLong and not baseLongEntrySignal) or
                  (lateEntryLong and not baseLongEntrySignal and not meanRevEntryLong)
shortEntrySignal = baseShortEntrySignal or
                  (meanRevEntryShort and not baseShortEntrySignal) or
                  (lateEntryShort and not baseShortEntrySignal and not meanRevEntryShort)

// Consume late state when a late entry fires (prevents repeats + clears baselines)
if barstate.isconfirmed and lateEntryLong
   lateArmedL := false
   lateUntilL := na
   st1m_anchor_L := na
   st3m_anchor_L := na
   badFavCntL := 0
   lateRetestSeenL := false
   lateEma5AtArm_L := na

if barstate.isconfirmed and lateEntryShort
   lateArmedS := false
   lateUntilS := na
   st1m_anchor_S := na
   st3m_anchor_S := na
   badFavCntS := 0
   lateRetestSeenS := false
   lateEma5AtArm_S := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  L) POSITION STATE & SEQUENCING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var float entryPriceLong  = na
var float entryPriceShort = na

var float lastTP_Long  = na
var float lastTP_Short = na
var float lastSL_Long  = na
var float lastSL_Short = na

var int posSeqL = 0
var int posSeqS = 0
var int nextSeq = 1

// â”€â”€ Track whether the currently open position was entered via Late Entry
var bool posIsLateLong  = false
var bool posIsLateShort = false

inLong  = strategy.position_size > 0
inShort = strategy.position_size < 0

inLong  := strategy.position_size > 0
inShort := strategy.position_size < 0

// Reset when flat
if strategy.position_size == 0
   posIsLateLong  := false
   posIsLateShort := false


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X1) FUSE EXITS (RSI / TICK extremes)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ============================================================================
//  EXIT SIDE â€” Inputs & Logic
//  X1) Fuse exits (RSI / TICK extremes)
//  X2) Lux PDZ & ATR Ladder
//  X3) Stops / TP / BE / Early Abort
//  X4) TD Sequencer (exits)
//  X5) Exit Deferrals (compression / Opp-EMA)
//  X7) EMA Exit Pair (emergency)
//  X8) Phase Exit (PO dots / RSI div)
// ============================================================================

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X1) FUSE EXITS â€” HARD (immediate) + SOFT (arm â†’ confirm)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupFuse = "EXIT: X1) Fuse Exits (Hard vs Soft)"

fuseEnable      = input.bool(true,  "Enable Fuse exits", group=groupFuse)

// RSI source for Fuse
fuseRsiEnable   = input.bool(true,  "RSI Fuse", group=groupFuse, inline="r")
fuseRsiTF       = input.string("Chart", "RSI TF", options=["Chart","1","3","5","10","15","60","D"], group=groupFuse, inline="r")
fuseRsiLen      = input.int(5, "Len", minval=2, group=groupFuse, inline="r")

// SOFT thresholds (arm only)
softRsiLong     = input.float(85, "SOFT Long: RSI â‰¥", step=0.1, group=groupFuse, inline="soft")
softRsiShort    = input.float(15.0, "SOFT Short: RSI â‰¤", step=0.1, group=groupFuse, inline="soft")

// HARD thresholds (instant exit)
hardRsiLong     = input.float(90, "HARD Long: RSI â‰¥", step=0.1, group=groupFuse, inline="hard")
hardRsiShort    = input.float(12.0,  "HARD Short: RSI â‰¤", step=0.1, group=groupFuse, inline="hard")

// TICK fuse (optional)
fuseTickEnable  = input.bool(false, "NYSE TICK Fuse", group=groupFuse, inline="t")
fuseTickSymbol  = input.symbol("TICK", "Symbol", group=groupFuse, inline="t")
softTickAbs     = input.int(1000, "SOFT |Abs| â‰¥", minval=200, group=groupFuse, inline="t2")
hardTickAbs     = input.int(1300, "HARD |Abs| â‰¥", minval=200, group=groupFuse, inline="t2")

// What confirms the SOFT Fuse?
groupFuseConfirm = "EXIT: X1a) Soft Fuse Confirm"

useFuseConfirm_1mPhaseDot = input.bool(false,  "Confirm with 1m Phase dot", group=groupFuseConfirm)
useFuseConfirm_EMA3Break  = input.bool(false,  "Backup: EMA(3) break (aggressive)", group=groupFuseConfirm)
useFuseConfirm_MomLoss    = input.bool(true,  "Backup: Momentum loss", group=groupFuseConfirm)

fuseMaxWaitBars           = input.int(6, "Max wait bars after arm (chart bars)", minval=1, group=groupFuseConfirm)

// Momentum-loss tuning (Backup 3)
momLossBars = input.int(2, "RSI rolling bars (â‰¥)", minval=1, group=groupFuseConfirm)
momNeedPriceFail = input.bool(true, "Require price failure vs EMA Fast", group=groupFuseConfirm)

// Values
var float rsiFuse  = na
var float tickFuse = na

rsiFuse  := (fuseEnable and fuseRsiEnable) ? rsi_on_tf(fuseRsiTF, fuseRsiLen) : na
tickFuse := (fuseEnable and fuseTickEnable) ? request.security(fuseTickSymbol, timeframe.period, close, barmerge.gaps_off, barmerge.lookahead_off) : na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LATE EXIT ENGINE â€” Separate tuning for Late positions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupLateExit = "EXIT: Z1) Late Exit Engine Overrides"

// â”€â”€ Late Fuse controls (separate from base Fuse)
lateFuseEnable = input.bool(true, "Late: Enable Late Fuse", group=groupLateExit)

// If ON: late fuse behaves like â€œhard-onlyâ€ (no arming/confirm). If OFF: late fuse mirrors base soft+confirm.
lateUseHardFuseOnly = input.bool(false, "Late: HARD-only (no soft arm)", group=groupLateExit)

// Late RSI bands (separate)
lateSoftRsiLong  = input.float(85.0, "Late SOFT Long: RSI â‰¥", step=0.1, group=groupLateExit)
lateSoftRsiShort = input.float(15.0, "Late SOFT Short: RSI â‰¤", step=0.1, group=groupLateExit)

lateHardRsiLong  = input.float(86.0, "Late HARD Long: RSI â‰¥", step=0.1, group=groupLateExit)
lateHardRsiShort = input.float(14.0, "Late HARD Short: RSI â‰¤", step=0.1, group=groupLateExit)

// Optional: Late tick bands (set = base if you donâ€™t want different)
lateUseTickFuse     = input.bool(false, "Late: Use TICK fuse", group=groupLateExit)
lateSoftTickAbs     = input.int(1000, "Late SOFT |Abs| â‰¥", minval=200, group=groupLateExit)
lateHardTickAbs     = input.int(1300, "Late HARD |Abs| â‰¥", minval=200, group=groupLateExit)

// 2) PDZ (Late)
latePDZ_skipBars   = input.int(0, "Late: PDZ skip bars", minval=0, maxval=40, group=groupLateExit)
latePDZ_oppUseEMA  = input.bool(true, "Late: PDZ Opp-EMA required", group=groupLateExit)

// 3) ATR Ladder (Late)
lateATR_skipBars   = input.int(0, "Late: ATR skip bars", minval=0, maxval=40, group=groupLateExit)
lateATR_oppUseEMA  = input.bool(false, "Late: ATR Opp-EMA required", group=groupLateExit)

// 4) Phase (Late)
latePH_skipBars    = input.int(0, "Late: Phase skip bars", minval=0, maxval=40, group=groupLateExit)
latePH_oppUseEMA   = input.bool(true, "Late: Phase Opp-EMA required", group=groupLateExit)

// 5) TD (Late)
lateTD_skipBars    = input.int(0, "Late: TD skip bars", minval=0, maxval=40, group=groupLateExit)
lateTD_oppUseEMA   = input.bool(false, "Late: TD Opp-EMA required", group=groupLateExit)

// 6) EA + BE (Late)
lateEA_ticks       = input.int(14, "Late: Early Abort ticks", minval=1, group=groupLateExit)
lateEA_bars        = input.int(6,  "Late: EA active bars", minval=1, group=groupLateExit)

lateBE_trig        = input.int(28, "Late: BE trigger ticks", minval=1, group=groupLateExit)
lateBE_off         = input.int(2,  "Late: BE offset ticks",  minval=0, group=groupLateExit)

// Helpers: identify â€œlate positionâ€ live
isLateLongPos  = (strategy.position_size > 0) and posIsLateLong
isLateShortPos = (strategy.position_size < 0) and posIsLateShort
isLatePos      = isLateLongPos or isLateShortPos

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BASE Fuse triggers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
hardFuseLong  = fuseEnable and ((fuseRsiEnable and not na(rsiFuse) and rsiFuse >= hardRsiLong)  or (fuseTickEnable and not na(tickFuse) and tickFuse >=  hardTickAbs))
hardFuseShort = fuseEnable and ((fuseRsiEnable and not na(rsiFuse) and rsiFuse <= hardRsiShort) or (fuseTickEnable and not na(tickFuse) and tickFuse <= -hardTickAbs))

softFuseLong  = fuseEnable and ((fuseRsiEnable and not na(rsiFuse) and rsiFuse >= softRsiLong)  or (fuseTickEnable and not na(tickFuse) and tickFuse >=  softTickAbs))
softFuseShort = fuseEnable and ((fuseRsiEnable and not na(rsiFuse) and rsiFuse <= softRsiShort) or (fuseTickEnable and not na(tickFuse) and tickFuse <= -softTickAbs))

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LATE Fuse triggers (only evaluated when in a late position)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lateHardFuseLong =
    lateFuseEnable and isLateLongPos and
    ((fuseRsiEnable and not na(rsiFuse) and rsiFuse >= lateHardRsiLong) or
     (lateUseTickFuse and fuseTickEnable and not na(tickFuse) and tickFuse >=  lateHardTickAbs))

lateHardFuseShort =
    lateFuseEnable and isLateShortPos and
    ((fuseRsiEnable and not na(rsiFuse) and rsiFuse <= lateHardRsiShort) or
     (lateUseTickFuse and fuseTickEnable and not na(tickFuse) and tickFuse <= -lateHardTickAbs))

lateSoftFuseLong =
    lateFuseEnable and isLateLongPos and
    ((fuseRsiEnable and not na(rsiFuse) and rsiFuse >= lateSoftRsiLong) or
     (lateUseTickFuse and fuseTickEnable and not na(tickFuse) and tickFuse >=  lateSoftTickAbs))

lateSoftFuseShort =
    lateFuseEnable and isLateShortPos and
    ((fuseRsiEnable and not na(rsiFuse) and rsiFuse <= lateSoftRsiShort) or
     (lateUseTickFuse and fuseTickEnable and not na(tickFuse) and tickFuse <= -lateSoftTickAbs))


// â”€â”€ 1m Phase dot confirm (uses your existing Saty oscillator semantics)
// We reuse your same Phase thresholds, but calculated on 1m
satyOsc_1m = _saty_osc("1")

leaveDist_1m = nz(satyOsc_1m[1]) >=  phaseExitLongAbs  and satyOsc_1m <  phaseExitLongAbs
leaveAcc_1m  = nz(satyOsc_1m[1]) <= -phaseExitShortAbs and satyOsc_1m > -phaseExitShortAbs

leaveExtUp_1m   = nz(satyOsc_1m[1]) >= 100  and satyOsc_1m < 100
leaveExtDn_1m   = nz(satyOsc_1m[1]) <= -100 and satyOsc_1m > -100

phaseDotLong_1m  = leaveDist_1m or leaveExtUp_1m      // â€œleave distributionâ€ on 1m
phaseDotShort_1m = leaveAcc_1m  or leaveExtDn_1m      // â€œleave accumulationâ€ on 1m

// Backup 2: EMA(3) break (aggressive)
ema3 = emaExit
ema3Break_Long  = close < ema3
ema3Break_Short = close > ema3

// Backup 3: momentum loss (RSI rolling + optional price failure vs EMA Fast)
// Compute on every bar (avoids Pine stateful warnings)
rsiFalling_raw = ta.falling(rsiFuse, momLossBars)
rsiRising_raw  = ta.rising(rsiFuse,  momLossBars)

// Then gate with your enable/na checks
rsiRollingDown = fuseRsiEnable and not na(rsiFuse) and rsiFalling_raw
rsiRollingUp   = fuseRsiEnable and not na(rsiFuse) and rsiRising_raw

priceFail_Long  = (not momNeedPriceFail) or (close < emaFast)
priceFail_Short = (not momNeedPriceFail) or (close > emaFast)

momLoss_Long  = rsiRollingDown and priceFail_Long
momLoss_Short = rsiRollingUp   and priceFail_Short

// Base fuse arm state
var bool fuseArmedL   = false
var bool fuseArmedS   = false
var int  fuseArmBarL  = na
var int  fuseArmBarS  = na

// Late fuse arm state (separate!)
var bool lateFuseArmedL  = false
var bool lateFuseArmedS  = false
var int  lateFuseArmBarL = na
var int  lateFuseArmBarS = na

// Helpers for â€œarmed timeoutâ€
// Base timeouts
fuseTimedOutL = fuseArmedL and not na(fuseArmBarL) and (bar_index - fuseArmBarL >= fuseMaxWaitBars)
fuseTimedOutS = fuseArmedS and not na(fuseArmBarS) and (bar_index - fuseArmBarS >= fuseMaxWaitBars)

// Late timeouts (reuse same wait bars)
lateFuseTimedOutL = lateFuseArmedL and not na(lateFuseArmBarL) and (bar_index - lateFuseArmBarL >= fuseMaxWaitBars)
lateFuseTimedOutS = lateFuseArmedS and not na(lateFuseArmBarS) and (bar_index - lateFuseArmBarS >= fuseMaxWaitBars)

// Confirmation signals (only used if armed)
confirmLong =
    (useFuseConfirm_1mPhaseDot and phaseDotLong_1m) or
    (useFuseConfirm_EMA3Break  and ema3Break_Long)  or
    (useFuseConfirm_MomLoss    and momLoss_Long)    or
    fuseTimedOutL

confirmShort =
    (useFuseConfirm_1mPhaseDot and phaseDotShort_1m) or
    (useFuseConfirm_EMA3Break  and ema3Break_Short)  or
    (useFuseConfirm_MomLoss    and momLoss_Short)    or
    fuseTimedOutS

lateConfirmLong =
    (useFuseConfirm_1mPhaseDot and phaseDotLong_1m) or
    (useFuseConfirm_EMA3Break  and ema3Break_Long)  or
    (useFuseConfirm_MomLoss    and momLoss_Long)    or
    lateFuseTimedOutL

lateConfirmShort =
    (useFuseConfirm_1mPhaseDot and phaseDotShort_1m) or
    (useFuseConfirm_EMA3Break  and ema3Break_Short)  or
    (useFuseConfirm_MomLoss    and momLoss_Short)    or
    lateFuseTimedOutS

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X2) DAILY ATR CONTEXT & LUX PDZ (SWING LEN 50)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupPDZ     = "EXIT: X2) Lux PDZ & ATR Ladder"

usePDZ        = input.bool(true,"Enable Lux PDZ exits", group=groupPDZ)
luxLen        = input.int(100,"Lux swing len",          group=groupPDZ)
pdzPct        = input.float(2,"Zone thickness %",step=0.1,group=groupPDZ)
useOppNowPDZ  = input.bool(false,"Require mid-EMA Opp-Now on PDZ exit", group=groupPDZ)
ladderOn      = input.bool(true,"Enable ATR Ladder exit", group=groupPDZ)
ladderNeedOpp = input.bool(true,"ATR Ladder requires Opp-Now", group=groupPDZ)


PCd  = request.security(syminfo.tickerid, "D", close[1],  barmerge.gaps_off, barmerge.lookahead_off)
ATRd = request.security(syminfo.tickerid, "D", ta.atr(14), barmerge.gaps_off, barmerge.lookahead_off)
L_up = PCd + 0.618*ATRd
L_dn = PCd - 0.618*ATRd

var float legTop = na
var float legBot = na
_newTop = ta.change(ta.highest(high, luxLen)) > 0
_newBot = ta.change(ta.lowest (low,  luxLen)) < 0

if _newTop
   legTop := high[luxLen]
   legBot := high[luxLen]

if _newBot
   legBot := low[luxLen]
   legTop := low[luxLen]

if not na(legTop) and not na(legBot)
   legTop := math.max(legTop, high)
   legBot := math.min(legBot, low)

pdzPremTop = legTop
pdzPremBot = na(legTop) or na(legBot) ? na :
            legTop*(1.0-pdzPct*0.01) + legBot*(pdzPct*0.01)

pdzDiscBot = legBot
pdzDiscTop = na(legTop) or na(legBot) ? na :
            legBot*(1.0-pdzPct*0.01) + legTop*(pdzPct*0.01)

inPremNow = usePDZ and not na(pdzPremBot) and high >= pdzPremBot
inDiscNow = usePDZ and not na(pdzDiscTop) and low  <= pdzDiscTop

touchUp(ep) => high >= math.min(L_up, PCd + 1.0*ATRd)
touchDn(ep) => low  <= math.max(L_dn, PCd - 1.0*ATRd)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PDZ Leave Confirmation (close-based reclaim) + 2-leave exit logic
//  - Touch uses wicks (existing inPremNow/inDiscNow)
//  - Leave is CONFIRMED only when CLOSE reclaims beyond PDZ edge (+ buffer)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pdzLeaveTicks = input.int(0, "PDZ leave confirm (ticks)", minval=0, group=groupPDZ)
pdzLeavePx    = pdzLeaveTicks * syminfo.mintick

// Premium (LONG side): â€œleaveâ€ = close back BELOW premium bottom - buffer
premTouch          = usePDZ and inPremNow
premLeaveConfirmed = usePDZ and not na(pdzPremBot) and close < (pdzPremBot - pdzLeavePx)

// Discount (SHORT side): â€œleaveâ€ = close back ABOVE discount top + buffer
discTouch          = usePDZ and inDiscNow
discLeaveConfirmed = usePDZ and not na(pdzDiscTop) and close > (pdzDiscTop + pdzLeavePx)

// Track touch cycles so we can fire one-bar leave events
var bool premTouchedCycle = false
var bool discTouchedCycle = false

premTouchedCycle := premTouch ? true : (premLeaveConfirmed ? false : premTouchedCycle)
discTouchedCycle := discTouch ? true : (discLeaveConfirmed ? false : discTouchedCycle)

// One-bar events: confirmed leave after having touched
premLeaveEvent = premLeaveConfirmed and premTouchedCycle[1]
discLeaveEvent = discLeaveConfirmed and discTouchedCycle[1]

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ATR LADDER STATE (Arm â†’ Confirm â†’ Exit once per position)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ladderConfirmTicks = input.int(0, "ATR Ladder confirm (ticks)", minval=0, group=groupPDZ)
ladderConfirmPx    = ladderConfirmTicks * syminfo.mintick

var bool ladderArmedL = false
var bool ladderArmedS = false
var bool ladderDoneL  = false
var bool ladderDoneS  = false

// Reset when flat
if strategy.position_size == 0
   ladderArmedL := false
   ladderArmedS := false
   ladderDoneL  := false
   ladderDoneS  := false

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PDZ Exit State â€” "Arm on first leave, exit on second leave"
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var bool pdzArmedL = false  // long side PDZ armed after first leave
var bool pdzArmedS = false  // short side PDZ armed after first leave

// OLD wick-only enter/leave flags are replaced by premLeaveEvent / discLeaveEvent above.
// (kept as no-ops to avoid accidental references)
enteredPremL = false
leftPremL    = false
enteredDiscS = false
leftDiscS    = false

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X3) STOPS / TP / BE / EARLY ABORT (+ RR helpers)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupStops   = "EXIT: X3) Stops / TP / BE / EA"



stopTicksMax    = input.int(20,"Max stop ticks", group=groupStops)
tpMode          = input.string("EW-or-Ladder","TP mode", options=["EW-or-Ladder","Fixed"], group=groupStops)
tpFixedTicks    = input.int(25,"Fixed TP ticks", group=groupStops)
minTPticks      = input.int(24, "Min TP ticks (arm â‰¥ this)", group=groupStops, minval=1)
beEnable        = input.bool(true,"Breakeven", group=groupStops)
beTrig          = input.int(28,"BE trigger ticks", group=groupStops)
beOff           = input.int(0,"BE offset (ticks)", group=groupStops)

// NEW: Optional v1 behavior â€” only allow BE if TP exists (lastTP is not na)
beRequireTP     = input.bool(false, "BE requires TP (match v1)", group=groupStops)

// NEW: BE Delay (bars after entry)
// Default 8: gives EMA-cross trades room to pull back before BE is allowed.
beDelayEnable   = input.bool(true, "BE Delay enable", group=groupStops)
beDelayBars     = input.int(5, "BE Delay bars", minval=0, maxval=200, group=groupStops)

eaEnable        = input.bool(false,"Early Abort (window N bars, â‰¥ ticks adverse)", group=groupStops)
eaTicks         = input.int(22,"EA ticks", group=groupStops)
eaBars          = input.int(4,"EA active bars", minval=1, group=groupStops)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  EXIT: Phase-Aware Trailing Stop (inputs)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupPhTrail = "EXIT: X3c) Phase-Aware Trailing Stop"

phTrailEnable      = input.bool(true, "Enable Phase-aware trailing stop", group=groupPhTrail)

phTrailEmaSrc      = input.string("EMA21", "Trail EMA", options=["EMA5","EMA8","EMA13","EMA21"], group=groupPhTrail)
phTrailOffsetTicks = input.int(0, "Trail offset (ticks)", minval=0, group=groupPhTrail)

phTrailMinBars     = input.int(3, "Only after N bars in trade", minval=0, group=groupPhTrail)
phTrailMinProfitTk = input.int(50, "Only after â‰¥ profit (ticks)", minval=0, group=groupPhTrail)

phTrailSlopeBars   = input.int(3, "Phase slope lookback bars", minval=1, maxval=10, group=groupPhTrail)




// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  EXIT Add-On: No-Progress Bail (Entry must clear by X ticks in X bars)
//  + Defer if above/below custom EMA and not too adverse from entry
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupNoProg = "EXIT: X3e) No-Progress Bail"

noProgEnable          = input.bool(true, "Enable No-Progress Bail", group=groupNoProg)

noProgBars            = input.int(10, "Must clear within N bars", minval=1, maxval=20, group=groupNoProg)
noProgClearTicks      = input.int(6, "Clear entry by ticks", minval=0, maxval=50, group=groupNoProg)

// Defer condition
noProgDeferEnable     = input.bool(true, "Defer if on good EMA side + not too adverse", group=groupNoProg)
noProgDeferEmaLen     = input.int(3, "Defer EMA length", minval=1, maxval=200, group=groupNoProg)
noProgDeferMaxAdverse = input.int(5, "Defer only if adverse â‰¤ ticks", minval=0, maxval=50, group=groupNoProg)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  EXIT Add-On: Early Phase Dot Abort (fast rejection killer)
//  If a Phase Dot prints very early after entry AND we're in DD â†’ exit.
//  Optional: apply to Base positions and/or Late positions.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupEarlyPhaseAbort = "EXIT: X3f) Early Phase Dot Abort"

earlyPhaseAbortEnable     = input.bool(true, "Enable Early Phase Dot Abort", group=groupEarlyPhaseAbort)
earlyPhaseAbortApplyBase  = input.bool(true, "Apply to BASE entries", group=groupEarlyPhaseAbort)
earlyPhaseAbortApplyLate  = input.bool(true, "Apply to LATE entries", group=groupEarlyPhaseAbort)

earlyPhaseAbortBars       = input.int(2,  "Dot must occur within N bars of entry", minval=1, maxval=5, group=groupEarlyPhaseAbort)
earlyPhaseAbortMinDDTicks = input.int(20, "Only if drawdown â‰¥ ticks", minval=1, maxval=200, group=groupEarlyPhaseAbort)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X3a) ST-ANCHORED STOP (Core) + FLAT TRAIL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupSTSL    = "EXIT: X3a) ST-based Stop (Core)"

useSTStop         = input.bool(true,  "Use ST Â± offset for SL", group=groupSTSL)
stStopOffsetTicks = input.int(3,      "ST SL offset (ticks)",   minval=0, group=groupSTSL)
stFlatBarsTrail   = input.int(2,      "Trail when ST flat â‰¥ N bars", minval=1, group=groupSTSL)

// Track plateau behaviour so we only trail once per ST step
var int   stFlatCntL         = 0
var int   stFlatCntS         = 0
var float stLastTrailLevel_L = na
var float stLastTrailLevel_S = na

rr_from_atr_long(ep) =>
   tp = L_up
   sl = f_to_tick(math.max(ep - ticks(stopTicksMax), ta.lowest(low[1], 12)))
   r  = math.abs(ep - sl)
   g  = math.abs(tp - ep)
   r <= 0 ? 0.0 : (g / r)

rr_from_atr_short(ep) =>
   tp = L_dn
   sl = f_to_tick(math.min(ep + ticks(stopTicksMax), ta.highest(high[1],12)))
   r  = math.abs(ep - sl)
   g  = math.abs(ep - tp)
   r <= 0 ? 0.0 : (g / r)

calcStopL(ep) =>
   useSTStop and not na(stLine) ?        f_to_tick(stLine - stStopOffsetTicks * syminfo.mintick) :        f_to_tick(math.max(ep - ticks(stopTicksMax), ta.lowest(low[1], 12)))

calcStopS(ep) =>
   useSTStop and not na(stLine) ?        f_to_tick(stLine + stStopOffsetTicks * syminfo.mintick) :        f_to_tick(math.min(ep + ticks(stopTicksMax), ta.highest(high[1], 12)))

// TP based on daily ATR ladder (0.618) unless Fixed
pickTP_L(ep) =>
   _tp = tpMode=="Fixed" ? f_px_from_ticks(ep, tpFixedTicks) : L_up
   _ticks = math.round((_tp - ep)/syminfo.mintick)
   (na(_tp) or _ticks < minTPticks) ? na : f_to_tick(_tp)

pickTP_S(ep) =>
   _tp = tpMode=="Fixed" ? f_px_from_ticks(ep, -tpFixedTicks) : L_dn
   _ticks = math.round((ep - _tp)/syminfo.mintick)
   (na(_tp) or _ticks < minTPticks) ? na : f_to_tick(_tp)

// Track bars since last open trade for EA window
barsInTrade = ta.barssince(strategy.opentrades > 0 ? false : true)
_eaBarsEff = (isLatePos ? lateEA_bars : eaBars)
inEAwindow = barsInTrade >= 0 and barsInTrade < _eaBarsEff

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X4) TD SEQUENCER (lite) â€” EXIT-SIDE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupTDExit  = "EXIT: X4) TD Sequencer (Exits)"

tdPrepLen      = input.int(9,"Prep len", group=groupTDExit)
tdPrepCmp      = input.int(4,"Prep compare", group=groupTDExit)
tdLeadLen      = input.int(13,"Lead-Up len", group=groupTDExit)
tdLeadCmp      = input.int(2,"Lead-Up compare", group=groupTDExit)
tdExitPrep     = input.bool(true,"Exit on Prep complete", group=groupTDExit)
tdExitLead     = input.bool(true,"Exit on Lead complete", group=groupTDExit)
tdOppLen       = input.int(13,"Opp EMA len (TD exits)", group=groupTDExit)
tdNeedOppTD    = input.bool(true,"TD exits require Opp-EMA", group=groupTDExit)

var int td_bull_prep = 0
var int td_bear_prep = 0
var int td_bull_lead = 0
var int td_bear_lead = 0

td_bear_prep := close > close[tdPrepCmp] ? nz(td_bear_prep[1]) + 1 : 0
td_bull_prep := close < close[tdPrepCmp] ? nz(td_bull_prep[1]) + 1 : 0
td_bear_lead := close > high[tdLeadCmp]  ? nz(td_bear_lead[1]) + 1 : 0
td_bull_lead := close < low[tdLeadCmp]   ? nz(td_bull_lead[1]) + 1 : 0

prepBullDone = td_bull_prep==tdPrepLen
prepBearDone = td_bear_prep==tdPrepLen
leadBullDone = td_bull_lead==tdLeadLen
leadBearDone = td_bear_lead==tdLeadLen

oppEMA_TD    = ta.ema(close, math.max(1, tdOppLen))

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  V2: TD9 CANDLE QUALITY (Smart TD Exit Logic)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// When TD9 fires, analyze candle quality to decide: exit immediately or defer based on regime

groupTD9Quality = "EXIT: V2) TD9 Candle Quality"
td9QualityEnable = input.bool(true, "Enable TD9 Candle Quality check", group=groupTD9Quality,
   tooltip="When TD9 completes, analyze candle quality to determine if we should exit or hold based on regime.")

// Candle quality analysis
td9_isBullish = close > open  // Bullish candle
td9_isBearish = close < open  // Bearish candle
td9_isInsideBar = high <= high[1] and low >= low[1]  // Inside bar (within prev candle OHLC)
td9_isNewHigh = high > high[1]  // New high
td9_isNewLow = low < low[1]  // New low
td9_aboveEma5 = close > ema5
td9_belowEma5 = close < ema5

// TD9 Candle Quality Decision Tree (for LONGS)
// - Bullish candle + new high? â†’ HOLD (strong)
// - Inside bar? â†’ Check regime (HH/HL = defer, LH/LL = exit)
// - Bearish candle + above 5 EMA? â†’ Check regime
// - Bearish candle + below 5 EMA? â†’ EXIT immediately
td9_shouldExitLong_Quality = false
td9_shouldHoldLong_Quality = false

if td9QualityEnable and (prepBearDone or leadBearDone)
   if td9_isBullish and td9_isNewHigh
       // Strong candle, new high â†’ HOLD
       td9_shouldHoldLong_Quality := true
   else if td9_isInsideBar
       // Inside bar â†’ check regime
       if regimeIsUptrend
           td9_shouldHoldLong_Quality := true  // HH/HL = uptrend intact, defer
       else
           td9_shouldExitLong_Quality := true  // LH/LL or neutral = weakness, exit
   else if td9_isBearish and td9_aboveEma5
       // Bearish but above 5 EMA â†’ check regime
       if regimeIsUptrend and not comp_chart
           td9_shouldHoldLong_Quality := true  // Uptrend + no compression = defer
       else
           td9_shouldExitLong_Quality := true  // Downtrend or compressed = exit
   else if td9_isBearish and td9_belowEma5
       // Bearish and below 5 EMA â†’ EXIT immediately
       td9_shouldExitLong_Quality := true
   else
       // Default: follow normal TD exit logic
       td9_shouldExitLong_Quality := true

// TD9 Candle Quality Decision Tree (for SHORTS)
// - Bearish candle + new low? â†’ HOLD (strong)
// - Inside bar? â†’ Check regime (LH/LL = defer, HH/HL = exit)
// - Bullish candle + below 5 EMA? â†’ Check regime
// - Bullish candle + above 5 EMA? â†’ EXIT immediately
td9_shouldExitShort_Quality = false
td9_shouldHoldShort_Quality = false

if td9QualityEnable and (prepBullDone or leadBullDone)
   if td9_isBearish and td9_isNewLow
       // Strong candle, new low â†’ HOLD
       td9_shouldHoldShort_Quality := true
   else if td9_isInsideBar
       // Inside bar â†’ check regime
       if regimeIsDowntrend
           td9_shouldHoldShort_Quality := true  // LH/LL = downtrend intact, defer
       else
           td9_shouldExitShort_Quality := true  // HH/HL or neutral = weakness, exit
   else if td9_isBullish and td9_belowEma5
       // Bullish but below 5 EMA â†’ check regime
       if regimeIsDowntrend and not comp_chart
           td9_shouldHoldShort_Quality := true  // Downtrend + no compression = defer
       else
           td9_shouldExitShort_Quality := true  // Uptrend or compressed = exit
   else if td9_isBullish and td9_aboveEma5
       // Bullish and above 5 EMA â†’ EXIT immediately
       td9_shouldExitShort_Quality := true
   else
       // Default: follow normal TD exit logic
       td9_shouldExitShort_Quality := true

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X5) EXIT DEFERRALS (Compression / EMA-hold)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
isCompChart = comp_chart
isComp1m    = comp_1m

groupExitComp= "EXIT: X5) Exit Deferrals & Compression"

exitCompUseChart = input.bool(true,  "Exit compression: Chart", group=groupExitComp, inline="xc")
exitCompUse1m    = input.bool(true,  "Exit compression: 1m",    group=groupExitComp, inline="xc")
exitCompAgg      = input.string("All", "Compression aggregation", options=["Any","All"], group=groupExitComp)
exitCompMode     = input.string("Block While Compressed", options=["Skip N Bars","Block While Compressed"], group=groupExitComp)
exitCompSkipBars = input.int(2,"Skip N bars", minval=1, maxval=40, group=groupExitComp)
lateExitBypassDefers = input.bool(true, "Late: bypass exit deferrals (PDZ/ATR/PH/TD/EA)", group=groupExitComp)

exitReleaseEmaCheck = input.bool(false, "Release: require EMA side", group=groupExitComp)
exitReleaseEmaSrc   = input.string("Exit", "Release EMA", options=["Exit","Mid","Fast","Custom"], group=groupExitComp, inline="re")
exitReleaseEmaLen   = input.int(5, "Custom EMA len", minval=1, group=groupExitComp, inline="re")

groupDefPDZ  = "EXIT: X5a) PDZ Exit Defers"
pdzUseChart  = input.bool(true,  "Defer PDZ on Chart comp", group=groupDefPDZ, inline="a")
pdzUse1m     = input.bool(true,  "Defer PDZ on 1m comp",    group=groupDefPDZ, inline="a")
pdzCompAgg   = input.string("All", "PDZ comp aggregation", options=["Any","All"], group=groupDefPDZ)
pdzMode      = input.string("Block While Compressed","PDZ behavior", options=["Skip N Bars","Block While Compressed"], group=groupDefPDZ)
pdzSkipBars  = input.int(2,"PDZ skip bars", minval=1, maxval=40, group=groupDefPDZ)
pdzOppUseEMA = input.bool(true,"PDZ: Opp-EMA required to release", group=groupDefPDZ)
pdzOppSrc    = input.string("Custom","PDZ Opp EMA", options=["Exit","Mid","Fast","Custom"], group=groupDefPDZ, inline="o")
pdzOppLen    = input.int(9,"PDZ Opp EMA len", minval=1, group=groupDefPDZ, inline="o")
pdzOppConsec = input.int(1,"PDZ Opp EMA consec closes", minval=0, group=groupDefPDZ)

groupDefATR  = "EXIT: X5b) ATR Ladder Exit Defers"
atrUseChart  = input.bool(true,  "Defer ATR on Chart comp", group=groupDefATR, inline="a")
atrUse1m     = input.bool(true,  "Defer ATR on 1m comp",    group=groupDefATR, inline="a")
atrCompAgg   = input.string("All", "ATR comp aggregation", options=["Any","All"], group=groupDefATR)
atrMode      = input.string("Block While Compressed","ATR behavior", options=["Skip N Bars","Block While Compressed"], group=groupDefATR)
atrSkipBars  = input.int(2,"ATR skip bars", minval=1, maxval=40, group=groupDefATR)
atrOppUseEMA = input.bool(false,"ATR: Opp-EMA required to release", group=groupDefATR)
atrOppSrc    = input.string("Custom","ATR Opp EMA", options=["Exit","Mid","Fast","Custom"], group=groupDefATR, inline="o")
atrOppLen    = input.int(13,"ATR Opp EMA len", minval=1, group=groupDefATR, inline="o")
atrOppConsec = input.int(1,"ATR Opp EMA consec closes", minval=0, group=groupDefATR)

groupDefPH   = "EXIT: X5c) Phase Exit Defers"
phUseChart   = input.bool(true,  "Defer Phase on Chart comp", group=groupDefPH, inline="a")
phUse1m      = input.bool(true,  "Defer Phase on 1m comp",    group=groupDefPH, inline="a")
phCompAgg    = input.string("All", "Phase comp aggregation", options=["Any","All"], group=groupDefPH)
phMode       = input.string("Block While Compressed","Phase behavior", options=["Skip N Bars","Block While Compressed"], group=groupDefPH)
phSkipBars   = input.int(1,"Phase skip bars", minval=1, maxval=40, group=groupDefPH)
phOppUseEMA  = input.bool(true,"Phase: Opp-EMA required to release", group=groupDefPH)
phOppSrc     = input.string("Custom","Phase Opp EMA", options=["Exit","Mid","Fast","Custom"], group=groupDefPH, inline="o")
phOppLen     = input.int(11,"Phase Opp EMA len", minval=1, group=groupDefPH, inline="o")
phOppConsec  = input.int(2,"Phase Opp EMA consec closes", minval=0, group=groupDefPH)

groupDefTD   = "EXIT: X5d) TD Exit Defers"
tdUseChartDef= input.bool(true,  "Defer TD on Chart comp", group=groupDefTD, inline="a")
tdUse1mDef   = input.bool(true,  "Defer TD on 1m comp",    group=groupDefTD, inline="a")
tdCompAgg    = input.string("All", "TD comp aggregation", options=["Any","All"], group=groupDefTD)
tdMode       = input.string("Block While Compressed", options=["Skip N Bars","Block While Compressed"], group=groupDefTD)
tdSkipBars   = input.int(2,"TD skip bars", minval=1, maxval=40, group=groupDefTD)
tdOppUseEMA  = input.bool(false,"TD: Opp-EMA required to release", group=groupDefTD)
tdOppSrcDef  = input.string("OppEMA_TD","TD Opp EMA", options=["OppEMA_TD","Exit","Mid","Fast","Custom"], group=groupDefTD, inline="o")
tdOppLenDef  = input.int(5,"TD Opp EMA len", minval=1, group=groupDefTD, inline="o")
tdOppConsec  = input.int(1,"TD Opp EMA consec closes", minval=0, group=groupDefTD)

groupDefEA   = "EXIT: X5e) Early Abort Defers"
eaUseChartDef= input.bool(false,"Defer EA on Chart comp", group=groupDefEA, inline="a")
eaUse1mDef   = input.bool(false, "Defer EA on 1m comp",    group=groupDefEA, inline="a")
eaCompAgg    = input.string("All", "EA comp aggregation", options=["Any","All"], group=groupDefEA)
eaModeDef    = input.string("Skip N Bars","EA behavior", options=["Skip N Bars","Block While Compressed"], group=groupDefEA)
eaSkipBarsDef= input.int(1,"EA skip bars", minval=1, maxval=10, group=groupDefEA)

// State for generic & per-signal defers
var bool exitPendL = false
var bool exitPendS = false
var float exitUntilL = na
var float exitUntilS = na

var bool pendL = false
var bool pendS = false
var float untilL = na
var float untilS = na
var string pendReasonL = ""
var string pendReasonS = ""

// Exit compression aggregator
_exitC = exitCompUseChart ? isCompChart : false
_exit1 = exitCompUse1m    ? isComp1m    : false
_selXC = (exitCompUseChart?1:0) + (exitCompUse1m?1:0)
isCompExit_any = (_exitC and exitCompUseChart) or (_exit1 and exitCompUse1m)
isCompExit_all = (exitCompUseChart?_exitC:true) and (exitCompUse1m?_exit1:true)
exitCompressed = (_selXC>0) and (exitCompAgg=="Any" ? isCompExit_any : isCompExit_all)

// Release EMA helpers
f_pick_ema(src, len) =>
   src=="Exit" ? emaExit :    src=="Mid"  ? emaMid  :    src=="Fast" ? emaFast :                  ta.ema(close, len)

exitRelEMA =    exitReleaseEmaSrc=="Exit" ? emaExit :    exitReleaseEmaSrc=="Mid"  ? emaMid  :    exitReleaseEmaSrc=="Fast" ? emaFast :                                ta.ema(close, exitReleaseEmaLen)

// Simple momentum proxy (optional momentum-based defers)
var float _mom = 0.0
_mom := ta.ema(close - ta.sma(close, 20), 20)
momRising = _mom > nz(_mom[1], _mom)


exitDeferOnMomentum  = input.bool(false, "Defer exits while momentum rising", group=groupExitComp)
exitMomLookbackBars  = input.int(1, "Momentum rising lookback (bars)", minval=1, group=groupExitComp)
deferByMomentum_Long  = exitDeferOnMomentum and inLong  and momRising
deferByMomentum_Short = exitDeferOnMomentum and inShort and momRising

// Helper: compression aggregator for a given signal
f_comp_agg(useChart, use1m, agg) =>
   _cC = (useChart ? isCompChart : false)
   _c1 = (use1m   ? isComp1m    : false)
   _sel = (useChart?1:0) + (use1m?1:0)
   _sel == 0 ? false : (agg=="Any" ? (_cC or _c1) : ((useChart?_cC:true) and (use1m?_c1:true)))


// Generic "should defer" with Skip N bars or Block behavior
f_should_defer_agg(useChart, use1m, agg, mode, skipBars) =>
   _cmp = f_comp_agg(useChart, use1m, agg)

   // Late positions: treat deferrals as off (exit immediately)
   _isLatePos = (strategy.position_size > 0 and posIsLateLong) or (strategy.position_size < 0 and posIsLateShort)
   if lateExitBypassDefers and _isLatePos
       _cmp := false

   int _until = na
   if _cmp and mode=="Skip N Bars"
       _until := bar_index + skipBars
   [_cmp, _until]
// Helper: N consecutive closes vs EMA
f_consec_ok(cond, n) =>
   n <= 0 ? true : (ta.sma(cond ? 1.0 : 0.0, n) * n == n)

// Choose Opp-EMA source per signal
f_opp_ema_for(src, fallbackLen) =>
   src=="OppEMA_TD" ? oppEMA_TD : f_pick_ema(src, fallbackLen)

// Map pending reason â†’ its own compression aggregation
f_pend_is_compressed(isLong) =>
   _r = isLong ? pendReasonL : pendReasonS
   _r == "PDZ" ? f_comp_agg(pdzUseChart, pdzUse1m, pdzCompAgg) :    _r == "ATR" ? f_comp_agg(atrUseChart, atrUse1m, atrCompAgg) :    _r == "PH"  ? f_comp_agg(phUseChart,  phUse1m,  phCompAgg)  :    _r == "TD"  ? f_comp_agg(tdUseChartDef, tdUse1mDef, tdCompAgg) :    _r == "EA"  ? f_comp_agg(eaUseChartDef, eaUse1mDef, eaCompAgg) :                  exitCompressed

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X6) OPP-EMA PRECOMPUTE FOR PDZ / ATR / PHASE / TD
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_pdzOppEmaL = f_opp_ema_for(pdzOppSrc, pdzOppLen)
_pdzOppEmaS = f_opp_ema_for(pdzOppSrc, pdzOppLen)
_pdzOppClBelowL = f_consec_ok(close < _pdzOppEmaL, pdzOppConsec)
_pdzOppClAboveS = f_consec_ok(close > _pdzOppEmaS, pdzOppConsec)
_pdzOppOkL = (not pdzOppUseEMA) or _pdzOppClBelowL
_pdzOppOkS = (not pdzOppUseEMA) or _pdzOppClAboveS

_atrOppEmaL = f_opp_ema_for(atrOppSrc, atrOppLen)
_atrOppEmaS = f_opp_ema_for(atrOppSrc, atrOppLen)
_atrOppClBelowL = f_consec_ok(close < _atrOppEmaL, atrOppConsec)
_atrOppClAboveS = f_consec_ok(close > _atrOppEmaS, atrOppConsec)
_atrOppOkL = (not atrOppUseEMA) or _atrOppClBelowL
_atrOppOkS = (not atrOppUseEMA) or _atrOppClAboveS

_phOppEmaL = f_opp_ema_for(phOppSrc, phOppLen)
_phOppEmaS = f_opp_ema_for(phOppSrc, phOppLen)
_phOppClBelowL = f_consec_ok(close < _phOppEmaL, phOppConsec)
_phOppClAboveS = f_consec_ok(close > _phOppEmaS, phOppConsec)
_phOppOkL = (not phOppUseEMA) or _phOppClBelowL
_phOppOkS = (not phOppUseEMA) or _phOppClAboveS

_tdOppEmaL = f_opp_ema_for(tdOppSrcDef, tdOppLenDef)
_tdOppEmaS = f_opp_ema_for(tdOppSrcDef, tdOppLenDef)
_tdOppClBelowL = f_consec_ok(close < _tdOppEmaL, tdOppConsec)
_tdOppClAboveS = f_consec_ok(close > _tdOppEmaS, tdOppConsec)
_tdOppOkL = (not tdOppUseEMA) or _tdOppClBelowL
_tdOppOkS = (not tdOppUseEMA) or _tdOppClAboveS

// â”€â”€ Precompute per-bar entry anchors for consistency (stops/TP)
epLongBar  = f_to_tick(close)
stLongBar  = calcStopL(epLongBar)
tpLongBar  = pickTP_L(epLongBar)

epShortBar = f_to_tick(close)
stShortBar = calcStopS(epShortBar)
tpShortBar = pickTP_S(epShortBar)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Y1) ENTRY EXECUTION â†’ BRACKETS (uses Phoenix longEntry/shortEntry)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


if barstate.isconfirmed
   // LONG
   if longEntrySignal and sessionOK_Long and strategy.position_size<=0
       if strategy.position_size < 0
           // Flip from short if needed
           _qtyFlipS = math.abs(strategy.position_size)
           f_send_close(orderContract,"BUY_TO_COVER",_qtyFlipS,close,"FLIP_TO_LONG",posSeqS)
           strategy.close("Short", comment="FLIP_TO_LONG")

       ep = epLongBar
       st = stLongBar
       tp = tpLongBar
       qtyL = f_compute_qty(ep, st)

       posSeqL := nextSeq
       nextSeq += 1

       strategy.entry("Long", strategy.long, qty=qtyL)
       strategy.exit(BRACKET_L_ID, "Long", stop=st, limit=tp)


       _isLateL = lateEntryLong and not baseLongEntrySignal
       posIsLateLong := _isLateL

       f_send_open(orderContract,"BUY",  useComputedQtyForWebhook?qtyL:orderQty, st,tp,ep,(_isLateL ? "LATE_ENTRY" : "BASE_ENTRY"),tpCalcTF,phaseTF,posSeqL)
       entryPriceLong := ep
       lastSL_Long    := st
       lastTP_Long    := tp
       // Clear arm once we enter
       armedL := false
       armUntilL := na

   // SHORT
   if shortEntrySignal and sessionOK_Short and strategy.position_size>=0
       if strategy.position_size > 0
           _qtyFlipL = math.abs(strategy.position_size)
           f_send_close(orderContract,"SELL",_qtyFlipL,close,"FLIP_TO_SHORT",posSeqL)
           strategy.close("Long", comment="FLIP_TO_SHORT")

       epS = epShortBar
       stS = stShortBar
       tpS = tpShortBar
       qtyS = f_compute_qty(epS, stS)

       posSeqS := nextSeq
       nextSeq += 1

       strategy.entry("Short", strategy.short, qty=qtyS)
       strategy.exit(BRACKET_S_ID, "Short", stop=stS, limit=tpS)


       _isLateS = lateEntryShort and not baseShortEntrySignal
       posIsLateShort := _isLateS

       f_send_open(orderContract,"SELL",   useComputedQtyForWebhook?qtyS:orderQty,  stS,tpS,epS,(_isLateS ? "LATE_ENTRY" : "BASE_ENTRY"),tpCalcTF,phaseTF,posSeqS)
       entryPriceShort := epS
       lastSL_Short    := stS
       lastTP_Short    := tpS
       armedS := false
       armUntilS := na

inLong  := strategy.position_size > 0
inShort := strategy.position_size < 0


// Stamp flag set only on the bar we actually amend SL to BE
var bool beStampNow = false

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X3b) ST STOP LADDER: trail when ST goes flat â‰¥ N bars
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if barstate.isconfirmed and useSTStop and not na(stLine)
   // LONG: ST below price acting as support
   if inLong
       // If ST stepped up, reset flat counter.
       if stLine > nz(stLine[1])
           stFlatCntL := 0
       else if stLine == nz(stLine[1])
           stFlatCntL += 1
       else
           stFlatCntL := 0

       // When flat for â‰¥ N bars and at a new level, trail SL to ST - offset
       if stFlatCntL >= stFlatBarsTrail and stLine != nz(stLastTrailLevel_L)
           newSL_L = f_to_tick(stLine - stStopOffsetTicks * syminfo.mintick)
           if newSL_L > nz(lastSL_Long, -1e10)
               strategy.exit(BRACKET_L_ID, "Long", stop=newSL_L, limit=lastTP_Long)
               f_send_amend(orderContract,"SL",newSL_L,posSeqL)
               lastSL_Long        := newSL_L
               stLastTrailLevel_L := stLine
               stFlatCntL         := 0
   else
       stFlatCntL := 0

   // SHORT: ST above price acting as resistance
   if inShort
       if stLine < nz(stLine[1])
           stFlatCntS := 0
       else if stLine == nz(stLine[1])
           stFlatCntS += 1
       else
           stFlatCntS := 0

       if stFlatCntS >= stFlatBarsTrail and stLine != nz(stLastTrailLevel_S)
           newSL_S = f_to_tick(stLine + stStopOffsetTicks * syminfo.mintick)
           if newSL_S < nz(lastSL_Short, 1e10)
               strategy.exit(BRACKET_S_ID, "Short", stop=newSL_S, limit=lastTP_Short)
               f_send_amend(orderContract,"SL",newSL_S,posSeqS)
               lastSL_Short        := newSL_S
               stLastTrailLevel_S  := stLine
               stFlatCntS          := 0
   else
       stFlatCntS := 0

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Y2) BREAKEVEN + EA WITH DEFERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if barstate.isconfirmed and beEnable
   // NEW: BE Delay gate (uses â€œbars in tradeâ€ approximation)
   // barsInTrade: 0 on the first bar after entry, 1 on the next, etc.
   // If beDelayBars=8 â†’ BE can only start on/after barsInTrade >= 8.
   beStampNow := false
   _beDelayOK = (not beDelayEnable) or (barsInTrade >= beDelayBars)
   if inLong and not na(entryPriceLong) and _beDelayOK and (not beRequireTP or not na(lastTP_Long))
       _beTrig = posIsLateLong ? lateBE_trig : beTrig
       _beOff  = posIsLateLong ? lateBE_off  : beOff

       prof = math.round((close - entryPriceLong)/syminfo.mintick)
       if prof >= _beTrig
           newSL = f_to_tick(entryPriceLong + ticks(_beOff))
           if na(lastSL_Long) or newSL > lastSL_Long
               // limit can be na; still updates stop safely
               strategy.exit(BRACKET_L_ID, "Long", stop=newSL, limit=lastTP_Long)
               f_send_amend(orderContract,"SL",newSL,posSeqL)
               lastSL_Long := newSL
               beStampNow := true

   if inShort and not na(entryPriceShort) and _beDelayOK and (not beRequireTP or not na(lastTP_Short))
       _beTrigS = posIsLateShort ? lateBE_trig : beTrig
       _beOffS  = posIsLateShort ? lateBE_off  : beOff

       profS = math.round((entryPriceShort - close)/syminfo.mintick)
       if profS >= _beTrigS
           newSLS = f_to_tick(entryPriceShort - ticks(_beOffS))
           if na(lastSL_Short) or newSLS < lastSL_Short
               // limit can be na; still updates stop safely
               strategy.exit(BRACKET_S_ID, "Short", stop=newSLS, limit=lastTP_Short)
               f_send_amend(orderContract,"SL",newSLS,posSeqS)
               lastSL_Short := newSLS
               beStampNow := true

// Explicit helpers for exits
f_exit_long(_reason) =>
   if strategy.position_size > 0
       _qty = math.abs(strategy.position_size)
       f_send_close(orderContract, "SELL", _qty, close, _reason, posSeqL)
       strategy.close("Long", comment=_reason)

f_exit_short(_reason) =>
   if strategy.position_size < 0
       _qty = math.abs(strategy.position_size)
       f_send_close(orderContract, "BUY_TO_COVER", _qty, close, _reason, posSeqS)
       strategy.close("Short", comment=_reason)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Early Phase Dot Abort (logic)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
earlyPhaseApplyOK() =>
   // If we're not in a position, don't care
   if strategy.position_size == 0
       false
   else
       // Late vs Base routing
       _isLate = (strategy.position_size > 0 and posIsLateLong) or (strategy.position_size < 0 and posIsLateShort)
       _isLate ? earlyPhaseAbortApplyLate : earlyPhaseAbortApplyBase

if barstate.isconfirmed and earlyPhaseAbortEnable and earlyPhaseApplyOK()
   _inWindow = (barsInTrade >= 0) and (barsInTrade <= earlyPhaseAbortBars)

   // LONG: dotLong early + DD >= threshold
   if inLong and _inWindow and not na(entryPriceLong) and phaseDotLong
       _ddTicksL = math.round((entryPriceLong - close) / syminfo.mintick)
       if _ddTicksL >= earlyPhaseAbortMinDDTicks
           f_exit_long("EARLY_PHASE_DOT_ABORT")
           lastAbortBar := bar_index

   // SHORT: dotShort early + DD >= threshold
   if inShort and _inWindow and not na(entryPriceShort) and phaseDotShort
       _ddTicksS = math.round((close - entryPriceShort) / syminfo.mintick)
       if _ddTicksS >= earlyPhaseAbortMinDDTicks
           f_exit_short("EARLY_PHASE_DOT_ABORT")
           lastAbortBar := bar_index

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  No-Progress Bail (logic)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var bool noProgClearedL = false
var bool noProgClearedS = false

if not inLong
   noProgClearedL := false
if not inShort
   noProgClearedS := false


deferEMA = ta.ema(close, noProgDeferEmaLen)

if barstate.isconfirmed and noProgEnable
   // Only evaluate during the opening window of the trade
   _inWindow = (barsInTrade >= 0) and (barsInTrade <= noProgBars)

   // LONG: did we clear entry by X ticks?
   if inLong and _inWindow and not na(entryPriceLong)
       _clearPx = entryPriceLong + (noProgClearTicks * syminfo.mintick)

       // Track if we ever cleared during the window
       if high >= _clearPx
           noProgClearedL := true

       // On deadline bar: if never cleared â†’ bail (unless deferred)
       if (barsInTrade == noProgBars) and (not noProgClearedL)
           _adverseTicks = math.round((entryPriceLong - close) / syminfo.mintick)  // >0 means below entry
           _deferOK = noProgDeferEnable and (close > deferEMA) and (_adverseTicks <= noProgDeferMaxAdverse)

           if not _deferOK
               f_exit_long("NO_PROGRESS_BAIL")

   // SHORT: did we clear entry by X ticks?
   if inShort and _inWindow and not na(entryPriceShort)
       _clearPxS = entryPriceShort - (noProgClearTicks * syminfo.mintick)

       // Track if we ever cleared during the window
       if low <= _clearPxS
           noProgClearedS := true

       // On deadline bar: if never cleared â†’ bail (unless deferred)
       if (barsInTrade == noProgBars) and (not noProgClearedS)
           _adverseTicksS = math.round((close - entryPriceShort) / syminfo.mintick) // >0 means above entry
           _deferOKS = noProgDeferEnable and (close < deferEMA) and (_adverseTicksS <= noProgDeferMaxAdverse)

           if not _deferOKS
               f_exit_short("NO_PROGRESS_BAIL")





// Early Abort with per-signal defers (EA â†’ pend then release)
if barstate.isconfirmed and eaEnable
   winBar = inEAwindow

   // LONG EA
   if inLong and winBar and not na(entryPriceLong)
       adverseL = math.round((entryPriceLong - close)/syminfo.mintick)
       _eaTicksEff = isLateLongPos ? lateEA_ticks : eaTicks
       if adverseL >= _eaTicksEff
           [eaDefL, eaUntilL] = f_should_defer_agg(eaUseChartDef, eaUse1mDef, eaCompAgg, eaModeDef, eaSkipBarsDef)
           if eaDefL
               pendL := true
               pendReasonL := "EA"
               if eaModeDef=="Skip N Bars" and not na(eaUntilL)
                   untilL := na(untilL) ? eaUntilL : math.max(untilL, eaUntilL)
           else
               f_exit_long("EARLY_ABORT")

   // SHORT EA
   if inShort and winBar and not na(entryPriceShort)
       adverseS = math.round((close - entryPriceShort)/syminfo.mintick)
       _eaTicksEff = isLateShortPos ? lateEA_ticks : eaTicks
       if adverseS >= _eaTicksEff
           [eaDefS, eaUntilS] = f_should_defer_agg(eaUseChartDef, eaUse1mDef, eaCompAgg, eaModeDef, eaSkipBarsDef)
           if eaDefS
               pendS := true
               pendReasonS := "EA"
               if eaModeDef=="Skip N Bars" and not na(eaUntilS)
                   untilS := na(untilS) ? eaUntilS : math.max(untilS, eaUntilS)
           else
               f_exit_short("EARLY_ABORT")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Phase-Trail derived series (must be AFTER EMAs + satyOsc_chart exist)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
phTrailEma =
    phTrailEmaSrc=="EMA5"  ? ema5  :
    phTrailEmaSrc=="EMA8"  ? ema8  :
    phTrailEmaSrc=="EMA13" ? emaMid :
                             ema21

phaseSlopeDown = ta.falling(satyOsc_chart, phTrailSlopeBars)  // weakens longs
phaseSlopeUp   = ta.rising (satyOsc_chart, phTrailSlopeBars)  // weakens shorts
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X3c) Phase-Aware Trailing Stop (place AFTER ST trail + BE/EA,
//       and BEFORE Prioritized Exits / EMA emergency exit)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if barstate.isconfirmed and phTrailEnable
   _barsOK = barsInTrade >= phTrailMinBars

   // LONG
   if inLong and not na(entryPriceLong) and not na(lastSL_Long)
       _profTk = math.round((close - entryPriceLong) / syminfo.mintick)
       _profOK = _profTk >= phTrailMinProfitTk

       if _barsOK and _profOK and phaseSlopeDown
           _trailSL = f_to_tick(phTrailEma - phTrailOffsetTicks * syminfo.mintick)

           // only tighten (never loosen)
           if _trailSL > lastSL_Long
               strategy.exit(BRACKET_L_ID, "Long", stop=_trailSL, limit=lastTP_Long)
               f_send_amend(orderContract, "SL", _trailSL, posSeqL)
               lastSL_Long := _trailSL

   // SHORT
   if inShort and not na(entryPriceShort) and not na(lastSL_Short)
       _profTkS = math.round((entryPriceShort - close) / syminfo.mintick)
       _profOKS = _profTkS >= phTrailMinProfitTk

       if _barsOK and _profOKS and phaseSlopeUp
           _trailSLS = f_to_tick(phTrailEma + phTrailOffsetTicks * syminfo.mintick)

           // only tighten (never loosen)
           if _trailSLS < lastSL_Short
               strategy.exit(BRACKET_S_ID, "Short", stop=_trailSLS, limit=lastTP_Short)
               f_send_amend(orderContract, "SL", _trailSLS, posSeqS)
               lastSL_Short := _trailSLS


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  VIS: Live SL/TP labels + BE stamp
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupTradeMarks = "â”â” L2) Trade Marks"

showTradeMarks = input.bool(true, "Show SL/TP labels + BE stamps", group=groupTradeMarks)
slLabelOffsetTicks = input.int(18, "SL label Y offset (ticks)", minval=0, group=groupTradeMarks)
tpLabelOffsetTicks = input.int(18, "TP label Y offset (ticks)", minval=0, group=groupTradeMarks)

beStampEnable = input.bool(true, "Show BE stamp when BE applied", group=groupTradeMarks)
beStampEmoji  = input.string("ðŸŸ¦BE", "BE stamp text", group=groupTradeMarks)
beStampYOffsetTicks = input.int(0, "BE stamp Y offset (ticks)", minval=0, group=groupTradeMarks)

// Live labels (one set active at a time)
var label slLiveLabel = na
var label tpLiveLabel = na




if showTradeMarks and beStampEnable and beStampNow
   label.new(
       bar_index, high,
       beStampEmoji,
       xloc=xloc.bar_index, yloc=yloc.price,
       style=label.style_label_down,
       size=size.tiny,
       color=color.new(color.aqua, 0),
       textcolor=color.white
   )
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  X7) EMA EXIT PAIR (emergency) â€” EXIT-SIDE ONLY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groupExitEMA = "EXIT: X7) EMA Exit Pair"

exitPairLen = input.int(29,"Exit Pair Slow", group=groupExitEMA)
emaPair     = ta.ema(close, exitPairLen)
crossExitDown = ta.crossunder(emaExit, emaPair)
crossExitUp   = ta.crossover (emaExit, emaPair)
// â”€â”€ Phase Exit group (all Phase-related inputs live here)
groupPhaseExit = "EXIT: X8) Phase Exit"


// Do Phase/TD have to "arm" before Phase exit can fire?
phaseExitNeedArm     = input.bool(false, "Phase exit requires Phase-leave arm", group=groupPhaseExit)

// Default: we now prefer pure Phase dots (61.8/100) over RSI div
phaseExitUseRSIDiv   = input.bool(false, "Phase exit uses RSI(5) divergence (else Phase dots)", group=groupPhaseExit)

// --- Phase arm state: remember last Phase-leave *since entry*
var int lastPhaseLeaveBarL = na
var int lastPhaseLeaveBarS = na

// Arm on Phase leave while in a position
if inLong and leaving_distribution
   lastPhaseLeaveBarL := bar_index
if not inLong
   lastPhaseLeaveBarL := na

if inShort and leaving_accumulation
   lastPhaseLeaveBarS := bar_index
if not inShort
   lastPhaseLeaveBarS := na

// â€œArmedâ€ means: we had a Phase-leave while this position has been open
phaseArmedL = not na(lastPhaseLeaveBarL)
phaseArmedS = not na(lastPhaseLeaveBarS)



// Effective flags: either require arm (Phase-leave) or not
phaseExitAllowedL = phaseExitNeedArm ? phaseArmedL : true
phaseExitAllowedS = phaseExitNeedArm ? phaseArmedS : true

// Phase exit signals:
//  - Long: Phase dot by default (leave +61.8 or +100)
//  - Short: Phase dot by default (leave -61.8 or -100)
//  - If phaseExitUseRSIDiv = true, revert to RSI(5) divergence semantics
phaseExitSignalL = phaseExitAllowedL and (phaseExitUseRSIDiv ? phaseRSI_BearDiv : phaseDotLong)
phaseExitSignalS = phaseExitAllowedS and (phaseExitUseRSIDiv ? phaseRSI_BullDiv : phaseDotShort)



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Y3) PRIORITIZED EXITS (FUSE â†’ PDZ â†’ ATR â†’ PHASE â†’ TD â†’ EMA)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if barstate.isconfirmed
   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   // LONG side
   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if inLong
       bool exitDoneL = false

       // 1) FUSE EXIT (Base vs Late)
       if isLateLongPos
           // LATE HARD (always wins)
           if lateHardFuseLong
               f_exit_long("FUSE_HARD_LATE")
               lateFuseArmedL   := false
               lateFuseArmBarL  := na
               exitDoneL := true
           else
               // Optional: HARD-only mode disables soft arming
               if (not lateUseHardFuseOnly)
                   if lateSoftFuseLong and not lateFuseArmedL
                       lateFuseArmedL  := true
                       lateFuseArmBarL := bar_index

                   if not exitDoneL and lateFuseArmedL and lateConfirmLong
                       f_exit_long("FUSE_SOFT_CONFIRM_LATE")
                       lateFuseArmedL  := false
                       lateFuseArmBarL := na
                       exitDoneL := true
       else
           // BASE HARD
           if hardFuseLong
               f_exit_long("FUSE_HARD")
               fuseArmedL  := false
               fuseArmBarL := na
               exitDoneL := true
           else
               // BASE SOFT
               if softFuseLong and not fuseArmedL
                   fuseArmedL  := true
                   fuseArmBarL := bar_index

               if not exitDoneL and fuseArmedL and confirmLong
                   f_exit_long("FUSE_SOFT_CONFIRM")
                   fuseArmedL  := false
                   fuseArmBarL := na
                   exitDoneL := true

       // Precompute anchors once
       epL        = strategy.position_avg_price
       hitLadderL = ladderOn and touchUp(epL)
       hitPDZL    = usePDZ and inPremNow
       oppNowL    = close < oppEMA_TD

       // 2) PDZ (Lux premium zone) â€” "first leave arms, second leave exits"
       if not exitDoneL and usePDZ and premLeaveEvent
           bool canPDZ = (not useOppNowPDZ or oppNowL)

           // First time we leave premium â†’ arm only
           if not pdzArmedL
               if canPDZ
                   pdzArmedL := true
               // no exit yet; just mark that this trade has *tasted* premium

           // Second (or later) leave while armed â†’ trigger PDZ exit path
           else
               if canPDZ
                   _pdzSkip = isLateLongPos ? latePDZ_skipBars : pdzSkipBars
                   _pdzNeedOpp = isLateLongPos ? latePDZ_oppUseEMA : pdzOppUseEMA

                   [pdzDefL, pdzUntilL] = f_should_defer_agg(pdzUseChart, pdzUse1m, pdzCompAgg, pdzMode, _pdzSkip)

                   _pdzOppOK_effective = (not _pdzNeedOpp) or _pdzOppOkL
                   if pdzDefL or not _pdzOppOK_effective
                       // Defer PDZ exit: let compression / Opp-EMA resolve
                       pendL       := true
                       pendReasonL := "PDZ"
                       if pdzMode=="Skip N Bars" and not na(pdzUntilL)
                           untilL := na(untilL) ? pdzUntilL : math.max(untilL, pdzUntilL)
                   else
                       // Immediate PDZ exit on second leave
                       f_exit_long("PDZ_LUX_EXIT")
                       pendL        := false
                       untilL       := na
                       pendReasonL  := ""
                       exitDoneL    := true

               // After weâ€™ve consumed the second leave, clear the arm either way
               pdzArmedL := false

       // 3) ATR Ladder (stateful): Touch â†’ Arm, then Confirm â†’ Exit (once)
       if inLong and ladderOn and not ladderDoneL
           // Arm on first touch (wick is fine)
           if not ladderArmedL and touchUp(strategy.position_avg_price)
               ladderArmedL := true

           // Confirm: close rejects back below ladder by X ticks OR ST flips against
           ladderConfirmL = ladderArmedL and (close < (L_up - ladderConfirmPx) or stBiasShort)

           if not exitDoneL and ladderConfirmL
               canATR = (not ladderNeedOpp or oppNowL)
               if canATR
                   _atrSkip = isLateLongPos ? lateATR_skipBars : atrSkipBars
                   _atrNeedOpp = isLateLongPos ? lateATR_oppUseEMA : atrOppUseEMA

                   [atrDefL, atrUntilL] = f_should_defer_agg(atrUseChart, atrUse1m, atrCompAgg, atrMode, _atrSkip)

                   _atrOppOK_effective = (not _atrNeedOpp) or _atrOppOkL
                   if atrDefL or not _atrOppOK_effective
                       pendL := true
                       pendReasonL := "ATR"
                       if atrMode=="Skip N Bars" and not na(atrUntilL)
                           untilL := na(untilL) ? atrUntilL : math.max(untilL, atrUntilL)
                   else
                       f_exit_long("ATR_LADDER_EXIT")
                       pendL        := false
                       untilL       := na
                       pendReasonL  := ""
                       exitDoneL    := true

               // Either way, consume the ladder for this trade (prevents repeated spam)
               ladderDoneL  := true
               ladderArmedL := false

       // 4) PHASE EXIT (LONG): Phase leave (or RSI div) + Phase defers
       if not exitDoneL and phaseExitSignalL
           // If any Phase defers are configured, go through the pend/defer path
           if phUseChart or phUse1m or phOppUseEMA
               _phSkip = isLateLongPos ? latePH_skipBars : phSkipBars
               _phNeedOpp = isLateLongPos ? latePH_oppUseEMA : phOppUseEMA

               [phDefL, phUntilL] = f_should_defer_agg(phUseChart, phUse1m, phCompAgg, phMode, _phSkip)

               _phOppOK_effective = (not _phNeedOpp) or _phOppOkL
               if phDefL or not _phOppOK_effective
                   // Defer: mark as pending Phase exit
                   pendL       := true
                   pendReasonL := "PH"
                   if phMode=="Skip N Bars" and not na(phUntilL)
                       untilL := na(untilL) ? phUntilL : math.max(untilL, phUntilL)
               else
                   // No defer â†’ exit immediately
                   f_exit_long("PHASE_EXIT")
                   pendL        := false
                   untilL       := na
                   pendReasonL  := ""
                   exitDoneL    := true
           else
               // Defers disabled â†’ always exit immediately
               f_exit_long("PHASE_EXIT")
               exitDoneL := true

       // 5) TD EXITS (Prep/Lead completed) - V2: with Candle Quality check
       if not exitDoneL
           oppGuardL = (tdOppLen <= 1) ? true : (close < oppEMA_TD)
           if (tdExitLead and leadBearDone) or (tdExitPrep and prepBearDone)
               if (not tdNeedOppTD) or oppGuardL
                   // V2: Check candle quality first
                   _shouldExitByQuality = (not td9QualityEnable) or td9_shouldExitLong_Quality
                   _shouldHoldByQuality = td9QualityEnable and td9_shouldHoldLong_Quality

                   if _shouldHoldByQuality
                       // Candle quality says HOLD â†’ defer this TD exit
                       pendL := true
                       pendReasonL := "TD(Quality:Hold)"
                   else if _shouldExitByQuality
                       // Candle quality says EXIT â†’ proceed with normal TD exit logic
                       _tdSkip = isLateLongPos ? lateTD_skipBars : tdSkipBars
                       _tdNeedOpp = isLateLongPos ? lateTD_oppUseEMA : tdOppUseEMA

                       [tdDefL, tdUntilL] = f_should_defer_agg(tdUseChartDef, tdUse1mDef, tdCompAgg, tdMode, _tdSkip)

                       _tdOppOK_effective = (not _tdNeedOpp) or _tdOppOkL
                       if tdDefL or not _tdOppOK_effective
                           pendL := true
                           pendReasonL := "TD"
                           if tdMode=="Skip N Bars" and not na(tdUntilL)
                               untilL := na(untilL) ? tdUntilL : math.max(untilL, tdUntilL)
                       else
                           f_exit_long("TDSEQ_EXIT")
                           pendL        := false
                           untilL       := na
                           pendReasonL  := ""
                           exitDoneL    := true

       // 6) EMA PAIR EMERGENCY EXIT
       if not exitDoneL and crossExitDown
           if exitCompressed or deferByMomentum_Long
               exitPendL := true
               if exitCompMode=="Skip N Bars"
                   exitUntilL := na(exitUntilL) ? (bar_index + exitCompSkipBars) : math.max(exitUntilL, bar_index + exitCompSkipBars)
           else
               f_exit_long("EXIT_EMA_CROSS")
               exitDoneL  := true

   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   // SHORT side
   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if inShort
       bool exitDoneS = false

       // 1) FUSE EXIT (Base vs Late)
       if isLateShortPos
           if lateHardFuseShort
               f_exit_short("FUSE_HARD_LATE")
               lateFuseArmedS   := false
               lateFuseArmBarS  := na
               exitDoneS := true
           else
               if (not lateUseHardFuseOnly)
                   if lateSoftFuseShort and not lateFuseArmedS
                       lateFuseArmedS  := true
                       lateFuseArmBarS := bar_index

                   if not exitDoneS and lateFuseArmedS and lateConfirmShort
                       f_exit_short("FUSE_SOFT_CONFIRM_LATE")
                       lateFuseArmedS  := false
                       lateFuseArmBarS := na
                       exitDoneS := true
       else
           if hardFuseShort
               f_exit_short("FUSE_HARD")
               fuseArmedS  := false
               fuseArmBarS := na
               exitDoneS := true
           else
               if softFuseShort and not fuseArmedS
                   fuseArmedS  := true
                   fuseArmBarS := bar_index

               if not exitDoneS and fuseArmedS and confirmShort
                   f_exit_short("FUSE_SOFT_CONFIRM")
                   fuseArmedS  := false
                   fuseArmBarS := na
                   exitDoneS := true

       // Precompute anchors once
       epS        = strategy.position_avg_price
       hitLadderS = ladderOn and touchDn(epS)
       hitPDZS    = usePDZ and inDiscNow
       oppNowS    = close > oppEMA_TD

       // 2) PDZ (Lux discount zone) â€” "first leave arms, second leave exits"
       if not exitDoneS and usePDZ and discLeaveEvent
           bool canPDZS = (not useOppNowPDZ or oppNowS)

           // First leave of discount â†’ arm only
           if not pdzArmedS
               if canPDZS
                   pdzArmedS := true
               // no exit yet; just mark discount has been tested & rejected

           // Second (or later) leave while armed â†’ trigger PDZ exit path
           else
               if canPDZS
                   _pdzSkip = isLateShortPos ? latePDZ_skipBars : pdzSkipBars
                   _pdzNeedOpp = isLateShortPos ? latePDZ_oppUseEMA : pdzOppUseEMA

                   [pdzDefS, pdzUntilS] = f_should_defer_agg(pdzUseChart, pdzUse1m, pdzCompAgg, pdzMode, _pdzSkip)

                   _pdzOppOK_effective = (not _pdzNeedOpp) or _pdzOppOkS
                   if pdzDefS or not _pdzOppOK_effective
                       pendS       := true
                       pendReasonS := "PDZ"
                       if pdzMode=="Skip N Bars" and not na(pdzUntilS)
                           untilS := na(untilS) ? pdzUntilS : math.max(untilS, pdzUntilS)
                   else
                       f_exit_short("PDZ_LUX_EXIT")
                       pendS        := false
                       untilS       := na
                       pendReasonS  := ""
                       exitDoneS    := true

               // Clear arm after second-leave handling
               pdzArmedS := false

       // 3) ATR Ladder (stateful): Touch â†’ Arm, then Confirm â†’ Exit (once)
       if inShort and ladderOn and not ladderDoneS
           if not ladderArmedS and touchDn(strategy.position_avg_price)
               ladderArmedS := true

           ladderConfirmS = ladderArmedS and (close > (L_dn + ladderConfirmPx) or stBiasLong)

           if not exitDoneS and ladderConfirmS
               canATRS = (not ladderNeedOpp or oppNowS)
               if canATRS
                   _atrSkip = isLateShortPos ? lateATR_skipBars : atrSkipBars
                   _atrNeedOpp = isLateShortPos ? lateATR_oppUseEMA : atrOppUseEMA

                   [atrDefS, atrUntilS] = f_should_defer_agg(atrUseChart, atrUse1m, atrCompAgg, atrMode, _atrSkip)

                   _atrOppOK_effective = (not _atrNeedOpp) or _atrOppOkS
                   if atrDefS or not _atrOppOK_effective
                       pendS := true
                       pendReasonS := "ATR"
                       if atrMode=="Skip N Bars" and not na(atrUntilS)
                           untilS := na(untilS) ? atrUntilS : math.max(untilS, atrUntilS)
                   else
                       f_exit_short("ATR_LADDER_EXIT")
                       pendS        := false
                       untilS       := na
                       pendReasonS  := ""
                       exitDoneS    := true

               ladderDoneS  := true
               ladderArmedS := false

       // 4) PHASE EXIT (SHORT): Phase leave (or RSI div) + Phase defers
       if not exitDoneS and phaseExitSignalS
           if phUseChart or phUse1m or phOppUseEMA
               _phSkip = isLateShortPos ? latePH_skipBars : phSkipBars
               _phNeedOpp = isLateShortPos ? latePH_oppUseEMA : phOppUseEMA

               [phDefS, phUntilS] = f_should_defer_agg(phUseChart, phUse1m, phCompAgg, phMode, _phSkip)

               _phOppOK_effective = (not _phNeedOpp) or _phOppOkS
               if phDefS or not _phOppOK_effective
                   pendS       := true
                   pendReasonS := "PH"
                   if phMode=="Skip N Bars" and not na(phUntilS)
                       untilS := na(untilS) ? phUntilS : math.max(untilS, phUntilS)
               else
                   f_exit_short("PHASE_EXIT")
                   pendS        := false
                   untilS       := na
                   pendReasonS  := ""
                   exitDoneS    := true
           else
               f_exit_short("PHASE_EXIT")
               exitDoneS := true

       // 5) TD EXITS (Prep/Lead completed) - V2: with Candle Quality check
       if not exitDoneS
           oppGuardS = (tdOppLen <= 1) ? true : (close > oppEMA_TD)
           if (tdExitLead and leadBullDone) or (tdExitPrep and prepBullDone)
               if (not tdNeedOppTD) or oppGuardS
                   // V2: Check candle quality first
                   _shouldExitByQuality = (not td9QualityEnable) or td9_shouldExitShort_Quality
                   _shouldHoldByQuality = td9QualityEnable and td9_shouldHoldShort_Quality

                   if _shouldHoldByQuality
                       // Candle quality says HOLD â†’ defer this TD exit
                       pendS := true
                       pendReasonS := "TD(Quality:Hold)"
                   else if _shouldExitByQuality
                       // Candle quality says EXIT â†’ proceed with normal TD exit logic
                       _tdSkip = isLateShortPos ? lateTD_skipBars : tdSkipBars
                       _tdNeedOpp = isLateShortPos ? lateTD_oppUseEMA : tdOppUseEMA

                       [tdDefS, tdUntilS] = f_should_defer_agg(tdUseChartDef, tdUse1mDef, tdCompAgg, tdMode, _tdSkip)

                       _tdOppOK_effective = (not _tdNeedOpp) or _tdOppOkS
                       if tdDefS or not _tdOppOK_effective
                           pendS := true
                           pendReasonS := "TD"
                           if tdMode=="Skip N Bars" and not na(tdUntilS)
                               untilS := na(untilS) ? tdUntilS : math.max(untilS, tdUntilS)
                       else
                           f_exit_short("TDSEQ_EXIT")
                           pendS        := false
                           untilS       := na
                           pendReasonS  := ""
                           exitDoneS    := true

       // 6) EMA PAIR EMERGENCY EXIT
       if not exitDoneS and crossExitUp
           if exitCompressed or deferByMomentum_Short
               exitPendS := true
               if exitCompMode=="Skip N Bars"
                   exitUntilS := na(exitUntilS) ? (bar_index + exitCompSkipBars) : math.max(exitUntilS, bar_index + exitCompSkipBars)
           else
               f_exit_short("EXIT_EMA_CROSS")
               exitDoneS  := true

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Y4) SETTLE PENDING SIGNAL-LEVEL EXITS (PDZ / ATR / PH / TD / EA)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if pendL
   if not inLong
       pendL := false
       untilL := na
       pendReasonL := ""
   else
       canReleaseL =            (pdzMode=="Skip N Bars" or atrMode=="Skip N Bars" or phMode=="Skip N Bars" or tdMode=="Skip N Bars" or eaModeDef=="Skip N Bars") ?                (not na(untilL) and bar_index>=untilL and not isComp1m) :                (not isComp1m)
       if canReleaseL
           if close < oppEMA_TD
               if f_pend_is_compressed(true)
                   exitPendL := true
                   if exitCompMode=="Skip N Bars"
                       exitUntilL := na(exitUntilL) ? (bar_index + exitCompSkipBars) : math.max(exitUntilL, bar_index + exitCompSkipBars)
               else
                   f_exit_long("DEFER_EXIT")
                   pendL := false
                   untilL := na
                   pendReasonL := ""

if pendS
   if not inShort
       pendS := false
       untilS := na
       pendReasonS := ""
   else
       canReleaseS =            (pdzMode=="Skip N Bars" or atrMode=="Skip N Bars" or phMode=="Skip N Bars" or tdMode=="Skip N Bars" or eaModeDef=="Skip N Bars") ?                (not na(untilS) and bar_index>=untilS and not isComp1m) :                (not isComp1m)
       if canReleaseS
           if close > oppEMA_TD
               if f_pend_is_compressed(false)
                   exitPendS := true
                   if exitCompMode=="Skip N Bars"
                       exitUntilS := na(exitUntilS) ? (bar_index + exitCompSkipBars) : math.max(exitUntilS, bar_index + exitCompSkipBars)
               else
                   f_exit_short("DEFER_EXIT")
                   pendS := false
                   untilS := na
                   pendReasonS := ""

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Y5) SETTLE GENERIC EXIT-COMP GATE (EXIT_EMA + deferred signals)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if exitPendL
   if not inLong
       exitPendL := false
       exitUntilL := na
       pendReasonL := ""
   else
       okSideL  = (not exitReleaseEmaCheck) or (close < exitRelEMA)
       canSendL =            ((exitCompMode=="Skip N Bars" and (not na(exitUntilL) and bar_index>=exitUntilL) and not f_pend_is_compressed(true)) or             (exitCompMode=="Block While Compressed" and not f_pend_is_compressed(true))) and okSideL
       if canSendL
           f_exit_long("DEFER_EXIT_COMP")
           exitPendL := false
           exitUntilL := na
           pendReasonL := ""

if exitPendS
   if not inShort
       exitPendS := false
       exitUntilS := na
       pendReasonS := ""
   else
       okSideS  = (not exitReleaseEmaCheck) or (close > exitRelEMA)
       canSendS =            ((exitCompMode=="Skip N Bars" and (not na(exitUntilS) and bar_index>=exitUntilS) and not f_pend_is_compressed(false)) or             (exitCompMode=="Block While Compressed" and not f_pend_is_compressed(false))) and okSideS
       if canSendS
           f_exit_short("DEFER_EXIT_COMP")
           exitPendS := false
           exitUntilS := na
           pendReasonS := ""

if strategy.position_size == 0
   // Base
   fuseArmedL  := false
   fuseArmedS  := false
   fuseArmBarL := na
   fuseArmBarS := na
   // Late
   lateFuseArmedL  := false
   lateFuseArmedS  := false
   lateFuseArmBarL := na
   lateFuseArmBarS := na

// Reset PDZ arms when flat (no open position)
if strategy.position_size == 0
   pdzArmedL := false
   pdzArmedS := false

// ============================================================================
//  VISUALS & HUD (unchanged from your Phoenix v1.1 script)
// ============================================================================

groupVisLite = "â”â” L) Visuals & HUD"

bgLongColor   = input.color(color.new(color.teal,0),"Long BG",group=groupVisLite)
bgShortColor  = input.color(color.new(color.red,0), "Short BG",group=groupVisLite)
bgTransp      = input.int(80,"BG transparency (0=opaque)",minval=0,maxval=100,group=groupVisLite)


showHUD       = input.bool(false,"Show simple HUD",group=groupVisLite)

// Background shading by position
bgcolor(inLong  ? color.new(bgLongColor,bgTransp) : inShort ? color.new(bgShortColor,bgTransp) : na)





// Simple HUD
var label hudLabel = na
hudYOffset = input.int(20,"HUD Y-offset (ticks)",minval=0,group=groupVisLite)

if barstate.isnew and showHUD
   _y = close + hudYOffset*syminfo.mintick
   _state = inLong ? "LONG" : inShort ? "SHORT" : "FLAT"
   _env   = useLiveEnv ? "LIVE" : "DEMO"
   _txt   = "PHOENIX | " + _env + " | " + _state + " | Pos=" + str.tostring(strategy.position_size)
   if not na(hudLabel)
       label.delete(hudLabel)
   hudLabel := label.new(bar_index,_y,_txt,        xloc=xloc.bar_index,yloc=yloc.price,        style=label.style_label_left,        size=size.small,        color=color.new(color.black,0),        textcolor=color.white)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Update SL/TP labels while in a trade
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if showTradeMarks
   // Clean up when flat
   if strategy.position_size == 0
       if not na(slLiveLabel)
           label.delete(slLiveLabel)
           slLiveLabel := na
       if not na(tpLiveLabel)
           label.delete(tpLiveLabel)
           tpLiveLabel := na
   else
       // Decide which side we are on + pick the active SL/TP vars
       bool _inLong  = strategy.position_size > 0
       float _sl = _inLong ? lastSL_Long : lastSL_Short
       float _tp = _inLong ? lastTP_Long : lastTP_Short

       // SL label
       if not na(_sl)
           float _ySL = _sl + (_inLong ? slLabelOffsetTicks * syminfo.mintick : -slLabelOffsetTicks * syminfo.mintick)
           if not na(slLiveLabel)
               label.delete(slLiveLabel)
           slLiveLabel := label.new(
                bar_index, _ySL,
                "SL: " + toFixed(_sl),
                xloc=xloc.bar_index, yloc=yloc.price,
                style=_inLong ? label.style_label_up : label.style_label_down,
                size=size.small,
                color=color.new(color.red, 0),
                textcolor=color.white)

       // TP label (only if TP exists)
       if not na(_tp)
           float _yTP = _tp + (_inLong ? tpLabelOffsetTicks * syminfo.mintick : -tpLabelOffsetTicks * syminfo.mintick)
           if not na(tpLiveLabel)
               label.delete(tpLiveLabel)
           tpLiveLabel := label.new(
                bar_index, _yTP,
                "TP: " + toFixed(_tp),
                xloc=xloc.bar_index, yloc=yloc.price,
                style=_inLong ? label.style_label_down : label.style_label_up,
                size=size.small,
                color=color.new(color.green, 0),
                textcolor=color.white)
       else
           // If TP becomes na mid-trade, remove TP label
           if not na(tpLiveLabel)
               label.delete(tpLiveLabel)
               tpLiveLabel := na
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SIMPLIFIED EMA CROSS CHECK LABELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  NEW SIMPLE DEBUG LABELS (V2 Clean)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Cross Check Labels - show ONLY failed checks (clean)
if dbgShowFailures and (ltfCrossU or ltfCrossD)
   isLong = ltfCrossU
   entryFired = isLong ? longEntrySignal : shortEntrySignal

   if not entryFired
       failures = array.new<string>()

       // Check score
       if crossScoreEnable
           score = isLong ? crossScoreLong : crossScoreShort
           threshold = crossScoreThreshold
           if score < threshold
               array.push(failures, "Score: " + str.tostring(score, "#") + " < " + str.tostring(threshold))

       // Check session
       sessionOK = isLong ? sessionOK_Long : sessionOK_Short
       if not sessionOK
           array.push(failures, "Outside session")

       // Check RSI entry
       rsiOK = isLong ? rsiEntryLongOK : rsiEntryShortOK
       if not rsiOK
           array.push(failures, "RSI entry veto")

       // Check MTF
       mtfOK = isLong ? mtfLongOK : mtfShortOK
       if not mtfOK
           array.push(failures, "MTF veto")

       // Check 1m ST gate
       st1mGate = isLong ? mtfST_1m_gateLong_final : mtfST_1m_gateShort_final
       if not st1mGate
           array.push(failures, "1m ST gate")

       // Check core filters (break down if failing)
       coreOK = isLong ? coreFilter_Long : coreFilter_Short
       if not coreOK
           if not ltfSepOK
               array.push(failures, "EMA separation")
           if useProximityToEMA and not proxOK
               array.push(failures, "Proximity to EMA")
           if useATRfloor and not atrOK_raw
               array.push(failures, "ATR floor")
           if useADXStrength and not adxOK_raw
               array.push(failures, "ADX strength")
           nBeyondOK = isLong ? nBeyond_Long : nBeyond_Short
           if useNClosesBeyondEMA and not nBeyondOK
               array.push(failures, "N closes beyond EMA")
           wickBiasOK_check = isLong ? wickBiasOK_Long : wickBiasOK_Short
           if not wickBiasOK_check
               array.push(failures, "Wick bias")
           barDirOK_check = isLong ? barDirOK_Long : barDirOK_Short
           if not barDirOK_check
               array.push(failures, "Bar direction")
           priceSideOK_check = isLong ? priceSideOK_Long : priceSideOK_Short
           if not priceSideOK_check
               array.push(failures, "Price side")
           cloudOK_check = isLong ? cloudEntryOK_Long : cloudEntryOK_Short
           if not cloudOK_check
               array.push(failures, "Cloud/EMA stack")
           rrOK_check = isLong ? rrOK_Long : rrOK_Short
           if not rrOK_check
               array.push(failures, "Risk/Reward ratio")
           recentDiv = isLong ? recentBearDiv : recentBullDiv
           if recentDiv
               array.push(failures, "Recent RSI divergence")

       // Check add-ons
       addOnsOK_check = isLong ? addOnsOK_Long : addOnsOK_Short
       if not addOnsOK_check
           if not (isLong ? phaseLevelOK_Long : phaseLevelOK_Short)
               array.push(failures, "Phase level (" + str.tostring(satyOsc_chart, "#.#") + ")")
           if not stDistOK
               array.push(failures, "ST distance")
           if not (isLong ? rejLongOK : rejShortOK)
               array.push(failures, "Rejection confirm")
           if not (isLong ? pdzProxOK_Long : pdzProxOK_Short)
               array.push(failures, "PDZ proximity")

       // Check phase slope
       phaseSlopeOK = isLong ? phaseEntryOK_Long : phaseEntryOK_Short
       if not phaseSlopeOK
           array.push(failures, "Phase slope veto")

       // Check last dot
       lastDotOK = isLong ? lastDotOK_Long_Base : lastDotOK_Short_Base
       if not lastDotOK
           array.push(failures, "Last dot too recent")

       // Check ABS
       absOK = isLong ? absOK_Long_Base : absOK_Short_Base
       if not absOK
           array.push(failures, "ABS veto")

       // Check LTF Score
       ltfOK = isLong ? ltfScoreOK_Long : ltfScoreOK_Short
       if not ltfOK
           array.push(failures, "LTF Score")

       // Check abort cooldown
       if not (abortCooldownLateOnly ? true : abortCooldownOK)
           array.push(failures, "Abort cooldown")

       // Check impulse
       if not impulseOK
           array.push(failures, "Impulse veto")

       // Build label - cleaner format
       if array.size(failures) > 0
           labelText = "âŒ REJECTED (" + str.tostring(array.size(failures)) + ")\n"
           for i = 0 to math.min(array.size(failures) - 1, 9)
               labelText += "â€¢ " + array.get(failures, i) + "\n"

           if array.size(failures) > 10
               labelText += "+" + str.tostring(array.size(failures) - 10) + " more\n"

           labelY = isLong ? high + 25 * syminfo.mintick : low - 25 * syminfo.mintick
           labelColor = color.new(color.orange, 20)
           label.new(bar_index, labelY, labelText, style=label.style_label_down,
               color=labelColor, textcolor=color.white, size=size.small)

// Debug: TT LTF score (Data Window / Status Line)
// TradingView strategies don't reliably render separate panes, so keep this out of the chart.
plot(dbgPlotTTLTFScore ? ltfScoreCombined : na, "TT LTF Score (Phoenix)", color=color.new(color.aqua, 0), linewidth=1, display=display.data_window)
plot(dbgPlotTTLTFScore ? ltfScoreCombined[1] : na, "TT LTF Score prev (Phoenix)", color=color.new(color.gray, 0), linewidth=1, display=display.data_window)
plot(dbgPlotTTLTFScore ? (ltfScoreCombined - ltfScoreCombined[1]) : na, "TT LTF Î” (Phoenix)", color=color.new(color.purple, 0), linewidth=1, display=display.data_window)
plot(dbgPlotTTLTFScore ? ltfScore30m : na, "TT LTF 30m score (Phoenix)", color=color.new(color.blue, 0), linewidth=1, display=display.data_window)
plot(dbgPlotTTLTFScore ? ltfScore10m : na, "TT LTF 10m score (Phoenix)", color=color.new(color.orange, 0), linewidth=1, display=display.data_window)
plot(dbgPlotTTLTFScore ? ltfScore3m : na, "TT LTF 3m score (Phoenix)", color=color.new(color.fuchsia, 0), linewidth=1, display=display.data_window)

// READY pings based on infoPingMode from header
var string _lastInfoDay = ""
var float  _lastPosSize = na

_should_send_ready() =>
   infoPingMode=="Off"               ? false :    infoPingMode=="Every Bar (debug)" ? barstate.isconfirmed :    infoPingMode=="On Load"           ? barstate.isfirst :    infoPingMode=="Once/Day"          ? ((ta.change(time("D"))!=0) or (_lastInfoDay!=str.tostring(time("D")))) :                                        (strategy.position_size!=nz(_lastPosSize))

_readyNow = _should_send_ready()

if enableInfoAlerts and _readyNow
   f_send_info("Ready: "+syminfo.ticker+" | LTF="+ltfTF+" | TP_TF="+tpCalcTF)
   _lastInfoDay := str.tostring(time("D"))
   _lastPosSize := strategy.position_size

if barstate.isconfirmed and dbgSendInfo
   if ltfCrossU and not longEntrySignal
       f_send_info("WHY_NO_LONG | mtf=" + str.tostring(mtfLongOK) + " | 1mGate=" + str.tostring(mtfST_1m_gateLong_final) +
                   " | impulseOK=" + str.tostring(impulseOK) + " | slopeTk=" + f_fmt_dec(stSlopeTicks,0) +
                   " | 1mSlopeTk=" + f_fmt_dec(mtfST_1m_slopeTk,0))

   if ltfCrossD and not shortEntrySignal
       f_send_info("WHY_NO_SHORT | mtf=" + str.tostring(mtfShortOK) + " | 1mGate=" + str.tostring(mtfST_1m_gateShort_final) +
                   " | impulseOK=" + str.tostring(impulseOK) + " | slopeTk=" + f_fmt_dec(stSlopeTicks,0) +
                   " | 1mSlopeTk=" + f_fmt_dec(mtfST_1m_slopeTk,0))

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LATE ENTRY DEBUG LABELS (show status when armed)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if dbgShowFailures and (lateArmedL or lateArmedS)
   isLong = lateArmedL

   // Declare variables at function scope
   float st1m_anch = na
   float st3m_anch = na
   bool bothFav = false
   float st1m_moved = 0.0
   float st3m_moved = 0.0
   bool moveOk = false

   // Build status text
   statusText = "â³ LATE ARMED (" + (isLong ? "LONG" : "SHORT") + ")\n"

   // Bars remaining
   barsLeft = isLong ? (na(lateUntilL) ? 0 : math.max(0, lateUntilL - bar_index)) : (na(lateUntilS) ? 0 : math.max(0, lateUntilS - bar_index))
   statusText += "Bars left: " + str.tostring(barsLeft) + "\n"

   // Assign variables based on direction
   if isLong
       bothFav := bothFavLong
       st1m_anch := st1m_anchor_L
       st3m_anch := st3m_anchor_L
       moveOk := moveOk_L
       if not na(st1m_anch)
           st1m_moved := (st1m_line - st1m_anch) / syminfo.mintick
       if not na(st3m_anch)
           st3m_moved := (st3m_line - st3m_anch) / syminfo.mintick
   else
       bothFav := bothFavShort
       st1m_anch := st1m_anchor_S
       st3m_anch := st3m_anchor_S
       moveOk := moveOk_S
       if not na(st1m_anch)
           st1m_moved := (st1m_anch - st1m_line) / syminfo.mintick
       if not na(st3m_anch)
           st3m_moved := (st3m_anch - st1m_line) / syminfo.mintick

   // ONLY SHOW FAILURES
   statusText += "â”€â”€â”€ BLOCKING â”€â”€â”€\n"
   hasBlockers = false

   // Check if BOTH ST favorable
   if na(st1m_anch) or na(st3m_anch)
       statusText += "â€¢ âŒ Waiting for BOTH ST favorable\n"
       hasBlockers := true
   else if not moveOk
       modeText = lateST_stMoveMode == "Both" ? " (need both)" : lateST_stMoveMode == "Either" ? " (need either)" : lateST_stMoveMode == "1m Only" ? " (1m only)" : " (3m only)"
       statusText += "â€¢ âŒ ST move: 1m=" + str.tostring(st1m_moved, "#.#") + "/" + str.tostring(lateST_1mMoveTicks) + "tk, 3m=" + str.tostring(st3m_moved, "#.#") + "/" + str.tostring(lateST_3mMoveTicks) + "tk" + modeText + "\n"
       hasBlockers := true

   // Retest check
   if lateST_retestNeed
       retestSeen = isLong ? lateRetestSeenL : lateRetestSeenS
       structOk = isLong ? structConfirmLong : structConfirmShort
       structBypass = lateST_structBypassRetest and structOk

       if not structBypass and not retestSeen
           hintText = (structOk and not lateST_structBypassRetest) ? " (enable bypass)" : ""
           statusText += "â€¢ âŒ Retest EMA" + str.tostring(lateST_retestEmaLen) + " not seen" + hintText + "\n"
           hasBlockers := true

   // EMA5 reclaim
   ema5ReclaimOk = isLong ? ema5ReclaimOK_L : ema5ReclaimOK_S
   if not ema5ReclaimOk
       runNeed = lateST_ema5Consec
       runCurr = isLong ? ema5UpRun : ema5DnRun
       statusText += "â€¢ âŒ EMA5 reclaim: " + str.tostring(runCurr) + "/" + str.tostring(runNeed) + " closes\n"
       hasBlockers := true

   // EMA5 improvement
   if lateST_ema5MustImprove
       ema5Impr = isLong ? ema5Improved_Long : ema5Improved_Short
       if not ema5Impr
           ema5AtArm = isLong ? lateEma5AtArm_L : lateEma5AtArm_S
           ema5Curr = ema5
           ema5Delta = ((ema5Curr - ema5AtArm) / syminfo.mintick)
           statusText += "â€¢ âŒ EMA5 improve: " + str.tostring(ema5Delta, "#.#") + "tk (need " + str.tostring(lateST_ema5ImproveTicks) + ")\n"
           hasBlockers := true

   // EMA5 slope
   if lateST_useEma5Slope and lateST_ema5SlopeBars > 0
       ema5SlopeOk = isLong ? ema5SlopeOK_Long : ema5SlopeOK_Short
       if not ema5SlopeOk
           statusText += "â€¢ âŒ EMA5 slope (need " + (isLong ? "rising" : "falling") + ")\n"
           hasBlockers := true

   // 1m confirm
   if lateST_use1mConfirm
       confirm1m = isLong ? confirm1m_Long : confirm1m_Short
       if not confirm1m
           statusText += "â€¢ âŒ 1m ST confirm\n"
           hasBlockers := true

   // Structure path blocker
   if lateST_useStructureConfirm
       structOk = isLong ? structConfirmLong : structConfirmShort
       if not structOk
           statusText += "â€¢ âŒ 21/48 cross not confirmed\n"
           hasBlockers := true

   // Check if raw signal is ready
   lateRawOK = isLong ? lateSignalLong_raw : lateSignalShort_raw

   if not hasBlockers and lateRawOK
       statusText += "âœ… Path checks passed!\n"

   if lateRawOK
       // Check additional filters that block final entry (ONLY SHOW FAILURES)
       lateCoreOK = isLong ? lateCore_Long : lateCore_Short
       if not lateCoreOK
           // Break down Late Core components (only failures)
           lateSessionOK = isLong ? lateSession_Long : lateSession_Short
           if not lateSessionOK
               statusText += "â€¢ âŒ Late session window\n"
               hasBlockers := true

           rsiOK = isLong ? rsiEntryLongOK : rsiEntryShortOK
           if not rsiOK
               statusText += "â€¢ âŒ RSI entry filter\n"
               hasBlockers := true

           chaseOK = isLong ? chaseOK_Long : chaseOK_Short
           if not chaseOK
               statusText += "â€¢ âŒ Chase guard (too far from 5 EMA)\n"
               hasBlockers := true

           lateCoreFilterOK = isLong ? lateCoreFilter_Long : lateCoreFilter_Short
           if not lateCoreFilterOK
               // Break down Core filter components (only failures)
               if not ltfSepOK
                   statusText += "â€¢ âŒ EMA separation\n"
                   hasBlockers := true

               if useProximityToEMA and not proxOK
                   statusText += "â€¢ âŒ Proximity to EMA\n"
                   hasBlockers := true

               if useATRfloorLate and not atrOK_late
                   statusText += "â€¢ âŒ ATR floor (Late: " + str.tostring(atrTicks, "#.#") + "/" + str.tostring(atrFloorTicksLate) + " ticks)\n"
                   hasBlockers := true

               if useADXStrength and not adxOK_raw
                   statusText += "â€¢ âŒ ADX strength\n"
                   hasBlockers := true

               nBeyondOK = isLong ? nBeyond_Long : nBeyond_Short
               if useNClosesBeyondEMA and not nBeyondOK
                   statusText += "â€¢ âŒ N closes beyond EMA\n"
                   hasBlockers := true

               wickBiasOK = isLong ? wickBiasOK_Long : wickBiasOK_Short
               if not wickBiasOK
                   statusText += "â€¢ âŒ Wick bias\n"
                   hasBlockers := true

               barDirOK = isLong ? barDirOK_Long : barDirOK_Short
               if not barDirOK
                   statusText += "â€¢ âŒ Bar direction\n"
                   hasBlockers := true

               priceSideOK = isLong ? priceSideOK_Long : priceSideOK_Short
               if not priceSideOK
                   statusText += "â€¢ âŒ Price side\n"
                   hasBlockers := true

               cloudOK = isLong ? cloudEntryOK_Long : cloudEntryOK_Short
               if not cloudOK
                   statusText += "â€¢ âŒ Cloud/EMA stack\n"
                   hasBlockers := true

               rrOK = isLong ? rrOK_Long : rrOK_Short
               if not rrOK
                   statusText += "â€¢ âŒ Risk/Reward ratio\n"
                   hasBlockers := true

               recentDiv = isLong ? recentBearDiv : recentBullDiv
               if recentDiv
                   statusText += "â€¢ âŒ Recent RSI divergence\n"
                   hasBlockers := true

           htfOK = isLong ? ((not htfEMA_ApplyToEntries) or htfPersistLongOK) : ((not htfEMA_ApplyToEntries) or htfPersistShortOK)
           if not htfOK
               statusText += "â€¢ âŒ HTF EMA bias\n"
               hasBlockers := true

           ltfScoreOK_check = isLong ? ltfScoreOK_Long : ltfScoreOK_Short
           if not ltfScoreOK_check
               statusText += "â€¢ âŒ LTF Score\n"
               hasBlockers := true

       if not impulseOK
           statusText += "â€¢ âŒ Impulse veto\n"
           hasBlockers := true

       cooldownOK = isLong ? cooldownLongOK : cooldownShortOK
       if not cooldownOK
           statusText += "â€¢ âŒ Cooldown active\n"
           hasBlockers := true

       lastDotOK_Late = isLong ? lastDotOK_Long_Late : lastDotOK_Short_Late
       if not lastDotOK_Late
           statusText += "â€¢ âŒ Last dot too recent (Late)\n"
           hasBlockers := true

       absOK_Late = isLong ? absOK_Long_Late : absOK_Short_Late
       if not absOK_Late
           statusText += "â€¢ âŒ ABS veto (Late)\n"
           hasBlockers := true

       if not abortCooldownOK
           statusText += "â€¢ âŒ Abort cooldown\n"
           hasBlockers := true

   // If no blockers at all
   if not hasBlockers
       statusText += "âœ… ALL CHECKS PASSED!\n(Entry should fire this bar)"

   // Display label
   labelY = isLong ? low - 30 * syminfo.mintick : high + 30 * syminfo.mintick
   labelColor = color.new(color.purple, 20)
   label.new(bar_index, labelY, statusText, style=isLong ? label.style_label_down : label.style_label_up,
       color=labelColor, textcolor=color.white, size=size.small)

// Simple Exit Reason Labels
if dbgShowExitReason and strategy.position_size[1] != 0 and strategy.position_size == 0
   wasLong = strategy.position_size[1] > 0
   pnl = strategy.netprofit - strategy.netprofit[1]
   labelText = "ðŸ›‘ EXIT (" + (wasLong ? "LONG" : "SHORT") + ")\nP/L: " + str.tostring(pnl, "#.##")
   labelColor = pnl > 0 ? color.new(color.green, 30) : color.new(color.red, 30)
   label.new(bar_index[1], close[1], labelText, style=label.style_label_left,
       color=labelColor, textcolor=color.white, size=size.normal)


