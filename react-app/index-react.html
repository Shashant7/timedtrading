<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"
    />
    <title>Timed Trading</title>

    <!-- React & ReactDOM via CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
      onerror="console.error('Failed to load React')"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      onerror="console.error('Failed to load ReactDOM')"
    ></script>

    <!-- PropTypes for Recharts compatibility (React 18 doesn't include it) -->
    <script
      crossorigin
      src="https://unpkg.com/prop-types@15/prop-types.min.js"
      onerror="console.error('Failed to load PropTypes')"
    ></script>
    <script>
      // Make PropTypes available globally for Recharts
      if (typeof PropTypes === "undefined" && typeof window !== "undefined") {
        console.warn("PropTypes not loaded, Recharts may have issues");
      } else if (typeof PropTypes !== "undefined") {
        // Ensure React.PropTypes is available for older libraries
        if (typeof React !== "undefined" && !React.PropTypes) {
          React.PropTypes = PropTypes;
        }
      }
    </script>

    <!-- Babel Standalone for JSX -->
    <script
      src="https://unpkg.com/@babel/standalone/babel.min.js"
      onerror="console.error('Failed to load Babel')"
    ></script>

    <!-- Tailwind CSS -->
    <script
      src="https://cdn.tailwindcss.com"
      onerror="console.error('Failed to load Tailwind')"
    ></script>

    <!-- Recharts for lightweight charting - try multiple sources -->
    <script
      src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"
      onerror="
        console.error(
          'Failed to load Recharts from unpkg, trying alternative...',
        );
        loadRechartsFallback();
      "
    ></script>
    <script>
      function loadRechartsFallback() {
        // Try alternative CDN
        const script = document.createElement("script");
        script.src =
          "https://cdn.jsdelivr.net/npm/recharts@2.10.3/umd/Recharts.js";
        script.onerror = function () {
          console.error("Recharts failed to load from all sources");
          window.RechartsFailed = true;
        };
        script.onload = function () {
          console.log("Recharts loaded from jsdelivr");
        };
        document.head.appendChild(script);
      }

      // Check if Recharts loaded after a delay
      window.addEventListener("load", function () {
        setTimeout(function () {
          if (typeof Recharts === "undefined" && !window.RechartsFailed) {
            console.warn("Recharts may not have loaded yet");
          }
        }, 2000);
      });
    </script>

    <!-- Loading indicator while scripts load -->
    <script>
      window.addEventListener("load", function () {
        // Check if all scripts loaded
        setTimeout(function () {
          const root = document.getElementById("root");
          if (root && root.innerHTML === "") {
            if (typeof React === "undefined") {
              root.innerHTML =
                '<div style="padding: 40px; text-align: center; color: #e7ecff;"><h2 style="color: #e74c3c;">Loading Error</h2><p>React failed to load. Check console (F12) for details.</p></div>';
            }
          }
        }, 2000);
      });
    </script>

    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --text: #e7ecff;
        --muted: #93a4d6;
        --line: #26325f;
        --good: #2ecc71;
        --bad: #e74c3c;
      }

      body {
        margin: 0;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial;
        background: var(--bg);
        color: var(--text);
      }

      /* Fix rare font ligature rendering issues (e.g., missing ‚Äúr‚Äù in ‚Äútr‚Äù). */
      .no-ligatures {
        font-variant-ligatures: none;
        font-feature-settings:
          "liga" 0,
          "clig" 0,
          "calt" 0;
      }

      .slider-thumb::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #00ffff;
        cursor: pointer;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
      }

      .slider-thumb::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #00ffff;
        cursor: pointer;
        border: none;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
      }

      .loading-spinner {
        border: 2px solid var(--line);
        border-top: 2px solid var(--text);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .prime-glow {
        box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        animation: pulse-glow 2s ease-in-out infinite;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        }
        50% {
          box-shadow: 0 0 20px rgba(46, 204, 113, 0.6);
        }
      }

      .momentum-elite-glow {
        box-shadow:
          0 0 15px rgba(168, 85, 247, 0.5),
          0 0 25px rgba(236, 72, 153, 0.3);
        animation: momentum-pulse 2.5s ease-in-out infinite;
      }

      @keyframes momentum-pulse {
        0%,
        100% {
          box-shadow:
            0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow:
            0 0 25px rgba(168, 85, 247, 0.8),
            0 0 45px rgba(236, 72, 153, 0.6);
        }
      }

      /* Slide-in overlay from right */
      .slide-in-right {
        animation: slideInRight 0.3s ease-out;
      }
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      /* Comet trail effect */
      .comet-trail {
        stroke-dasharray: 5, 5;
        animation: cometMove 2s linear infinite;
      }
      @keyframes cometMove {
        from {
          stroke-dashoffset: 0;
        }
        to {
          stroke-dashoffset: 20;
        }
      }

      /* Bubble Trail path (prefer readability over animation) */
      .trail-path {
        stroke-linecap: round;
        stroke-linejoin: round;
        filter: drop-shadow(0 0 4px rgba(0, 255, 255, 0.25));
      }

      @keyframes momentum-pulse-old {
        0%,
        100% {
          box-shadow:
            0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow:
            0 0 25px rgba(168, 85, 247, 0.7),
            0 0 35px rgba(236, 72, 153, 0.5);
        }
      }

      .bubble-transition {
        transition: all 0.2s ease-out;
      }

      .bubble-hover {
        transform: scale(1.15);
        filter: brightness(1.2);
      }

      .fade-in {
        animation: fadeIn 0.3s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slide-in {
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Phase color gradient helper */
      .phase-gradient {
        background: linear-gradient(
          to right,
          #2ecc71 0%,
          #27ae60 20%,
          #f39c12 40%,
          #e67e22 60%,
          #e74c3c 80%,
          #c0392b 100%
        );
      }

      /* Hide scrollbars while keeping scroll functionality */
      .scrollbar-hide {
        -ms-overflow-style: none; /* IE and Edge */
        scrollbar-width: none; /* Firefox */
      }
      .scrollbar-hide::-webkit-scrollbar {
        display: none; /* Chrome, Safari, Opera */
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div style="padding: 40px; text-align: center; color: #e7ecff">
        <div class="loading-spinner" style="margin: 0 auto 20px"></div>
        <p>Loading dashboard...</p>
      </div>
    </div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef, memo } = React;

      // Get Recharts components with fallback
      let RechartsComponents = null;
      if (typeof Recharts !== "undefined") {
        RechartsComponents = {
          ScatterChart: Recharts.ScatterChart,
          Scatter: Recharts.Scatter,
          XAxis: Recharts.XAxis,
          YAxis: Recharts.YAxis,
          CartesianGrid: Recharts.CartesianGrid,
          Tooltip: Recharts.Tooltip,
          ResponsiveContainer: Recharts.ResponsiveContainer,
          ReferenceLine: Recharts.ReferenceLine,
          ReferenceArea: Recharts.ReferenceArea,
        };
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Types & Constants
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
      const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
      const API_BASE = "https://timed-trading-ingest.shashant.workers.dev";

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Hooks
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Normalize trail point keys so chart rendering doesn't collapse to 0,0
      // Supports older / alternate API formats (x/y, ltf/htf, etc.)
      function normalizeTrailPoints(trail) {
        if (!Array.isArray(trail)) return [];
        return trail
          .map((p) => {
            if (!p || typeof p !== "object") return null;

            const ltf =
              p.ltf_score ??
              p.ltfScore ??
              p.ltf ??
              p.x ??
              p.ltf_value ??
              p.ltfValue ??
              p.ltf_score_value;
            const htf =
              p.htf_score ??
              p.htfScore ??
              p.htf ??
              p.y ??
              p.htf_value ??
              p.htfValue ??
              p.htf_score_value;

            const phase =
              p.phase_pct ??
              p.phasePct ??
              p.phase ??
              p.phase_completion ??
              p.phaseCompletion;
            const completion =
              p.completion ?? p.comp ?? p.completion_pct ?? p.completionPct;

            return {
              ...p,
              ltf_score: Number.isFinite(Number(ltf)) ? Number(ltf) : 0,
              htf_score: Number.isFinite(Number(htf)) ? Number(htf) : 0,
              phase_pct: Number.isFinite(Number(phase))
                ? Math.max(0, Math.min(1, Number(phase)))
                : Number.isFinite(Number(p.phase_pct))
                  ? Number(p.phase_pct)
                  : 0,
              completion: Number.isFinite(Number(completion))
                ? Math.max(0, Math.min(1, Number(completion)))
                : Number.isFinite(Number(p.completion))
                  ? Number(p.completion)
                  : 0,
            };
          })
          .filter(Boolean);
      }

      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);
        const [versionInfo, setVersionInfo] = useState(null);
        const [tickersWithoutScores, setTickersWithoutScores] = useState([]);
        // Local fallback for Kanban prev-lane tracking (covers cases where the backend doesn't stamp prev_kanban_stage).
        const kanbanPrevLocalRef = React.useRef({});

        const fetchData = useCallback(async () => {
          try {
            setLoading(true);
            setError(null); // Clear any previous errors
            // Add timeout to prevent hanging - increased to 30s for large datasets
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

            // Fetch both ticker data and ticker index to ensure all 133 tickers are shown
            const timestamp = Date.now();
            const [dataRes, tickersRes] = await Promise.all([
              fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
                signal: controller.signal,
                cache: "no-store",
                headers: {
                  Accept: "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `data-${timestamp}`,
                },
              }),
              fetch(`${API_BASE}/timed/tickers?_t=${timestamp}`, {
                signal: controller.signal,
                cache: "no-store",
                headers: {
                  Accept: "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `tickers-${timestamp}`,
                },
              }),
            ]);

            clearTimeout(timeoutId);

            if (!dataRes.ok) {
              const errorText = await dataRes.text();
              throw new Error(
                `HTTP ${dataRes.status}: ${errorText || "Unknown error"}`,
              );
            }

            const dataJson = await dataRes.json();
            const tickersJson = await tickersRes.json();

            if (dataJson.ok) {
              const tickerData = dataJson.data || {};
              const allTickers =
                tickersJson.ok && tickersJson.tickers
                  ? tickersJson.tickers
                  : [];

              // Local prev-lane fallback (so transition marker/glow always works).
              // Only stamps when backend didn't provide prev_kanban_stage.
              try {
                const prevMap =
                  kanbanPrevLocalRef.current &&
                  typeof kanbanPrevLocalRef.current === "object"
                    ? kanbanPrevLocalRef.current
                    : {};
                for (const [symRaw, objRaw] of Object.entries(tickerData)) {
                  const sym = String(symRaw || "").toUpperCase();
                  const obj = objRaw && typeof objRaw === "object" ? objRaw : null;
                  if (!sym || !obj) continue;
                  const stage = obj.kanban_stage != null ? String(obj.kanban_stage) : "";
                  if (!stage) continue;
                  const prev = prevMap[sym] != null ? String(prevMap[sym]) : "";
                  if (prev && prev !== stage && (obj.prev_kanban_stage == null || String(obj.prev_kanban_stage).trim() === "")) {
                    obj.prev_kanban_stage = prev;
                    obj.prev_kanban_stage_ts = Date.now();
                  }
                  prevMap[sym] = stage;
                }
                kanbanPrevLocalRef.current = prevMap;
              } catch {
                // ignore
              }

              // Log version information for debugging
              const dataVersion = dataJson.dataVersion || "unknown";
              const versionsSeen = dataJson.versionsSeen || [];
              const versionFiltered = dataJson.versionFiltered || 0;
              const versionBreakdown = dataJson.versionBreakdown || {};
              const acceptedVersions = dataJson.acceptedVersions || [];
              const currentDataVersion =
                dataJson.currentDataVersion || "unknown";

              // Store version info for UI display
              setVersionInfo({
                storedVersion: dataVersion,
                versionsSeen: versionsSeen,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                acceptedVersions: acceptedVersions,
                currentDataVersion: currentDataVersion,
              });

              console.log(`[UI] Data Version Info:`, {
                storedVersion: dataVersion,
                currentDataVersion: currentDataVersion,
                versionsSeen: versionsSeen,
                acceptedVersions: acceptedVersions,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                tickersReturned: Object.keys(tickerData).length,
                totalTickersInIndex: allTickers.length,
              });

              // Normalize ticker keys: BRK.B -> BRK-B
              const normalizedData = {};
              Object.keys(tickerData).forEach((key) => {
                const normalizedKey = normTicker(key);
                normalizedData[normalizedKey] = tickerData[key];
                // If we normalized, ensure ticker field matches
                if (normalizedKey !== key && normalizedData[normalizedKey]) {
                  normalizedData[normalizedKey].ticker = normalizedKey;
                }
              });

              // Merge: ensure all tickers from index are present, even if no recent data
              // This maintains the full 133 ticker baseline
              const mergedData = { ...normalizedData };
              allTickers.forEach((ticker) => {
                const normalizedTicker = normTicker(ticker);
                if (!mergedData[normalizedTicker]) {
                  // Add placeholder for tickers without recent data
                  // They'll appear on the chart with their last known position (if available)
                  // or won't render until data comes in
                  mergedData[normalizedTicker] = {
                    ticker: normalizedTicker,
                    // Note: Without data, these tickers won't render bubbles
                    // but they'll be available when data arrives
                  };
                }
              });

              setData(mergedData);
              setLastUpdate(new Date());
              setError(null);

              // Log ticker counts for debugging
              const tickersWithData = Object.keys(mergedData).filter((t) => {
                const d = mergedData[t];
                return (
                  d && d.htf_score !== undefined && d.ltf_score !== undefined
                );
              });
              // Log detailed breakdown
              const tickersByVersion = {};
              const tickersWithoutScores = [];
              Object.keys(mergedData).forEach((t) => {
                const d = mergedData[t];
                if (d) {
                  const version = d.script_version || "unknown";
                  if (!tickersByVersion[version]) {
                    tickersByVersion[version] = [];
                  }
                  tickersByVersion[version].push(t);

                  if (d.htf_score === undefined && d.ltf_score === undefined) {
                    tickersWithoutScores.push({
                      ticker: t,
                      version: version,
                      hasPrice: !!d.price,
                    });
                  }
                }
              });

              console.log(
                `[UI] Loaded ${tickersWithData.length} tickers with scores, ${allTickers.length} total in index`,
              );
              console.log(`[UI] Tickers by version:`, tickersByVersion);
              if (tickersWithoutScores.length > 0) {
                console.warn(
                  `[UI] ‚ö†Ô∏è ${tickersWithoutScores.length} tickers without scores:`,
                  tickersWithoutScores.slice(0, 10),
                );
                // Store in state for UI display
                setTickersWithoutScores(tickersWithoutScores);
              } else {
                setTickersWithoutScores([]);
              }

              if (versionFiltered > 0) {
                console.warn(
                  `[UI] ‚ö†Ô∏è ${versionFiltered} tickers filtered out due to version mismatch.`,
                  {
                    storedVersion: dataVersion,
                    currentDataVersion: currentDataVersion,
                    versionsSeen: versionsSeen,
                    acceptedVersions: acceptedVersions,
                    versionBreakdown: versionBreakdown,
                  },
                );
              }

              // Log sample tickers to see what we're getting
              const sampleTickers = Object.keys(tickerData).slice(0, 10);
              console.log(
                `[UI] Sample tickers:`,
                sampleTickers.map((t) => ({
                  ticker: t,
                  version: tickerData[t]?.script_version || "unknown",
                  hasScores: !!(
                    tickerData[t]?.htf_score !== undefined &&
                    tickerData[t]?.ltf_score !== undefined
                  ),
                  htf_score: tickerData[t]?.htf_score,
                  ltf_score: tickerData[t]?.ltf_score,
                  dynamicScore: tickerData[t]?.dynamicScore, // Check if API provides this
                  rank: tickerData[t]?.rank,
                })),
              );

              // Check if dynamicScore is coming from API
              const hasDynamicScore = Object.values(tickerData).some(
                (t) => t?.dynamicScore !== undefined,
              );
              console.log(
                `[UI] API provides dynamicScore: ${
                  hasDynamicScore
                    ? "YES ‚úÖ"
                    : "NO ‚ùå (will use fallback calculation)"
                }`,
              );

              // Check order of tickers from API
              const apiTickerOrder = Object.keys(tickerData).slice(0, 10);
              console.log(
                `[UI] First 10 tickers from API (order):`,
                apiTickerOrder,
              );
            } else {
              setError(
                `API Error: ${dataJson.error || "Failed to fetch data"}`,
              );
            }
          } catch (e) {
            if (e.name === "AbortError") {
              setError("Request timeout - please try again");
            } else if (
              e.message.includes("Failed to fetch") ||
              e.message.includes("Load failed")
            ) {
              setError(
                "Network error - check console for details. API may be temporarily unavailable.",
              );
            } else {
              setError(e.message);
            }
            console.error("Fetch error:", e);
            console.error("Error details:", {
              name: e.name,
              message: e.message,
              stack: e.stack,
            });
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 180000); // 3 minutes auto-refresh
          return () => clearInterval(interval);
        }, [fetchData]);

        return {
          data,
          loading,
          error,
          lastUpdate,
          versionInfo,
          tickersWithoutScores,
          refetch: fetchData,
        };
      }

      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = useState(value);

        useEffect(() => {
          const handler = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);

          return () => {
            clearTimeout(handler);
          };
        }, [value, delay]);

        return debouncedValue;
      }

      function useTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchTrades = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/trades`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.trades)) {
              setTrades(json.trades);
            } else {
              setTrades([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch trades:", err);
            setTrades([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchTrades();
          const interval = setInterval(fetchTrades, 180000); // Refresh every 3 minutes
          return () => clearInterval(interval);
        }, [fetchTrades]);

        return { trades, loading, error, refetch: fetchTrades };
      }

      // Hook to fetch sector ratings
      function useSectors() {
        const [sectors, setSectors] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSectors = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/sectors`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.sectors)) {
              setSectors(json.sectors);
            } else {
              setSectors([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch sectors:", err);
            setSectors([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchSectors();
          // Refresh sectors every 5 minutes
          const interval = setInterval(fetchSectors, 300000);
          return () => clearInterval(interval);
        }, [fetchSectors]);

        return { sectors, loading, error, refetch: fetchSectors };
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Sector Mapping (matching worker sector-mapping.js)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Sector mapping function - matches worker/sector-mapping.js
      function getTickerSector(ticker) {
        const T = normTicker(ticker).toUpperCase();
        // This mapping should match worker/sector-mapping.js
        // For now, we'll fetch from API, but provide a fallback lookup
        const SECTOR_MAP = {
          // S&P Sector ETFs (SPDR) - map ETF ticker -> underlying sector
          XLK: "Information Technology",
          XLF: "Financials",
          XLY: "Consumer Discretionary",
          XLP: "Consumer Staples",
          XLC: "Communication Services",
          XLI: "Industrials",
          XLB: "Basic Materials",
          XLE: "Energy",
          XLRE: "Real Estate",
          XLU: "Utilities",
          XLV: "Healthcare",
          // Consumer Discretionary
          AMZN: "Consumer Discretionary",
          TSLA: "Consumer Discretionary",
          NKE: "Consumer Discretionary",
          TJX: "Consumer Discretionary",
          HD: "Consumer Discretionary",
          MCD: "Consumer Discretionary",
          SBUX: "Consumer Discretionary",
          LOW: "Consumer Discretionary",
          NFLX: "Consumer Discretionary",
          BKNG: "Consumer Discretionary",
          CMG: "Consumer Discretionary",
          ABNB: "Consumer Discretionary",
          EXPE: "Consumer Discretionary",
          RBLX: "Consumer Discretionary",
          ULTA: "Consumer Discretionary",
          SHOP: "Consumer Discretionary",
          // Industrials
          CAT: "Industrials",
          GE: "Industrials",
          BA: "Industrials",
          HON: "Industrials",
          RTX: "Industrials",
          EMR: "Industrials",
          ETN: "Industrials",
          DE: "Industrials",
          PH: "Industrials",
          CSX: "Industrials",
          UNP: "Industrials",
          UPS: "Industrials",
          FDX: "Industrials",
          LMT: "Industrials",
          NOC: "Industrials",
          GD: "Industrials",
          TT: "Industrials",
          PWR: "Industrials",
          AWI: "Industrials",
          WTS: "Industrials",
          DY: "Industrials",
          FIX: "Industrials",
          ITT: "Industrials",
          STRL: "Industrials",
          // Information Technology
          AAPL: "Information Technology",
          MSFT: "Information Technology",
          NVDA: "Information Technology",
          AVGO: "Information Technology",
          AMD: "Information Technology",
          ORCL: "Information Technology",
          CRM: "Information Technology",
          ADBE: "Information Technology",
          INTC: "Information Technology",
          CSCO: "Information Technology",
          QCOM: "Information Technology",
          TXN: "Information Technology",
          AMAT: "Information Technology",
          LRCX: "Information Technology",
          KLAC: "Information Technology",
          ANET: "Information Technology",
          CDNS: "Information Technology",
          CRWD: "Information Technology",
          PANW: "Information Technology",
          PLTR: "Information Technology",
          MDB: "Information Technology",
          PATH: "Information Technology",
          QLYS: "Information Technology",
          PEGA: "Information Technology",
          IOT: "Information Technology",
          PSTG: "Information Technology",
          MU: "Information Technology",
          APLD: "Information Technology",
          // Communication Services
          META: "Communication Services",
          GOOGL: "Communication Services",
          GOOG: "Communication Services",
          NFLX: "Communication Services",
          DIS: "Communication Services",
          CMCSA: "Communication Services",
          VZ: "Communication Services",
          T: "Communication Services",
          TWLO: "Communication Services",
          RDDT: "Communication Services",
          // Basic Materials
          LIN: "Basic Materials",
          APD: "Basic Materials",
          ECL: "Basic Materials",
          SHW: "Basic Materials",
          PPG: "Basic Materials",
          FCX: "Basic Materials",
          NEM: "Basic Materials",
          ALB: "Basic Materials",
          MP: "Basic Materials",
          NEU: "Basic Materials",
          AU: "Basic Materials",
          CCJ: "Basic Materials",
          RGLD: "Basic Materials",
          SN: "Basic Materials",
          // Energy
          XOM: "Energy",
          CVX: "Energy",
          SLB: "Energy",
          EOG: "Energy",
          COP: "Energy",
          MPC: "Energy",
          PSX: "Energy",
          VST: "Energy",
          FSLR: "Energy",
          // Financials
          JPM: "Financials",
          BAC: "Financials",
          WFC: "Financials",
          GS: "Financials",
          MS: "Financials",
          C: "Financials",
          AXP: "Financials",
          COF: "Financials",
          SPGI: "Financials",
          MCO: "Financials",
          BLK: "Financials",
          SCHW: "Financials",
          PNC: "Financials",
          BK: "Financials",
          TFC: "Financials",
          USB: "Financials",
          ALLY: "Financials",
          EWBC: "Financials",
          WAL: "Financials",
          SOFI: "Financials",
          HOOD: "Financials",
          // Real Estate
          AMT: "Real Estate",
          PLD: "Real Estate",
          EQIX: "Real Estate",
          PSA: "Real Estate",
          WELL: "Real Estate",
          SPG: "Real Estate",
          O: "Real Estate",
          DLR: "Real Estate",
          VICI: "Real Estate",
          EXPI: "Real Estate",
          // Healthcare
          UNH: "Healthcare",
          JNJ: "Healthcare",
          LLY: "Healthcare",
          ABBV: "Healthcare",
          MRK: "Healthcare",
          TMO: "Healthcare",
          ABT: "Healthcare",
          DHR: "Healthcare",
          BMY: "Healthcare",
          AMGN: "Healthcare",
          GILD: "Healthcare",
          REGN: "Healthcare",
          VRTX: "Healthcare",
          BIIB: "Healthcare",
          UTHR: "Healthcare",
          HIMS: "Healthcare",
          NBIS: "Healthcare",
          // Utilities
          NEE: "Utilities",
          DUK: "Utilities",
          SO: "Utilities",
          D: "Utilities",
          AEP: "Utilities",
          SRE: "Utilities",
          EXC: "Utilities",
          XEL: "Utilities",
          WEC: "Utilities",
          ES: "Utilities",
          PEG: "Utilities",
          ETR: "Utilities",
          FE: "Utilities",
          AEE: "Utilities",
        };
        const sector = SECTOR_MAP[T] || null;
        // Return empty string instead of null for easier filtering
        return sector || "";
      }

      // Normalize sector names to match worker sector ratings.
      // TradingView sector/industry labels can differ ("Health Care" vs "Healthcare", "Materials" vs "Basic Materials", etc).
      function normalizeSectorKey(sectorName) {
        const raw = String(sectorName || "")
          .trim()
          .toLowerCase()
          .replace(/[-_/]+/g, " ")
          .replace(/&/g, "and")
          .replace(/\s+/g, " ");
        if (!raw) return "";
        const ALIASES = {
          "health care": "healthcare",
          healthcare: "healthcare",
          materials: "basic materials",
          "basic materials": "basic materials",
          "non energy minerals": "basic materials",
          "consumer durables": "consumer discretionary",
          "consumer non durables": "consumer staples",
          "consumer cyclical": "consumer discretionary",
          "consumer discretionary": "consumer discretionary",
          "consumer defensive": "consumer staples",
          "consumer staples": "consumer staples",
          "financial services": "financials",
          finance: "financials",
          financials: "financials",
          technology: "information technology",
          "technology services": "information technology",
          "electronic technology": "information technology",
          "information technology": "information technology",
          communications: "communication services",
          "communication services": "communication services",
          "energy minerals": "energy",
          energy: "energy",
          industrials: "industrials",
          utilities: "utilities",
          "real estate": "real estate",
        };
        return ALIASES[raw] || raw;
      }

      function sectorKeyToCanonicalName(key) {
        const K = String(key || "")
          .trim()
          .toLowerCase();
        const CANON = {
          "consumer discretionary": "Consumer Discretionary",
          industrials: "Industrials",
          "information technology": "Information Technology",
          "communication services": "Communication Services",
          "basic materials": "Basic Materials",
          energy: "Energy",
          financials: "Financials",
          "real estate": "Real Estate",
          "consumer staples": "Consumer Staples",
          healthcare: "Healthcare",
          utilities: "Utilities",
        };
        return CANON[K] || key;
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Groups (matching original)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const GROUPS = {
        UPTICKS: new Set([
          "TSLA",
          "CLS",
          "CRS",
          "VST",
          "FSLR",
          "JCI",
          "ORCL",
          "AMZN",
          "BRK.B",
          "BABA",
          "WMT",
          "PH",
          "GEV",
          "HII",
          "PWR",
          "SPGI",
          "APP",
          "PANW",
          "RDDT",
          "TT",
          "GLXY",
          "ETHA",
          "MTB",
          "AMGN",
          "GILD",
          "KO",
        ]),
        SuperGranny: new Set(["META", "NVDA", "AMD", "ANET", "GS"]),
        GRNI: new Set([
          "VST",
          "TSLA",
          "TJX",
          "SPGI",
          "SOFI",
          "PWR",
          "PNC",
          "PLTR",
          "PANW",
          "NVDA",
          "NFLX",
          "MSTR",
          "MSFT",
          "MNST",
          "META",
          "LRCX",
          "KLAC",
          "JPM",
          "HOOD",
          "GS",
          "GOOGL",
          "GEV",
          "GE",
          "EXPE",
          "ETN",
          "EMR",
          "DE",
          "CRWD",
          "COST",
          "CDNS",
          "CAT",
          "BK",
          "AXP",
          "AXON",
          "AVGO",
          "ANET",
          "AMZN",
          "AMD",
          "AAPL",
        ]),
        GRNJ: new Set([
          "RKLB",
          "LITE",
          "SN",
          "ALB",
          "RDDT",
          "RGLD",
          "MTZ",
          "ON",
          "ALLY",
          "DY",
          "CCJ",
          "EWBC",
          "PATH",
          "WFRD",
          "WAL",
          "IESC",
          "ENS",
          "TWLO",
          "MLI",
          "KTOS",
          "MDB",
          "TLN",
          "EME",
          "AWI",
          "IBP",
          "DCI",
          "WTS",
          "FIX",
          "UTHR",
          "NBIS",
          "SGI",
          "AYI",
          "RIOT",
          "NXT",
          "SANM",
          "BWXT",
          "PEGA",
          "JOBY",
          "IONQ",
          "SOFI",
          "ITT",
          "STRL",
          "QLYS",
          "MP",
          "GLXY",
          "HIMS",
          "IOT",
          "BE",
          "NEU",
          "AVAV",
          "PSTG",
          "RBLX",
        ]),
        GRNY: new Set([
          "GEV",
          "LRCX",
          "PNC",
          "GOOGL",
          "GS",
          "META",
          "MNST",
          "KLAC",
          "TJX",
          "GE",
          "EXPE",
          "CAT",
          "BK",
          "SPGI",
          "TSLA",
          "EMR",
          "JPM",
          "AXP",
          "ANET",
          "AXON",
          "AAPL",
          "NVDA",
          "AVGO",
          "PWR",
          "CDNS",
          "DE",
          "MSFT",
          "COST",
          "VST",
          "PLTR",
          "AMZN",
          "HOOD",
          "ETN",
          "SOFI",
          "AMD",
          "PANW",
          "CRWD",
          "NFLX",
          "MSTR",
        ]),
        Social: new Set([
          "CSCO",
          "BA",
          "NKE",
          "AAPL",
          "PI",
          "APLD",
          "MU",
          // Social group (added)
          "SWK",
          "AEHR",
          "SLV",
          "SNDK",
          "INTC",
          "SOXL",
          "IREN",
          "RKLB",
          "CRWV",
          "BE",
          "ONDS",
          "ASTS",
          "LITE",
          "AGQ",
          "IBRX",
          "LRCX",
          "WDC",
          "CRVS",
          "GDXJ",
          "HL",
          "STX",
          "MP",
          "B",
        ]),
        SP_Sectors: new Set([
          "XLK",
          "XLF",
          "XLY",
          "XLP",
          "XLC",
          "XLI",
          "XLB",
          "XLE",
          "XLRE",
          "XLU",
          "XLV",
        ]),
        Futures: new Set(["ES1!", "NQ1!", "BTCUSD", "ETHUSD", "ETHA", "VIX"]),
      };

      const GROUP_LABELS = {
        SP_Sectors: "S&P Sectors",
        Futures: "Futures",
      };

      const GROUP_ORDER = [
        "SP_Sectors",
        "Futures",
        "UPTICKS",
        "SuperGranny",
        "GRNI",
        "GRNJ",
        "GRNY",
        "Social",
        "No Group",
      ];

      function normTicker(t) {
        let s = String(t || "")
          .trim()
          .toUpperCase();
        // Normalize BRK.B to BRK-B (TradingView sends BRK.B, but we use BRK-B for US market)
        if (s === "BRK.B" || s === "BRK-B") {
          s = "BRK-B";
        }
        return s;
      }

      function groupsForTicker(t) {
        const T = normTicker(t);
        const out = [];
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) out.push(g);
        // If ticker is not in any group, add it to "No Group"
        if (out.length === 0) {
          out.push("No Group");
        }
        return out;
      }

      // Check if ticker is in any group (including "No Group")
      function isTickerInGroups(t) {
        const T = normTicker(t);
        // Check if ticker is in any actual group
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) return true;
        // If not in any group, it's in "No Group" - return true
        return true;
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Utils
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      // Phase-based color (Turbo-like gradient: 0=green, 0.5=yellow, 1=red)
      // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
      function phaseCompletionToColor(phasePct) {
        const p = Math.max(0, Math.min(1, phasePct));
        if (p < 0.3) {
          // Green: #2ecc71 (under 30%)
          return "#2ecc71";
        } else if (p < 0.6) {
          // Yellow: #f39c12 (30-60%)
          return "#f39c12";
        } else {
          // Red: #e74c3c (60-100%)
          return "#e74c3c";
        }
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          // Green to light green: #2ecc71 to #27ae60
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(
            204 + (174 - 204) * t,
          )}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          // Light green to yellow: #27ae60 to #f39c12
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(
            174 + (156 - 174) * t,
          )}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          // Yellow to orange: #f39c12 to #e67e22
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(
            156 + (126 - 156) * t,
          )}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          // Orange to red: #e67e22 to #e74c3c
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(
            126 + (76 - 126) * t,
          )}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          // Red to dark red: #e74c3c to #c0392b
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(
            76 + (57 - 76) * t,
          )}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }

      // Move status helpers (Active / Invalidated / Completed)
      function prettyMoveReason(r) {
        const key = String(r || "").trim();
        const map = {
          sl_breached: "SL breached",
          tp_reached: "TP reached",
          daily_ema_regime_break: "Daily EMA regime break",
          ichimoku_regime_break: "Ichimoku regime break",
          late_cycle: "Late-cycle",
          overextended: "Overextended",
          left_entry_corridor: "Left entry corridor",
        };
        return map[key] || key.replace(/_/g, " ");
      }

      function getMoveStatusInfo(ticker) {
        const ms =
          ticker?.move_status && typeof ticker.move_status === "object"
            ? ticker.move_status
            : null;
        const hasMoveStatus = !!(ms && ms.status);
        const statusRaw = ms?.status ? String(ms.status) : "";
        const status = statusRaw ? statusRaw.trim().toUpperCase() : "ACTIVE";
        const sideRaw = ms?.side ? String(ms.side) : "";
        const side = sideRaw ? sideRaw.trim().toUpperCase() : null;
        const severityRaw = ms?.severity ? String(ms.severity) : "";
        const severity = severityRaw
          ? severityRaw.trim().toUpperCase()
          : "NONE";
        const reasons = Array.isArray(ms?.reasons)
          ? ms.reasons
              .filter((x) => x != null)
              .map((x) => String(x))
              .map((x) => x.trim())
              .filter(Boolean)
          : [];
        const headlineReason = reasons.length
          ? prettyMoveReason(reasons[0])
          : null;

        if (status === "INVALIDATED") {
          return {
            hasMoveStatus,
            status,
            side,
            severity,
            reasons,
            icon: "‚õî",
            pillCls: "bg-red-500/15 text-red-300 border-red-500/40",
            stroke: "#ef4444",
            dash: "4 3",
            headlineReason,
          };
        }
        if (status === "COMPLETED") {
          return {
            hasMoveStatus,
            status,
            side,
            severity,
            reasons,
            icon: "‚úÖ",
            pillCls: "bg-purple-500/15 text-purple-300 border-purple-500/40",
            stroke: "#a855f7",
            dash: "2 3",
            headlineReason,
          };
        }
        return {
          hasMoveStatus,
          status: "ACTIVE",
          side,
          severity,
          reasons,
          icon: "üü¢",
          pillCls: "bg-green-500/10 text-green-300 border-green-500/30",
          stroke: "#22c55e",
          dash: null,
          headlineReason,
        };
      }

      function computeMoveProgressPct(ticker) {
        const mv = getMoveStatusInfo(ticker);
        const side = mv?.side;
        const price = Number(ticker?.price);
        const triggerPrice = Number(ticker?.trigger_price);
        const tp = Number(ticker?.tp);
        if (
          !side ||
          !Number.isFinite(price) ||
          !Number.isFinite(triggerPrice) ||
          !Number.isFinite(tp)
        )
          return null;
        if (side === "LONG") {
          const den = tp - triggerPrice;
          if (!Number.isFinite(den) || Math.abs(den) < 1e-9) return null;
          return Math.max(0, Math.min(1.2, (price - triggerPrice) / den));
        }
        if (side === "SHORT") {
          const den = triggerPrice - tp;
          if (!Number.isFinite(den) || Math.abs(den) < 1e-9) return null;
          return Math.max(0, Math.min(1.2, (triggerPrice - price) / den));
        }
        return null;
      }

      function formatAgeFromTs(tsLike) {
        const ts = Number(tsLike);
        if (!Number.isFinite(ts) || ts <= 0) return null;
        const ms = ts < 1e12 ? ts * 1000 : ts;
        const ageMs = Date.now() - ms;
        if (!Number.isFinite(ageMs) || ageMs < 0) return null;
        const mins = Math.floor(ageMs / 60000);
        if (mins < 60) return `${mins}m`;
        const hrs = Math.floor(mins / 60);
        if (hrs < 24) return `${hrs}h`;
        const days = Math.floor(hrs / 24);
        return `${days}d`;
      }

      // Trail/Bubble-journey derived intent classifier (entry-focused, but can recommend HOLD/EXIT).
      function classifyEntryIntent(ticker) {
        const t = ticker && typeof ticker === "object" ? ticker : {};
        const flags = t.flags && typeof t.flags === "object" ? t.flags : {};
        const move = getMoveStatusInfo(t);
        const ent = entryType(t);
        const inCorridor = !!ent?.corridor;

        const rr = Number(t.rr);
        const rank = Number(t.rank);
        const comp = completionForSize(t);
        const phase = Number(t.phase_pct);
        const zone = String(t.phase_zone || "").toUpperCase();

        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const inSqueeze = sqOn && !sqRel;
        const momentumElite = !!flags.momentum_elite;
        const thesis = flags.thesis_match === true;

        const deltas = t.deltas && typeof t.deltas === "object" ? t.deltas : {};
        const seq = t.seq && typeof t.seq === "object" ? t.seq : {};
        const patt =
          seq.pattern && typeof seq.pattern === "object" ? seq.pattern : {};

        const htf4h = Number(deltas.htf_4h);
        const ltf4h = Number(deltas.ltf_4h);
        const htfImproving4h = !!flags.htf_improving_4h;
        const htfMove4h = Number.isFinite(htf4h) ? Math.abs(htf4h) : 0;

        // Exit conditions (even if move_status still says ACTIVE)
        const lateCycle =
          zone === "HIGH" ||
          zone === "EXTREME" ||
          (Number.isFinite(phase) && phase >= 0.75);
        const overextended = Number.isFinite(comp) && comp >= 0.9;
        if (
          move.hasMoveStatus &&
          (move.status === "INVALIDATED" || move.status === "COMPLETED")
        ) {
          return {
            group:
              move.status === "COMPLETED"
                ? "Completed moves"
                : "Invalidated moves",
            action: "EXIT",
            confidence: 0.95,
            why: [move.headlineReason || move.status],
          };
        }
        if (overextended || lateCycle) {
          return {
            group: "Late-cycle / Overextended",
            action: "EXIT",
            confidence: overextended ? 0.9 : 0.75,
            why: [
              overextended ? "Completion very high" : null,
              lateCycle ? `Phase zone ${zone || "HIGH"}` : null,
            ].filter(Boolean),
          };
        }

        // Entry archetypes (grouping)
        const squeezeToMomentum = patt.squeezeReleaseToMomentum_6h === true;
        const corridorReclaim = seq.corridorEntry_60m === true;
        const squeezeOnToRelease = patt.squeezeOnToRelease_24h === true;

        if (squeezeToMomentum) {
          return {
            group: "Squeeze ‚Üí Momentum",
            action: inCorridor ? "ENTRY" : "WAIT",
            confidence: inCorridor ? 0.82 : 0.7,
            why: [
              "Squeeze release ‚Üí momentum transition",
              htfImproving4h ? "HTF improving (4h)" : null,
              Number.isFinite(rr) ? `RR ${rr.toFixed(2)}` : null,
            ].filter(Boolean),
          };
        }

        if (momentumElite && (sqRel || htfImproving4h || htfMove4h >= 5)) {
          return {
            group: "Momentum Elite",
            action: inCorridor ? "ENTRY" : "HOLD",
            confidence: inCorridor ? 0.8 : 0.68,
            why: [
              "Momentum Elite",
              sqRel ? "Squeeze release" : null,
              htfImproving4h ? "HTF improving (4h)" : null,
            ].filter(Boolean),
          };
        }

        if (corridorReclaim && htfImproving4h) {
          return {
            group: "Corridor reclaim",
            action: inCorridor ? "ENTRY" : "HOLD",
            confidence: inCorridor ? 0.78 : 0.62,
            why: ["Recent corridor entry", "HTF improving (4h)"],
          };
        }

        if (inSqueeze && (inCorridor || squeezeOnToRelease)) {
          return {
            group: "Squeeze pressure build",
            action: inCorridor ? "WAIT" : "HOLD",
            confidence: 0.62,
            why: ["Squeeze ON", "Waiting for release"],
          };
        }

        // Default: make a sensible ENTRY vs HOLD/WAI
        const baseGood =
          Number.isFinite(rank) &&
          rank >= 70 &&
          Number.isFinite(rr) &&
          rr >= 1.3 &&
          comp <= 0.7;
        const momentumGood =
          (Number.isFinite(htf4h) &&
            Number.isFinite(ltf4h) &&
            (htfMove4h >= 5 || Math.abs(ltf4h) >= 5)) ||
          htfImproving4h ||
          thesis;

        if (baseGood && momentumGood) {
          return {
            group: "Trend continuation",
            action: inCorridor ? "ENTRY" : "HOLD",
            confidence: inCorridor ? 0.68 : 0.55,
            why: [
              thesis ? "Thesis match" : null,
              htfImproving4h ? "HTF improving (4h)" : null,
              Number.isFinite(htf4h) ? `ŒîHTF(4h) ${htf4h.toFixed(1)}` : null,
            ].filter(Boolean),
          };
        }

        return {
          group: "Unclear / Chop",
          action: inCorridor ? "WAIT" : "HOLD",
          confidence: 0.45,
          why: [
            inCorridor
              ? "In corridor but weak confirmation"
              : "Out of corridor",
            thesis ? "Thesis match (weak)" : null,
          ].filter(Boolean),
        };
      }

      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";

        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      // Winner Signature (early-run high-probability pattern)
      // Note: UI classification uses only the *current* snapshot (no sequence mining yet).
      function winnerSignatureScore(ticker) {
        if (!ticker) return 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const ent = entryType(ticker);
        const comp = completionForSize(ticker);
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : NaN;

        const isSetup = state.includes("PULLBACK");
        const inCorridor = !!ent?.corridor;
        const lowCompletion = Number.isFinite(comp) && comp < 0.15;
        const earlyPhase = Number.isFinite(phase) && phase < 0.6;
        const inSqueeze = !!flags.sq30_on && !flags.sq30_release;

        return [
          isSetup,
          inCorridor,
          lowCompletion,
          earlyPhase,
          inSqueeze,
        ].filter(Boolean).length;
      }

      function isWinnerSignature(ticker) {
        if (!ticker) return false;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const ent = entryType(ticker);
        const comp = completionForSize(ticker);
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : NaN;

        const isSetup = state.includes("PULLBACK");
        const inCorridor = !!ent?.corridor;
        const lowCompletion = Number.isFinite(comp) && comp < 0.15;
        const earlyPhase = Number.isFinite(phase) && phase < 0.6;
        const inSqueeze = !!flags.sq30_on && !flags.sq30_release;

        // Core: setup + corridor + low completion
        // Plus: early phase OR in squeeze (pressure build marker)
        if (!(isSetup && inCorridor && lowCompletion)) return false;
        if (!(earlyPhase || inSqueeze)) return false;
        return true;
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function completionForSize(ticker) {
        // Use the completion value from Pine Script payload directly
        // Pine Script calculates: completion = abs(close - triggerPrice) / expectedMove
        // This is more accurate than recalculating from trigger to TP because:
        // 1. It accounts for expectedMove (which may differ from TP distance)
        // 2. It handles direction correctly
        // 3. It works even when price hasn't reached trigger yet
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      function getDirectionFromState(ticker) {
        const state = String(ticker?.state || "");
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        return null;
      }

      function computeEntryRef(ticker) {
        const entryRef = numFromAny(ticker?.entry_ref);
        if (Number.isFinite(entryRef) && entryRef > 0) return entryRef;
        const trigger = numFromAny(ticker?.trigger_price);
        if (Number.isFinite(trigger) && trigger > 0) return trigger;
        const price = numFromAny(
          ticker?.price ?? ticker?.close ?? ticker?.c ?? ticker?.last,
        );
        return Number.isFinite(price) && price > 0 ? price : null;
      }

      function computeTpMaxPrice(ticker) {
        const entry = computeEntryRef(ticker);
        if (!Number.isFinite(entry)) return null;
        const directMax = numFromAny(ticker?.tp_max_price ?? ticker?.tp_max);
        if (Number.isFinite(directMax) && directMax > 0) return directMax;
        const dir = getDirectionFromState(ticker);
        const tpLevels = Array.isArray(ticker?.tp_levels)
          ? ticker.tp_levels
          : [];
        const candidates = tpLevels
          .map((tp) => {
            const px =
              tp && typeof tp === "object" && tp.price != null ? tp.price : tp;
            const price = numFromAny(px);
            return Number.isFinite(price) ? price : null;
          })
          .filter((p) => Number.isFinite(p));

        if (ticker?.tp != null) {
          const tp = numFromAny(ticker.tp);
          if (Number.isFinite(tp)) candidates.push(tp);
        }

        if (candidates.length === 0) return null;

        if (dir === "LONG") {
          const valid = candidates.filter((p) => p > entry);
          return valid.length > 0 ? Math.max(...valid) : null;
        }
        if (dir === "SHORT") {
          const valid = candidates.filter((p) => p < entry);
          return valid.length > 0 ? Math.min(...valid) : null;
        }

        return null;
      }

      function computeTpTargetPrice(ticker) {
        const directTarget = numFromAny(
          ticker?.tp_target_price ?? ticker?.tp_target,
        );
        if (Number.isFinite(directTarget) && directTarget > 0)
          return directTarget;
        const primary = numFromAny(ticker?.tp);
        if (Number.isFinite(primary) && primary > 0) return primary;
        return null;
      }

      function numFromAny(v) {
        if (v == null) return null;
        if (typeof v === "number") return Number.isFinite(v) ? v : null;
        if (typeof v === "string") {
          const s = v.trim();
          if (!s) return null;
          // Accept things like "$77.16", "77.16 USD", "1,234.50"
          const m = s.replace(/,/g, "").match(/-?\d+(\.\d+)?/);
          if (!m) return null;
          const n = Number(m[0]);
          return Number.isFinite(n) ? n : null;
        }
        // Common object formats: { price }, etc.
        if (typeof v === "object" && v.price != null)
          return numFromAny(v.price);
        return null;
      }

      function fmtUsdAbs(n) {
        const x = numFromAny(n);
        if (!Number.isFinite(x)) return "‚Äî";
        return `$${Math.abs(x).toFixed(2)}`;
      }

      function getIngestMs(src) {
        const raw = src?.ingest_ts ?? src?.ingest_time ?? src?.ts;
        if (raw == null) return null;
        const msRaw =
          typeof raw === "number" ? raw : new Date(String(raw)).getTime();
        // Heuristic: if seconds, convert to ms
        const ms =
          typeof msRaw === "number" && msRaw > 0 && msRaw < 1e12
            ? msRaw * 1000
            : msRaw;
        return Number.isFinite(ms) ? ms : null;
      }

      function getNyClock(now = new Date()) {
        try {
          const parts = new Intl.DateTimeFormat("en-US", {
            timeZone: "America/New_York",
            weekday: "short",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          }).formatToParts(now);
          const get = (type) => parts.find((p) => p.type === type)?.value;
          const weekday = get("weekday") || "";
          const hour = Number(get("hour"));
          const minute = Number(get("minute"));
          return {
            weekday,
            hour: Number.isFinite(hour) ? hour : null,
            minute: Number.isFinite(minute) ? minute : null,
          };
        } catch {
          return { weekday: "", hour: null, minute: null };
        }
      }

      function isNyRegularMarketOpen(now = new Date()) {
        const { weekday, hour, minute } = getNyClock(now);
        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return true; // fail open (don't hide data)
        const wd = String(weekday || "").toLowerCase();
        const isWeekday =
          wd.startsWith("mon") ||
          wd.startsWith("tue") ||
          wd.startsWith("wed") ||
          wd.startsWith("thu") ||
          wd.startsWith("fri");
        if (!isWeekday) return false;
        const mins = hour * 60 + minute;
        const open = 9 * 60 + 30; // 9:30 ET
        const close = 16 * 60; // 16:00 ET
        return mins >= open && mins <= close;
      }

      function ageLabelFromMinutes(ageMin) {
        const m = Number(ageMin);
        if (!Number.isFinite(m) || m < 0) return null;
        if (m >= 60 * 24) return `${Math.round(m / (60 * 24))}d`;
        if (m >= 120) return `${Math.round(m / 60)}h`;
        return `${Math.round(m)}m`;
      }

      function getStaleInfo(src, { maxAgeMin = 90 } = {}) {
        const staleness = String(src?.staleness || "").toUpperCase();
        const ingestMs = getIngestMs(src);
        const ageMin = Number.isFinite(ingestMs)
          ? (Date.now() - ingestMs) / 60000
          : null;
        const staleByFlag = staleness && staleness !== "FRESH";
        const staleByAge = Number.isFinite(ageMin) && ageMin > maxAgeMin;
        const isStale = !!(staleByFlag || staleByAge);
        return {
          staleness: staleness || null,
          ingestMs,
          ageMin: Number.isFinite(ageMin) ? ageMin : null,
          ageLabel: ageLabelFromMinutes(ageMin),
          staleByFlag: !!staleByFlag,
          staleByAge: !!staleByAge,
          isStale,
        };
      }

      function getDailyChange(t) {
        const marketOpen = isNyRegularMarketOpen();
        // In after-hours/weekends, allow a wider "fresh" window so we can still show daily change for analysis.
        // We still treat explicit STALE flags as stale (trust > convenience).
        const maxAgeMin = marketOpen ? 90 : 72 * 60;
        const stale = getStaleInfo(t, { maxAgeMin });
        // During market hours: do not show daily change if stale.
        // Outside market hours: allow stale-by-age (but not stale-by-flag) so the UI isn't blank.
        if (stale.isStale && (marketOpen || stale.staleByFlag)) {
          return { dayChg: null, dayPct: null, stale, marketOpen };
        }
        const price = Number(t?.price);
        const pickNum = (obj, keys) => {
          for (const k of keys) {
            const v = Number(obj?.[k]);
            if (Number.isFinite(v)) return v;
          }
          return null;
        };
        const prevClose = pickNum(t, [
          "prev_close",
          "previous_close",
          "prior_close",
          "yclose",
          "close_prev",
        ]);
        // Prefer explicit daily-change fields from ingest (Heartbeat Pine emits these).
        // However, some stored "latest" snapshots can carry a stale/incorrect prev_close-derived day_change_pct.
        // So we treat "change/change_pct" as a safe fallback *only when* the day_* values look absurd.
        let dayChg = pickNum(t, [
          "day_change",
          "daily_change",
          "session_change",
          "chg",
          "ch",
        ]);
        let dayPct = pickNum(t, [
          "day_change_pct",
          "daily_change_pct",
          "session_change_pct",
          "chp",
        ]);

        const altChg = pickNum(t, ["change", "session_change"]);
        const altPct = pickNum(t, [
          "change_pct",
          "pct_change",
          "session_change_pct",
        ]);
        const looksAbsurd = (pct) => Number.isFinite(pct) && Math.abs(pct) > 5; // >5% is rare for large caps; usually indicates a bad anchor
        const looksSane = (pct) => Number.isFinite(pct) && Math.abs(pct) <= 5;

        // If day_* is present but looks wrong, fall back to change/change_pct when it looks sane.
        // Also handle the more common failure mode: day_* and change_* disagree (often due to a bad prev_close anchor).
        const pctDisagrees =
          Number.isFinite(dayPct) &&
          Number.isFinite(altPct) &&
          (dayPct >= 0 !== altPct >= 0 || Math.abs(dayPct - altPct) >= 1.5);
        if ((looksAbsurd(dayPct) && looksSane(altPct)) || pctDisagrees) {
          if (Number.isFinite(altPct)) dayPct = altPct;
          // Also switch $ change to avoid mismatched "$ + %".
          if (Number.isFinite(altChg)) dayChg = altChg;
        }

        // If missing, compute like a watchlist using prev close.
        if (
          !Number.isFinite(dayChg) &&
          !Number.isFinite(dayPct) &&
          Number.isFinite(price) &&
          price > 0 &&
          Number.isFinite(prevClose) &&
          prevClose > 0
        ) {
          dayChg = price - prevClose;
          dayPct = (dayChg / prevClose) * 100;
        }

        // If only one of (abs, pct) is present, compute the other using current price
        if (
          !Number.isFinite(dayChg) &&
          Number.isFinite(dayPct) &&
          Number.isFinite(price) &&
          price > 0
        ) {
          const p = dayPct / 100;
          if (Number.isFinite(p) && Math.abs(p) < 5) {
            const prev = price / (1 + p);
            const abs = price - prev;
            dayChg = Number.isFinite(abs) ? abs : null;
          }
        }
        if (
          !Number.isFinite(dayPct) &&
          Number.isFinite(dayChg) &&
          Number.isFinite(price) &&
          price > 0
        ) {
          const prev = price - dayChg;
          if (Number.isFinite(prev) && Math.abs(prev) > 1e-9) {
            dayPct = (dayChg / prev) * 100;
          }
        }
        return { dayChg, dayPct, stale, marketOpen };
      }

      // Shared card skin (used by Kanban + Viewport cards)
      // - background tint by daily % change (blue/orange)
      // - completion fill overlay (left->right)
      // - subtle edge glow by direction of daily change
      function getCardSkin(t) {
        const pickNum = (obj, keys) => {
          for (const k of keys) {
            const v = Number(obj?.[k]);
            if (Number.isFinite(v)) return v;
          }
          return null;
        };

        const priceNum = Number(t?.price);
        const prevCloseNum = pickNum(t, [
          "prev_close",
          "previous_close",
          "prior_close",
          "yclose",
          "close_prev",
        ]);

        const baseDaily = getDailyChange(t) || {};
        let dayPct = Number(baseDaily?.dayPct);
        let dayChg = Number(baseDaily?.dayChg);

        // Fallback: if staleness gating hides daily change, use raw fields.
        if (!Number.isFinite(dayPct)) {
          dayPct = pickNum(t, [
            "day_change_pct",
            "daily_change_pct",
            "session_change_pct",
            "change_pct",
            "pct_change",
            "chp",
          ]);
        }
        if (!Number.isFinite(dayChg)) {
          dayChg = pickNum(t, [
            "day_change",
            "daily_change",
            "session_change",
            "change",
            "chg",
            "ch",
          ]);
        }
        if (
          (!Number.isFinite(dayChg) || !Number.isFinite(dayPct)) &&
          Number.isFinite(priceNum) &&
          priceNum > 0 &&
          Number.isFinite(prevCloseNum) &&
          prevCloseNum > 0
        ) {
          const chg = priceNum - prevCloseNum;
          const pct = (chg / prevCloseNum) * 100;
          if (!Number.isFinite(dayChg)) dayChg = chg;
          if (!Number.isFinite(dayPct)) dayPct = pct;
        }

        const dayAbs = Number.isFinite(dayPct) ? Math.min(5, Math.abs(dayPct)) : null;
        const dayIntensity =
          dayAbs != null ? Math.max(0, Math.min(1, dayAbs / 2.5)) : 0; // 0..1 (2.5% => full)
        const tintAlpha = 0.08 + dayIntensity * 0.26;
        const tint =
          Number.isFinite(dayPct) && dayPct !== 0
            ? dayPct >= 0
              ? `rgba(59,130,246,${tintAlpha})`
              : `rgba(249,115,22,${tintAlpha})`
            : "rgba(0,0,0,0)";

        const compP = completionForSize(t);
        const compPct = Number.isFinite(compP)
          ? Math.round(Math.max(0, Math.min(1, compP)) * 100)
          : null;
        const compFill =
          Number.isFinite(compP) && compPct != null
            ? `linear-gradient(90deg, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0.06) ${compPct}%, rgba(255,255,255,0) ${compPct}%, rgba(255,255,255,0) 100%)`
            : null;
        const bgTint = `linear-gradient(0deg, ${tint}, ${tint})`;
        const bgImage = compFill ? `${compFill}, ${bgTint}` : bgTint;

        const dayEdgeClass =
          Number.isFinite(dayPct) && dayPct !== 0
            ? dayPct >= 0
              ? "shadow-[0_0_0_1px_rgba(56,189,248,0.22)]"
              : "shadow-[0_0_0_1px_rgba(251,146,60,0.22)]"
            : "";

        return {
          dayChg: Number.isFinite(dayChg) ? dayChg : null,
          dayPct: Number.isFinite(dayPct) ? dayPct : null,
          bgImage,
          dayEdgeClass,
        };
      }

      function computeReturnPct(ticker) {
        const direct =
          numFromAny(ticker?.expected_return_pct) ||
          numFromAny(ticker?.tp_target_pct) ||
          numFromAny(ticker?.tp_max_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(ticker);
        const tpTarget =
          computeTpTargetPrice(ticker) ?? computeTpMaxPrice(ticker);
        if (!Number.isFinite(entry) || !Number.isFinite(tpTarget)) return null;
        return (Math.abs(tpTarget - entry) / entry) * 100;
      }

      function computeRiskPct(ticker) {
        const direct = numFromAny(ticker?.risk_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(ticker);
        const sl = numFromAny(
          ticker?.sl ??
            ticker?.sl_price ??
            ticker?.stop_loss ??
            ticker?.stop ??
            ticker?.trade?.sl ??
            ticker?.trade?.sl_price,
        );
        if (!Number.isFinite(entry) || !Number.isFinite(sl)) return null;
        return (Math.abs(entry - sl) / entry) * 100;
      }

      function computeEtaDays(ticker) {
        const staleness = String(ticker?.staleness || "").toUpperCase();
        if (staleness && staleness !== "FRESH") return null;
        const baseEta = numFromAny(ticker?.eta_days_v2 ?? ticker?.eta_days);
        if (!Number.isFinite(baseEta) || baseEta <= 0) return null;
        const dir = getDirectionFromState(ticker);
        const entry = computeEntryRef(ticker);
        const target = computeTpTargetPrice(ticker);
        const current = numFromAny(
          ticker?.price ?? ticker?.close ?? ticker?.c ?? ticker?.last,
        );
        if (
          !Number.isFinite(entry) ||
          !Number.isFinite(target) ||
          !Number.isFinite(current) ||
          !dir
        ) {
          return baseEta;
        }
        const totalDist = Math.abs(target - entry);
        if (!Number.isFinite(totalDist) || totalDist <= 0) return baseEta;
        const progress =
          dir === "LONG"
            ? (current - entry) / (target - entry)
            : (entry - current) / (entry - target);
        if (!Number.isFinite(progress)) return baseEta;
        const clamped = Math.max(0, Math.min(1, progress));
        const remaining = baseEta * (1 - clamped);
        return Math.max(0.1, Math.round(remaining * 100) / 100);
      }

      function formatEntryZone(ticker) {
        const entry = computeEntryRef(ticker);
        const price = numFromAny(
          ticker?.price ?? ticker?.close ?? ticker?.c ?? ticker?.last,
        );
        if (!Number.isFinite(entry) || !Number.isFinite(price)) return "‚Äî";
        const low = Math.min(entry, price);
        const high = Math.max(entry, price);
        if (Math.abs(high - low) < 0.01) return `$${entry.toFixed(2)}`;
        return `$${low.toFixed(2)}‚Äì$${high.toFixed(2)}`;
      }

      function formatIngestTime(ticker) {
        const raw = ticker?.ingest_time ?? ticker?.ingest_ts ?? ticker?.ts;
        if (raw == null) return "‚Äî";
        const ms =
          typeof raw === "number" ? raw : new Date(String(raw)).getTime();
        if (!Number.isFinite(ms)) return "‚Äî";
        try {
          return new Date(ms).toLocaleString();
        } catch (e) {
          return new Date(ms).toISOString();
        }
      }

      // Compute bubble visuals (radius + color) for historical trail points.
      // NOTE: Trail points from KV/D1 may not include `rr`, so we fall back to `rank`
      // (similar to the main bubble renderers) to preserve meaningful size variation.
      // We also scale trail bubble radii down for readability while preserving relative size.
      function bubbleVisualForTrailPoint(point, tickerSymbol) {
        const comp =
          point && point.completion != null ? Number(point.completion) : 0;
        const validComp = Number.isFinite(comp)
          ? Math.max(0, Math.min(1, comp))
          : 0;

        // Prefer explicit phase_pct; otherwise fall back to completion as a proxy
        const phasePctRaw =
          point && point.phase_pct != null ? Number(point.phase_pct) : null;
        const phasePct =
          phasePctRaw != null && Number.isFinite(phasePctRaw)
            ? Math.max(0, Math.min(1, phasePctRaw))
            : validComp > 0
              ? validComp
              : 0.1;

        const rrRaw = point && point.rr != null ? Number(point.rr) : null;
        const rankRaw = point && point.rank != null ? Number(point.rank) : null;
        const fallbackRR =
          rankRaw != null && Number.isFinite(rankRaw)
            ? Math.max(0.5, Math.min(5, rankRaw / 50))
            : 0.5;
        const validRR =
          rrRaw != null && Number.isFinite(rrRaw) && rrRaw > 0
            ? rrRaw
            : fallbackRR;

        const cappedRR = Math.min(validRR, 5);
        const baseSize = 4;
        const rrMultiplier = 2;
        const size = baseSize + cappedRR * rrMultiplier * (1 - validComp);

        const sym = String(tickerSymbol || point?.ticker || "")
          .trim()
          .toUpperCase();
        const tickerHash = sym
          .split("")
          .reduce((acc, char) => acc + char.charCodeAt(0), 0);
        const sizeVariation = (tickerHash % 5) * 0.8;
        const finalSize = Math.max(baseSize, size + sizeVariation);

        // Trail bubbles should reflect their true size-at-the-time.
        const TRAIL_SIZE_SCALE = 1.0;
        const radius = Math.max(
          2.5,
          Math.min(50, finalSize * TRAIL_SIZE_SCALE),
        );
        const color = phaseCompletionToColor(phasePct);
        return { radius, color, phasePct, validComp, validRR };
      }

      // Split a trail into segments when there are big timestamp gaps.
      // This prevents confusing ‚Äúteleport‚Äù lines (e.g., overnight / missing samples).
      function splitTrailByGaps(trail, gapMs = 30 * 60 * 1000) {
        if (!Array.isArray(trail) || trail.length === 0) return [];
        const segments = [];
        let cur = [];
        for (let i = 0; i < trail.length; i++) {
          const p = trail[i];
          const prev = i > 0 ? trail[i - 1] : null;
          const ts = Number(p?.ts);
          const prevTs = Number(prev?.ts);
          const hasGap =
            prev &&
            Number.isFinite(ts) &&
            Number.isFinite(prevTs) &&
            ts - prevTs > gapMs;
          if (hasGap && cur.length > 0) {
            segments.push(cur);
            cur = [];
          }
          cur.push(p);
        }
        if (cur.length > 0) segments.push(cur);
        return segments;
      }

      // Smooth path through points using Catmull-Rom ‚Üí cubic Bezier conversion.
      function catmullRomPath(points) {
        if (!Array.isArray(points) || points.length < 2) return "";
        const pts = points.map((p) => ({
          x: Number(p?.x) || 0,
          y: Number(p?.y) || 0,
        }));
        let d = `M ${pts[0].x} ${pts[0].y}`;
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = i > 0 ? pts[i - 1] : pts[i];
          const p1 = pts[i];
          const p2 = pts[i + 1];
          const p3 = i + 2 < pts.length ? pts[i + 2] : p2;
          const c1x = p1.x + (p2.x - p0.x) / 6;
          const c1y = p1.y + (p2.y - p0.y) / 6;
          const c2x = p2.x - (p3.x - p1.x) / 6;
          const c2y = p2.y - (p3.y - p1.y) / 6;
          d += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
        }
        return d;
      }

      // Calculate score breakdown (mirrors computeDynamicScore / backend-style scoring)
      function calculateScoreBreakdown(ticker) {
        const htf = Number(ticker?.htf_score) || 0;
        const ltf = Number(ticker?.ltf_score) || 0;
        const phase = Number(ticker?.phase_pct) || 0;
        const rr = Number(ticker?.rr) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker?.flags || {};
        const state = String(ticker?.state || "");
        const ent = entryType(ticker || {});
        const inCorridor = !!ent?.corridor;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;

        const breakdown = {
          base: Number(ticker?.rank) || 50, // worker base score
          corridor: inCorridor ? 12 : 0,
          corridorAligned: inCorridor && aligned ? 8 : 0,
          squeezeRelease: sqRel && inCorridor ? 10 : 0,
          squeezeOn: sqOn && inCorridor && !sqRel ? 5 : 0,
          rr: rr >= 2.0 ? 8 : rr >= 1.5 ? 5 : rr >= 1.0 ? 2 : 0,
          phase: phase < 0.3 ? 6 : phase < 0.5 ? 3 : phase > 0.7 ? -5 : 0,
          completion: comp < 0.3 ? 5 : comp > 0.8 ? -8 : 0,
          htfStrength: Math.min(8, Math.abs(htf) * 0.15),
          ltfStrength: Math.min(6, Math.abs(ltf) * 0.12),
          phaseZoneChange: phaseZoneChange ? 4 : 0,
        };

        breakdown.total = Math.max(
          0,
          breakdown.base +
            breakdown.corridor +
            breakdown.corridorAligned +
            breakdown.squeezeRelease +
            breakdown.squeezeOn +
            breakdown.rr +
            breakdown.phase +
            breakdown.completion +
            breakdown.htfStrength +
            breakdown.ltfStrength +
            breakdown.phaseZoneChange,
        );

        return breakdown;
      }

      // Dynamic SCORE calculation that considers real-time conditions
      // NOTE: This returns a SCORE (0-200+), not a RANK (position 1-135)
      // RANK is determined by sorting all tickers by this score
      function computeDynamicScore(ticker) {
        const baseScore = Number(ticker.rank) || 50; // Base score from worker (0-100)
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;

        let dynamicScore = baseScore;

        // Corridor bonus (high priority - active setups)
        if (inCorridor) {
          dynamicScore += 12; // Strong bonus for being in corridor

          // Extra bonus if aligned AND in corridor (perfect setup)
          if (aligned) {
            dynamicScore += 8;
          }
        }

        // Squeeze release in corridor = very strong signal
        if (sqRel && inCorridor) {
          dynamicScore += 10;
        }

        // Squeeze on in corridor = building pressure
        if (sqOn && inCorridor && !sqRel) {
          dynamicScore += 5;
        }

        // RR bonus (scaled - better RR = higher score)
        if (rr >= 2.0) {
          dynamicScore += 8; // Excellent RR
        } else if (rr >= 1.5) {
          dynamicScore += 5; // Good RR
        } else if (rr >= 1.0) {
          dynamicScore += 2; // Acceptable RR
        }

        // Phase bonus (early phase = better opportunity)
        if (phase < 0.3) {
          dynamicScore += 6; // Very early
        } else if (phase < 0.5) {
          dynamicScore += 3; // Early
        } else if (phase > 0.7) {
          dynamicScore -= 5; // Late phase penalty
        }

        // Completion bonus (low completion = more room to run)
        if (comp < 0.3) {
          dynamicScore += 5; // Early in move
        } else if (comp > 0.8) {
          dynamicScore -= 8; // Near completion penalty
        }

        // Score strength bonus (strong HTF/LTF scores)
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;

        // Phase zone change bonus
        if (phaseZoneChange) {
          dynamicScore += 4;
        }

        // NO CAP - let scores go above 100 to avoid ties
        // Minimum is 0, but no maximum cap
        dynamicScore = Math.max(0, dynamicScore);

        return Math.round(dynamicScore * 100) / 100; // Round to 2 decimals for precision
      }

      // Alias for backward compatibility (but rename internally)
      const computeDynamicRank = computeDynamicScore;

      function toTickerArray(source) {
        if (!source) return [];
        if (Array.isArray(source)) {
          return source.filter((t) => t && typeof t === "object" && t.ticker);
        }
        if (typeof source === "object") {
          return Object.values(source).filter(
            (t) => t && typeof t === "object" && t.ticker,
          );
        }
        return [];
      }

      function rankScoreForTicker(ticker) {
        const rankScore = Number(ticker?.rank_score);
        if (Number.isFinite(rankScore)) return rankScore;
        const dynamicRank = Number(ticker?.dynamicRank);
        if (Number.isFinite(dynamicRank)) return dynamicRank;
        const dynamicScore = Number(ticker?.dynamicScore);
        if (Number.isFinite(dynamicScore)) return dynamicScore;
        return Number(computeDynamicRank(ticker)) || 0;
      }

      function getRankedTickers(source) {
        const list = toTickerArray(source);
        const withScores = list.map((t) => ({
          ...t,
          __rankPos: Number(t?.rank_position),
          __rankScore: rankScoreForTicker(t),
        }));
        withScores.sort((a, b) => {
          const rankA = Number(a.__rankPos);
          const rankB = Number(b.__rankPos);
          const hasRankA = Number.isFinite(rankA) && rankA > 0;
          const hasRankB = Number.isFinite(rankB) && rankB > 0;
          if (hasRankA && hasRankB) return rankA - rankB;
          if (hasRankA) return -1;
          if (hasRankB) return 1;
          const scoreA = Number(a.__rankScore) || 0;
          const scoreB = Number(b.__rankScore) || 0;
          return scoreB - scoreA;
        });
        return withScores;
      }

      function getRankPosition(sortedTickers, tickerSymbol) {
        const sym = String(tickerSymbol || "")
          .trim()
          .toUpperCase();
        if (!sym) return null;
        const index = sortedTickers.findIndex(
          (t) =>
            String(t.ticker || "")
              .trim()
              .toUpperCase() === sym,
        );
        return index >= 0 ? index + 1 : null;
      }

      function getRankPositionFromMap(rankPositions, tickerSymbol) {
        if (!rankPositions) return null;
        const sym = String(tickerSymbol || "")
          .trim()
          .toUpperCase();
        if (!sym) return null;
        const pos = Number(rankPositions[sym]);
        return Number.isFinite(pos) && pos > 0 ? pos : null;
      }

      function downsampleByInterval(points, intervalMs) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const buckets = new Map();
        points.forEach((p) => {
          const tsRaw = p.__ts_ms ?? p.ts ?? p.ingest_ts ?? p.ingest_time;
          const ts =
            typeof tsRaw === "string"
              ? new Date(tsRaw).getTime()
              : Number(tsRaw);
          if (!Number.isFinite(ts)) return;
          const bucket = Math.floor(ts / intervalMs) * intervalMs;
          const prev = buckets.get(bucket);
          if (!prev || ts > prev.__ts_ms) {
            buckets.set(bucket, { ...p, __ts_ms: ts, __bucket: bucket });
          }
        });
        return Array.from(buckets.values()).sort(
          (a, b) => a.__ts_ms - b.__ts_ms,
        );
      }

      // Debug: Verify function is loaded correctly
      console.log(
        "üîç [RANKING SYSTEM] computeDynamicScore function loaded (no 100 cap)",
      );
      console.log(
        "üîç [RANKING SYSTEM] Function signature:",
        typeof computeDynamicScore,
      );

      // Parse natural language query into filter conditions
      function parseNaturalLanguageQuery(query) {
        if (!query || typeof query !== "string") return null;

        const queryLower = query.toLowerCase().trim();
        const conditions = {};

        // Multi-ticker search: "AAPL, GOOGL, TSLA"
        // Also check if it's a simple ticker list (comma-separated, no filter keywords)
        if (
          query.includes(",") &&
          !query.match(
            /rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup|above|over|below|under/,
          )
        ) {
          return {
            type: "multi-ticker",
            tickers: query.split(",").map((t) => t.trim().toUpperCase()),
          };
        }

        // Ranked filter (all tickers sorted by rank)
        if (
          queryLower.match(/\btop\s*40\b|\btop40\b|\branked\b|\ball\s+ranked\b/)
        ) {
          conditions.top40 = true;
        }

        // Top N (rank-position) shortcuts:
        // - "top 2" / "top2" ‚Üí topN=2
        // - "rank less than 3" / "rank under 3" / "rank < 3" ‚Üí topN=2 (i.e., #1 and #2)
        // - "rank at most 3" / "rank <= 3" ‚Üí topN=3
        const topNMatch = queryLower.match(/\btop\s*(\d+)\b/);
        if (topNMatch) {
          const n = parseInt(topNMatch[1], 10);
          if (Number.isFinite(n) && n > 0) {
            conditions.topN = n;
          }
        }
        const rankPosStrictMatch = queryLower.match(
          /\brank(?:ed)?\s*(?:<|less\s+than|under|below)\s*(\d+)\b/i,
        );
        if (rankPosStrictMatch) {
          const raw = parseInt(rankPosStrictMatch[1], 10);
          const n = Number.isFinite(raw) ? raw - 1 : NaN;
          if (Number.isFinite(n) && n > 0) {
            conditions.topN = n;
          }
        }
        const rankPosLteMatch = queryLower.match(
          /\brank(?:ed)?\s*(?:<=|at\s+most)\s*(\d+)\b/i,
        );
        if (rankPosLteMatch) {
          const n = parseInt(rankPosLteMatch[1], 10);
          if (Number.isFinite(n) && n > 0) {
            conditions.topN = n;
          }
        }

        // Top Long Setup
        if (queryLower.match(/\btop\s*long\s*setup\b|\btop\s*long\b/)) {
          conditions.topLongSetup = true;
        }

        // Top Short Setup
        if (queryLower.match(/\btop\s*short\s*setup\b|\btop\s*short\b/)) {
          conditions.topShortSetup = true;
        }

        // Prime setup
        if (queryLower.match(/\bprime\b|\bprime setup\b/)) {
          conditions.prime = true;
        }

        // Momentum Elite
        if (queryLower.match(/\bmomentum elite\b|\belite\b/)) {
          conditions.momentumElite = true;
        }

        // In corridor
        if (queryLower.match(/\bin corridor\b|\bcorridor\b/)) {
          conditions.inCorridor = true;
        }

        // Squeeze release
        if (queryLower.match(/\bsqueeze release\b|\bsqueeze released\b/)) {
          conditions.squeezeRelease = true;
        }

        // Helper function to extract numeric value with various operators
        const extractNumericCondition = (
          pattern,
          fieldName,
          isPercentage = false,
        ) => {
          // Match operators: >, >=, <, <=, above, below, over, under, greater than, less than, at least, at most
          const operators = {
            ">": "min",
            ">=": "min",
            above: "min",
            over: "min",
            "greater than": "min",
            "at least": "min",
            "<": "max",
            "<=": "max",
            below: "max",
            under: "max",
            "less than": "max",
            "at most": "max",
          };

          for (const [op, type] of Object.entries(operators)) {
            const regex = new RegExp(
              `\\b${pattern}\\s*(?:${op.replace(
                /[.*+?^${}()|[\]\\]/g,
                "\\$&",
              )})\\s*([\\d.]+)\\s*%?`,
              "i",
            );
            const match = queryLower.match(regex);
            if (match) {
              const value = isPercentage
                ? parseFloat(match[1]) / 100
                : parseFloat(match[1]);
              return { type, value };
            }
          }
          return null;
        };

        // Rank conditions (score threshold): "rank > 75", "rank above 75", "rank over 75"
        // NOTE: rank-position queries (e.g. "rank < 3") are handled above via `topN`.
        const rankCondition = extractNumericCondition("rank", "rank");
        if (rankCondition) {
          if (rankCondition.type === "min") {
            conditions.minRank = rankCondition.value;
          } else {
            // For max rank, we'd need a maxRank filter - skip for now
          }
        }

        // RR/Risk-Reward conditions: "RR > 2", "risk reward over 2", "RR above 1.5"
        const rrCondition = extractNumericCondition(
          "(?:rr|risk[\\s-]?reward)",
          "rr",
        );
        if (rrCondition && rrCondition.type === "min") {
          conditions.minRR = rrCondition.value;
        }

        // Phase conditions: "phase > 50%", "phase over 50%", "phase above 50", "phase under 30%"
        const phaseMinCondition = extractNumericCondition(
          "phase",
          "phase",
          true,
        );
        if (phaseMinCondition && phaseMinCondition.type === "min") {
          conditions.minPhase = phaseMinCondition.value;
        }
        const phaseMaxCondition = extractNumericCondition(
          "phase",
          "phase",
          true,
        );
        if (phaseMaxCondition && phaseMaxCondition.type === "max") {
          conditions.maxPhase = phaseMaxCondition.value;
        }

        // Completion conditions: "completion < 30%", "completion under 30%", "completion below 50%"
        const compCondition = extractNumericCondition(
          "completion",
          "completion",
          true,
        );
        if (compCondition && compCondition.type === "max") {
          conditions.maxCompletion = compCondition.value;
        }

        // Price change: "moved 5 points", "moved $5", "price change > 5", "price change over 5"
        const priceChangeMatch = queryLower.match(
          /\b(?:moved|price\s*change)\s+(?:over|above|greater\s*than|>|>=|at\s*least)\s*(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/,
        );
        if (priceChangeMatch) {
          conditions.minPriceChange = parseFloat(priceChangeMatch[1]);
        } else {
          // Also support "moved 5 points" without operator
          const simplePriceChangeMatch = queryLower.match(
            /\bmoved\s+(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/,
          );
          if (simplePriceChangeMatch) {
            conditions.minPriceChange = parseFloat(simplePriceChangeMatch[1]);
          }
        }

        // If we found any conditions, return them
        if (Object.keys(conditions).length > 0) {
          return { type: "query", conditions };
        }

        return null;
      }

      function applyFilters(dataObj, filters, trades = []) {
        const out = [];

        const deriveHorizonBucket = (t) => {
          const etaRaw = t?.eta_days_v2 ?? t?.eta_days;
          const eta = Number(etaRaw);
          if (!Number.isFinite(eta) || eta <= 0) return null;
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        // Opportunity classification used by Viewport + Bubble Chart filtering
        const isEligibleOpportunity = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = Number(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);

          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < 1.5) return false;
          if (Number.isFinite(completion) && completion > 0.6) return false;
          if (Number.isFinite(ret) && ret < 5) return false;
          if (Number.isFinite(risk) && risk < 0.5) return false;
          if (Number.isFinite(etaConf) && etaConf < 0.55) return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > 0.75) return false;
          if (Number.isFinite(diversity) && diversity < 25) return false;
          return true;
        };

        const guidanceCategoryForAction = (action) => {
          const a = String(action || "").toLowerCase();
          if (!a) return "OTHER";
          if (a.includes("exit") || a.includes("trim")) return "EXIT_TRIM";
          if (a.startsWith("monitor") || a.includes("monitor closely"))
            return "MONITOR";
          if (a.startsWith("initiate")) return "INITIATE";
          if (a.startsWith("consider")) return "CONSIDER";
          if (a.startsWith("wait")) return "WAIT";
          if (a.includes("blocked")) return "BLOCKED";
          return "OTHER";
        };

        // Create a set of tickers that have trades (normalize ticker names)
        const tickersWithTrades = new Set();
        if (Array.isArray(trades)) {
          trades.forEach((trade) => {
            if (trade && trade.ticker) {
              tickersWithTrades.add(normTicker(trade.ticker));
            }
          });
        }

        // Parse natural language query if search field looks like a query
        const queryResult = parseNaturalLanguageQuery(filters.search);
        let effectiveFilters = { ...filters };
        let multiTickerList = null;

        if (queryResult) {
          if (queryResult.type === "multi-ticker") {
            multiTickerList = queryResult.tickers;
            // Clear search filter since we're handling it manually
            effectiveFilters = { ...effectiveFilters, search: "" };
          } else if (queryResult.type === "query") {
            // Merge query conditions into filters
            effectiveFilters = {
              ...effectiveFilters,
              ...queryResult.conditions,
              search: "",
            };
          }
        }

        // Debug: Check if BMNR/BABA are in the data object at all
        if (dataObj["BMNR"] || dataObj["BABA"]) {
          console.log(`[DATA CHECK] BMNR/BABA found in dataObj:`, {
            BMNR: !!dataObj["BMNR"],
            BABA: !!dataObj["BABA"],
            BMNR_keys: dataObj["BMNR"] ? Object.keys(dataObj["BMNR"]) : [],
            BABA_keys: dataObj["BABA"] ? Object.keys(dataObj["BABA"]) : [],
            BMNR_htf: dataObj["BMNR"]?.htf_score,
            BMNR_ltf: dataObj["BMNR"]?.ltf_score,
            BABA_htf: dataObj["BABA"]?.htf_score,
            BABA_ltf: dataObj["BABA"]?.ltf_score,
          });
        } else {
          console.log(
            `[DATA CHECK] BMNR/BABA NOT found in dataObj. Total tickers: ${
              Object.keys(dataObj).length
            }`,
          );
        }

        // Parse ticker filter (comma-separated ticker symbols)
        const tickerFilterSet = new Set();
        // Support tickerFilter from dedicated field OR from search query if it's a multi-ticker query
        if (
          effectiveFilters.tickerFilter &&
          typeof effectiveFilters.tickerFilter === "string"
        ) {
          effectiveFilters.tickerFilter
            .split(",")
            .map((t) => t.trim().toUpperCase())
            .filter(Boolean)
            .forEach((t) => tickerFilterSet.add(t));
        }
        // Also check if search query is a multi-ticker list
        if (queryResult && queryResult.type === "multi-ticker") {
          queryResult.tickers.forEach((t) => tickerFilterSet.add(t));
        }

        for (const [tickerRaw, d] of Object.entries(dataObj)) {
          // Skip completely empty entries, but allow entries with just ticker name
          if (!d || typeof d !== "object") continue;
          const ticker = String(tickerRaw || d.ticker || "")
            .trim()
            .toUpperCase();
          if (!ticker) continue;

          // Apply ticker filter if specified
          if (tickerFilterSet.size > 0 && !tickerFilterSet.has(ticker)) {
            continue;
          }

          // Horizon bucket filter (SHORT_TERM / SWING / POSITIONAL)
          if (
            effectiveFilters.horizonBucket &&
            typeof effectiveFilters.horizonBucket === "string"
          ) {
            const rawBucket = d?.horizon_bucket || deriveHorizonBucket(d) || "";
            const hb = String(rawBucket).trim().toUpperCase();
            if (hb !== String(effectiveFilters.horizonBucket).toUpperCase()) {
              continue;
            }
          }

          // Debug BMNR/BABA at the very start of the loop
          if (ticker === "BMNR" || ticker === "BABA") {
            console.log(`[FILTER START] ${ticker}:`, {
              tickerRaw,
              hasData: !!d,
              dataKeys: d ? Object.keys(d) : [],
              htf_score: d?.htf_score,
              ltf_score: d?.ltf_score,
              state: d?.state,
              price: d?.price,
            });
          }

          // Show all tickers - they will be in a group (including "No Group" if unmapped)
          // S&P Sectors and Futures are always visible, and unmapped tickers go to "No Group"
          const isSPSector =
            GROUPS.SP_Sectors && GROUPS.SP_Sectors.has(normTicker(ticker));
          const isFuture =
            GROUPS.Futures && GROUPS.Futures.has(normTicker(ticker));
          const inGroups = isTickerInGroups(ticker); // Always returns true now (includes "No Group")

          // All tickers should be shown (either in a group or in "No Group")
          // This check is now redundant but kept for clarity
          if (!inGroups) {
            console.log(
              `[FILTER] ${ticker} skipped: unexpected - should be in a group`,
            );
            continue;
          }

          // Include tickers even if they don't have scores yet - they'll show at center (0,0) with default values
          // This allows bubbles to appear immediately when tickers are added to watchlist
          // They'll update once TradingView sends data (within 5 minutes)
          const hasScores =
            d.htf_score !== undefined || d.ltf_score !== undefined;
          if (!hasScores) {
            // Provide default values so bubble can render
            d.htf_score = d.htf_score !== undefined ? d.htf_score : 0;
            d.ltf_score = d.ltf_score !== undefined ? d.ltf_score : 0;
            d.waitingForData = true; // Flag to indicate waiting for TradingView data
          }

          // Debug BMNR/BABA after score check
          if (ticker === "BMNR" || ticker === "BABA") {
            console.log(`[BMNR DEBUG] After score check:`, {
              ticker,
              hasScores,
              htf_score: d.htf_score,
              ltf_score: d.ltf_score,
              state: d.state,
              price: d.price,
              groups: groupsForTicker(normTicker(ticker)),
              inGroups,
            });
          }

          // Multi-ticker search
          if (multiTickerList && multiTickerList.length > 0) {
            if (!multiTickerList.includes(ticker)) continue;
          } else if (
            effectiveFilters.search &&
            !ticker.includes(effectiveFilters.search.toUpperCase())
          ) {
            // Regular search (if not multi-ticker)
            continue;
          }

          // Group filter
          if (effectiveFilters.group && effectiveFilters.group !== "ALL") {
            const T = normTicker(ticker);
            const gs = groupsForTicker(T);
            if (effectiveFilters.group === "ANY") {
              if (gs.length === 0) continue;
            } else if (effectiveFilters.group === "UNGROUPED") {
              // UNGROUPED means only in "No Group" (not in any actual group)
              const actualGroups = gs.filter((g) => g !== "No Group");
              if (actualGroups.length > 0) continue;
            } else {
              if (!gs.includes(effectiveFilters.group)) continue;
            }
          }

          // Handle Top Long Setup and Top Short Setup from natural language
          if (effectiveFilters.topLongSetup === true) {
            if (d.state !== "HTF_BULL_LTF_PULLBACK") continue;
          }
          if (effectiveFilters.topShortSetup === true) {
            if (d.state !== "HTF_BEAR_LTF_PULLBACK") continue;
          }

          if (
            effectiveFilters.quadrants &&
            !effectiveFilters.quadrants.includes(d.state)
          )
            continue;
          if (
            effectiveFilters.minRank &&
            (Number(d.rank) || 0) < effectiveFilters.minRank
          )
            continue;
          if (
            effectiveFilters.minRR &&
            (Number(d.rr) || 0) < effectiveFilters.minRR
          )
            continue;
          if (
            effectiveFilters.maxCompletion &&
            completionForSize(d) > effectiveFilters.maxCompletion
          )
            continue;
          // Thesis preset gate: base thresholds (preset) + requires richer winner patterns from Worker
          // (still one pill; Worker computes `flags.thesis_match`)
          if (isThesisModeActive(effectiveFilters)) {
            const flags = d.flags || {};
            if (flags.thesis_match !== true) continue;
          }
          if (effectiveFilters.inCorridor === true) {
            const ent = entryType(d);
            if (!ent.corridor) continue;
          }
          if (effectiveFilters.squeezeRelease === true) {
            const flags = d.flags || {};
            if (!flags.sq30_release) continue;
          }
          if (effectiveFilters.inSqueeze === true) {
            const flags = d.flags || {};
            // In Squeeze: sq30_on is true but sq30_release is false
            if (!flags.sq30_on || flags.sq30_release) continue;
          }
          if (effectiveFilters.momentumElite === true) {
            const flags = d.flags || {};
            if (!flags.momentum_elite) continue;
          }
          if (effectiveFilters.prime === true) {
            if (!isPrimeBubble(d)) continue;
          }
          if (effectiveFilters.winnerSignature === true) {
            if (!isWinnerSignature(d)) continue;
          }
          if (effectiveFilters.flipWatch === true) {
            const flags = d.flags || {};
            if (!flags.flip_watch) continue;
          }

          // Kanban Stage filter
          if (
            effectiveFilters.kanbanStage &&
            typeof effectiveFilters.kanbanStage === "string"
          ) {
            const stage = String(d.kanban_stage || "");
            const wantStage = String(effectiveFilters.kanbanStage).trim();
            if (stage !== wantStage) continue;
          }

          // Pattern Group filter (Action Moves groups)
          if (
            effectiveFilters.patternGroup &&
            typeof effectiveFilters.patternGroup === "string"
          ) {
            const intent = classifyEntryIntent(d);
            const wantGroup = String(effectiveFilters.patternGroup).trim();
            if (intent.group !== wantGroup) continue;
          }

          // Opportunities filter (Viewport row 3)
          if (
            effectiveFilters.opportunities &&
            typeof effectiveFilters.opportunities === "string"
          ) {
            const mode = String(effectiveFilters.opportunities).toUpperCase();
            const prime = isPrimeBubble(d);
            const eligible = isEligibleOpportunity(d);
            if (mode === "PRIME") {
              if (!prime) continue;
            } else if (mode === "ELIGIBLE") {
              if (!eligible) continue;
            } else if (mode === "WATCH") {
              if (prime || eligible) continue;
            }
          }

          // Guidance filter (based on natural-language decision)
          if (
            effectiveFilters.guidanceCategory &&
            typeof effectiveFilters.guidanceCategory === "string"
          ) {
            const actionInfo = getActionDescription(d);
            const cat = guidanceCategoryForAction(actionInfo?.action);
            const want = String(
              effectiveFilters.guidanceCategory,
            ).toUpperCase();
            if (cat !== want) continue;
          }
          if (effectiveFilters.minPriceChange !== undefined) {
            // Calculate price change from trigger price to current price
            const currentPrice = Number(d.price) || 0;
            const triggerPrice = Number(d.trigger_price) || 0;
            if (triggerPrice > 0) {
              const priceChange = Math.abs(currentPrice - triggerPrice);
              if (priceChange < effectiveFilters.minPriceChange) continue;
            } else {
              // No trigger price, skip this filter
              continue;
            }
          }
          if (effectiveFilters.minPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase < effectiveFilters.minPhase) continue;
          }
          if (effectiveFilters.maxPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase > effectiveFilters.maxPhase) continue;
          }

          // Trades filter - only show tickers that have trades
          if (effectiveFilters.hasTrades === true) {
            if (!tickersWithTrades.has(normTicker(ticker))) continue;
          }

          // Sector filter - only show tickers in the selected sector
          if (effectiveFilters.sector) {
            // PRIORITIZE SECTOR_MAP lookup over TradingView sector data
            // TradingView uses industry classifications (e.g., "Electronic Technology", "Retail Trade")
            // but we use GICS sectors (e.g., "Information Technology", "Consumer Discretionary")
            // So we always check SECTOR_MAP first, then fall back to TradingView data
            const tickerSector =
              getTickerSector(ticker) ||
              d.sector ||
              d.fundamentals?.sector ||
              "";
            // Normalize for resilient comparison (handles aliases like Health Care vs Healthcare)
            const normalizedTickerSector = normalizeSectorKey(tickerSector);
            const normalizedFilterSector = normalizeSectorKey(
              effectiveFilters.sector,
            );
            const matches =
              normalizedTickerSector &&
              normalizedTickerSector === normalizedFilterSector;

            // Debug logging for first few tickers when sector filter is active
            if (out.length < 3 && normalizedTickerSector) {
              console.log(
                `[SECTOR FILTER] ${ticker}: tickerSector="${normalizedTickerSector}", filterSector="${normalizedFilterSector}", matches=${matches}, fromMap=${!!getTickerSector(
                  ticker,
                )}`,
              );
            }

            if (!matches) {
              continue;
            }
          }

          // TD9 Setup filter - only show tickers with TD9 signals
          if (effectiveFilters.td9Setup === "any") {
            const tdSeq = d.td_sequential || {};
            const hasTD9Bullish =
              tdSeq.td9_bullish === true || tdSeq.td9_bullish === "true";
            const hasTD9Bearish =
              tdSeq.td9_bearish === true || tdSeq.td9_bearish === "true";
            if (!hasTD9Bullish && !hasTD9Bearish) continue;
          }

          out.push({ ticker, ...d });
        }

        // Apply Ranked / Top-N filter (rank position).
        // - `top40` shows ALL ranked tickers sorted by score (misnamed historically).
        // - `topN` limits that ranked list to the top N.
        const topN = Math.floor(Number(effectiveFilters.topN));
        const hasTopN = Number.isFinite(topN) && topN > 0;
        if (effectiveFilters.top40 === true || hasTopN) {
          // Get ALL tickers from dataObj (not filtered 'out' array)
          const allTickersWithRank = Object.values(dataObj).filter(
            (t) =>
              t &&
              typeof t === "object" &&
              t.ticker &&
              t.rank !== undefined &&
              t.rank !== null,
          );

          // Sort by dynamicScore from API (backend calculation) - pure score sorting, no alphabetical tiebreaker
          allTickersWithRank.sort((a, b) => {
            const scoreA = Number(a.dynamicScore || a.rank) || 0; // Use dynamicScore from API, fallback to rank
            const scoreB = Number(b.dynamicScore || b.rank) || 0;
            // Descending order: higher score = better position
            return scoreB - scoreA;
          });

          // Ranked order lookup (ticker -> index) based on the sorted list above.
          const rankedSymbols = allTickersWithRank
            .map((t) =>
              String(t.ticker || "")
                .trim()
                .toUpperCase(),
            )
            .filter(Boolean);
          const rankIndex = {};
          rankedSymbols.forEach((sym, idx) => {
            if (rankIndex[sym] == null) rankIndex[sym] = idx;
          });

          // Filter 'out' to only include tickers that have ranks, maintaining rank order
          const rankedOut = out
            .filter((t) => {
              const tickerUpper = String(t.ticker || "")
                .trim()
                .toUpperCase();
              return rankIndex[tickerUpper] != null;
            })
            .sort((a, b) => {
              // Maintain the same ranked order as `allTickersWithRank`
              const aSym = String(a.ticker || "")
                .trim()
                .toUpperCase();
              const bSym = String(b.ticker || "")
                .trim()
                .toUpperCase();
              const ia = rankIndex[aSym];
              const ib = rankIndex[bSym];
              if (ia != null && ib != null) return ia - ib; // lower index = better rank
              if (ia != null) return -1;
              if (ib != null) return 1;
              return 0;
            });
          return hasTopN ? rankedOut.slice(0, topN) : rankedOut;
        }

        return out;
      }

      // Thesis preset (used by filter pill + auto-apply + UI badges)
      // Derived from latest best-setups analysis + self-learning.
      const THESIS_PRESET = {
        minRank: 74,
        minRR: 1.5,
        maxCompletion: 0.6,
        maxPhase: 0.6,
      };

      function isThesisModeActive(filters) {
        const f = filters || {};
        const maxCompletion = Number(f.maxCompletion);
        const minRR = Number(f.minRR);
        const minRank = Number(f.minRank);
        const maxPhase = Number(f.maxPhase);
        return (
          Number.isFinite(minRank) &&
          minRank >= THESIS_PRESET.minRank &&
          Number.isFinite(minRR) &&
          minRR >= THESIS_PRESET.minRR &&
          Number.isFinite(maxCompletion) &&
          maxCompletion <= THESIS_PRESET.maxCompletion + 1e-9 &&
          (f.maxPhase === undefined ||
            (Number.isFinite(maxPhase) &&
              maxPhase <= THESIS_PRESET.maxPhase + 1e-9))
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Components
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Native SVG Bubble component (works without Recharts)
      const SVGBubble = memo(
        ({
          ticker,
          onClick,
          onHover,
          isHovered,
          scaleX,
          scaleY,
          offsetX,
          offsetY,
          layoutX = null,
          layoutY = null,
          showLabels,
          isTopRanked = false,
          thesisMode = false,
        }) => {
          // CRITICAL DEBUG: Log EVERY bubble call immediately
          if (!window._svgBubbleCallCount) {
            window._svgBubbleCallCount = 0;
          }
          window._svgBubbleCallCount++;

          // Always log first 10 to see what's happening
          if (window._svgBubbleCallCount <= 10) {
            console.log(
              `[SVGBUBBLE CALLED] #${window._svgBubbleCallCount} - ${
                ticker?.ticker || "NO TICKER"
              }`,
              {
                ticker: ticker?.ticker,
                hasTicker: !!ticker,
                tickerKeys: ticker ? Object.keys(ticker).slice(0, 20) : [],
                hasPhasePct: ticker ? "phase_pct" in ticker : false,
                phasePct: ticker ? ticker.phase_pct : undefined,
              },
            );
          }

          // CRITICAL: If no ticker, return null immediately
          if (!ticker || !ticker.ticker) {
            console.error(`[SVGBUBBLE ERROR] No ticker provided!`, { ticker });
            return null;
          }

          // Ensure we have valid numeric values - check for null/undefined explicitly
          // Try multiple property names in case data structure varies
          const comp =
            ticker.completion != null
              ? Number(ticker.completion)
              : ticker.completion_pct != null
                ? Number(ticker.completion_pct)
                : 0;
          const phasePct =
            ticker.phase_pct != null
              ? Number(ticker.phase_pct)
              : ticker.phase != null
                ? Number(ticker.phase)
                : 0;
          const rr =
            ticker.rr != null
              ? Number(ticker.rr)
              : ticker.risk_reward != null
                ? Number(ticker.risk_reward)
                : 0;
          const waitingForData = ticker.waitingForData === true;

          // Validate values are finite numbers and clamp to valid ranges
          const validComp = Number.isFinite(comp)
            ? Math.max(0, Math.min(1, comp))
            : 0;

          // If phase_pct is missing, try to estimate from completion or use a default based on state
          let validPhasePct = Number.isFinite(phasePct)
            ? Math.max(0, Math.min(1, phasePct))
            : null;

          // Fallback: if phase_pct is missing, use completion as proxy or estimate from state
          if (validPhasePct === null) {
            if (validComp > 0) {
              validPhasePct = validComp; // Use completion as phase estimate
            } else if (ticker.state) {
              // Estimate phase based on state (early states = lower phase)
              const state = String(ticker.state).toUpperCase();
              if (state.includes("PREP") || state.includes("PULLBACK")) {
                validPhasePct = 0.2; // Early phase
              } else if (state.includes("BULL") || state.includes("BEAR")) {
                validPhasePct = 0.5; // Mid phase
              } else {
                validPhasePct = 0.1; // Default to early phase
              }
            } else {
              validPhasePct = 0.1; // Default to early phase (green)
            }
          }

          // Default RR to a small value if missing to ensure size variation
          // Use dynamicRank or rank as fallback for size if RR is missing
          const fallbackRR = ticker.dynamicRank
            ? Math.max(0.5, Math.min(5, (Number(ticker.dynamicRank) || 0) / 50))
            : ticker.rank
              ? Math.max(0.5, Math.min(5, (Number(ticker.rank) || 0) / 50))
              : 0.5;
          const validRR = Number.isFinite(rr) && rr > 0 ? rr : fallbackRR;

          // Bubble size based on RR, adjusted for completion (lower completion = larger size)
          // RR is the opportunity, but we want to reduce size as completion increases
          // Formula: baseSize + (RR * multiplier) * (1 - completion)
          // This makes high RR + low completion = largest bubbles
          // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
          const cappedRR = Math.min(validRR, 5); // Cap RR at 5 for size calculation
          const completionPenalty = 1 - validComp; // 1.0 when completion is 0, 0.0 when completion is 1
          const baseSize = 4; // Further reduced for less overlap
          const rrMultiplier = 2; // Further reduced for smaller bubbles
          // Smaller size for tickers waiting for data
          const size = waitingForData
            ? baseSize * 0.7
            : baseSize + cappedRR * rrMultiplier * completionPenalty;

          // Force minimum size variation - if all sizes are the same, add variation based on ticker
          // Use multiple factors for better variation
          const tickerHash = (ticker.ticker || "")
            .split("")
            .reduce((acc, char) => acc + char.charCodeAt(0), 0);
          const sizeVariation = (tickerHash % 5) * 0.8; // Add 0-3.2px variation based on ticker name
          const finalSize = Math.max(baseSize, size + sizeVariation); // Add variation, ensure minimum baseSize

          const prime = isPrimeBubble(ticker);
          const winnerSig = isWinnerSignature(ticker);
          const flags = ticker.flags || {};
          const ent = entryType(ticker);
          const move = getMoveStatusInfo(ticker);

          // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
          // Use gray for tickers waiting for data
          // SIMPLIFIED: Direct calculation to ensure it always works
          let color;

          // DEBUG: Log phase calculation for first few bubbles
          if (window._svgBubbleCallCount <= 5) {
            console.log(`[BUBBLE COLOR CALC] ${ticker.ticker}:`, {
              waitingForData,
              validPhasePct,
              phasePct,
              rawPhasePct: ticker.phase_pct,
              hasPhasePct: "phase_pct" in ticker,
            });
          }

          if (waitingForData) {
            color = "#6b7a9f"; // Gray for waiting
          } else {
            // Direct color calculation based on phase percentage
            // Ensure validPhasePct is a number
            const p = Number.isFinite(validPhasePct)
              ? Math.max(0, Math.min(1, validPhasePct))
              : 0.1; // Default to 0.1 (green) if invalid

            if (p < 0.3) {
              color = "#2ecc71"; // Green: under 30%
            } else if (p < 0.6) {
              color = "#f39c12"; // Yellow: 30-60%
            } else {
              color = "#e74c3c"; // Red: 60-100%
            }
          }

          // Final safety: ensure color is always valid
          if (!color || typeof color !== "string" || !color.startsWith("#")) {
            console.warn(
              `[BUBBLE COLOR] Invalid color for ${ticker.ticker}, using green fallback:`,
              color,
            );
            color = "#2ecc71"; // Green fallback
          }

          // Ensure opacity is high enough to be visible (minimum 0.6)
          const baseOpacity = waitingForData
            ? 0.6
            : isHovered
              ? 1
              : prime
                ? 0.95
                : winnerSig
                  ? 0.95
                  : 0.85; // Increased from 0.7 to 0.85 for better visibility
          const moveOpacityMult =
            waitingForData || isHovered
              ? 1
              : move.status === "INVALIDATED"
                ? 0.28
                : move.status === "COMPLETED"
                  ? 0.65
                  : 1;
          const opacity = Math.max(0.12, baseOpacity * moveOpacityMult);

          const flipWatch = !!flags.flip_watch;

          const borderWidth = waitingForData
            ? 2
            : flipWatch
              ? 3.5
              : prime
                ? 3
                : winnerSig
                  ? 3
                  : flags.sq30_release
                    ? 2
                    : flags.sq30_on
                      ? 2
                      : 1.5; // Increased from 1 to 1.5 for better visibility

          let borderColor = waitingForData
            ? "#93a4d6"
            : flipWatch
              ? "#fbbf24" // Amber for flip watch
              : prime
                ? "#2ecc71"
                : winnerSig
                  ? "#a855f7"
                  : flags.sq30_release
                    ? "#00ffff"
                    : flags.sq30_on
                      ? "#ffd700"
                      : "#ffffff";
          if (!waitingForData && move.status !== "ACTIVE") {
            borderColor = move.stroke;
          }

          const bubbleSize = isHovered ? finalSize * 1.2 : finalSize;

          // Debug logging for first few tickers to verify calculations
          const shouldLog =
            ticker.ticker === "AAPL" ||
            ticker.ticker === "QQQ" ||
            ticker.ticker === "NVDA" ||
            ticker.ticker === "ITT" ||
            ticker.ticker === "GOOGL" ||
            ticker.ticker === "MSFT";

          if (shouldLog) {
            console.log(`[BUBBLE DEBUG] ${ticker.ticker}:`, {
              size: size.toFixed(2),
              finalSize: finalSize.toFixed(2),
              bubbleSize: bubbleSize.toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              validRR: validRR.toFixed(2),
              validComp: validComp.toFixed(2),
              validPhasePct: validPhasePct.toFixed(2),
              rawRR: rr,
              rawComp: comp,
              rawPhasePct: phasePct,
              prime,
              flags,
              hasColor: !!color && color !== "#ffffff",
              hasSize: size > 0,
              tickerKeys: Object.keys(ticker).slice(0, 15),
            });
          }

          // ALWAYS log first bubble to ensure code is running
          if (!window._bubbleDebugLogged) {
            window._bubbleDebugLogged = true;
            console.log(`[BUBBLE DEBUG] FIRST BUBBLE: ${ticker.ticker}`, {
              size: size.toFixed(2),
              finalSize: finalSize.toFixed(2),
              bubbleSize: bubbleSize.toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              validRR,
              validComp,
              validPhasePct,
              rawRR: rr,
              rawComp: comp,
              rawPhasePct: phasePct,
              tickerKeys: Object.keys(ticker),
              ticker: ticker,
            });
          }

          // Log first 10 bubbles to verify styling is applied
          if (window._svgBubbleCallCount <= 10) {
            console.log(`[BUBBLE STYLE] ${ticker.ticker}:`, {
              color,
              colorType: typeof color,
              colorLength: color ? color.length : 0,
              size: bubbleSize.toFixed(2),
              phasePct: validPhasePct,
              rr: validRR,
              completion: validComp,
              rawPhasePct: phasePct,
              rawRR: rr,
              rawComp: comp,
              opacity,
              borderColor,
              borderWidth,
              tickerKeys: Object.keys(ticker).slice(0, 20),
              hasPhasePct: "phase_pct" in ticker,
              hasRR: "rr" in ticker,
              hasCompletion: "completion" in ticker,
            });
          }

          // Calculate position correctly:
          // BubbleChart passes pre-adjusted offsets:
          // - offsetX already includes +50*scaleX (centers at x=0)
          // - offsetY already includes plotHeight - 50*scaleY (centers at y=0)
          // - scaleY is negative for y-axis inversion
          // So we just multiply scores by scales and add offsets
          const ltfScore = Number(ticker.ltf_score) || 0;
          const htfScore = Number(ticker.htf_score) || 0;

          // X: LTF score * scaleX + offsetX (offsetX already centered)
          const x = Number.isFinite(Number(layoutX))
            ? Number(layoutX)
            : ltfScore * scaleX + offsetX;

          // Y: HTF score * scaleY + offsetY (scaleY is negative, offsetY already centered)
          const y = Number.isFinite(Number(layoutY))
            ? Number(layoutY)
            : htfScore * scaleY + offsetY;

          // Determine emojis and label position (show all applicable emojis)
          const isInSqueeze = !!flags.sq30_on && !flags.sq30_release;
          const emojis = [];
          if (isTopRanked) emojis.push("üëë");
          if (flags.thesis_match === true && !waitingForData) emojis.push("üß†");
          if (waitingForData) emojis.push("‚è≥");
          if (!waitingForData) {
            if (flipWatch) emojis.push("üéØ"); // Flip watch - about to transition
            if (!!flags.momentum_elite) emojis.push("üöÄ");
            if (prime) emojis.push("‚≠ê");
            if (winnerSig) emojis.push("üèÜ");
            if (flags.sq30_release) emojis.push("‚ö°");
            if (isInSqueeze) emojis.push("üß®");
          }
          const emojiText = emojis.join("");
          // For #1 ranked, position emoji higher (reduced from 50 to 20 for smaller crown)
          const labelY =
            y - bubbleSize - (emojiText ? (isTopRanked ? 20 : 12) : 8);

          // FINAL SAFETY CHECK - ensure all values are valid before rendering
          // CRITICAL: Double-check color is valid before using
          const finalColor =
            color && typeof color === "string" && color.startsWith("#")
              ? color
              : "#2ecc71"; // Force green if invalid

          const finalOpacity =
            typeof opacity === "number" && opacity >= 0 && opacity <= 1
              ? opacity
              : 0.85;
          const renderedSize = Math.max(3, Math.min(50, bubbleSize)); // Clamp size between 3 and 50
          const finalBorderColor =
            borderColor && typeof borderColor === "string"
              ? borderColor
              : "#ffffff";
          const finalBorderWidth =
            typeof borderWidth === "number" && borderWidth > 0
              ? borderWidth
              : 1.5;
          const decisionSummary = summarizeEntryDecision(ticker);
          const decisionTooltip = decisionSummary
            ? `System ${decisionSummary.status}: ${decisionSummary.detail}`
            : null;

          // Log first 5 bubbles to verify styling
          if (window._svgBubbleCallCount <= 5) {
            console.log(`[BUBBLE STYLE] ${ticker.ticker}:`, {
              originalColor: color,
              finalColor: finalColor,
              size: renderedSize,
              phasePct: validPhasePct,
              opacity: finalOpacity,
              borderColor: finalBorderColor,
              willRender: true,
            });
          }

          return (
            <g
              onClick={() => onClick(ticker.ticker)}
              onMouseEnter={() => onHover(ticker.ticker)}
              onMouseLeave={() => onHover(null)}
              onTouchStart={(e) => {
                e.preventDefault();
                onHover(ticker.ticker);
                onClick(ticker.ticker);
              }}
              onTouchEnd={(e) => {
                e.preventDefault();
                onHover(null);
              }}
              style={{
                cursor: "pointer",
                transition: "all 0.2s ease-out",
                touchAction: "manipulation",
              }}
            >
              {decisionTooltip && <title>{decisionTooltip}</title>}
              {/* Pulsing glow effect for flip watch */}
              {flipWatch && (
                <>
                  <circle
                    cx={x}
                    cy={y}
                    r={renderedSize + 4}
                    fill="none"
                    stroke="#fbbf24"
                    strokeWidth="2"
                    opacity="0.5"
                  >
                    <animate
                      attributeName="r"
                      values={`${renderedSize + 3};${renderedSize + 6};${renderedSize + 3}`}
                      dur="2s"
                      repeatCount="indefinite"
                    />
                    <animate
                      attributeName="opacity"
                      values="0.3;0.7;0.3"
                      dur="2s"
                      repeatCount="indefinite"
                    />
                  </circle>
                  <circle
                    cx={x}
                    cy={y}
                    r={renderedSize + 2}
                    fill="none"
                    stroke="#fbbf24"
                    strokeWidth="1"
                    opacity="0.4"
                  />
                </>
              )}
              {/* Glow effect for prime */}
              {prime && (
                <circle
                  cx={x}
                  cy={y}
                  r={renderedSize + 2}
                  fill="none"
                  stroke="#2ecc71"
                  strokeWidth="1"
                  opacity="0.3"
                />
              )}
              <circle
                cx={x}
                cy={y}
                r={renderedSize}
                fill={finalColor}
                fillOpacity={finalOpacity}
                stroke={finalBorderColor}
                strokeWidth={finalBorderWidth}
              />
              {/* Emoji above bubble - show multiple when applicable */}
              {emojiText && (
                <g style={{ pointerEvents: "none" }}>
                  {/* Background circle for #1 ranked - reduced size */}
                  {isTopRanked && (
                    <circle
                      cx={x}
                      cy={labelY - 5}
                      r="18"
                      fill="#ffd700"
                      fillOpacity="0.3"
                    >
                      <animate
                        attributeName="fillOpacity"
                        values="0.2;0.5;0.2"
                        dur="1.5s"
                        repeatCount="indefinite"
                      />
                    </circle>
                  )}
                  {/* Outer glow ring for #1 - reduced size */}
                  {isTopRanked && (
                    <>
                      <circle
                        cx={x}
                        cy={labelY - 5}
                        r="22"
                        fill="none"
                        stroke="#ffd700"
                        strokeWidth="2"
                        opacity="0.6"
                      >
                        <animate
                          attributeName="r"
                          values="20;24;20"
                          dur="2s"
                          repeatCount="indefinite"
                        />
                        <animate
                          attributeName="opacity"
                          values="0.4;0.8;0.4"
                          dur="2s"
                          repeatCount="indefinite"
                        />
                      </circle>
                    </>
                  )}
                  {/* Main emoji text */}
                  <text
                    x={x}
                    y={labelY}
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fontSize={
                      isTopRanked
                        ? "24"
                        : waitingForData
                          ? "10"
                          : prime
                            ? "14"
                            : "12"
                    }
                    fill={
                      isTopRanked
                        ? "#ffd700"
                        : waitingForData
                          ? "#93a4d6"
                          : prime
                            ? "#2ecc71"
                            : winnerSig
                              ? "#a855f7"
                              : flags.sq30_release
                                ? "#00ffff"
                                : flags.momentum_elite
                                  ? "#a855f7"
                                  : "#ffd700"
                    }
                    fontWeight="bold"
                    style={{
                      textShadow: isTopRanked
                        ? "0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.6)"
                        : "0 0 3px rgba(0,0,0,0.8)",
                      filter: isTopRanked
                        ? "drop-shadow(0 0 15px rgba(255, 215, 0, 1)) drop-shadow(0 0 30px rgba(255, 215, 0, 0.9)) drop-shadow(0 0 45px rgba(255, 215, 0, 0.7))"
                        : "none",
                      pointerEvents: "none",
                    }}
                  >
                    {emojiText}
                  </text>
                  {/* Additional sparkle effects for #1 - reduced size */}
                  {isTopRanked && (
                    <>
                      <text
                        x={x - 15}
                        y={labelY - 10}
                        textAnchor="middle"
                        dominantBaseline="middle"
                        fontSize="12"
                        fill="#ffd700"
                        opacity="0.9"
                        style={{ pointerEvents: "none" }}
                      >
                        ‚ú®
                      </text>
                      <text
                        x={x + 15}
                        y={labelY - 10}
                        textAnchor="middle"
                        dominantBaseline="middle"
                        fontSize="12"
                        fill="#ffd700"
                        opacity="0.9"
                        style={{ pointerEvents: "none" }}
                      >
                        ‚ú®
                      </text>
                    </>
                  )}
                </g>
              )}
              {/* Additional glow effect for #1 ranked - reduced size */}
              {isTopRanked && (
                <>
                  <circle
                    cx={x}
                    cy={y}
                    r={bubbleSize + 4}
                    fill="none"
                    stroke="#ffd700"
                    strokeWidth="2"
                    opacity="0.6"
                  >
                    <animate
                      attributeName="opacity"
                      values="0.3;0.9;0.3"
                      dur="2s"
                      repeatCount="indefinite"
                    />
                    <animate
                      attributeName="r"
                      values={`${bubbleSize + 3};${bubbleSize + 6};${
                        bubbleSize + 3
                      }`}
                      dur="2s"
                      repeatCount="indefinite"
                    />
                  </circle>
                  {/* Outer glow ring */}
                  <circle
                    cx={x}
                    cy={y}
                    r={bubbleSize + 6}
                    fill="none"
                    stroke="#ffd700"
                    strokeWidth="1.5"
                    opacity="0.3"
                  >
                    <animate
                      attributeName="opacity"
                      values="0.1;0.5;0.1"
                      dur="2s"
                      repeatCount="indefinite"
                    />
                  </circle>
                </>
              )}
              {/* Ticker label */}
              {(showLabels || isHovered) && (
                <text
                  x={x}
                  y={labelY - (emojiText ? 14 : 8)}
                  textAnchor="middle"
                  fontSize="10"
                  fill={waitingForData ? "#93a4d6" : "#e7ecff"}
                  fontWeight="600"
                  style={{
                    textShadow: "0 0 4px rgba(0,0,0,0.9)",
                    pointerEvents: "none",
                  }}
                >
                  {ticker.ticker}
                </text>
              )}
            </g>
          );
        },
      );

      const Bubble = memo(
        ({ ticker, onClick, onHover, isHovered, showLabels }) => {
          // DEBUG: Log Recharts Bubble component calls
          if (!window._rechartsBubbleCallCount) {
            window._rechartsBubbleCallCount = 0;
          }
          window._rechartsBubbleCallCount++;
          if (window._rechartsBubbleCallCount <= 5) {
            console.log(
              `[RECHARTS BUBBLE CALLED] #${window._rechartsBubbleCallCount} - ${
                ticker?.ticker || "NO TICKER"
              }`,
              {
                ticker: ticker,
                hasTicker: !!ticker,
                tickerKeys: ticker ? Object.keys(ticker) : [],
              },
            );
          }

          // Ensure we have valid numeric values - check for null/undefined explicitly
          const comp =
            ticker.completion != null ? Number(ticker.completion) : 0;
          const phasePct =
            ticker.phase_pct != null ? Number(ticker.phase_pct) : 0;
          const rr = ticker.rr != null ? Number(ticker.rr) : 0;
          const waitingForData = ticker.waitingForData === true;

          // Validate values are finite numbers and clamp to valid ranges
          const validComp = Number.isFinite(comp)
            ? Math.max(0, Math.min(1, comp))
            : 0;
          const validPhasePct = Number.isFinite(phasePct)
            ? Math.max(0, Math.min(1, phasePct))
            : 0;
          const validRR = Number.isFinite(rr) && rr > 0 ? rr : 0;

          // Bubble size based on RR, adjusted for completion (lower completion = larger size)
          // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
          const cappedRR = Math.min(validRR, 5); // Cap RR at 5 for size calculation
          const completionPenalty = 1 - validComp; // 1.0 when completion is 0, 0.0 when completion is 1
          const baseSize = 8;
          const rrMultiplier = 6; // Scale factor for RR
          // Smaller size for tickers waiting for data
          const size = waitingForData
            ? baseSize * 0.7
            : baseSize + cappedRR * rrMultiplier * completionPenalty;

          // Force minimum size variation - if all sizes are the same, add variation based on ticker
          const sizeVariation = (ticker.ticker?.charCodeAt(0) || 0) % 3; // Add small variation based on ticker name
          const finalSize = Math.max(baseSize, size + sizeVariation * 0.5); // Add 0-1px variation, ensure minimum baseSize

          const prime = isPrimeBubble(ticker);
          const flags = ticker.flags || {};

          // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
          // Use gray for tickers waiting for data
          // SIMPLIFIED: Direct calculation to ensure it always works
          let color;
          if (waitingForData) {
            color = "#6b7a9f"; // Gray for waiting
          } else {
            // Direct color calculation based on phase percentage
            // Ensure validPhasePct is a number
            const p = Number.isFinite(validPhasePct)
              ? Math.max(0, Math.min(1, validPhasePct))
              : 0.1; // Default to 0.1 (green) if invalid

            if (p < 0.3) {
              color = "#2ecc71"; // Green: under 30%
            } else if (p < 0.6) {
              color = "#f39c12"; // Yellow: 30-60%
            } else {
              color = "#e74c3c"; // Red: 60-100%
            }
          }

          // Final safety: ensure color is always valid
          if (!color || typeof color !== "string" || !color.startsWith("#")) {
            color = "#2ecc71"; // Green fallback
          }

          // Ensure opacity is high enough to be visible (minimum 0.6)
          const opacity = waitingForData
            ? 0.6
            : isHovered
              ? 1
              : prime
                ? 0.95
                : 0.85; // Increased from 0.7 to 0.85 for better visibility

          const borderWidth = waitingForData
            ? 2
            : prime
              ? 3
              : flags.sq30_release
                ? 2
                : flags.sq30_on
                  ? 2
                  : 1.5; // Increased from 1 to 1.5 for better visibility

          const borderColor = waitingForData
            ? "#93a4d6"
            : prime
              ? "#2ecc71"
              : flags.sq30_release
                ? "#00ffff"
                : flags.sq30_on
                  ? "#ffd700"
                  : "#ffffff";

          // Debug logging for first few tickers to verify calculations
          if (
            ticker.ticker === "AAPL" ||
            ticker.ticker === "QQQ" ||
            ticker.ticker === "NVDA"
          ) {
            console.log(`[BUBBLE DEBUG] ${ticker.ticker}:`, {
              size: size.toFixed(2),
              bubbleSize: (isHovered ? size * 1.2 : size).toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              rr: rr.toFixed(2),
              comp: comp.toFixed(2),
              phasePct: phasePct.toFixed(2),
              prime,
              flags,
            });
          }

          const bubbleSize = isHovered ? finalSize * 1.2 : finalSize;

          // Debug logging for first few tickers
          const shouldLog =
            ticker.ticker === "AAPL" ||
            ticker.ticker === "QQQ" ||
            ticker.ticker === "NVDA" ||
            ticker.ticker === "ITT" ||
            ticker.ticker === "GOOGL" ||
            ticker.ticker === "MSFT";

          if (shouldLog) {
            console.log(`[RECHARTS BUBBLE DEBUG] ${ticker.ticker}:`, {
              size: size.toFixed(2),
              finalSize: finalSize.toFixed(2),
              bubbleSize: bubbleSize.toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              validRR: validRR.toFixed(2),
              validComp: validComp.toFixed(2),
              validPhasePct: validPhasePct.toFixed(2),
              rawRR: rr,
              rawComp: comp,
              rawPhasePct: phasePct,
              prime,
              flags,
            });
          }

          // ALWAYS log first bubble to ensure code is running
          if (!window._rechartsBubbleDebugLogged) {
            window._rechartsBubbleDebugLogged = true;
            console.log(
              `[RECHARTS BUBBLE DEBUG] FIRST BUBBLE: ${ticker.ticker}`,
              {
                size: size.toFixed(2),
                finalSize: finalSize.toFixed(2),
                bubbleSize: bubbleSize.toFixed(2),
                color,
                opacity,
                borderColor,
                borderWidth,
                validRR,
                validComp,
                validPhasePct,
                ticker: ticker,
              },
            );
          }

          const x = Number(ticker.ltf_score) || 0;
          const y = Number(ticker.htf_score) || 0;

          // Determine emoji and label position
          const hasSqueeze = flags.sq30_release || flags.sq30_on;
          const emoji = prime
            ? "‚≠ê"
            : flags.sq30_release
              ? "‚ö°"
              : flags.sq30_on
                ? "üß®"
                : "";
          const labelY = y - bubbleSize - (emoji ? 12 : 8);

          return (
            <g
              onClick={() => onClick(ticker.ticker)}
              onMouseEnter={() => onHover(ticker.ticker)}
              onMouseLeave={() => onHover(null)}
              onTouchStart={(e) => {
                e.preventDefault();
                onHover(ticker.ticker);
                onClick(ticker.ticker);
              }}
              onTouchEnd={(e) => {
                e.preventDefault();
                onHover(null);
              }}
              style={{
                cursor: "pointer",
                transition: "all 0.2s ease-out",
                touchAction: "manipulation",
              }}
            >
              {/* Glow effect for prime */}
              {prime && (
                <circle
                  cx={x}
                  cy={y}
                  r={bubbleSize + 2}
                  fill="none"
                  stroke="#2ecc71"
                  strokeWidth="1"
                  opacity="0.3"
                />
              )}
              <circle
                cx={x}
                cy={y}
                r={Math.max(3, bubbleSize)}
                fill={color}
                fillOpacity={opacity}
                stroke={borderColor}
                strokeWidth={borderWidth}
                strokeDasharray={
                  !waitingForData && move.dash ? move.dash : undefined
                }
              />
              {/* Move status badge (Completed / Invalidated) */}
              {!waitingForData && move.status !== "ACTIVE" && (
                <g style={{ pointerEvents: "none" }}>
                  <text
                    x={x + bubbleSize * 0.55}
                    y={y - bubbleSize * 0.55}
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fontSize="12"
                    fontWeight="800"
                    style={{ textShadow: "0 0 4px rgba(0,0,0,0.9)" }}
                  >
                    {move.icon}
                  </text>
                </g>
              )}
              {/* Emoji above bubble */}
              {emoji && (
                <text
                  x={x}
                  y={labelY}
                  textAnchor="middle"
                  fontSize={prime ? "14" : "12"}
                  fill={
                    prime
                      ? "#2ecc71"
                      : flags.sq30_release
                        ? "#00ffff"
                        : "#ffd700"
                  }
                  fontWeight="bold"
                  style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
                >
                  {emoji}
                </text>
              )}
              {/* Ticker label */}
              {(showLabels || isHovered) && (
                <text
                  x={x}
                  y={labelY - (emoji ? 14 : 8)}
                  textAnchor="middle"
                  fontSize="10"
                  fill="#e7ecff"
                  fontWeight="600"
                  style={{
                    textShadow: "0 0 4px rgba(0,0,0,0.9)",
                    pointerEvents: "none",
                  }}
                >
                  {ticker.ticker}
                </text>
              )}
            </g>
          );
        },
      );

      // Hook to fetch trail data for all tickers
      // NOTE: This is intentionally "best effort" and must not hammer the API.
      function useAllTrails(tickers, enabled = true) {
        const [allTrails, setAllTrails] = useState({});
        const [loadingTrails, setLoadingTrails] = useState(false);
        const trailsFetchedRef = React.useRef(new Set());
        const trailsAttemptedAtRef = React.useRef(new Map()); // ticker -> lastAttemptMs

        React.useEffect(() => {
          // If disabled (e.g., a ticker is selected), do NOT continue background trail fetching.
          // This avoids starving the selected ticker's own /trail request and prevents 429 loops.
          if (!enabled) {
            setLoadingTrails(false);
            return;
          }

          if (!tickers || tickers.length === 0) {
            setAllTrails({});
            return;
          }

          // Only fetch trails for tickers we haven't fetched yet
          const tickersToFetch = tickers
            .map((t) => String(t?.ticker || "").toUpperCase())
            .filter((t) => {
              if (!t) return false;
              if (trailsFetchedRef.current.has(t)) return false;
              // Cooldown for failed attempts (especially 429)
              const lastAttempt = trailsAttemptedAtRef.current.get(t) || 0;
              const cooldownMs = 60_000; // 60s cooldown between attempts
              if (Date.now() - lastAttempt < cooldownMs) return false;
              return true;
            });

          if (tickersToFetch.length === 0) return;

          // Limit concurrent fetches to avoid overwhelming the API
          // Reduced batch size to avoid rate limiting and server errors
          const MAX_CONCURRENT = 5;
          const batches = [];
          for (let i = 0; i < tickersToFetch.length; i += MAX_CONCURRENT) {
            batches.push(tickersToFetch.slice(i, i + MAX_CONCURRENT));
          }

          setLoadingTrails(true);

          const fetchBatch = async (batch) => {
            const promises = batch.map(async (ticker) => {
              trailsAttemptedAtRef.current.set(ticker, Date.now());
              // Retry logic with exponential backoff
              let lastError = null;
              for (let attempt = 0; attempt < 3; attempt++) {
                try {
                  const res = await fetch(
                    `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                      ticker,
                    )}`,
                    {
                      signal: AbortSignal.timeout(5000), // 5 second timeout
                    },
                  );

                  if (res.ok) {
                    const json = await res.json();
                    if (
                      json.ok &&
                      Array.isArray(json.trail) &&
                      json.trail.length > 0
                    ) {
                      return {
                        ticker,
                        trail: normalizeTrailPoints(json.trail),
                      };
                    }
                    // If ok but empty trail, return empty (not an error)
                    return { ticker, trail: [] };
                  } else if (res.status === 429) {
                    // Rate limited - wait longer before retry
                    await new Promise((resolve) =>
                      setTimeout(resolve, 1000 * (attempt + 1)),
                    );
                    continue;
                  } else if (res.status >= 500) {
                    // Server error - retry with backoff
                    if (attempt < 2) {
                      await new Promise((resolve) =>
                        setTimeout(resolve, 500 * Math.pow(2, attempt)),
                      );
                      continue;
                    }
                  }
                  // For other errors (400, 404, etc.), don't retry
                  return { ticker, trail: [] };
                } catch (err) {
                  lastError = err;
                  // Only retry on network errors or timeouts, not on abort
                  if (
                    err.name !== "AbortError" &&
                    err.name !== "TimeoutError" &&
                    attempt < 2
                  ) {
                    await new Promise((resolve) =>
                      setTimeout(resolve, 500 * Math.pow(2, attempt)),
                    );
                    continue;
                  }
                  // If it's an abort/timeout or last attempt, return empty
                  if (attempt === 2 || err.name === "AbortError") {
                    break;
                  }
                }
              }
              // If we get here, all retries failed
              if (lastError && lastError.name !== "AbortError") {
                // Only log if it's not a timeout/abort (those are expected)
                console.warn(
                  `Failed to fetch trail for ${ticker} after 3 attempts:`,
                  lastError.message,
                );
              }
              return { ticker, trail: [] };
            });

            const results = await Promise.all(promises);
            return results;
          };

          // Fetch all batches sequentially to avoid overwhelming the API
          const fetchAllBatches = async () => {
            const allResults = [];
            for (const batch of batches) {
              const results = await fetchBatch(batch);
              allResults.push(...results);

              // Update state incrementally for better UX
              setAllTrails((prev) => {
                const updated = { ...prev };
                results.forEach(({ ticker, trail }) => {
                  // IMPORTANT: Mark as fetched on ANY successful fetch attempt result (even empty)
                  // so we don't hammer the API in a tight loop when trails are missing or rate-limited.
                  trailsFetchedRef.current.add(ticker);
                  updated[ticker] = Array.isArray(trail) ? trail : [];

                  // Debug: Log when trails are loaded (or confirmed empty) for a small sample
                  if (
                    Object.keys(updated).length <= 10 ||
                    ticker === "AAPL" ||
                    ticker === "MSFT"
                  ) {
                    console.log(
                      `[TRAILS] Loaded ${
                        Array.isArray(trail) ? trail.length : 0
                      } points for ${ticker}`,
                    );
                  }
                });
                return updated;
              });

              // Longer delay between batches to avoid overwhelming the API
              await new Promise((resolve) => setTimeout(resolve, 500));
            }
            setLoadingTrails(false);
          };

          fetchAllBatches();
        }, [tickers, enabled]);

        return { allTrails, loadingTrails };
      }

      function BubbleChart({
        tickers,
        onBubbleClick,
        hoveredTicker,
        onHover,
        selectedTicker,
        selectedTrail,
        isTimeTravelActive = false,
        highlightTrailPoint = null,
        allData,
        rankedTickers,
        rankedTickerPositions,
        thesisMode = false,
      }) {
        // Debug: Log props received
        React.useEffect(() => {
          console.log(`[BUBBLE CHART] Props received:`, {
            selectedTicker,
            hasSelectedTrail: !!selectedTrail,
            selectedTrailLength: Array.isArray(selectedTrail)
              ? selectedTrail.length
              : 0,
            tickersCount: tickers ? tickers.length : 0,
          });
        }, [selectedTicker, selectedTrail, tickers]);

        // When a ticker is selected, "solo" it (show only that bubble + journey).
        // IMPORTANT: chart zoom should remain stable (domain is computed from the full loaded universe, not this filtered list).
        const displayTickers = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          if (!selectedTicker) return list;
          const sym = String(selectedTicker).toUpperCase();
          const solo = list.filter(
            (t) => String(t?.ticker || "").toUpperCase() === sym,
          );
          // If selection is no longer in the filtered universe, fall back to showing the current universe.
          return solo.length > 0 ? solo : list;
        }, [tickers, selectedTicker]);

        // Time Travel mode is snapshot-only: BubbleChart does NOT render trails for all bubbles.
        // The only trail we render is `selectedTrail` (Selected Ticker mode).
        // Debug: Log what BubbleChart receives
        React.useEffect(() => {
          if (!window._bubbleChartPropsLogged) {
            window._bubbleChartPropsLogged = true;
            console.log(`[BUBBLE CHART PROPS] Received:`, {
              tickersCount: tickers ? tickers.length : 0,
              hasTickers: !!tickers,
              isArray: Array.isArray(tickers),
              firstTicker:
                tickers && tickers.length > 0
                  ? {
                      ticker: tickers[0].ticker,
                      hasPhasePct: "phase_pct" in (tickers[0] || {}),
                      hasCompletion: "completion" in (tickers[0] || {}),
                      hasRR: "rr" in (tickers[0] || {}),
                      keys: Object.keys(tickers[0] || {}).slice(0, 15),
                    }
                  : null,
              hasAllData: !!allData,
              allDataKeys: allData ? Object.keys(allData).slice(0, 10) : [],
            });
          }
        }, [tickers, allData]);

        const [tooltip, setTooltip] = useState(null);
        const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
        const [showLabels, setShowLabels] = useState(true);
        const [crosshairPos, setCrosshairPos] = useState(null); // { x, y, ltfValue, htfValue }
        const containerRef = React.useRef(null);

        // Calculate #1 ranked ticker using SAME data source as Ranked List
        const topRankedTicker = React.useMemo(() => {
          if (rankedTickers && rankedTickers.length > 0) {
            return rankedTickers[0].ticker;
          }
          if (!allData || typeof allData !== "object") return null;
          const sorted = getRankedTickers(allData);
          return sorted.length > 0 ? sorted[0].ticker : null;
        }, [rankedTickers, allData]);
        const [dimensions, setDimensions] = React.useState({
          width: 1600,
          height: 1000,
        });

        // Update dimensions on mount and resize to use full container space
        React.useEffect(() => {
          const updateDimensions = () => {
            if (containerRef.current) {
              const rect = containerRef.current.getBoundingClientRect();
              // Use actual container size, with minimums
              setDimensions({
                width: Math.max(rect.width - 16, 1200), // Account for padding
                height: Math.max(rect.height - 16, 800),
              });
            }
          };
          // Initial update
          const timeoutId = setTimeout(updateDimensions, 100);
          window.addEventListener("resize", updateDimensions);
          return () => {
            clearTimeout(timeoutId);
            window.removeEventListener("resize", updateDimensions);
          };
        }, []);

        // Check Recharts availability (may load later)
        // Re-check inside component in case Recharts loaded after initial script execution
        let currentRechartsComponents = RechartsComponents;
        if (!currentRechartsComponents && typeof Recharts !== "undefined") {
          currentRechartsComponents = {
            ScatterChart: Recharts.ScatterChart,
            Scatter: Recharts.Scatter,
            XAxis: Recharts.XAxis,
            YAxis: Recharts.YAxis,
            CartesianGrid: Recharts.CartesianGrid,
            Tooltip: Recharts.Tooltip,
            ResponsiveContainer: Recharts.ResponsiveContainer,
            ReferenceLine: Recharts.ReferenceLine,
            ReferenceArea: Recharts.ReferenceArea,
          };
        }

        // TEMP: force Native SVG rendering (selection + trail lives here)
        const FORCE_NATIVE_SVG = true;
        if (FORCE_NATIVE_SVG) currentRechartsComponents = null;

        // Debug: Log which path we're taking
        console.log(
          `[BUBBLE CHART RENDER] Using ${
            currentRechartsComponents ? "Recharts" : "Native SVG"
          } mode`,
          {
            selectedTicker,
            hasSelectedTrail: !!selectedTrail,
            selectedTrailLength: Array.isArray(selectedTrail)
              ? selectedTrail.length
              : 0,
          },
        );

        // Fallback: Native SVG chart (works without Recharts)
        if (!currentRechartsComponents) {
          const chartWidth = dimensions.width;
          const chartHeight = dimensions.height;
          const margin = 70; // Extra margin so axis labels don't clip
          const plotWidth = chartWidth - 2 * margin;
          const plotHeight = chartHeight - 2 * margin;

          // Auto-zoom: set domains based on active tickers (symmetric around 0)
          const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
          const axisDomain = (arr, key, fallback = 50) => {
            let min = Infinity;
            let max = -Infinity;
            for (const t of arr) {
              const v = Number(t?.[key]);
              if (!Number.isFinite(v)) continue;
              if (v < min) min = v;
              if (v > max) max = v;
            }
            if (!Number.isFinite(min) || !Number.isFinite(max)) return fallback;
            const maxAbs = Math.max(Math.abs(min), Math.abs(max), 5);
            // Pad a bit, but keep within canonical -50..50 score space
            return clamp(maxAbs * 1.15, 10, 50);
          };
          // Domain base: full loaded universe (stable across filter clicks), fallback to current tickers list.
          const domainBase = (() => {
            if (allData && typeof allData === "object") {
              return Object.values(allData).filter(
                (t) => t && typeof t === "object",
              );
            }
            return Array.isArray(tickers) ? tickers : [];
          })();
          const domainXMax = axisDomain(domainBase, "ltf_score", 50);
          const domainYMax = axisDomain(domainBase, "htf_score", 50);

          // Scaling based on dynamic domains
          const scaleX = plotWidth / (2 * domainXMax);
          const scaleY = plotHeight / (2 * domainYMax);
          const offsetX = margin;
          const offsetY = margin;

          const handlePointerMove = (clientX, clientY, targetEl) => {
            const rect = targetEl.getBoundingClientRect();

            // CSS pixels within the rendered SVG element (used for HTML tooltip positioning)
            const cssX = clientX - rect.left;
            const cssY = clientY - rect.top;
            setTooltipPos({ x: cssX, y: cssY });

            // Convert screen coords ‚Üí SVG viewBox units using the SVG's actual transform.
            // This accounts for preserveAspectRatio letterboxing and any scaling caused by layout changes.
            let svgX;
            let svgY;
            try {
              if (targetEl && typeof targetEl.createSVGPoint === "function") {
                const pt = targetEl.createSVGPoint();
                pt.x = clientX;
                pt.y = clientY;
                const ctm = targetEl.getScreenCTM && targetEl.getScreenCTM();
                if (ctm && typeof ctm.inverse === "function") {
                  const p = pt.matrixTransform(ctm.inverse());
                  svgX = p.x;
                  svgY = p.y;
                }
              }
            } catch {}

            // Fallback if CTM isn't available
            if (!Number.isFinite(svgX) || !Number.isFinite(svgY)) {
              const sx = rect.width ? chartWidth / rect.width : 1;
              const sy = rect.height ? chartHeight / rect.height : 1;
              svgX = cssX * sx;
              svgY = cssY * sy;
            }

            // Convert SVG position to plot-area coordinates
            const chartX = svgX - offsetX;
            const chartY = svgY - offsetY;

            // Check if mouse is within plot area
            if (
              chartX >= 0 &&
              chartX <= plotWidth &&
              chartY >= 0 &&
              chartY <= plotHeight
            ) {
              // Convert to LTF/HTF scores
              const ltfValue = chartX / scaleX - domainXMax; // -domainXMax..domainXMax
              const htfValue = domainYMax - chartY / scaleY; // Inverted: top is +domainYMax

              setCrosshairPos({
                x: svgX,
                y: svgY,
                ltfValue: ltfValue,
                htfValue: htfValue,
                chartX: chartX,
                chartY: chartY,
              });
            } else {
              setCrosshairPos(null);
            }
          };

          const handleMouseMove = (e) => {
            handlePointerMove(e.clientX, e.clientY, e.currentTarget);
          };

          const handleMouseLeave = () => {
            setTooltip(null);
            setCrosshairPos(null);
          };

          // Collision avoidance: lightly repel overlapping bubbles while anchoring to true score position
          const layoutPositions = (() => {
            const list = Array.isArray(displayTickers) ? displayTickers : [];
            if (list.length === 0) return {};

            const hash = (s) =>
              String(s || "")
                .split("")
                .reduce((acc, ch) => acc + ch.charCodeAt(0), 0);

            const bubbleRadius = (t) => {
              const waiting = t?.waitingForData === true;
              const compRaw = t?.completion != null ? Number(t.completion) : 0;
              const comp = Number.isFinite(compRaw) ? clamp(compRaw, 0, 1) : 0;
              const rrRaw = t?.rr != null ? Number(t.rr) : 0.5;
              const rr = Number.isFinite(rrRaw) && rrRaw > 0 ? rrRaw : 0.5;
              const cappedRR = Math.min(rr, 5);
              const baseSize = 4;
              const rrMultiplier = 2;
              const size = waiting
                ? baseSize * 0.7
                : baseSize + cappedRR * rrMultiplier * (1 - comp);
              const v = (hash(t?.ticker) % 5) * 0.8;
              const finalSize = Math.max(baseSize, size + v);
              return clamp(finalSize, 3, 30);
            };

            const nodes = list.map((t) => {
              const ltf = Number(t?.ltf_score) || 0;
              const htf = Number(t?.htf_score) || 0;
              const x0 = offsetX + (ltf + domainXMax) * scaleX;
              const y0 = offsetY + (domainYMax - htf) * scaleY;
              const r = bubbleRadius(t);
              const j = (hash(t?.ticker) % 7) - 3; // deterministic tiny offset
              return {
                ticker: String(t?.ticker || ""),
                x0,
                y0,
                x: x0 + j * 0.15,
                y: y0 + j * 0.15,
                r,
              };
            });

            const PAD = 1.0;
            const ITER = 12;
            const ANCHOR = 0.18;
            const REPULSE = 0.6;
            const minX = offsetX + 2;
            const maxX = offsetX + plotWidth - 2;
            const minY = offsetY + 2;
            const maxY = offsetY + plotHeight - 2;

            for (let it = 0; it < ITER; it++) {
              for (let i = 0; i < nodes.length; i++) {
                const a = nodes[i];
                for (let j = i + 1; j < nodes.length; j++) {
                  const b = nodes[j];
                  let dx = b.x - a.x;
                  let dy = b.y - a.y;
                  let dist = Math.hypot(dx, dy);
                  const minDist = a.r + b.r + PAD;
                  if (!Number.isFinite(dist) || dist === 0) {
                    const n = ((hash(a.ticker + b.ticker) % 10) - 5) * 0.02;
                    dx = n;
                    dy = -n;
                    dist = Math.hypot(dx, dy) || 1;
                  }
                  if (dist < minDist) {
                    const push = ((minDist - dist) / dist) * 0.5 * REPULSE;
                    a.x -= dx * push;
                    a.y -= dy * push;
                    b.x += dx * push;
                    b.y += dy * push;
                  }
                }
              }
              for (const n of nodes) {
                n.x += (n.x0 - n.x) * ANCHOR;
                n.y += (n.y0 - n.y) * ANCHOR;
                n.x = clamp(n.x, minX + n.r, maxX - n.r);
                n.y = clamp(n.y, minY + n.r, maxY - n.r);
              }
            }

            const out = {};
            for (const n of nodes) {
              if (!n.ticker) continue;
              out[n.ticker] = { x: n.x, y: n.y };
            }
            return out;
          })();

          return (
            <div
              ref={containerRef}
              className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-2 relative"
            >
              {/* Label toggle */}
              <div className="absolute top-2 right-2 z-10">
                <button
                  onClick={() => setShowLabels(!showLabels)}
                  className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f] text-xs text-[#93a4d6] hover:bg-[#1a2550] transition-colors"
                >
                  {showLabels ? "Hide Labels" : "Show Labels"}
                </button>
              </div>
              <svg
                width="100%"
                height="100%"
                viewBox={`0 0 ${chartWidth} ${chartHeight}`}
                preserveAspectRatio="xMidYMid meet"
                onMouseMove={handleMouseMove}
                onMouseLeave={handleMouseLeave}
                onTouchMove={(e) => {
                  // Convert touch event to mouse-like coordinates for mobile
                  const touch = e.touches[0];
                  if (touch) {
                    handlePointerMove(
                      touch.clientX,
                      touch.clientY,
                      e.currentTarget,
                    );
                  }
                }}
                onTouchEnd={handleMouseLeave}
                className="w-full h-full touch-none"
              >
                {/* Grid with better styling */}
                <defs>
                  <pattern
                    id="grid"
                    width="50"
                    height="50"
                    patternUnits="userSpaceOnUse"
                  >
                    <path
                      d="M 50 0 L 0 0 0 50"
                      fill="none"
                      stroke="#26325f"
                      strokeWidth="0.5"
                      opacity="0.5"
                    />
                  </pattern>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                      <feMergeNode in="coloredBlur" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>

                  {/* Arrowhead marker for the Bubble Trail path */}
                  <marker
                    id="trailArrow"
                    viewBox="0 0 10 10"
                    refX="9"
                    refY="5"
                    markerWidth="6"
                    markerHeight="6"
                    orient="auto"
                  >
                    <path
                      d="M 0 0 L 10 5 L 0 10 z"
                      fill="#00ffff"
                      opacity="0.8"
                    />
                  </marker>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />

                {/* Axes - Zero lines (X=0 and Y=0) - Make them very visible */}
                {/* Vertical center line (X=0) */}
                <line
                  x1={offsetX + domainXMax * scaleX}
                  y1={offsetY}
                  x2={offsetX + domainXMax * scaleX}
                  y2={offsetY + plotHeight}
                  stroke="#ffffff"
                  strokeWidth="2"
                  opacity="1"
                />
                {/* Horizontal center line (Y=0) */}
                <line
                  x1={offsetX}
                  y1={offsetY + plotHeight / 2}
                  x2={offsetX + plotWidth}
                  y2={offsetY + plotHeight / 2}
                  stroke="#ffffff"
                  strokeWidth="2"
                  opacity="1"
                />
                {/* Vertical axis line (y-axis) */}
                <line
                  x1={offsetX}
                  y1={offsetY}
                  x2={offsetX}
                  y2={offsetY + plotHeight}
                  stroke="#93a4d6"
                  strokeWidth="2"
                  opacity="0.6"
                />

                {/* Axis labels */}
                <text
                  x={offsetX - 50}
                  y={offsetY + plotHeight / 2}
                  fill="#93a4d6"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                  transform={`rotate(-90 ${offsetX - 50} ${
                    offsetY + plotHeight / 2
                  })`}
                >
                  HTF Score
                </text>
                <text
                  x={offsetX + plotWidth / 2}
                  y={offsetY + plotHeight + 40}
                  fill="#93a4d6"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                >
                  LTF Score
                </text>

                {/* Axis scale markers */}
                {[
                  -domainXMax,
                  -domainXMax / 2,
                  0,
                  domainXMax / 2,
                  domainXMax,
                ].map((val) => {
                  const x = offsetX + (val + domainXMax) * scaleX;
                  const y = offsetY + plotHeight / 2;
                  return (
                    <g key={`x-${val}`}>
                      <line
                        x1={x}
                        y1={y - 5}
                        x2={x}
                        y2={y + 5}
                        stroke="#93a4d6"
                        strokeWidth="2"
                      />
                      <text
                        x={x}
                        y={y + 20}
                        fill="#93a4d6"
                        textAnchor="middle"
                        fontSize="10"
                      >
                        {Math.round(val)}
                      </text>
                    </g>
                  );
                })}
                {[
                  -domainYMax,
                  -domainYMax / 2,
                  0,
                  domainYMax / 2,
                  domainYMax,
                ].map((val) => {
                  const x = offsetX;
                  const y = offsetY + plotHeight - (val + domainYMax) * scaleY;
                  return (
                    <g key={`y-${val}`}>
                      <line
                        x1={x - 5}
                        y1={y}
                        x2={x + 5}
                        y2={y}
                        stroke="#93a4d6"
                        strokeWidth="2"
                      />
                      <text
                        x={x - 15}
                        y={y + 4}
                        fill="#93a4d6"
                        textAnchor="end"
                        fontSize="10"
                      >
                        {Math.round(val)}
                      </text>
                    </g>
                  );
                })}

                {/* Quadrant labels - moved further from center for more bubble space */}
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + 20}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q1 Prep
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + 20}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q2 Bull
                </text>
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + plotHeight - 5}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q3 Bear
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + plotHeight - 5}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q4 Pullback
                </text>

                {/* Corridors - More pronounced */}
                <rect
                  x={offsetX + (LONG_CORRIDOR.ltfMin + domainXMax) * scaleX}
                  y={offsetY}
                  width={(LONG_CORRIDOR.ltfMax - LONG_CORRIDOR.ltfMin) * scaleX}
                  height={plotHeight / 2}
                  fill="rgba(46,204,113,0.25)"
                  stroke="rgba(46,204,113,0.6)"
                  strokeWidth="2"
                  strokeDasharray="4 4"
                />
                <rect
                  x={offsetX + (SHORT_CORRIDOR.ltfMin + domainXMax) * scaleX}
                  y={offsetY + plotHeight / 2}
                  width={
                    (SHORT_CORRIDOR.ltfMax - SHORT_CORRIDOR.ltfMin) * scaleX
                  }
                  height={plotHeight / 2}
                  fill="rgba(231,76,60,0.25)"
                  stroke="rgba(231,76,60,0.6)"
                  strokeWidth="2"
                  strokeDasharray="4 4"
                />

                {/* Crosshair - Vertical line */}
                {crosshairPos &&
                  crosshairPos.chartX >= 0 &&
                  crosshairPos.chartX <= plotWidth && (
                    <line
                      x1={offsetX + crosshairPos.chartX}
                      y1={offsetY}
                      x2={offsetX + crosshairPos.chartX}
                      y2={offsetY + plotHeight}
                      stroke="#00ffff"
                      strokeWidth="1"
                      strokeDasharray="4 4"
                      opacity="0.7"
                      pointerEvents="none"
                    />
                  )}

                {/* Crosshair - Horizontal line */}
                {crosshairPos &&
                  crosshairPos.chartY >= 0 &&
                  crosshairPos.chartY <= plotHeight && (
                    <line
                      x1={offsetX}
                      y1={offsetY + crosshairPos.chartY}
                      x2={offsetX + plotWidth}
                      y2={offsetY + crosshairPos.chartY}
                      stroke="#00ffff"
                      strokeWidth="1"
                      strokeDasharray="4 4"
                      opacity="0.7"
                      pointerEvents="none"
                    />
                  )}

                {/* Crosshair value labels - Always show when crosshair is active */}
                {crosshairPos && (
                  <>
                    {/* LTF value at bottom - show if crosshair is in plot area */}
                    {crosshairPos.chartX >= 0 &&
                      crosshairPos.chartX <= plotWidth && (
                        <g>
                          <rect
                            x={offsetX + crosshairPos.chartX - 30}
                            y={offsetY + plotHeight + 5}
                            width="60"
                            height="20"
                            fill="#0b1020"
                            stroke="#00ffff"
                            strokeWidth="1.5"
                            opacity="0.95"
                            rx="3"
                          />
                          <text
                            x={offsetX + crosshairPos.chartX}
                            y={offsetY + plotHeight + 18}
                            fill="#00ffff"
                            textAnchor="middle"
                            fontSize="12"
                            fontWeight="700"
                          >
                            LTF: {crosshairPos.ltfValue.toFixed(1)}
                          </text>
                        </g>
                      )}

                    {/* HTF value on left - show if crosshair is in plot area */}
                    {crosshairPos.chartY >= 0 &&
                      crosshairPos.chartY <= plotHeight && (
                        <g>
                          <rect
                            x={offsetX - 55}
                            y={offsetY + crosshairPos.chartY - 10}
                            width="50"
                            height="20"
                            fill="#0b1020"
                            stroke="#00ffff"
                            strokeWidth="1.5"
                            opacity="0.95"
                            rx="3"
                          />
                          <text
                            x={offsetX - 30}
                            y={offsetY + crosshairPos.chartY + 5}
                            fill="#00ffff"
                            textAnchor="middle"
                            fontSize="12"
                            fontWeight="700"
                          >
                            HTF: {crosshairPos.htfValue.toFixed(1)}
                          </text>
                        </g>
                      )}
                  </>
                )}

                {/* Bubble Journey overlay */}
                {selectedTicker &&
                  selectedTrail &&
                  selectedTrail.length > 1 && (
                    <>
                      {/* Trail path */}
                      {(() => {
                        const GAP_MS = 30 * 60 * 1000; // break across big gaps (e.g., overnight)
                        const segments = splitTrailByGaps(
                          selectedTrail,
                          GAP_MS,
                        );
                        return segments
                          .filter((seg) => Array.isArray(seg) && seg.length > 1)
                          .map((seg, segIdx) => {
                            const pts = seg.map((p) => ({
                              x:
                                (Number(p?.ltf_score) || 0) * scaleX +
                                offsetX +
                                domainXMax * scaleX,
                              y:
                                (Number(p?.htf_score) || 0) * -scaleY +
                                offsetY +
                                plotHeight -
                                domainYMax * scaleY,
                            }));
                            const d = catmullRomPath(pts);
                            if (!d) return null;
                            const isLast = segIdx === segments.length - 1;
                            const opacity =
                              0.35 +
                              (segIdx / Math.max(1, segments.length - 1)) *
                                0.25;
                            return (
                              <path
                                key={`trail-path-${segIdx}`}
                                d={d}
                                fill="none"
                                stroke="#00ffff"
                                strokeWidth="2.25"
                                opacity={opacity}
                                className="trail-path"
                                markerEnd={
                                  isLast ? "url(#trailArrow)" : undefined
                                }
                                pointerEvents="none"
                              />
                            );
                          });
                      })()}

                      {/* Trail points */}
                      {selectedTrail.slice(0, -1).map((point, idx) => {
                        const x =
                          (Number(point?.ltf_score) || 0) * scaleX +
                          offsetX +
                          domainXMax * scaleX;
                        const y =
                          (Number(point?.htf_score) || 0) * -scaleY +
                          offsetY +
                          plotHeight -
                          domainYMax * scaleY;
                        const visual = bubbleVisualForTrailPoint(
                          point,
                          selectedTicker,
                        );
                        const size = visual.radius;
                        const opacity =
                          0.3 + (idx / selectedTrail.length) * 0.4;
                        return (
                          <circle
                            key={`trail-point-${idx}`}
                            cx={x}
                            cy={y}
                            r={size}
                            fill={visual.color}
                            fillOpacity={opacity}
                            stroke={visual.color}
                            strokeWidth="1"
                            strokeOpacity={opacity * 0.5}
                          />
                        );
                      })}

                      {/* Highlight a specific historical point */}
                      {highlightTrailPoint &&
                        Number.isFinite(
                          Number(highlightTrailPoint?.ltf_score),
                        ) &&
                        Number.isFinite(
                          Number(highlightTrailPoint?.htf_score),
                        ) &&
                        (() => {
                          const hx =
                            (Number(highlightTrailPoint.ltf_score) || 0) *
                              scaleX +
                            offsetX +
                            domainXMax * scaleX;
                          const hy =
                            (Number(highlightTrailPoint.htf_score) || 0) *
                              -scaleY +
                            offsetY +
                            plotHeight -
                            domainYMax * scaleY;
                          const visual = bubbleVisualForTrailPoint(
                            highlightTrailPoint,
                            selectedTicker,
                          );
                          const r = Math.max(3, Number(visual?.radius) || 6);
                          return (
                            <g
                              key={`trail-highlight-${String(
                                highlightTrailPoint?.ts ?? "",
                              )}`}
                              pointerEvents="none"
                            >
                              <circle
                                cx={hx}
                                cy={hy}
                                r={r + 3}
                                fill="none"
                                stroke="#00ffff"
                                strokeWidth="2.25"
                                opacity="0.9"
                              >
                                <animate
                                  attributeName="r"
                                  values={`${r + 2};${r + 10};${r + 2}`}
                                  dur="1.4s"
                                  repeatCount="indefinite"
                                />
                                <animate
                                  attributeName="opacity"
                                  values="0.95;0.25;0.95"
                                  dur="1.4s"
                                  repeatCount="indefinite"
                                />
                              </circle>
                              <circle
                                cx={hx}
                                cy={hy}
                                r={r + 1}
                                fill="none"
                                stroke={visual?.color || "#00ffff"}
                                strokeWidth="1.5"
                                opacity="0.8"
                              />
                            </g>
                          );
                        })()}
                    </>
                  )}

                {/* Current bubbles */}
                {displayTickers.map((ticker) => (
                  <SVGBubble
                    key={ticker.ticker}
                    ticker={ticker}
                    onClick={onBubbleClick}
                    onHover={(t) => {
                      onHover(t);
                      if (t) setTooltip(tickers.find((tt) => tt.ticker === t));
                    }}
                    isHovered={
                      hoveredTicker === ticker.ticker ||
                      (selectedTicker &&
                        String(selectedTicker).toUpperCase() ===
                          String(ticker.ticker || "").toUpperCase())
                    }
                    scaleX={scaleX}
                    scaleY={-scaleY}
                    offsetX={offsetX + domainXMax * scaleX}
                    offsetY={offsetY + plotHeight - domainYMax * scaleY}
                    layoutX={layoutPositions?.[ticker.ticker]?.x}
                    layoutY={layoutPositions?.[ticker.ticker]?.y}
                    showLabels={showLabels}
                    isTopRanked={topRankedTicker === ticker.ticker}
                    thesisMode={thesisMode}
                  />
                ))}

                {/* Time Travel floating label near the selected bubble */}
                {isTimeTravelActive &&
                  selectedTicker &&
                  (() => {
                    const sym = String(selectedTicker || "")
                      .trim()
                      .toUpperCase();
                    if (!sym) return null;
                    const selectedObj = (
                      Array.isArray(tickers) ? tickers : []
                    ).find(
                      (t) =>
                        t &&
                        String(t.ticker || "")
                          .trim()
                          .toUpperCase() === sym,
                    );
                    if (!selectedObj) return null;

                    const ltf = Number(selectedObj?.ltf_score) || 0;
                    const htf = Number(selectedObj?.htf_score) || 0;
                    const lx = layoutPositions?.[selectedObj.ticker]?.x;
                    const ly = layoutPositions?.[selectedObj.ticker]?.y;

                    const ox = offsetX + domainXMax * scaleX;
                    const oy = offsetY + plotHeight - domainYMax * scaleY;
                    const sx = scaleX;
                    const sy = -scaleY;

                    const x = Number.isFinite(Number(lx))
                      ? Number(lx)
                      : ltf * sx + ox;
                    const y = Number.isFinite(Number(ly))
                      ? Number(ly)
                      : htf * sy + oy;

                    const toMs = (v) => {
                      if (v == null) return NaN;
                      if (typeof v === "number") {
                        const n = v;
                        // Heuristic: if seconds, convert to ms
                        return n > 0 && n < 1e12 ? n * 1000 : n;
                      }
                      const n = Number(v);
                      if (Number.isFinite(n))
                        return n > 0 && n < 1e12 ? n * 1000 : n;
                      const d = new Date(String(v));
                      const ms = d.getTime();
                      return Number.isFinite(ms) ? ms : NaN;
                    };

                    const tsMs = toMs(
                      selectedObj.ts ??
                        selectedObj.ingest_ts ??
                        selectedObj.ingest_time,
                    );
                    const price = Number(selectedObj.price);

                    const tsText = Number.isFinite(tsMs)
                      ? new Date(tsMs).toLocaleString("en-US", {
                          month: "short",
                          day: "numeric",
                          hour: "numeric",
                          minute: "2-digit",
                        })
                      : "‚Äî";
                    const pxText = Number.isFinite(price)
                      ? `$${price.toFixed(2)}`
                      : "‚Äî";
                    const labelText = `${tsText} ‚Ä¢ ${pxText}`;

                    // Position the label near the bubble; clamp inside the SVG viewport.
                    const pad = 8;
                    const approxW = Math.min(
                      260,
                      Math.max(140, labelText.length * 6.2),
                    );
                    const w = approxW;
                    const h = 22;
                    let lx0 = x + 14;
                    let ly0 = y - 34;
                    lx0 = Math.max(pad, Math.min(chartWidth - w - pad, lx0));
                    ly0 = Math.max(pad, Math.min(chartHeight - h - pad, ly0));

                    return (
                      <g pointerEvents="none" opacity="0.98">
                        <rect
                          x={lx0}
                          y={ly0}
                          width={w}
                          height={h}
                          rx="6"
                          fill="#0b1020"
                          stroke="#00ffff"
                          strokeWidth="1"
                          fillOpacity="0.85"
                        />
                        <text
                          x={lx0 + w / 2}
                          y={ly0 + 15}
                          fill="#e7ecff"
                          textAnchor="middle"
                          fontSize="11"
                          fontWeight="700"
                        >
                          {labelText}
                        </text>
                      </g>
                    );
                  })()}
              </svg>

              {/* Tooltip */}
              {tooltip &&
                (() => {
                  // Calculate rank position using worker's rank field (stored at worker level)
                  // This matches the ranking system used throughout the platform
                  let rankPosition = null;
                  let totalTickers = 0;
                  const sortedByRank =
                    rankedTickers && rankedTickers.length > 0
                      ? rankedTickers
                      : getRankedTickers(allData);
                  totalTickers = sortedByRank.length;
                  rankPosition =
                    getRankPositionFromMap(
                      rankedTickerPositions,
                      tooltip.ticker,
                    ) ?? getRankPosition(sortedByRank, tooltip.ticker);
                  const rankTotal =
                    Number.isFinite(Number(tooltip.rank_total)) &&
                    Number(tooltip.rank_total) > 0
                      ? Number(tooltip.rank_total)
                      : totalTickers;
                  totalTickers = rankTotal;
                  return (
                    <div
                      className="absolute bg-[#121a33] border-2 border-[#26325f] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl fade-in"
                      style={{
                        left: tooltipPos.x + 10,
                        top: tooltipPos.y - 10,
                        minWidth: "200px",
                      }}
                    >
                      <div className="font-bold text-base mb-2">
                        {tooltip.ticker}
                        {tooltip.price && (
                          <span className="ml-2 text-sm font-normal text-white">
                            ${Number(tooltip.price).toFixed(2)}
                          </span>
                        )}
                      </div>
                      {(() => {
                        // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                        const ingestTime =
                          tooltip.ingest_ts ||
                          tooltip.ingest_time ||
                          tooltip.ts;
                        if (ingestTime) {
                          try {
                            const timeValue =
                              typeof ingestTime === "string"
                                ? new Date(ingestTime)
                                : new Date(Number(ingestTime));
                            if (!isNaN(timeValue.getTime())) {
                              const ageMs = Date.now() - timeValue.getTime();
                              const ageMinutes = Math.floor(ageMs / 60000);
                              const ageHours = Math.floor(ageMinutes / 60);

                              // Warn if data is stale (older than 30 minutes)
                              const isStale = ageMinutes > 30;

                              const displayTime = timeValue.toLocaleTimeString(
                                "en-US",
                                {
                                  hour: "numeric",
                                  minute: "2-digit",
                                  hour12: true,
                                },
                              );
                              const displayDate = timeValue.toLocaleDateString(
                                "en-US",
                                {
                                  month: "short",
                                  day: "numeric",
                                },
                              );
                              return (
                                <div
                                  className={`text-[10px] mb-2 ${
                                    isStale
                                      ? "text-yellow-400"
                                      : "text-[#93a4d6]"
                                  }`}
                                >
                                  {displayDate} {displayTime}
                                  {isStale && (
                                    <span
                                      className="ml-1"
                                      title={`Data is ${
                                        ageHours > 0 ? `${ageHours}h ` : ""
                                      }${ageMinutes % 60}m old`}
                                    >
                                      ‚ö†Ô∏è
                                    </span>
                                  )}
                                </div>
                              );
                            }
                          } catch (e) {}
                        }
                        return null;
                      })()}
                      {isPrimeBubble(tooltip) && (
                        <div className="mb-2 px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold text-center">
                          ‚≠ê PRIME SETUP
                        </div>
                      )}
                      {isWinnerSignature(tooltip) && (
                        <div className="mb-2 px-2 py-1 rounded bg-purple-500/20 text-purple-300 text-xs font-semibold text-center border border-purple-500/30">
                          üèÜ WINNER SIGNATURE
                        </div>
                      )}
                      {(() => {
                        const mv = getMoveStatusInfo(tooltip);
                        return (
                          <div className="mb-2 flex items-center justify-between gap-2">
                            <span className="text-[11px] text-[#93a4d6]">
                              Move
                            </span>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${mv.pillCls}`}
                            >
                              {mv.icon} {mv.status}
                            </span>
                          </div>
                        );
                      })()}
                      {(() => {
                        const mv = getMoveStatusInfo(tooltip);
                        if (mv.status === "ACTIVE" || !mv.headlineReason)
                          return null;
                        return (
                          <div className="mb-2 text-[10px] text-[#6b7a9f]">
                            <span className="text-[#93a4d6]">
                              {mv.status === "INVALIDATED"
                                ? "Invalidated"
                                : "Completed"}
                              :
                            </span>{" "}
                            <span className="text-[#e7ecff]">
                              {mv.headlineReason}
                            </span>
                          </div>
                        );
                      })()}
                      <div className="space-y-1">
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">Score</span>
                          <span className="font-semibold">
                            {(() => {
                              const s = rankScoreForTicker(tooltip);
                              return Number.isFinite(s) ? s.toFixed(1) : "‚Äî";
                            })()}
                          </span>
                        </div>
                        {rankPosition !== null && totalTickers > 0 && (
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Rank</span>
                            <span className="font-semibold">
                              {rankPosition} / {totalTickers}
                            </span>
                          </div>
                        )}
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">RR</span>
                          <span className="font-semibold">
                            {tooltip.rr ? Number(tooltip.rr).toFixed(2) : "‚Äî"}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">State</span>
                          <span className="font-semibold">
                            {tooltip.state || "‚Äî"}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">Phase</span>
                          <span
                            className="font-semibold"
                            style={{
                              color: phaseToColor(
                                Number(tooltip.phase_pct) || 0,
                              ),
                            }}
                          >
                            {Math.round((Number(tooltip.phase_pct) || 0) * 100)}
                            %{tooltip.phase_zone && ` (${tooltip.phase_zone})`}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">Completion</span>
                          <span className="font-semibold">
                            {Math.round(completionForSize(tooltip) * 100)}%
                          </span>
                        </div>
                      </div>
                    </div>
                  );
                })()}
            </div>
          );
        }

        // Recharts version (if loaded) - use currentRechartsComponents
        const {
          ScatterChart,
          Scatter,
          XAxis,
          YAxis,
          CartesianGrid,
          Tooltip,
          ResponsiveContainer,
          ReferenceLine,
          ReferenceArea,
        } = currentRechartsComponents;

        const [rechartsCrosshair, setRechartsCrosshair] = useState(null);
        const chartContainerRef = React.useRef(null);

        // Store ranked tickers for tooltip access
        const allTickersForRanking = rankedTickers;

        // Filter data based on selectedTicker - if selected, only show that ticker
        const data = useMemo(() => {
          const tickersToUse = selectedTicker
            ? tickers.filter((t) => {
                if (!t || typeof t !== "object") return false;
                const tTicker = String(t.ticker || "").toUpperCase();
                return tTicker === String(selectedTicker).toUpperCase();
              })
            : tickers;

          console.log(
            `[RECHARTS DATA] selectedTicker=${selectedTicker}, using ${tickersToUse.length} of ${tickers.length} tickers`,
          );

          return tickersToUse.map((t) => ({
            x: Number(t.ltf_score) || 0,
            y: Number(t.htf_score) || 0,
            ticker: t,
          }));
        }, [tickers, selectedTicker]);

        // Recharts shape renderer - receives cx, cy, payload from Recharts
        const BubbleShape = React.useCallback(
          (props) => {
            const { cx, cy, payload } = props;
            const ticker = payload?.ticker;
            if (!ticker) return null;

            const comp =
              ticker.completion != null ? Number(ticker.completion) : 0;
            const phasePct =
              ticker.phase_pct != null ? Number(ticker.phase_pct) : 0;
            const rr = ticker.rr != null ? Number(ticker.rr) : 0;
            const waitingForData = ticker.waitingForData === true;

            const validComp = Number.isFinite(comp)
              ? Math.max(0, Math.min(1, comp))
              : 0;
            const validPhase = Number.isFinite(phasePct)
              ? Math.max(0, Math.min(1, phasePct))
              : 0.1;
            const validRR = Number.isFinite(rr) && rr > 0 ? rr : 0.5;

            const cappedRR = Math.min(validRR, 5);
            const baseSize = 4; // Further reduced for less overlap
            const rrMultiplier = 2; // Further reduced for smaller bubbles
            const size = waitingForData
              ? baseSize * 0.7
              : baseSize + cappedRR * rrMultiplier * (1 - validComp);

            // Add size variation for better visual distinction
            const tickerHash = (ticker.ticker || "")
              .split("")
              .reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const sizeVariation = (tickerHash % 5) * 0.8;
            const finalSize = Math.max(baseSize, size + sizeVariation);

            // Color based on phase
            let color = "#2ecc71"; // Green default
            if (waitingForData) {
              color = "#6b7a9f"; // Gray for waiting
            } else if (validPhase >= 0.6) {
              color = "#e74c3c"; // Red: 60-100%
            } else if (validPhase >= 0.3) {
              color = "#f39c12"; // Yellow: 30-60%
            }

            const flags = ticker.flags || {};
            const prime = isPrimeBubble(ticker);
            const winnerSig = isWinnerSignature(ticker);
            const move = getMoveStatusInfo(ticker);
            const isTopRanked = topRankedTicker === ticker.ticker;
            const isBubbleHovered = hoveredTicker === ticker.ticker;
            const isInSqueeze = !!flags.sq30_on && !flags.sq30_release;

            // Determine emojis (show all applicable)
            const emojis = [];
            if (isTopRanked) emojis.push("üëë");
            if (flags.thesis_match === true && !waitingForData)
              emojis.push("üß†");
            if (waitingForData) emojis.push("‚è≥");
            if (!waitingForData) {
              if (!!flags.momentum_elite) emojis.push("üöÄ");
              if (prime) emojis.push("‚≠ê");
              if (winnerSig) emojis.push("üèÜ");
              if (flags.sq30_release) emojis.push("‚ö°");
              if (isInSqueeze) emojis.push("üß®");
            }
            const emojiText = emojis.join("");

            let borderColor = waitingForData
              ? "#93a4d6"
              : prime
                ? "#2ecc71"
                : winnerSig
                  ? "#a855f7"
                  : flags.sq30_release
                    ? "#00ffff"
                    : flags.sq30_on
                      ? "#ffd700"
                      : "#ffffff";

            const baseOpacity = waitingForData
              ? 0.6
              : isBubbleHovered
                ? 1
                : prime
                  ? 0.95
                  : winnerSig
                    ? 0.95
                    : 0.85;
            const moveOpacityMult =
              waitingForData || isBubbleHovered
                ? 1
                : move.status === "INVALIDATED"
                  ? 0.28
                  : move.status === "COMPLETED"
                    ? 0.65
                    : 1;
            const opacity = Math.max(0.12, baseOpacity * moveOpacityMult);

            // Make Move Status visually obvious on-chart
            if (!waitingForData && move.status !== "ACTIVE") {
              borderColor = move.stroke;
            }
            const borderWidth = waitingForData
              ? 2
              : prime
                ? 3
                : winnerSig
                  ? 3
                  : flags.sq30_release || flags.sq30_on
                    ? 2
                    : 1.5;
            const bubbleSize = isBubbleHovered ? finalSize * 1.2 : finalSize;
            const labelY =
              cy - bubbleSize - (emojiText ? (isTopRanked ? 20 : 12) : 8);

            return (
              <g
                onClick={() => {
                  console.log(
                    `[BUBBLE CLICK] Direct click on ticker: ${ticker.ticker}`,
                  );
                  onBubbleClick(ticker.ticker);
                }}
                onMouseEnter={() => onHover(ticker.ticker)}
                onMouseLeave={() => onHover(null)}
                onTouchStart={(e) => {
                  e.preventDefault();
                  onHover(ticker.ticker);
                  console.log(
                    `[BUBBLE CLICK] Touch on ticker: ${ticker.ticker}`,
                  );
                  onBubbleClick(ticker.ticker);
                }}
                onTouchEnd={(e) => {
                  e.preventDefault();
                  onHover(null);
                }}
                style={{
                  cursor: "pointer",
                  transition: "all 0.2s ease-out",
                  touchAction: "manipulation",
                }}
              >
                {/* Glow effect for prime */}
                {prime && (
                  <circle
                    cx={cx}
                    cy={cy}
                    r={bubbleSize + 2}
                    fill="none"
                    stroke="#2ecc71"
                    strokeWidth="1"
                    opacity="0.3"
                  />
                )}
                {/* Additional glow effects for #1 ranked - reduced size */}
                {isTopRanked && (
                  <>
                    <circle
                      cx={cx}
                      cy={cy}
                      r={bubbleSize + 4}
                      fill="none"
                      stroke="#ffd700"
                      strokeWidth="2"
                      opacity="0.6"
                    >
                      <animate
                        attributeName="opacity"
                        values="0.3;0.9;0.3"
                        dur="2s"
                        repeatCount="indefinite"
                      />
                      <animate
                        attributeName="r"
                        values={`${bubbleSize + 3};${bubbleSize + 6};${
                          bubbleSize + 3
                        }`}
                        dur="2s"
                        repeatCount="indefinite"
                      />
                    </circle>
                    <circle
                      cx={cx}
                      cy={cy}
                      r={bubbleSize + 6}
                      fill="none"
                      stroke="#ffd700"
                      strokeWidth="1.5"
                      opacity="0.3"
                    >
                      <animate
                        attributeName="opacity"
                        values="0.1;0.5;0.1"
                        dur="2s"
                        repeatCount="indefinite"
                      />
                    </circle>
                  </>
                )}
                <circle
                  cx={cx}
                  cy={cy}
                  r={Math.max(3, bubbleSize)}
                  fill={color}
                  fillOpacity={opacity}
                  stroke={borderColor}
                  strokeWidth={borderWidth}
                  strokeDasharray={
                    !waitingForData && move.dash ? move.dash : undefined
                  }
                />
                {/* Move status badge (Completed / Invalidated) */}
                {!waitingForData && move.status !== "ACTIVE" && (
                  <g style={{ pointerEvents: "none" }}>
                    <text
                      x={cx + bubbleSize * 0.55}
                      y={cy - bubbleSize * 0.55}
                      textAnchor="middle"
                      dominantBaseline="middle"
                      fontSize="12"
                      fontWeight="800"
                      style={{ textShadow: "0 0 4px rgba(0,0,0,0.9)" }}
                    >
                      {move.icon}
                    </text>
                  </g>
                )}
                {/* Emoji above bubble */}
                {emojiText && (
                  <g style={{ pointerEvents: "none" }}>
                    {/* Background circle for #1 ranked - reduced size */}
                    {isTopRanked && (
                      <circle
                        cx={cx}
                        cy={labelY - 5}
                        r="18"
                        fill="#ffd700"
                        fillOpacity="0.3"
                      >
                        <animate
                          attributeName="fillOpacity"
                          values="0.2;0.5;0.2"
                          dur="1.5s"
                          repeatCount="indefinite"
                        />
                      </circle>
                    )}
                    {/* Outer glow ring for #1 - reduced size */}
                    {isTopRanked && (
                      <>
                        <circle
                          cx={cx}
                          cy={labelY - 5}
                          r="22"
                          fill="none"
                          stroke="#ffd700"
                          strokeWidth="2"
                          opacity="0.6"
                        >
                          <animate
                            attributeName="r"
                            values="20;24;20"
                            dur="2s"
                            repeatCount="indefinite"
                          />
                          <animate
                            attributeName="opacity"
                            values="0.4;0.8;0.4"
                            dur="2s"
                            repeatCount="indefinite"
                          />
                        </circle>
                      </>
                    )}
                    {/* Main emoji text */}
                    <text
                      x={cx}
                      y={labelY}
                      textAnchor="middle"
                      dominantBaseline="middle"
                      fontSize={
                        isTopRanked
                          ? "24"
                          : waitingForData
                            ? "10"
                            : prime
                              ? "14"
                              : "12"
                      }
                      fill={
                        isTopRanked
                          ? "#ffd700"
                          : waitingForData
                            ? "#93a4d6"
                            : prime
                              ? "#2ecc71"
                              : winnerSig
                                ? "#a855f7"
                                : flags.sq30_release
                                  ? "#00ffff"
                                  : flags.momentum_elite
                                    ? "#a855f7"
                                    : "#ffd700"
                      }
                      fontWeight="bold"
                      style={{
                        textShadow: isTopRanked
                          ? "0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.8)"
                          : "0 0 3px rgba(0,0,0,0.8)",
                        filter: isTopRanked
                          ? "drop-shadow(0 0 15px rgba(255, 215, 0, 1))"
                          : "none",
                        pointerEvents: "none",
                      }}
                    >
                      {emojiText}
                    </text>
                    {/* Sparkle effects for #1 - reduced size */}
                    {isTopRanked && (
                      <>
                        <text
                          x={cx - 15}
                          y={labelY - 10}
                          textAnchor="middle"
                          dominantBaseline="middle"
                          fontSize="12"
                          fill="#ffd700"
                          opacity="0.9"
                          style={{ pointerEvents: "none" }}
                        >
                          ‚ú®
                        </text>
                        <text
                          x={cx + 15}
                          y={labelY - 10}
                          textAnchor="middle"
                          dominantBaseline="middle"
                          fontSize="12"
                          fill="#ffd700"
                          opacity="0.9"
                          style={{ pointerEvents: "none" }}
                        >
                          ‚ú®
                        </text>
                      </>
                    )}
                  </g>
                )}
                {/* Ticker label */}
                {(showLabels || isBubbleHovered) && (
                  <text
                    x={cx}
                    y={labelY - (emojiText ? 14 : 8)}
                    textAnchor="middle"
                    fontSize="10"
                    fill={waitingForData ? "#93a4d6" : "#e7ecff"}
                    fontWeight="600"
                    style={{
                      textShadow: "0 0 4px rgba(0,0,0,0.9)",
                      pointerEvents: "none",
                    }}
                  >
                    {ticker.ticker}
                  </text>
                )}
              </g>
            );
          },
          [onBubbleClick, onHover, hoveredTicker, topRankedTicker, showLabels],
        );

        const handleRechartsMouseMove = (e) => {
          if (
            e &&
            e.activeCoordinate &&
            e.chartX !== undefined &&
            e.chartY !== undefined
          ) {
            // Calculate values from chart coordinates
            // Domain is [-50, 50] for both axes
            // activeCoordinate gives us pixel position, we need to convert to data values
            const chart = e.chart;
            if (chart && chartContainerRef.current) {
              const rect = chartContainerRef.current.getBoundingClientRect();
              const margin = { top: 20, right: 20, bottom: 20, left: 20 };
              const plotWidth = rect.width - margin.left - margin.right;
              const plotHeight = rect.height - margin.top - margin.bottom;

              // Convert pixel coordinates to data values
              const ltfValue =
                ((e.chartX - margin.left) / plotWidth) * 100 - 50;
              const htfValue =
                50 - ((e.chartY - margin.top) / plotHeight) * 100;

              setRechartsCrosshair({
                x: e.chartX,
                y: e.chartY,
                ltfValue: ltfValue,
                htfValue: htfValue,
              });
            } else if (e.activePayload && e.activePayload[0]) {
              // Fallback: use payload data if available
              const payload = e.activePayload[0].payload;
              setRechartsCrosshair({
                x: e.activeCoordinate.x,
                y: e.activeCoordinate.y,
                ltfValue: payload.x,
                htfValue: payload.y,
              });
            }
          }
        };

        const handleRechartsMouseLeave = () => {
          setRechartsCrosshair(null);
        };

        return (
          <div
            ref={chartContainerRef}
            className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-4 relative"
          >
            <ResponsiveContainer width="100%" height="100%">
              <ScatterChart
                margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
                onMouseMove={handleRechartsMouseMove}
                onMouseLeave={handleRechartsMouseLeave}
                onTouchMove={(e) => {
                  // Recharts handles touch events, but we need to ensure they work
                  if (e.activeCoordinate) {
                    handleRechartsMouseMove(e);
                  }
                }}
                onTouchEnd={handleRechartsMouseLeave}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#26325f" />
                <XAxis
                  type="number"
                  dataKey="x"
                  name="LTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <YAxis
                  type="number"
                  dataKey="y"
                  name="HTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                {/* Corridors - Long corridor (top half, LTF: -8 to +12) - More pronounced */}
                <ReferenceArea
                  x1={LONG_CORRIDOR.ltfMin}
                  x2={LONG_CORRIDOR.ltfMax}
                  y1={0}
                  y2={50}
                  fill="rgba(46,204,113,0.25)"
                  stroke="rgba(46,204,113,0.6)"
                  strokeWidth={2}
                  strokeDasharray="4 4"
                />
                {/* Corridors - Short corridor (bottom half, LTF: -12 to +8) - More pronounced */}
                <ReferenceArea
                  x1={SHORT_CORRIDOR.ltfMin}
                  x2={SHORT_CORRIDOR.ltfMax}
                  y1={-50}
                  y2={0}
                  fill="rgba(231,76,60,0.25)"
                  stroke="rgba(231,76,60,0.6)"
                  strokeWidth={2}
                  strokeDasharray="4 4"
                />
                {/* Zero lines - X=0 and Y=0 */}
                <ReferenceLine
                  x={0}
                  stroke="#ffffff"
                  strokeWidth={2}
                  opacity={1}
                />
                <ReferenceLine
                  y={0}
                  stroke="#ffffff"
                  strokeWidth={2}
                  opacity={1}
                />
                {/* Crosshair - Vertical line */}
                {rechartsCrosshair && rechartsCrosshair.ltfValue !== null && (
                  <ReferenceLine
                    x={rechartsCrosshair.ltfValue}
                    stroke="#00ffff"
                    strokeWidth={1}
                    strokeDasharray="4 4"
                    opacity={0.7}
                  />
                )}
                {/* Crosshair - Horizontal line */}
                {rechartsCrosshair && rechartsCrosshair.htfValue !== null && (
                  <ReferenceLine
                    y={rechartsCrosshair.htfValue}
                    stroke="#00ffff"
                    strokeWidth={1}
                    strokeDasharray="4 4"
                    opacity={0.7}
                  />
                )}
                <Tooltip
                  content={({ active, payload }) => {
                    if (!active || !payload?.[0]) return null;
                    const t = payload[0].payload.ticker;

                    // Calculate rank position (same logic as native SVG tooltip)
                    let rankPosition = null;
                    let totalTickers = 0;
                    const sortedByRank =
                      allTickersForRanking &&
                      Array.isArray(allTickersForRanking)
                        ? allTickersForRanking
                        : getRankedTickers(allData);
                    totalTickers = sortedByRank.length;
                    rankPosition =
                      getRankPositionFromMap(rankedTickerPositions, t.ticker) ??
                      getRankPosition(sortedByRank, t.ticker);
                    const rankTotal =
                      Number.isFinite(Number(t.rank_total)) &&
                      Number(t.rank_total) > 0
                        ? Number(t.rank_total)
                        : totalTickers;
                    totalTickers = rankTotal;

                    return (
                      <div className="bg-[#121a33] border-2 border-[#26325f] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl">
                        <div className="font-bold text-base mb-2">
                          {t.ticker}
                          {t.price && (
                            <span className="ml-2 text-sm font-normal text-white">
                              ${Number(t.price).toFixed(2)}
                            </span>
                          )}
                        </div>
                        {(() => {
                          // Show ingest time (same logic as native SVG tooltip)
                          const ingestTime =
                            t.ingest_ts || t.ingest_time || t.ts;
                          if (ingestTime) {
                            try {
                              const timeValue =
                                typeof ingestTime === "string"
                                  ? new Date(ingestTime)
                                  : new Date(Number(ingestTime));
                              if (!isNaN(timeValue.getTime())) {
                                const ageMs = Date.now() - timeValue.getTime();
                                const ageMinutes = Math.floor(ageMs / 60000);
                                const ageHours = Math.floor(ageMinutes / 60);
                                const isStale = ageMinutes > 30;

                                const displayTime =
                                  timeValue.toLocaleTimeString("en-US", {
                                    hour: "numeric",
                                    minute: "2-digit",
                                    hour12: true,
                                  });
                                const displayDate =
                                  timeValue.toLocaleDateString("en-US", {
                                    month: "short",
                                    day: "numeric",
                                  });
                                return (
                                  <div
                                    className={`text-[10px] mb-2 ${
                                      isStale
                                        ? "text-yellow-400"
                                        : "text-[#93a4d6]"
                                    }`}
                                  >
                                    {displayDate} {displayTime}
                                    {isStale && (
                                      <span
                                        className="ml-1"
                                        title={`Data is ${
                                          ageHours > 0 ? `${ageHours}h ` : ""
                                        }${ageMinutes % 60}m old`}
                                      >
                                        ‚ö†Ô∏è
                                      </span>
                                    )}
                                  </div>
                                );
                              }
                            } catch (e) {}
                          }
                          return null;
                        })()}
                        {isPrimeBubble(t) && (
                          <div className="mb-2 px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold text-center">
                            ‚≠ê PRIME SETUP
                          </div>
                        )}
                        {isWinnerSignature(t) && (
                          <div className="mb-2 px-2 py-1 rounded bg-purple-500/20 text-purple-300 text-xs font-semibold text-center border border-purple-500/30">
                            üèÜ WINNER SIGNATURE
                          </div>
                        )}
                        {(() => {
                          const mv = getMoveStatusInfo(t);
                          return (
                            <div className="mb-2 flex items-center justify-between gap-2">
                              <span className="text-[11px] text-[#93a4d6]">
                                Move
                              </span>
                              <span
                                className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${mv.pillCls}`}
                              >
                                {mv.icon} {mv.status}
                              </span>
                            </div>
                          );
                        })()}
                        {(() => {
                          const mv = getMoveStatusInfo(t);
                          if (mv.status === "ACTIVE" || !mv.headlineReason)
                            return null;
                          return (
                            <div className="mb-2 text-[10px] text-[#6b7a9f]">
                              <span className="text-[#93a4d6]">
                                {mv.status === "INVALIDATED"
                                  ? "Invalidated"
                                  : "Completed"}
                                :
                              </span>{" "}
                              <span className="text-[#e7ecff]">
                                {mv.headlineReason}
                              </span>
                            </div>
                          );
                        })()}
                        <div className="space-y-1">
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Score</span>
                            <span className="font-semibold">
                              {(() => {
                                const s = rankScoreForTicker(t);
                                return Number.isFinite(s) ? s.toFixed(1) : "‚Äî";
                              })()}
                            </span>
                          </div>
                          {rankPosition !== null && totalTickers > 0 && (
                            <div className="flex justify-between">
                              <span className="text-[#93a4d6]">Rank</span>
                              <span className="font-semibold">
                                {rankPosition} / {totalTickers}
                              </span>
                            </div>
                          )}
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">RR</span>
                            <span className="font-semibold">
                              {t.rr ? Number(t.rr).toFixed(2) : "‚Äî"}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">State</span>
                            <span className="font-semibold">
                              {t.state || "‚Äî"}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Phase</span>
                            <span
                              className="font-semibold"
                              style={{
                                color: phaseToColor(Number(t.phase_pct) || 0),
                              }}
                            >
                              {Math.round((Number(t.phase_pct) || 0) * 100)}%
                              {t.phase_zone && ` (${t.phase_zone})`}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Completion</span>
                            <span className="font-semibold">
                              {Math.round(completionForSize(t) * 100)}%
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Horizon</span>
                            <span className="font-semibold">
                              {(() => {
                                const eta = computeEtaDays(t);
                                const bucket = String(t.horizon_bucket || "")
                                  .trim()
                                  .toUpperCase();
                                if (bucket) return bucket.replace("_", " ");
                                if (!Number.isFinite(eta)) return "‚Äî";
                                if (eta <= 7) return "SHORT TERM";
                                if (eta <= 30) return "SWING";
                                return "POSITIONAL";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">ETA</span>
                            <span className="font-semibold">
                              {(() => {
                                const eta = computeEtaDays(t);
                                return Number.isFinite(eta)
                                  ? `${eta.toFixed(1)}d`
                                  : "‚Äî";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Return %</span>
                            <span className="font-semibold">
                              {(() => {
                                const ret = computeReturnPct(t);
                                return Number.isFinite(ret)
                                  ? `${ret.toFixed(1)}%`
                                  : "‚Äî";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Risk %</span>
                            <span className="font-semibold">
                              {(() => {
                                const risk = computeRiskPct(t);
                                return Number.isFinite(risk)
                                  ? `${risk.toFixed(1)}%`
                                  : "‚Äî";
                              })()}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  }}
                />
                <Scatter data={data} shape={BubbleShape} />
              </ScatterChart>
            </ResponsiveContainer>

            {/* Trail rendering overlay for selected ticker (Recharts mode) */}
            {selectedTicker &&
              selectedTrail &&
              Array.isArray(selectedTrail) &&
              selectedTrail.length > 1 && (
                <svg
                  className="absolute inset-0 pointer-events-none z-10"
                  style={{ width: "100%", height: "100%" }}
                >
                  <defs>
                    <linearGradient
                      id="trailGradient"
                      x1="0%"
                      y1="0%"
                      x2="100%"
                      y2="100%"
                    >
                      <stop offset="0%" stopColor="#00ffff" stopOpacity="0.3" />
                      <stop
                        offset="100%"
                        stopColor="#00ffff"
                        stopOpacity="0.6"
                      />
                    </linearGradient>

                    {/* Arrowhead marker for the Bubble Trail path */}
                    <marker
                      id="trailArrowRecharts"
                      viewBox="0 0 10 10"
                      refX="9"
                      refY="5"
                      markerWidth="6"
                      markerHeight="6"
                      orient="auto"
                    >
                      <path
                        d="M 0 0 L 10 5 L 0 10 z"
                        fill="#00ffff"
                        opacity="0.8"
                      />
                    </marker>
                  </defs>
                  <g>
                    {/* Trail lines */}
                    {(() => {
                      const chartWidth =
                        chartContainerRef.current?.clientWidth || 1200;
                      const chartHeight =
                        chartContainerRef.current?.clientHeight || 800;
                      const margin = 20;
                      const plotWidth = chartWidth - 2 * margin;
                      const plotHeight = chartHeight - 2 * margin;

                      const GAP_MS = 30 * 60 * 1000;
                      const segments = splitTrailByGaps(selectedTrail, GAP_MS);

                      return segments
                        .filter((seg) => Array.isArray(seg) && seg.length > 1)
                        .map((seg, segIdx) => {
                          const pts = seg.map((p) => ({
                            x:
                              (((Number(p?.ltf_score) || 0) + 50) / 100) *
                                plotWidth +
                              margin,
                            y:
                              ((50 - (Number(p?.htf_score) || 0)) / 100) *
                                plotHeight +
                              margin,
                          }));
                          const d = catmullRomPath(pts);
                          if (!d) return null;
                          const isLast = segIdx === segments.length - 1;
                          const opacity =
                            0.35 +
                            (segIdx / Math.max(1, segments.length - 1)) * 0.25;
                          return (
                            <path
                              key={`trail-path-recharts-${segIdx}`}
                              d={d}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity={opacity}
                              className="trail-path"
                              markerEnd={
                                isLast ? "url(#trailArrowRecharts)" : undefined
                              }
                            />
                          );
                        });
                    })()}
                    {/* Trail points (historical bubbles) */}
                    {selectedTrail.slice(0, -1).map((point, idx) => {
                      const chartWidth =
                        chartContainerRef.current?.clientWidth || 1200;
                      const chartHeight =
                        chartContainerRef.current?.clientHeight || 800;
                      const margin = 20;
                      const plotWidth = chartWidth - 2 * margin;
                      const plotHeight = chartHeight - 2 * margin;

                      const cx =
                        (((Number(point.ltf_score) || 0) + 50) / 100) *
                          plotWidth +
                        margin;
                      const cy =
                        ((50 - (Number(point.htf_score) || 0)) / 100) *
                          plotHeight +
                        margin;
                      const visual = bubbleVisualForTrailPoint(
                        point,
                        selectedTicker,
                      );
                      const size = visual.radius;
                      const opacity = 0.3 + (idx / selectedTrail.length) * 0.4;
                      const color = visual.color;

                      return (
                        <circle
                          key={`trail-point-${idx}`}
                          cx={cx}
                          cy={cy}
                          r={size}
                          fill={color}
                          fillOpacity={opacity}
                          stroke={color}
                          strokeWidth="1"
                          strokeOpacity={opacity * 0.5}
                        />
                      );
                    })}
                    {/* Highlight a specific historical point (from Bubble Journey hover/click) */}
                    {highlightTrailPoint &&
                      Number.isFinite(Number(highlightTrailPoint?.ltf_score)) &&
                      Number.isFinite(Number(highlightTrailPoint?.htf_score)) &&
                      (() => {
                        const chartWidth =
                          chartContainerRef.current?.clientWidth || 1200;
                        const chartHeight =
                          chartContainerRef.current?.clientHeight || 800;
                        const margin = 20;
                        const plotWidth = chartWidth - 2 * margin;
                        const plotHeight = chartHeight - 2 * margin;

                        const hx =
                          (((Number(highlightTrailPoint.ltf_score) || 0) + 50) /
                            100) *
                            plotWidth +
                          margin;
                        const hy =
                          ((50 - (Number(highlightTrailPoint.htf_score) || 0)) /
                            100) *
                            plotHeight +
                          margin;

                        const visual = bubbleVisualForTrailPoint(
                          highlightTrailPoint,
                          selectedTicker,
                        );
                        const r = Math.max(3, Number(visual?.radius) || 6);

                        return (
                          <g
                            key={`trail-highlight-recharts-${String(
                              highlightTrailPoint?.ts ?? "",
                            )}`}
                            pointerEvents="none"
                          >
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 3}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity="0.9"
                            >
                              <animate
                                attributeName="r"
                                values={`${r + 2};${r + 10};${r + 2}`}
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                              <animate
                                attributeName="opacity"
                                values="0.95;0.25;0.95"
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                            </circle>
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 1}
                              fill="none"
                              stroke={visual?.color || "#00ffff"}
                              strokeWidth="1.5"
                              opacity="0.8"
                            />
                          </g>
                        );
                      })()}
                  </g>
                </svg>
              )}

            {/* Crosshair value labels for Recharts */}
            {rechartsCrosshair && (
              <>
                {rechartsCrosshair.ltfValue !== null && (
                  <div
                    className="absolute bg-[#0b1020] border border-[#00ffff] rounded px-2 py-1 text-[#00ffff] text-xs font-semibold pointer-events-none z-20"
                    style={{
                      left: `${rechartsCrosshair.x + 20}px`,
                      bottom: "20px",
                      transform: "translateX(-50%)",
                    }}
                  >
                    LTF: {rechartsCrosshair.ltfValue.toFixed(1)}
                  </div>
                )}
                {rechartsCrosshair.htfValue !== null && (
                  <div
                    className="absolute bg-[#0b1020] border border-[#00ffff] rounded px-2 py-1 text-[#00ffff] text-xs font-semibold pointer-events-none z-20"
                    style={{
                      left: "20px",
                      top: `${rechartsCrosshair.y + 20}px`,
                      transform: "translateY(-50%)",
                    }}
                  >
                    HTF: {rechartsCrosshair.htfValue.toFixed(1)}
                  </div>
                )}
              </>
            )}
          </div>
        );
      }

      // Format date/time from timestamp
      function formatTriggerDateTime(ts) {
        if (!ts || typeof ts !== "number") return "‚Äî";
        const date = new Date(ts);
        return {
          date: date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          }),
          time: date.toLocaleTimeString("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          }),
        };
      }

      // Get "Why" reason from ticker data
      function getWhyReason(ticker) {
        const reasons = ticker.reasons || [];
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        if (flags.sq30_release) return "Squeeze Release";
        if (flags.phase_zone_change) return "Phase Zone Change";
        if (state.includes("BULL") && state.includes("BULL"))
          return "Both Timeframes Bullish";
        if (state.includes("BEAR") && state.includes("BEAR"))
          return "Both Timeframes Bearish";
        if (reasons.length > 0) return reasons[0];
        return "Setup Active";
      }

      const ENTRY_DECISION_LABELS = {
        futures_disabled: "Futures excluded",
        missing_levels: "Missing price/SL/TP",
        not_in_corridor: "Not in entry corridor",
        corridor_misaligned: "Corridor misaligned",
        no_trigger: "No trigger/squeeze",
        rr_below_min: "RR below minimum",
        completion_high: "Completion too high",
        phase_high: "Phase too high",
        rank_low: "Rank too low",
        stale_data: "Data delayed",
      };

      function summarizeEntryDecision(ticker) {
        const decision = ticker?.entry_decision;
        if (!decision || typeof decision !== "object") return null;
        const blockers = Array.isArray(decision.blockers)
          ? decision.blockers
          : [];
        const warnings = Array.isArray(decision.warnings)
          ? decision.warnings
          : [];
        const label = (code) =>
          ENTRY_DECISION_LABELS[code] || String(code || "").replace(/_/g, " ");
        if (decision.ok) {
          return {
            status: "Eligible",
            detail: "All entry checks passed",
            tone: "text-green-400",
            bg: "bg-green-500/20",
            blockers: [],
            warnings: warnings.map(label),
          };
        }
        if (blockers.length === 0) {
          return {
            status: "Waiting",
            detail: "Setup not confirmed yet",
            tone: "text-[#93a4d6]",
            bg: "bg-[#26325f]",
            blockers: [],
            warnings: warnings.map(label),
          };
        }
        const shown = blockers.slice(0, 3).map(label);
        const extra =
          blockers.length > 3 ? ` +${blockers.length - 3} more` : "";
        return {
          status: "Blocked",
          detail: `${shown.join(", ")}${extra}`,
          tone: "text-yellow-400",
          bg: "bg-yellow-500/20",
          blockers: blockers.map(label),
          warnings: warnings.map(label),
        };
      }

      // Get direction from state
      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL"))
          return {
            text: "LONG",
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        if (state.includes("BEAR"))
          return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: "‚Äî", color: "text-[#93a4d6]", bg: "bg-[#26325f]" };
      }

      function SetupCard({ ticker, isSelected, onClick }) {
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const momentumElite = !!flags.momentum_elite;
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const dir = getDirection(ticker);
        const why = getWhyReason(ticker);
        const triggerDT = formatTriggerDateTime(ticker.trigger_ts);
        const tpLevels = ticker.tp_levels || [];
        const comp = completionForSize(ticker);
        const decision = summarizeEntryDecision(ticker);
        const skin = getCardSkin(ticker);

        return (
          <div
            className={`p-1.5 rounded-lg border cursor-pointer transition-all ${
              isSelected
                ? "border-blue-500 bg-blue-500/10 shadow-lg"
                : momentumElite
                  ? "border-purple-500 bg-purple-500/15 momentum-elite-glow border-2"
                  : prime
                    ? "border-green-500 bg-green-500/10 prime-glow"
                    : "border-[#26325f] bg-[#0f1630] hover:brightness-[1.06] hover:border-[#3a4aa0]"
            }`}
            onClick={onClick}
            style={{
              backgroundColor: "#0f1630",
              backgroundImage: skin?.bgImage || undefined,
            }}
          >
            {/* Header */}
            <div className="flex items-center justify-between mb-1">
              <div className="flex items-center gap-1.5">
                <span className="font-bold text-sm">{ticker.ticker}</span>
                {momentumElite && (
                  <span
                    className="text-purple-400 text-xs font-bold"
                    title="Momentum Elite"
                  >
                    üöÄ
                  </span>
                )}
                {prime && <span className="text-green-500 text-xs">‚≠ê</span>}
                {flags.sq30_release && (
                  <span className="text-cyan-400 text-xs">‚ö°</span>
                )}
                {flags.sq30_on && (
                  <span className="text-yellow-400 text-xs">üß®</span>
                )}
              </div>
              <div className="flex items-center gap-1.5">
                {ticker.price && (
                  <div className="text-right">
                    <span className="text-xs font-semibold text-white">
                      ${Number(ticker.price).toFixed(2)}
                    </span>
                    {(() => {
                      const { dayChg, dayPct, stale, marketOpen } =
                        getDailyChange(ticker);
                      if (!Number.isFinite(dayChg) && !Number.isFinite(dayPct))
                        return null;
                      const sign =
                        Number(dayChg || dayPct || 0) >= 0 ? "+" : "-";
                      const cls =
                        Number(dayChg || dayPct || 0) >= 0
                          ? "text-green-400"
                          : "text-red-400";
                      return (
                        <div className={`text-[10px] ${cls}`}>
                          {Number.isFinite(dayPct)
                            ? `${sign}${Math.abs(dayPct).toFixed(2)}%`
                            : "‚Äî"}{" "}
                          {Number.isFinite(dayChg)
                            ? `(${sign}${fmtUsdAbs(dayChg)})`
                            : ""}
                          {!marketOpen && (
                            <span className="ml-2 text-[10px] text-[#93a4d6]">
                              AH
                              {stale?.ageLabel
                                ? ` ‚Ä¢ as of ${stale.ageLabel}`
                                : ""}
                            </span>
                          )}
                        </div>
                      );
                    })()}
                    {(() => {
                      // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                      const ingestTime =
                        ticker.ingest_ts || ticker.ingest_time || ticker.ts;
                      if (ingestTime) {
                        try {
                          const timeValue =
                            typeof ingestTime === "string"
                              ? new Date(ingestTime)
                              : new Date(Number(ingestTime));
                          if (!isNaN(timeValue.getTime())) {
                            const ageMs = Date.now() - timeValue.getTime();
                            const ageMinutes = Math.floor(ageMs / 60000);
                            const ageHours = Math.floor(ageMinutes / 60);

                            // Warn if data is stale (older than 30 minutes)
                            const isStale = ageMinutes > 30;

                            const displayTime = timeValue.toLocaleTimeString(
                              "en-US",
                              {
                                hour: "numeric",
                                minute: "2-digit",
                                hour12: true,
                              },
                            );
                            const displayDate = timeValue.toLocaleDateString(
                              "en-US",
                              {
                                month: "short",
                                day: "numeric",
                              },
                            );
                            return (
                              <div
                                className={`text-[9px] mt-0.5 ${
                                  isStale ? "text-yellow-400" : "text-[#93a4d6]"
                                }`}
                              >
                                {displayDate} {displayTime}
                                {isStale && (
                                  <span
                                    className="ml-0.5"
                                    title={`Data is ${
                                      ageHours > 0 ? `${ageHours}h ` : ""
                                    }${ageMinutes % 60}m old`}
                                  >
                                    ‚ö†Ô∏è
                                  </span>
                                )}
                              </div>
                            );
                          }
                        } catch (e) {}
                      }
                      return null;
                    })()}
                  </div>
                )}
                <div
                  className={`px-1.5 py-0.5 rounded font-bold text-[10px] ${dir.bg} ${dir.color}`}
                >
                  {dir.text}
                </div>
              </div>
            </div>

            {/* Why and Action - Compact */}
            <div className="mb-1">
              <div className="text-[8px] text-[#93a4d6] mb-0.5">
                Why:{" "}
                <span className="text-white font-semibold text-[9px]">
                  {why}
                </span>
              </div>
              {(() => {
                const actionInfo = getActionDescription(ticker);
                return (
                  <div
                    className={`text-[8px] ${actionInfo.color} font-semibold`}
                  >
                    {actionInfo.action}
                  </div>
                );
              })()}
            </div>

            {/* Price, SL, TP - Compact inline */}
            <div className="grid grid-cols-3 gap-1 mb-1 text-[8px]">
              {ticker.price && (
                <div>
                  <div className="text-[8px] text-[#93a4d6]">Price</div>
                  <div className="font-semibold text-white">
                    ${Number(ticker.price).toFixed(2)}
                  </div>
                </div>
              )}
              <div>
                <div className="text-[8px] text-[#93a4d6]">SL</div>
                <div className="font-semibold text-red-400">
                  {ticker.sl ? `$${Number(ticker.sl).toFixed(2)}` : "‚Äî"}
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6]">TP</div>
                <div className="font-semibold text-green-400">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "‚Äî"}
                </div>
              </div>
            </div>

            {/* Trigger Info - Compact */}
            {ticker.trigger_price && (
              <div className="mb-1 text-[8px]">
                <span className="text-[#93a4d6]">Trigger: </span>
                <span className="text-white font-semibold">
                  ${Number(ticker.trigger_price).toFixed(2)}
                </span>
                {ticker.trigger_ts && (
                  <>
                    <span className="text-[#93a4d6] ml-1.5">@ </span>
                    <span className="text-white text-[7px]">
                      {triggerDT.date} {triggerDT.time}
                    </span>
                  </>
                )}
              </div>
            )}

            {/* Phase and Completion - Compact */}
            <div className="grid grid-cols-2 gap-1 mb-1">
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Phase</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full transition-all"
                    style={{
                      width: `${phase * 100}%`,
                      backgroundColor: phaseColor,
                    }}
                  />
                </div>
                <div
                  className="text-[9px] mt-0.5"
                  style={{ color: phaseColor }}
                >
                  {Math.round(phase * 100)}%
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Complete</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full bg-blue-500 transition-all"
                    style={{ width: `${comp * 100}%` }}
                  />
                </div>
                <div className="text-[9px] mt-0.5 text-blue-400">
                  {Math.round(comp * 100)}%
                </div>
              </div>
            </div>

            {/* TP Levels - Compact */}
            {tpLevels.length > 1 && (
              <div className="mb-1">
                <div className="flex flex-wrap gap-0.5">
                  {tpLevels.slice(0, 2).map((tp, idx) => (
                    <span
                      key={idx}
                      className="px-0.5 py-0 rounded bg-green-500/20 text-green-400 text-[7px] font-mono"
                    >
                      TP{idx + 1}: ${Number(tp).toFixed(2)}
                    </span>
                  ))}
                  {tpLevels.length > 2 && (
                    <span className="px-0.5 py-0 rounded bg-[#26325f] text-[#93a4d6] text-[7px]">
                      +{tpLevels.length - 2}
                    </span>
                  )}
                </div>
              </div>
            )}

            {/* Additional Info - Compact */}
            <div className="flex items-center justify-between text-[8px] pt-0.5 border-t border-[#26325f]/50">
              <div className="flex gap-1">
                <span className="px-1 py-0.5 rounded bg-[#26325f]">
                  R{ticker.rank || "‚Äî"}
                </span>
                {ticker.rr && (
                  <span className="px-1 py-0.5 rounded bg-[#26325f]">
                    RR{Number(ticker.rr).toFixed(1)}
                  </span>
                )}
              </div>
              {ent.corridor && (
                <span
                  className={`px-1 py-0.5 rounded text-[8px] font-semibold ${dir.bg} ${dir.color}`}
                >
                  {ent.side}
                </span>
              )}
            </div>
            {decision && (
              <div className="mt-1 text-[8px] text-[#93a4d6]">
                <span
                  className={`px-1 py-0.5 rounded ${decision.bg} ${decision.tone}`}
                  title={
                    decision.blockers && decision.blockers.length > 0
                      ? `Blocked: ${decision.blockers.join(", ")}`
                      : decision.warnings && decision.warnings.length > 0
                        ? `Warnings: ${decision.warnings.join(", ")}`
                        : ""
                  }
                >
                  {decision.status}
                </span>
                <span className="ml-1">{decision.detail}</span>
                {decision.warnings && decision.warnings.length > 0 && (
                  <span className="ml-1 text-yellow-300">
                    ‚Ä¢ {decision.warnings[0]}
                  </span>
                )}
              </div>
            )}
          </div>
        );
      }

      // Generate plain English action description
      function getActionDescription(ticker) {
        const stage = String(ticker?.kanban_stage || "").trim().toLowerCase();
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const momentumPct = ticker.momentum_pct || {};

        const isAligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;

        // Lane-aware guidance: when the Kanban lane is explicit, keep the headline aligned
        // with the lane so the UI doesn't contradict itself. Add phase/completion as caution.
        if (stage === "enter_now" || stage === "just_flipped" || stage === "flip_watch") {
          const late =
            (Number.isFinite(phase) && phase > 0.7) ||
            (Number.isFinite(comp) && comp > 0.8);
          const cautionParts = [];
          if (Number.isFinite(phase) && phase > 0.7)
            cautionParts.push(`Phase ${(phase * 100).toFixed(0)}% (late-cycle)`);
          if (Number.isFinite(comp) && comp > 0.8)
            cautionParts.push(
              `Completion ${(comp * 100).toFixed(0)}% (near target)`,
            );
          const caution =
            cautionParts.length > 0 ? `Caution: ${cautionParts.join(" ‚Ä¢ ")}.` : "";

          if (stage === "flip_watch") {
            return {
              action: late ? "Flip Watch (Late-cycle)" : "Flip Watch",
              description: `Ticker is in the Flip Watch lane: momentum alignment is near and the system is watching for a flip into momentum. Wait for the flip / corridor confirmation before entering. ${caution}`.trim(),
              color: "text-amber-300",
              bg: "bg-amber-500/15",
            };
          }
          if (stage === "just_flipped") {
            return {
              action: late ? "Just Flipped (Late-cycle)" : "Just Flipped",
              description: `Ticker just flipped into momentum (recent corridor entry). Prefer waiting for the first pullback / corridor stabilization, then enter on confirmation. ${caution}`.trim(),
              color: "text-cyan-300",
              bg: "bg-cyan-500/15",
            };
          }
          // enter_now
          return {
            action: late ? "Enter Now (Late-cycle)" : "Enter Now",
            description: `Ticker is in the Enter Now lane: it meets momentum + quality gates for an entry candidate. If you have no open trade, the paper portfolio may enter when conditions persist (cooldowns apply). ${caution}`.trim(),
            color: late ? "text-yellow-300" : "text-green-300",
            bg: late ? "bg-yellow-500/15" : "bg-green-500/15",
          };
        }

        // High completion = near target, consider exit/trim
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(
              0,
            )}% completion, indicating the move is near its target. ${
              momentumElite ? "Despite Momentum Elite status, " : ""
            }Consider taking profits or trimming 50-75% of position to lock in gains while allowing runners to continue. Monitor for signs of reversal or continuation beyond TP levels.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // High phase = late in cycle, be cautious
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(
              0,
            )}% indicates late-cycle conditions. ${
              momentumElite
                ? "While Momentum Elite suggests continued strength, "
                : ""
            }Market is approaching exhaustion zone. Wait for pullback to better entry or trim existing positions by 30-50% to reduce risk. Look for phase reset or continuation signals before adding size.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20",
          };
        }

        // Momentum Elite + Prime setup = strongest signal
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          const momentumStr =
            momentumPct.month != null
              ? ` with ${Number(momentumPct.month).toFixed(
                  0,
                )}% monthly momentum`
              : "";
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock${momentumStr} showing Prime setup with exceptional alignment. Both HTF and LTF are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2,
            )}:1). This represents a high-probability setup with strong fundamentals backing the technical signal. Consider entering with full position size, using TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Momentum Elite + Squeeze release = strong momentum signal
        if (momentumElite && sqRelease && inCorridor && isAligned) {
          const momentumStr =
            momentumPct.week != null
              ? ` (${Number(momentumPct.week).toFixed(0)}% weekly)`
              : "";
          return {
            action: "Initiate Position - Momentum Breakout",
            description: `Momentum Elite stock${momentumStr} experiencing squeeze release with timeframe alignment. This indicates pent-up energy being released in the direction of the trend. The combination of Momentum Elite fundamentals and technical squeeze release creates a high-probability momentum continuation setup. Enter on pullback to corridor or on break of squeeze high/low, targeting TP levels.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Prime setup with good conditions = initiate
        if (isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - Prime Setup",
            description: `Prime setup detected with strong technical alignment. Both timeframes are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2,
            )}:1). ${
              momentumElite
                ? "Momentum Elite status adds fundamental strength to this technical setup. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) with low completion (${(
              comp * 100
            ).toFixed(
              0,
            )}%) suggests room to run. Consider entering position, using SL for risk management and TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Momentum Elite + In corridor = quality momentum play
        if (
          momentumElite &&
          inCorridor &&
          isAligned &&
          comp < 0.5 &&
          phase < 0.6
        ) {
          return {
            action: "Consider Entry - Momentum Elite Setup",
            description: `Momentum Elite stock in favorable technical setup. Price is in entry corridor with both timeframes aligned, early phase (${(
              phase * 100
            ).toFixed(0)}%), and low completion (${(comp * 100).toFixed(
              0,
            )}%) indicating room for continuation. ${
              sqRelease
                ? "Squeeze release adds momentum confirmation. "
                : sqOn
                  ? "Squeeze building suggests potential breakout. "
                  : ""
            }The combination of strong fundamentals (Momentum Elite) and favorable technicals creates a quality setup. Enter on confirmation or pullback, targeting TP levels.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Squeeze release in corridor = strong signal
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. This indicates pent-up energy being released in the direction of the trend. ${
              momentumElite
                ? "Momentum Elite status adds fundamental backing to this technical signal. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(
              comp * 100
            ).toFixed(
              0,
            )}%) suggest continuation potential. Enter on pullback or break, using SL for protection and TP levels as targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // In corridor and aligned = good setup
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase (${(
              phase * 100
            ).toFixed(0)}%) and low completion (${(comp * 100).toFixed(
              0,
            )}%) suggest room to run. ${
              momentumElite
                ? "Momentum Elite status adds quality to this setup. "
                : ""
            }${
              sqOn ? "Squeeze building suggests potential momentum. " : ""
            }Rank is ${
              rank >= 70 ? "strong" : "moderate"
            } (${rank}) with RR of ${rr.toFixed(
              2,
            )}:1. Monitor for entry confirmation or wait for squeeze release signal before initiating position.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Pullback setup = wait for confirmation
        if (isPullback && !inCorridor) {
          return {
            action: "Wait for Entry - Pullback Setup",
            description: `Pullback detected (${state}) but price not yet in entry corridor. ${
              momentumElite
                ? "Momentum Elite status suggests this pullback may be shallow and could present a quality entry. "
                : ""
            }Wait for price to enter corridor (Q1‚ÜíQ2 for LONG, Q4‚ÜíQ3 for SHORT) before considering entry. ${
              sqOn
                ? "Squeeze building suggests potential momentum when released. "
                : ""
            }Monitor for corridor entry and confirmation signals before initiating position.`,
            color: "text-cyan-400",
            bg: "bg-cyan-500/20",
          };
        }

        // Squeeze on but not released = building pressure
        if (sqOn && !sqRelease) {
          return {
            action: "Monitor Closely - Squeeze Building",
            description: `Squeeze building but not yet released, indicating pressure is accumulating. ${
              momentumElite
                ? "Momentum Elite status suggests when released, the move could be significant. "
                : ""
            }${
              inCorridor
                ? "Price is in entry corridor, making this a high-probability setup when squeeze releases. "
                : "Wait for price to enter corridor and squeeze to release before entering. "
            }Monitor closely for squeeze release signal, which typically provides strong directional momentum.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // Default: wait
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. ${
            momentumElite ? "Momentum Elite status is positive, but " : ""
          }Technical conditions need improvement. ${
            !inCorridor ? "Price needs to enter entry corridor. " : ""
          }${!isAligned ? "Timeframes need better alignment. " : ""}${
            comp > 0.5
              ? `Completion is high (${(comp * 100).toFixed(
                  0,
                )}%), reducing upside potential. `
              : ""
          }Wait for better conditions, confirmation signals, or entry corridor alignment before considering position.`,
          color: "text-[#93a4d6]",
          bg: "bg-[#26325f]",
        };
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Activity Feed Component
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function ActivityFeed({ onTickerClick, tickerData }) {
        const [events, setEvents] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [searchQuery, setSearchQuery] = useState("");
        const [activeFilter, setActiveFilter] = React.useState(null);
        const feedRef = React.useRef(null);

        // Helper to get latest ticker data and merge with event
        // IMPORTANT: Always use latest RR from tickerData to match Bubble Chart (which recomputes RR)
        // This ensures Activity Feed RR matches Bubble Chart RR (both use recomputed values from /timed/all)
        const getEventWithTickerData = useCallback(
          (event) => {
            const latestData = tickerData?.[event.ticker] || {};
            // Merge event data with latest ticker data, preferring latest data for RR (matches Bubble Chart computation)
            // Use event data for historical snapshots (price, sl, tp at event time) but latest RR for consistency
            return {
              ...event,
              price: event.price || latestData.price,
              sl: event.sl !== undefined ? event.sl : latestData.sl,
              tp: event.tp !== undefined ? event.tp : latestData.tp,
              tp_levels: event.tp_levels || latestData.tp_levels,
              // Always use latest RR to match Bubble Chart (which uses recomputed RR from /timed/all)
              // This ensures consistency since worker recomputes RR using fused SL levels
              rr: latestData.rr !== undefined ? latestData.rr : event.rr,
              phase_pct:
                event.phase_pct !== undefined
                  ? event.phase_pct
                  : latestData.phase_pct,
              completion:
                event.completion !== undefined
                  ? event.completion
                  : latestData.completion,
              // Include momentum_pct from latest data if available
              momentum_pct: latestData.momentum_pct || event.momentum_pct,
            };
          },
          [tickerData],
        );

        const fetchActivity = React.useCallback(async (isRetry = false) => {
          try {
            setLoading(true);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // Increased timeout to 10s

            // Add timestamp to URL to prevent caching on hard refresh
            const timestamp = Date.now();
            const res = await fetch(
              `https://timed-trading-ingest.shashant.workers.dev/timed/activity?limit=50&_t=${timestamp}`,
              {
                signal: controller.signal,
                cache: "no-store", // Prevent caching issues on hard refresh
                headers: {
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `activity-${timestamp}`, // Additional cache busting header
                },
              },
            );
            clearTimeout(timeoutId);

            if (!res.ok) {
              throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }

            const data = await res.json();

            if (data.ok && Array.isArray(data.events)) {
              setEvents(data.events);
              setError(null); // Clear any previous errors
            } else {
              // Log error for debugging
              console.warn("Activity feed response:", {
                status: res.status,
                ok: res.ok,
                dataOk: data.ok,
                error: data.error,
                eventsCount: data.events?.length || 0,
              });

              // Handle rate limit error
              if (res.status === 429) {
                setError(
                  "Rate limit exceeded. Please wait a moment and refresh.",
                );
              } else if (data.error) {
                setError(data.error);
              } else {
                setError(null);
              }

              // Still set events if it's an empty array (no error, just no data)
              if (Array.isArray(data.events)) {
                setEvents(data.events);
              }
            }
          } catch (err) {
            if (err.name !== "AbortError") {
              console.error("Activity feed fetch error:", err);
              setError("Failed to load activity feed");
              // Retry after a short delay on first load failure (only once)
              if (!isRetry) {
                setTimeout(() => {
                  fetchActivity(true);
                }, 2000);
              }
            }
          } finally {
            setLoading(false);
          }
        }, []);

        // Initial fetch and periodic refresh - ensure it runs on mount
        React.useEffect(() => {
          // Use a small delay to ensure component is fully mounted
          const initialTimeout = setTimeout(() => {
            fetchActivity();
          }, 100);

          const interval = setInterval(fetchActivity, 5 * 60 * 1000); // Refresh every 5 minutes to align with data updates

          return () => {
            clearTimeout(initialTimeout);
            clearInterval(interval);
          };
        }, [fetchActivity]);

        // Auto-scroll to top when new events arrive
        React.useEffect(() => {
          if (feedRef.current && events.length > 0) {
            feedRef.current.scrollTop = 0;
          }
        }, [events.length]);

        const formatTime = (ts) => {
          const date = new Date(ts);
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / 60000);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);

          if (diffMins < 1) return "just now";
          if (diffMins < 60) return `${diffMins}m ago`;
          if (diffHours < 24) return `${diffHours}h ago`;
          if (diffDays < 7) return `${diffDays}d ago`;
          return date.toLocaleDateString();
        };

        const getEventIcon = (type) => {
          switch (type) {
            case "corridor_entry":
              return "üö™";
            case "squeeze_start":
              return "‚ö°";
            case "squeeze_release":
              return "üí•";
            case "state_aligned":
              return "üéØ";
            case "momentum_elite":
              return "üöÄ";
            case "td9_exit":
              return "üî¢";
            case "td9_entry":
              return "üî¢";
            case "discord_alert":
              return "üì¢";
            case "trade_entry":
              return "‚úÖ";
            case "ingest_missing":
              return "‚è±Ô∏è";
            default:
              return "üìä";
          }
        };

        const getEventColor = (type) => {
          switch (type) {
            case "corridor_entry":
              return "text-blue-400";
            case "squeeze_start":
              return "text-yellow-400";
            case "squeeze_release":
              return "text-green-400";
            case "state_aligned":
              return "text-purple-400";
            case "momentum_elite":
              return "text-pink-400";
            case "td9_exit":
              return "text-orange-400";
            case "td9_entry":
              return "text-cyan-400";
            case "discord_alert":
              return "text-indigo-400";
            case "trade_entry":
              return "text-green-400";
            case "ingest_missing":
              return "text-red-400";
            default:
              return "text-gray-400";
          }
        };

        const getEventLabel = (event) => {
          switch (event.type) {
            case "corridor_entry":
              return `${event.ticker} entered ${event.side || "corridor"}`;
            case "squeeze_start":
              return `${event.ticker} squeeze started`;
            case "squeeze_release":
              return `${event.ticker} squeeze released${
                event.side ? ` (${event.side})` : ""
              }`;
            case "state_aligned":
              return `${event.ticker} aligned ${event.side || ""}`;
            case "momentum_elite":
              return `${event.ticker} Momentum Elite`;
            case "td9_exit":
              return `${event.ticker} TD9 Exit ${event.direction || ""}`;
            case "td9_entry":
              return `${event.ticker} TD9 Entry ${event.direction || ""}`;
            case "discord_alert":
              return `üì¢ Alert Fired: ${event.ticker} ${
                event.direction || event.action || ""
              } ${event.action === "entry" ? "Entry" : ""}`;
            case "trade_entry":
              return `‚úÖ Trade Entered: ${event.ticker} ${
                event.direction || ""
              }`;
            case "ingest_missing":
              return `‚è±Ô∏è Missing ingest: ${event.ticker} ${
                event.age_min != null ? `(${event.age_min}m)` : ""
              }`;
            default:
              return `${event.ticker} event`;
          }
        };

        // Filter events by search query and active filter
        const filteredEvents = useMemo(() => {
          let filtered = events;

          // Apply type filter
          if (activeFilter) {
            filtered = filtered.filter((event) => event.type === activeFilter);
          }

          // Apply search query
          if (searchQuery.trim()) {
            const query = searchQuery.toLowerCase();
            filtered = filtered.filter((event) => {
              const ticker = (event.ticker || "").toLowerCase();
              const type = (event.type || "").toLowerCase();
              const direction = (event.direction || "").toLowerCase();
              const side = (event.side || "").toLowerCase();
              return (
                ticker.includes(query) ||
                type.includes(query) ||
                direction.includes(query) ||
                side.includes(query)
              );
            });
          }

          return filtered;
        }, [events, searchQuery, activeFilter]);

        return (
          <div className="w-80 bg-[#0f1630] border border-[#26325f] rounded-xl p-4 flex flex-col">
            <div className="flex items-center justify-between mb-3 pb-2 border-b border-[#26325f]">
              <h3 className="text-lg font-semibold text-white">
                Activity Feed
              </h3>
              <button
                onClick={fetchActivity}
                className="text-xs text-[#93a4d6] hover:text-white transition-colors"
                title="Refresh"
              >
                ‚Üª
              </button>
            </div>

            {/* Search Bar and Filter Tags */}
            <div className="mb-3 space-y-2">
              <input
                type="text"
                placeholder="Search events..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full px-3 py-1.5 text-xs bg-[#121a33] border border-[#26325f] rounded text-white placeholder-[#6b7a9f] focus:outline-none focus:border-[#3a4a7a]"
              />
              {/* Filter Tags */}
              <div className="flex flex-wrap gap-1.5">
                {[
                  { label: "All", type: null },
                  { label: "Trade Entered", type: "trade_entry" },
                  { label: "Alerts", type: "discord_alert" },
                  { label: "Squeeze", type: "squeeze_release" },
                  { label: "Ingest Missing", type: "ingest_missing" },
                ].map((filter) => (
                  <button
                    key={filter.label}
                    onClick={() =>
                      setActiveFilter(
                        activeFilter === filter.type ? null : filter.type,
                      )
                    }
                    className={`px-2 py-0.5 text-[10px] rounded border transition-colors ${
                      activeFilter === filter.type
                        ? "bg-blue-500/20 border-blue-500 text-blue-400"
                        : "bg-[#121a33] border-[#26325f] text-[#93a4d6] hover:border-[#3a4a7a]"
                    }`}
                  >
                    {filter.label}
                  </button>
                ))}
              </div>
            </div>

            <div
              ref={feedRef}
              className="flex-1 overflow-y-auto space-y-2 pr-2"
              style={{ maxHeight: "760px" }}
            >
              {loading && events.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  <div className="loading-spinner mx-auto mb-2"></div>
                  Loading events...
                </div>
              ) : error ? (
                <div className="text-center text-yellow-400 py-8 px-2">
                  <div className="text-sm mb-2">{error}</div>
                  <button
                    onClick={fetchActivity}
                    className="text-xs text-[#93a4d6] hover:text-white underline"
                  >
                    Retry
                  </button>
                </div>
              ) : filteredEvents.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  {searchQuery.trim()
                    ? "No events match your search"
                    : "No recent activity"}
                </div>
              ) : (
                filteredEvents.map((event) => {
                  const eventData = getEventWithTickerData(event);
                  // Calculate Max TP from tp_levels array
                  let maxTP = eventData.tp;
                  if (
                    eventData.tp_levels &&
                    Array.isArray(eventData.tp_levels) &&
                    eventData.tp_levels.length > 0
                  ) {
                    const tpPrices = eventData.tp_levels
                      .map((tpItem) => {
                        if (
                          typeof tpItem === "object" &&
                          tpItem !== null &&
                          tpItem.price != null
                        ) {
                          return Number(tpItem.price);
                        }
                        return typeof tpItem === "number"
                          ? tpItem
                          : Number(tpItem);
                      })
                      .filter((p) => Number.isFinite(p));
                    if (tpPrices.length > 0) {
                      maxTP = Math.max(...tpPrices);
                    }
                  }

                  return (
                    <div
                      key={event.id || `${event.ticker}-${event.ts}`}
                      onClick={() =>
                        onTickerClick && onTickerClick(event.ticker)
                      }
                      className="bg-[#121a33] border border-[#26325f] rounded p-2 text-xs hover:border-[#3a4a7a] hover:bg-[#1a2440] transition-colors cursor-pointer"
                    >
                      <div className="flex items-start justify-between gap-2 mb-1.5">
                        <div className="flex items-center gap-1.5 flex-1 min-w-0">
                          <span className="text-base">
                            {getEventIcon(event.type)}
                          </span>
                          <div className="flex-1 min-w-0">
                            <span
                              className={`font-semibold ${getEventColor(
                                event.type,
                              )} truncate block`}
                            >
                              {getEventLabel(event)}
                            </span>
                            {eventData.price && (
                              <div className="text-[10px] text-white mt-0.5">
                                ${Number(eventData.price).toFixed(2)}
                                {(() => {
                                  // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                                  const ingestTime =
                                    eventData.ingest_ts ||
                                    eventData.ingest_time ||
                                    eventData.ts ||
                                    event.ts;
                                  if (ingestTime) {
                                    try {
                                      const timeValue =
                                        typeof ingestTime === "string"
                                          ? new Date(ingestTime)
                                          : new Date(Number(ingestTime));
                                      if (!isNaN(timeValue.getTime())) {
                                        const ageMs =
                                          Date.now() - timeValue.getTime();
                                        const ageMinutes = Math.floor(
                                          ageMs / 60000,
                                        );
                                        const ageHours = Math.floor(
                                          ageMinutes / 60,
                                        );

                                        // Warn if data is stale (older than 30 minutes)
                                        const isStale = ageMinutes > 30;

                                        const displayTime =
                                          timeValue.toLocaleTimeString(
                                            "en-US",
                                            {
                                              hour: "numeric",
                                              minute: "2-digit",
                                              hour12: true,
                                            },
                                          );
                                        const displayDate =
                                          timeValue.toLocaleDateString(
                                            "en-US",
                                            {
                                              month: "short",
                                              day: "numeric",
                                            },
                                          );
                                        return (
                                          <span
                                            className={`ml-1.5 ${
                                              isStale
                                                ? "text-yellow-400"
                                                : "text-[#93a4d6]"
                                            }`}
                                          >
                                            {displayDate} {displayTime}
                                            {isStale && (
                                              <span
                                                className="ml-0.5"
                                                title={`Data is ${
                                                  ageHours > 0
                                                    ? `${ageHours}h `
                                                    : ""
                                                }${ageMinutes % 60}m old`}
                                              >
                                                ‚ö†Ô∏è
                                              </span>
                                            )}
                                          </span>
                                        );
                                      }
                                    } catch (e) {}
                                  }
                                  return null;
                                })()}
                              </div>
                            )}
                          </div>
                        </div>
                        <span className="text-[#6b7a9f] text-[10px] whitespace-nowrap">
                          {formatTime(event.ts)}
                        </span>
                      </div>

                      {/* Standardized Fields - Always Show */}
                      <div className="space-y-1.5 border-t border-[#26325f]/50 pt-1.5 mt-1.5">
                        {/* SL Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            SL:
                          </span>
                          <span className="text-red-400 font-mono text-[10px]">
                            {eventData.sl != null
                              ? `$${Number(eventData.sl).toFixed(2)}`
                              : "‚Äî"}
                          </span>
                        </div>

                        {/* Max TP Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            Max TP:
                          </span>
                          <span className="text-green-400 font-mono text-[10px]">
                            {maxTP != null
                              ? `$${Number(maxTP).toFixed(2)}`
                              : "‚Äî"}
                          </span>
                        </div>

                        {/* RR Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            RR:
                          </span>
                          <span className="text-blue-400 font-mono text-[10px]">
                            {eventData.rr != null
                              ? Number(eventData.rr).toFixed(2)
                              : "‚Äî"}
                          </span>
                        </div>

                        {/* Phase Complete Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            Phase:
                          </span>
                          <div className="flex items-center gap-1.5">
                            <div className="w-16 h-1 bg-[#26325f] rounded-full overflow-hidden">
                              <div
                                className="h-full rounded-full transition-all"
                                style={{
                                  width: `${
                                    (Number(eventData.phase_pct) || 0) * 100
                                  }%`,
                                  backgroundColor: (() => {
                                    const phase =
                                      Number(eventData.phase_pct) || 0;
                                    if (phase < 0.3) return "#2ecc71";
                                    if (phase < 0.6) return "#f39c12";
                                    return "#e74c3c";
                                  })(),
                                }}
                              />
                            </div>
                            <span className="text-white font-mono text-[10px] min-w-[2.5rem]">
                              {eventData.phase_pct != null
                                ? `${Math.round(
                                    Number(eventData.phase_pct) * 100,
                                  )}%`
                                : "‚Äî"}
                            </span>
                          </div>
                        </div>
                      </div>

                      {/* Additional Info - Compact */}
                      {(event.rank || event.state || event.trigger_dir) && (
                        <div className="flex items-center gap-2 text-[#6b7a9f] text-[10px] mt-1.5 pt-1.5 border-t border-[#26325f]/30">
                          {event.rank && <span>Rank {event.rank}</span>}
                          {event.state && (
                            <span className="truncate" title={event.state}>
                              {event.state.split("_").pop()}
                            </span>
                          )}
                          {event.trigger_dir && (
                            <span>Dir: {event.trigger_dir}</span>
                          )}
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      // Welcome Modal Component - Dashboard Guide (Trading Concepts)
      function DashboardWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const allSteps = [
          {
            title: "Start with the Action Center",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Keep it simple: open <strong>Action Center</strong> and follow
                  the lanes <strong>left ‚Üí right</strong>. The lane is the
                  instruction for what to do <strong>right now</strong>.
                </p>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    The only workflow
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Find a ticker in <strong className="text-white">Enter Now</strong>{" "}
                      (or <strong className="text-white">Flip Watch</strong>)
                    </li>
                    <li>Click it to open the <strong className="text-white">Right Rail</strong></li>
                    <li>
                      Execute with the displayed <strong className="text-white">SL / TP</strong>
                    </li>
                    <li>
                      Manage as it moves through lanes:{" "}
                      <strong className="text-white">
                        Hold ‚Üí Defend ‚Üí Trim ‚Üí Exit
                      </strong>
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Tip:</strong> If you‚Äôre
                    unsure, don‚Äôt interpret‚Äîjust follow the lane.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Lane meanings (quick cheat sheet)",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  Don‚Äôt overthink it. Each lane is a single instruction:
                </p>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">Watch</strong>: not ready yet
                      (track it)
                    </div>
                    <div>
                      <strong className="text-white">Flip Watch</strong>: setup is
                      trying to turn into momentum (get ready)
                    </div>
                    <div>
                      <strong className="text-white">Just Flipped</strong>: momentum
                      just started (monitor closely)
                    </div>
                    <div>
                      <strong className="text-white">Enter Now</strong>: valid entry
                      window (execute SL/TP)
                    </div>
                    <div>
                      <strong className="text-white">Hold</strong>: trade working
                      (do nothing)
                    </div>
                    <div>
                      <strong className="text-white">Defend</strong>: protect the
                      position (tighten risk / reduce)
                    </div>
                    <div>
                      <strong className="text-white">Trim</strong>: take partials
                      (lock gains)
                    </div>
                    <div>
                      <strong className="text-white">Exit</strong>: get out (risk
                      is rising)
                    </div>
                    <div>
                      <strong className="text-white">Archive</strong>: completed or
                      invalidated (done)
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Right Rail (10-second checklist)",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Click any ticker card to open the <strong>Right Rail</strong>.
                  Then do this:
                </p>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-2">
                    <li>
                      Read the <strong className="text-white">Lane</strong> (that‚Äôs the instruction).
                    </li>
                    <li>
                      Confirm <strong className="text-white">Bias</strong> (LONG/SHORT).
                    </li>
                    <li>
                      Use the displayed <strong className="text-white">Entry / SL / TP</strong>.
                    </li>
                    <li>
                      If lane is <strong className="text-white">Enter Now</strong>: execute.
                      If lane is <strong className="text-white">Hold/Defend/Trim/Exit</strong>: manage only.
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Rule:</strong> Don‚Äôt add steps.
                    Follow the lane and repeat.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Viewport + Filter Tags üß≠",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The dashboard is built for <strong>fast scanning</strong>. The{" "}
                  <strong className="text-white">Viewport</strong> (left) and{" "}
                  <strong className="text-white">Bubble Chart</strong> (center)
                  are always kept in sync by the filter tags.
                </p>

                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    üéõÔ∏è Filter Tags (controls Viewport + Bubble Chart)
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Guidance</strong>: Initiate
                      / Consider / Monitor / Wait / Exit
                    </li>
                    <li>
                      <strong className="text-white">Horizon</strong>:
                      Short-Term / Swing / Positional
                    </li>
                    <li>
                      <strong className="text-white">Opportunities</strong>:
                      Eligible / Prime / Watch + Q1‚ÄìQ4
                    </li>
                    <li>
                      <strong className="text-white">Specials</strong>: In
                      Squeeze üß® / Squeeze Release ‚ö° / Momentum Elite üöÄ /
                      Winner Signature üèÜ
                    </li>
                    <li>
                      <strong className="text-white">Groups</strong>: Upticks /
                      Super Granny / GRN* / Social / No Group
                    </li>
                    <li>
                      <strong className="text-white">S&amp;P Sectors</strong>:
                      filter by sector (with rating)
                    </li>
                  </ul>
                </div>

                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    üî≠ Viewport (left panel)
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      Shows the most actionable tickers first (Prime / Eligible
                      / Watch).
                    </li>
                    <li>
                      <strong className="text-white">
                        Scrolls inside the panel
                      </strong>{" "}
                      and stays the same height as the Bubble Chart.
                    </li>
                    <li>
                      Click any row to open the{" "}
                      <strong className="text-white">Right Rail detail</strong>.
                    </li>
                  </ul>
                </div>

                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2">
                    üèÜ Winner Signature
                  </h3>
                  <p className="text-sm text-[#93a4d6]">
                    Winner Signature highlights{" "}
                    <strong className="text-white">early-run</strong> candidates
                    that match the current ‚Äúwinner-like‚Äù pattern (setup +
                    corridor + low completion, plus early phase or squeeze
                    build). Use it to narrow the universe, then confirm
                    direction in Q1/Q4 and check SL/TP in the Right Rail.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Prime Setups ‚≠ê",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  <strong className="text-yellow-400">Prime Setups</strong> are
                  the highest-quality opportunities. They have a ‚≠ê icon and
                  appear with a green glow.
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    Prime Setup Criteria:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Rank ‚â• 75</strong> - High
                      overall quality score
                    </li>
                    <li>
                      <strong className="text-white">Risk/Reward ‚â• 1.5</strong>{" "}
                      - Good profit potential vs risk
                    </li>
                    <li>
                      <strong className="text-white">Completion ‚â§ 40%</strong> -
                      Still early in the move
                    </li>
                    <li>
                      <strong className="text-white">In Corridor</strong> -
                      Valid entry zone
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    üí° How to Find Prime Setups:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"Prime Only"</strong>{" "}
                      filter button
                    </li>
                    <li>Look for bubbles with ‚≠ê icons and green borders</li>
                    <li>Click on a bubble to see detailed entry/exit levels</li>
                    <li>Check the Risk/Reward ratio - higher is better!</li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Tip:</strong> Prime
                    setups are rare but offer the best risk/reward. Focus on Q1
                    (Long Setup) and Q4 (Short Setup) quadrants for the best
                    entries.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "In Corridor üéØ",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The <strong className="text-cyan-400">Corridor</strong> is a
                  specific zone where entries are considered valid and safe.
                </p>
                <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                  <h3 className="text-cyan-400 font-semibold mb-2">
                    What is a Corridor?
                  </h3>
                  <p className="text-sm text-[#93a4d6] mb-3">
                    A corridor is a narrow band on the chart where price action
                    is optimal for entry. Think of it as a "sweet spot" where
                    the setup is most likely to succeed.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Long Corridor üìà
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        HTF Score &gt; 0<br />
                        LTF Score: -8 to +12
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Short Corridor üìâ
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        HTF Score &lt; 0<br />
                        LTF Score: -12 to +8
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    üéØ How to Use Corridor Filter:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"In Corridor"</strong>{" "}
                      filter button
                    </li>
                    <li>This shows only tickers in valid entry zones</li>
                    <li>These are the safest setups to trade</li>
                    <li>
                      Combine with "Prime Only" for the best opportunities
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">
                      Why Corridors Matter:
                    </strong>{" "}
                    Tickers outside corridors may be too early, too late, or in
                    unfavorable conditions. Corridor entries have the highest
                    probability of success.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "TD Sequential (TD9) üî¢",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  <strong className="text-purple-400">TD Sequential</strong> is
                  a powerful indicator that identifies potential reversal
                  points.
                </p>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    What is TD9?
                  </h3>
                  <p className="text-sm text-[#93a4d6] mb-3">
                    TD Sequential counts consecutive bars in one direction. When
                    it reaches <strong className="text-white">9</strong>, it
                    signals potential exhaustion and reversal.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        TD9 Bullish üìà
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        Signals potential <strong>bottom</strong> and upward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for LONG entries
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        TD9 Bearish üìâ
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        Signals potential <strong>top</strong> and downward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for SHORT entries or exit
                        LONGs
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    üî¢ How to Use TD9 Filter:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"TD9 Setup"</strong> filter
                      button
                    </li>
                    <li>This shows only tickers with active TD9 signals</li>
                    <li>
                      TD9 signals are strongest when combined with other
                      factors:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>
                          In the correct quadrant (Q1 for bullish, Q4 for
                          bearish)
                        </li>
                        <li>In corridor</li>
                        <li>With good Risk/Reward</li>
                      </ul>
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Pro Tip:</strong> TD9
                    signals are most powerful at extremes. If you see a TD9
                    signal in Q1 (Long Setup) or Q4 (Short Setup), it's a strong
                    confirmation of a reversal setup.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Squeeze Indicators üß®‚ö°",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The <strong className="text-yellow-400">Squeeze</strong>{" "}
                  indicator shows when volatility is building up, like a spring
                  being compressed before release.
                </p>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    Find these under{" "}
                    <strong className="text-white">Specials</strong> in the
                    filter tags. On the chart, you‚Äôll also see icons on bubbles:
                    <span className="text-white">
                      {" "}
                      üß® (In Squeeze)
                    </span> and{" "}
                    <span className="text-white">‚ö° (Squeeze Release)</span>.
                  </p>
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                    <h3 className="text-yellow-400 font-semibold mb-2 flex items-center gap-2">
                      üß® In Squeeze
                    </h3>
                    <p className="text-sm text-[#93a4d6] mb-3">
                      Volatility is{" "}
                      <strong className="text-white">compressed</strong> - price
                      is consolidating.
                    </p>
                    <div className="text-xs text-[#93a4d6] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        Energy is building up
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Watch
                        closely - a big move is coming
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Wait for squeeze release
                      </div>
                    </div>
                  </div>
                  <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                    <h3 className="text-cyan-400 font-semibold mb-2 flex items-center gap-2">
                      ‚ö° Squeeze Release
                    </h3>
                    <p className="text-sm text-[#93a4d6] mb-3">
                      Volatility has{" "}
                      <strong className="text-white">exploded</strong> - price
                      is breaking out.
                    </p>
                    <div className="text-xs text-[#93a4d6] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        The spring has released!
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Strong
                        momentum signal
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Enter on pullback or breakout
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    üéØ How to Use Squeeze Filters:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">
                        "In Squeeze" Filter:
                      </strong>{" "}
                      Shows tickers where volatility is building. These are good
                      to watch but wait for release before entering.
                    </div>
                    <div>
                      <strong className="text-white">
                        "Squeeze Release" Filter:
                      </strong>{" "}
                      Shows tickers where the squeeze has fired. These often
                      have strong momentum - combine with Prime filter for best
                      results.
                    </div>
                    <div>
                      <strong className="text-white">
                        "Winner Signature" Filter:
                      </strong>{" "}
                      A focused list of early-run candidates (often setup +
                      corridor + low completion). Use it as your ‚Äúshortlist‚Äù,
                      then confirm direction and risk.
                    </div>
                  </div>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    üí° Best Practices:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">
                        Squeeze Release + Prime Setup
                      </strong>{" "}
                      = Very strong signal
                    </li>
                    <li>
                      <strong className="text-white">
                        Squeeze Release + In Corridor
                      </strong>{" "}
                      = High probability entry
                    </li>
                    <li>
                      <strong className="text-white">In Squeeze</strong> =
                      Prepare but don't enter yet
                    </li>
                    <li>
                      Look for squeeze release in the direction of the HTF trend
                    </li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together üéì",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Now that you understand the concepts, here's a{" "}
                  <strong className="text-yellow-400">
                    step-by-step workflow
                  </strong>{" "}
                  to find great setups:
                </p>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <h3 className="text-[#e7ecff] font-semibold mb-2">
                    üß† Quick mental model
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Position</strong> = scores
                      (HTF trend + LTF timing).
                    </li>
                    <li>
                      <strong className="text-white">Size</strong> = RR adjusted
                      by completion (earlier = bigger).
                    </li>
                    <li>
                      <strong className="text-white">Color</strong> = phase
                      (green ‚Üí yellow ‚Üí red).
                    </li>
                    <li>
                      <strong className="text-white">Badges/icons</strong> =
                      Prime ‚≠ê, Squeeze üß®/‚ö°, Winner Signature üèÜ.
                    </li>
                  </ul>
                  <p className="text-xs text-[#93a4d6] mt-2">
                    The chart auto-zooms to your current filtered universe and
                    applies light spacing so overlaps separate while staying
                    near true score.
                  </p>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    üìã Your Trading Workflow:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Step 1: Choose Your Direction
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ For LONG trades: Focus on Q1 (Long Setup) quadrant
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ For SHORT trades: Focus on Q4 (Short Setup) quadrant
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 2: Apply Quality Filters
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Click "Prime Only" to see only high-quality setups
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Click "In Corridor" to ensure valid entry zones
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 3: Look for Confirmation Signals
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ TD9 Setup: Strong reversal signal
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Squeeze Release ‚ö°: Strong momentum
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Momentum Elite üöÄ: Best fundamentals
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Winner Signature üèÜ: Winner-like early-run shortlist
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 4: Analyze the Setup
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Click on a bubble to see details
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Check Risk/Reward ratio (aim for ‚â• 1.5)
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Verify entry price, stop loss, and take profit levels
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Use the Viewport + Right Rail to compare multiple
                        candidates quickly
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Bonus: Use Time Travel
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Toggle Time Travel to replay the Bubble Chart over
                        time
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Use the Time step selector (5m ‚Üí 1W) to zoom from
                        intraday to multi-day structure
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 5: Execute Your Trade
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Enter at the suggested entry price
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Set stop loss at the SL level
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Target the TP levels (consider trimming at first TP)
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ‚≠ê The Perfect Setup Checklist:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-1">
                    <div>
                      ‚úÖ In the correct quadrant (Q1 for LONG, Q4 for SHORT)
                    </div>
                    <div>‚úÖ Prime Setup (‚≠ê icon)</div>
                    <div>‚úÖ In Corridor</div>
                    <div>‚úÖ Risk/Reward ‚â• 1.5</div>
                    <div>‚úÖ Completion ‚â§ 40% (still early)</div>
                    <div>
                      ‚úÖ TD9 signal OR Squeeze Release (bonus confirmation)
                    </div>
                    <div>
                      ‚úÖ Winner Signature üèÜ (optional shortlist accelerator)
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Remember:</strong> Not
                    every setup will have all these factors. Use your judgment
                    and risk management. Start with paper trading if you're new!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        // Keep onboarding simple: show only the first 3 lane-first steps.
        const steps = allSteps.slice(0, 3);

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[#0b1020] border-2 border-[#26325f] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              {/* Header */}
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[#26325f] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[#26325f]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[#93a4d6] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[#26325f] transition-colors"
                  title="Close Welcome Guide"
                >
                  √ó
                </button>
              </div>

              {/* Content */}
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>

              {/* Footer */}
              <div className="border-t border-[#26325f] p-4 flex items-center justify-between bg-[#0f1630]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[#26325f] text-[#93a4d6] opacity-50 cursor-not-allowed"
                      : "border-[#26325f] bg-[#1a2550] hover:bg-[#26325f] text-white"
                  }`}
                >
                  ‚Üê Previous
                </button>
                <div className="text-sm text-[#93a4d6]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next ‚Üí
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Trading! üöÄ
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Welcome Modal Component - Trade Tracker Guide (Simulated Trades)
      function TrackerWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const allSteps = [
          {
            title: "Trade Tracker = feedback loop",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Use Trade Tracker to learn which <strong>lanes</strong> and
                  <strong> setups</strong> actually work, then compound the
                  process.
                </p>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    Keep it simple:
                    <br />
                    ‚Ä¢ Manage open trades in <strong className="text-white">Portfolio</strong>
                    <br />
                    ‚Ä¢ Review lane decisions in <strong className="text-white">By Day Activity</strong>
                    <br />
                    ‚Ä¢ Click any row to open the <strong className="text-white">Right Rail</strong>
                    (it shows what lane you were in and why)
                  </p>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    The compounding loop
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>Find your best lane + trigger combinations</li>
                    <li>Repeat them (raise size slowly as confidence grows)</li>
                    <li>Kill what doesn‚Äôt work (stop feeding losing patterns)</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Tip:</strong> When you
                    see a good trade, click into the Right Rail and note the
                    lane + trigger combo‚Äîthen look for that same pattern in the
                    Action Center next time.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Lane-first review (Right Rail)",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Trade Tracker helps you <strong>audit lane decisions</strong>{" "}
                  so we repeat winners and stop feeding losers.
                </p>

                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <h3 className="text-white font-semibold mb-2">
                    What to do daily
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-2">
                    <li>
                      Check <strong className="text-white">Portfolio</strong>{" "}
                      for open trades (P&L + risk).
                    </li>
                    <li>
                      Open <strong className="text-white">By Day Activity</strong>{" "}
                      to replay lane changes + entries/exits.
                    </li>
                    <li>
                      Click any row to open the{" "}
                      <strong className="text-white">Right Rail</strong> ‚Äî it
                      shows the lane + why (trigger/decision).
                    </li>
                  </ol>
                </div>

                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    The only question
                  </h3>
                  <p className="text-sm text-[#93a4d6]">
                    ‚ÄúIf I followed the lane + decision exactly, did it pay?‚Äù If
                    not: which lane/trigger combo should be demoted or blocked?
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Trim & exit discipline (no AGQ disasters)",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  We win by being ruthless on{" "}
                  <strong>risk management</strong>: trim winners, exit losers
                  early, and don‚Äôt ‚Äúhope‚Äù in HOLD.
                </p>

                <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                  <h3 className="text-red-400 font-semibold mb-2">
                    What to flag immediately
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-2">
                    <li>
                      ‚ÄúEnter Now‚Äù when entry decision is not green-lit (should
                      never happen)
                    </li>
                    <li>Big adverse move after entry (exit/defend faster)</li>
                    <li>Lane backtracking (enter ‚Üí just flipped ‚Üí hold)</li>
                  </ul>
                </div>

                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    What to record (so we compound)
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">Lane</strong> +{" "}
                      <strong className="text-white">trigger</strong> at entry
                    </div>
                    <div>
                      <strong className="text-white">Exit reason</strong>{" "}
                      (trim/defend/stop/target)
                    </div>
                    <div>
                      <strong className="text-white">Outcome</strong> (did the
                      lane rule work?)
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "How P&L is Calculated üí∞",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  Understanding how profit and loss is calculated helps you
                  interpret the results:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    üìà For Stocks:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">Position Size:</strong>{" "}
                      $1,000 per trade
                    </div>
                    <div>
                      <strong className="text-white">Shares:</strong> $1,000 √∑
                      Entry Price
                    </div>
                    <div>
                      <strong className="text-white">P&L (LONG):</strong>{" "}
                      (Current Price - Entry Price) √ó Shares
                    </div>
                    <div>
                      <strong className="text-white">P&L (SHORT):</strong>{" "}
                      (Entry Price - Current Price) √ó Shares
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    üìä For Futures:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">Contracts:</strong> Usually
                      1 contract per trade
                    </div>
                    <div>
                      <strong className="text-white">Point Value:</strong> Each
                      futures contract has a point value:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>NQ1! (Nasdaq): $20 per point</li>
                        <li>ES1! (S&P 500): $50 per point</li>
                        <li>Other futures vary</li>
                      </ul>
                    </div>
                    <div>
                      <strong className="text-white">P&L:</strong> (Price
                      Change) √ó Contracts √ó Point Value
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2">
                    üéØ Example:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-1">
                    <div>
                      <strong className="text-white">Stock Trade:</strong> AAPL
                      at $150 entry, $155 current
                    </div>
                    <div className="ml-4">
                      Shares: $1,000 √∑ $150 = 6.67 shares
                    </div>
                    <div className="ml-4">
                      P&L: ($155 - $150) √ó 6.67 ={" "}
                      <span className="text-green-400">+$33.35</span>
                    </div>
                    <div className="mt-2">
                      <strong className="text-white">Futures Trade:</strong>{" "}
                      NQ1! at 15,000 entry, 15,100 current
                    </div>
                    <div className="ml-4">
                      Price Change: 15,100 - 15,000 = 100 points
                    </div>
                    <div className="ml-4">
                      P&L: 100 √ó 1 √ó $20 ={" "}
                      <span className="text-green-400">+$2,000</span>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Tracking & Analytics üìä",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The Trade Tracker provides powerful analytics to help you
                  learn:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    üìà Performance Metrics:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Win Rate:</strong>{" "}
                      Percentage of winning trades
                    </li>
                    <li>
                      <strong className="text-white">Total P&L:</strong> Sum of
                      all profits and losses
                    </li>
                    <li>
                      <strong className="text-white">Average Win/Loss:</strong>{" "}
                      Average profit per win vs loss
                    </li>
                    <li>
                      <strong className="text-white">Best/Worst Trade:</strong>{" "}
                      Your biggest winners and losers
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    üîç Filter by Version:
                  </h3>
                  <p className="text-sm text-[#93a4d6] mb-2">
                    Use the "Model Version" dropdown to compare performance
                    across different versions of the trading model. This helps
                    you see which improvements work best.
                  </p>
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-white">Tip:</strong> Newer versions
                    often include improvements, but older versions may have
                    proven track records.
                  </p>
                </div>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    üìä Daily Summary:
                  </h3>
                  <p className="text-sm text-[#93a4d6]">
                    Click "View Daily Summary" to see performance breakdowns by:
                  </p>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1 mt-2">
                    <li>Rank ranges (which ranked setups perform best)</li>
                    <li>Risk/Reward ratios (which RR ratios win more)</li>
                    <li>Quadrants (which chart zones are most profitable)</li>
                    <li>Overall statistics and insights</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Remember:</strong> The
                    goal is to learn which setups work best. Review your wins
                    and losses regularly to improve your trading strategy!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together üéì",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Here's your{" "}
                  <strong className="text-yellow-400">workflow</strong> for
                  using the Trade Tracker:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    üìã Daily Workflow:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Monitor Open Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Check the "Open Trades" section regularly
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Watch P&L update in real-time
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Click trades to see detailed information
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Review Closed Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Check "Closed Trades" to see final results
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Review trade history to understand what happened
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Learn from both wins and losses
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Analyze Performance
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Use the version filter to compare models
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Check daily summary for insights
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Look for patterns in winning vs losing trades
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Improve Your Strategy
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Focus on setups with high win rates
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Avoid setups that consistently lose
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        ‚Ä¢ Adjust filters on the main dashboard based on results
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ‚≠ê Key Takeaways:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-1">
                    <div>‚úÖ Trades are created automatically from alerts</div>
                    <div>‚úÖ Each trade uses $1,000 position size</div>
                    <div>‚úÖ P&L updates in real-time for open trades</div>
                    <div>‚úÖ Trades close automatically at SL or TP</div>
                    <div>‚úÖ Use analytics to learn which setups work best</div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">
                      Ready to start tracking?
                    </strong>{" "}
                    The Trade Tracker refreshes every 30 seconds to show the
                    latest trades and updates. Click "Start Tracking!" to begin!
                  </p>
                </div>
              </div>
            ),
          },
        ];
        const steps = allSteps.slice(0, 3);

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[#0b1020] border-2 border-[#26325f] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[#26325f] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[#26325f]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[#93a4d6] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[#26325f] transition-colors"
                  title="Close Welcome Guide"
                >
                  √ó
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[#26325f] p-4 flex items-center justify-between bg-[#0f1630]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[#26325f] text-[#93a4d6] opacity-50 cursor-not-allowed"
                      : "border-[#26325f] bg-[#1a2550] hover:bg-[#26325f] text-white"
                  }`}
                >
                  ‚Üê Previous
                </button>
                <div className="text-sm text-[#93a4d6]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next ‚Üí
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Tracking! üöÄ
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Time Travel Slider Component
      function TimeTravelSlider({
        tickers,
        allTickers,
        data,
        onTimeChange,
        tickerFilter,
        selectedTicker,
      }) {
        const [isActive, setIsActive] = useState(false);
        const [selectedTimestamp, setSelectedTimestamp] = useState(null);
        const [trailData, setTrailData] = useState({});
        const [loadingTrails, setLoadingTrails] = useState(false);
        const [trailLoadProgress, setTrailLoadProgress] = useState({
          total: 0,
          done: 0,
        });
        const [isPlaying, setIsPlaying] = useState(false);
        const [playSpeedMs, setPlaySpeedMs] = useState(600); // ms per 5-min step
        const [loopPlayback, setLoopPlayback] = useState(true);
        const STEP_OPTIONS = React.useMemo(
          () => [
            { label: "5m", ms: 5 * 60 * 1000 },
            { label: "15m", ms: 15 * 60 * 1000 },
            { label: "30m", ms: 30 * 60 * 1000 },
            { label: "1H", ms: 60 * 60 * 1000 },
            { label: "4H", ms: 4 * 60 * 60 * 1000 },
            { label: "1D", ms: 24 * 60 * 60 * 1000 },
            { label: "1W", ms: 7 * 24 * 60 * 60 * 1000 },
          ],
          [],
        );
        const [stepMs, setStepMs] = useState(5 * 60 * 1000);

        // Prevent render loops when parent passes unstable callbacks/arrays.
        // (This was causing "Maximum update depth exceeded" and breaking Play.)
        const onTimeChangeRef = React.useRef(onTimeChange);
        useEffect(() => {
          onTimeChangeRef.current = onTimeChange;
        }, [onTimeChange]);

        const tickersRef = React.useRef(tickers);
        tickersRef.current = tickers;

        // Bucket timestamp to selected step (stable reference for effects)
        const roundToStep = React.useCallback(
          (ts) => {
            const ms = Number(ts);
            const step = Number(stepMs);
            if (!Number.isFinite(ms) || !Number.isFinite(step) || step <= 0)
              return ms;
            return Math.floor(ms / step) * step;
          },
          [stepMs],
        );

        // Get available timestamps from ALL tickers (not just filtered) for stable range
        // This prevents the slider from jumping around when search filters change
        const availableTimestamps = useMemo(() => {
          const timestamps = new Set();
          const sourceTickers =
            allTickers && typeof allTickers === "object"
              ? Array.isArray(allTickers)
                ? allTickers
                : Object.values(allTickers)
              : tickers;

          sourceTickers.forEach((t) => {
            if (!t || typeof t !== "object") return;
            if (t.ts) {
              const rounded = roundToStep(Number(t.ts));
              timestamps.add(rounded);
            }
            if (t.ingest_ts) {
              const ts =
                typeof t.ingest_ts === "string"
                  ? new Date(t.ingest_ts).getTime()
                  : Number(t.ingest_ts);
              if (ts) {
                const rounded = roundToStep(ts);
                timestamps.add(rounded);
              }
            }
          });
          return Array.from(timestamps).sort((a, b) => a - b);
        }, [allTickers, tickers, roundToStep]);

        const minTimestamp =
          availableTimestamps.length > 0
            ? availableTimestamps[0]
            : roundToStep(Date.now() - 7 * 24 * 60 * 60 * 1000);
        const maxTimestamp =
          availableTimestamps.length > 0
            ? availableTimestamps[availableTimestamps.length - 1]
            : roundToStep(Date.now());

        const STEP_MS = stepMs;

        const buildSnapshotTickers = React.useCallback(
          (sourceTickers, trails, roundedTimestamp) => {
            if (!Array.isArray(sourceTickers)) return [];
            return sourceTickers
              .map((ticker) => {
                const symbol = ticker?.ticker;
                if (!symbol) return null;

                const trail = trails?.[symbol] || [];
                const pointsWithTs = Array.isArray(trail)
                  ? trail
                      .map((point) => {
                        const pointTs =
                          point.ts ||
                          (point.timestamp
                            ? new Date(point.timestamp).getTime()
                            : null);
                        if (!pointTs) return null;
                        return {
                          point,
                          pointTs,
                          roundedPointTs: roundToStep(pointTs),
                        };
                      })
                      .filter(Boolean)
                  : [];

                // Snapshot: use closest known point. If missing data, keep visible using latest values.
                if (pointsWithTs.length > 0) {
                  const closest = pointsWithTs.reduce((best, cur) => {
                    if (!best) return cur;
                    const bestDist = Math.abs(
                      best.roundedPointTs - roundedTimestamp,
                    );
                    const curDist = Math.abs(
                      cur.roundedPointTs - roundedTimestamp,
                    );
                    return curDist < bestDist ? cur : best;
                  }, null);

                  const closestPoint = closest.point;
                  return {
                    ...ticker,
                    htf_score:
                      closestPoint.htf_score !== undefined
                        ? closestPoint.htf_score
                        : ticker.htf_score,
                    ltf_score:
                      closestPoint.ltf_score !== undefined
                        ? closestPoint.ltf_score
                        : ticker.ltf_score,
                    price:
                      closestPoint.price !== undefined
                        ? closestPoint.price
                        : ticker.price,
                    state: closestPoint.state || ticker.state,
                    rank:
                      closestPoint.rank !== undefined
                        ? closestPoint.rank
                        : ticker.rank,
                    rr:
                      closestPoint.rr !== undefined
                        ? closestPoint.rr
                        : ticker.rr,
                    completion:
                      closestPoint.completion !== undefined
                        ? closestPoint.completion
                        : ticker.completion,
                    phase_pct:
                      closestPoint.phase_pct !== undefined
                        ? closestPoint.phase_pct
                        : ticker.phase_pct,
                    ts: closest.pointTs,
                    _isTimeTravel: true,
                    _timeTravelMissing: false,
                  };
                }

                return {
                  ...ticker,
                  _isTimeTravel: true,
                  _timeTravelMissing: true,
                  ts: ticker.ts || ticker.ingest_ts || null,
                };
              })
              .filter(Boolean);
          },
          [roundToStep],
        );

        // Fetch trail data and filter by timestamp
        // Use a ref to track if we're currently fetching to prevent race conditions
        const fetchingRef = React.useRef(false);
        const lastFetchedSymbolsRef = React.useRef("");

        // Memoize ticker symbols to prevent unnecessary re-fetches
        const tickerSymbols = useMemo(() => {
          return tickers
            .map((t) => t.ticker)
            .sort()
            .join(",");
        }, [tickers]);

        // Fetch trails ONCE when activating (or when ticker set changes).
        // Snapshot updates (including animation) should NOT refetch trails.
        useEffect(() => {
          let cancelled = false;

          if (!isActive) {
            setIsPlaying(false);
            setTrailData({});
            setTrailLoadProgress({ total: 0, done: 0 });
            lastFetchedSymbolsRef.current = "";
            onTimeChangeRef.current?.(null);
            return () => {
              cancelled = true;
            };
          }

          if (tickersRef.current.length === 0) {
            onTimeChangeRef.current?.([]);
            return () => {
              cancelled = true;
            };
          }

          // Prevent concurrent fetches
          if (fetchingRef.current) return;

          // Avoid refetch if we already fetched this exact ticker set
          if (lastFetchedSymbolsRef.current === tickerSymbols) {
            return;
          }

          const fetchTrails = async () => {
            fetchingRef.current = true;
            setLoadingTrails(true);
            lastFetchedSymbolsRef.current = tickerSymbols;
            try {
              const trails = {};
              const tickerSymbolsArray = tickersRef.current.map(
                (t) => t.ticker,
              );
              setTrailLoadProgress({
                total: tickerSymbolsArray.length,
                done: 0,
              });

              const MAX_CONCURRENT = 5;
              for (
                let i = 0;
                i < tickerSymbolsArray.length;
                i += MAX_CONCURRENT
              ) {
                const batch = tickerSymbolsArray.slice(i, i + MAX_CONCURRENT);
                const batchResults = await Promise.all(
                  batch.map(async (ticker) => {
                    try {
                      const res = await fetch(
                        `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                          ticker,
                        )}`,
                      );
                      if (res.ok) {
                        const json = await res.json();
                        if (
                          json.ok &&
                          json.trail &&
                          Array.isArray(json.trail)
                        ) {
                          return { ticker, trail: json.trail };
                        }
                      }
                      return { ticker, trail: [] };
                    } catch (err) {
                      return { ticker, trail: [] };
                    }
                  }),
                );

                batchResults.forEach(({ ticker, trail }) => {
                  if (Array.isArray(trail) && trail.length > 0) {
                    trails[ticker] = trail;
                  }
                });

                if (!cancelled) {
                  setTrailLoadProgress((p) => ({
                    total: p.total || tickerSymbolsArray.length,
                    done: Math.min(
                      (p.done || 0) + batch.length,
                      tickerSymbolsArray.length,
                    ),
                  }));
                }

                // Small delay between batches to avoid spikes
                await new Promise((r) => setTimeout(r, 250));
              }

              if (!cancelled) setTrailData(trails);
            } catch (err) {
              console.error("Failed to fetch trails:", err);
              if (!cancelled) setTrailData({});
            } finally {
              if (!cancelled) setLoadingTrails(false);
              fetchingRef.current = false;
            }
          };

          fetchTrails();
          return () => {
            cancelled = true;
          };
        }, [isActive, tickerSymbols]);

        // Compute snapshot whenever timestamp changes or new trails arrive.
        useEffect(() => {
          if (!isActive) return;
          if (!selectedTimestamp) return;
          const roundedTimestamp = roundToStep(selectedTimestamp);
          const snapshot = buildSnapshotTickers(
            tickersRef.current,
            trailData,
            roundedTimestamp,
          );
          onTimeChangeRef.current?.(snapshot);
        }, [
          isActive,
          selectedTimestamp,
          trailData,
          tickerSymbols,
          buildSnapshotTickers,
          roundToStep,
        ]);

        // Animation: advance by 5 minutes at a configurable speed.
        useEffect(() => {
          if (!isActive || !isPlaying) return;

          const id = setInterval(() => {
            setSelectedTimestamp((prev) => {
              const cur =
                prev !== null && prev !== undefined
                  ? roundToStep(prev)
                  : roundToStep(maxTimestamp);
              const next = cur + STEP_MS;
              if (next > maxTimestamp) {
                if (loopPlayback) {
                  return roundToStep(minTimestamp);
                }
                setIsPlaying(false);
                return cur;
              }
              return next;
            });
          }, playSpeedMs);

          return () => clearInterval(id);
        }, [
          isActive,
          isPlaying,
          playSpeedMs,
          loopPlayback,
          minTimestamp,
          maxTimestamp,
          roundToStep,
          STEP_MS,
        ]);

        const handleTimestampChange = (e) => {
          const ts = Number(e.target.value);
          // Round to selected step
          const rounded = roundToStep(ts);
          setSelectedTimestamp(rounded);
          setIsPlaying(false);
        };

        const formatTimestamp = (ts) => {
          if (!ts) return "Now";
          const date = new Date(ts);
          return date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          });
        };

        const currentValue = selectedTimestamp
          ? roundToStep(selectedTimestamp)
          : roundToStep(maxTimestamp);
        const progress =
          maxTimestamp > minTimestamp
            ? ((currentValue - minTimestamp) / (maxTimestamp - minTimestamp)) *
              100
            : 100;

        // Parse ticker filter to show which tickers are being tracked
        const trackedTickers = useMemo(() => {
          if (!tickerFilter || typeof tickerFilter !== "string") return [];
          return tickerFilter
            .split(",")
            .map((t) => t.trim().toUpperCase())
            .filter(Boolean);
        }, [tickerFilter]);

        const selectedSym = useMemo(() => {
          const s = String(selectedTicker || "")
            .trim()
            .toUpperCase();
          return s || null;
        }, [selectedTicker]);

        const selectedSnapshotInfo = useMemo(() => {
          if (!isActive) return null;
          if (!selectedSym) return null;
          if (!Number.isFinite(currentValue)) return null;
          const trail = trailData?.[selectedSym] || [];
          if (!Array.isArray(trail) || trail.length === 0) return null;

          const pointsWithTs = trail
            .map((point) => {
              const pointTs =
                point.ts ||
                (point.timestamp ? new Date(point.timestamp).getTime() : null);
              if (!pointTs) return null;
              return {
                point,
                pointTs: Number(pointTs),
                roundedPointTs: roundToStep(pointTs),
              };
            })
            .filter(Boolean);

          if (pointsWithTs.length === 0) return null;
          const closest = pointsWithTs.reduce((best, cur) => {
            if (!best) return cur;
            const bestDist = Math.abs(best.roundedPointTs - currentValue);
            const curDist = Math.abs(cur.roundedPointTs - currentValue);
            return curDist < bestDist ? cur : best;
          }, null);

          const px = Number(closest?.point?.price);
          return {
            ts: Number.isFinite(closest?.pointTs) ? closest.pointTs : null,
            price: Number.isFinite(px) ? px : null,
          };
        }, [isActive, selectedSym, currentValue, trailData, roundToStep]);

        const fmtPrice = (p) => {
          const n = Number(p);
          return Number.isFinite(n) ? `$${n.toFixed(2)}` : "‚Äî";
        };

        return (
          <div className="mb-4 bg-[#121a33] border border-[#26325f] rounded-xl p-4">
            <div className="flex items-center justify-between mb-3 flex-wrap gap-2">
              <div className="flex items-center gap-3 flex-wrap">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={isActive}
                    onChange={(e) => {
                      setIsActive(e.target.checked);
                      if (!e.target.checked) {
                        setIsPlaying(false);
                        setSelectedTimestamp(null);
                        onTimeChangeRef.current?.(null);
                      } else {
                        // Round to 5 minutes when activating
                        setSelectedTimestamp(roundToStep(maxTimestamp));
                      }
                    }}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-semibold text-white">
                    ‚è±Ô∏è Time Travel
                  </span>
                </label>
                {isActive && (
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => {
                        // Ensure we have a starting timestamp before playing
                        if (!isPlaying) {
                          setSelectedTimestamp((prev) =>
                            prev !== null && prev !== undefined
                              ? prev
                              : maxTimestamp,
                          );
                        }
                        setIsPlaying((p) => !p);
                      }}
                      className="px-2 py-1 bg-[#26325f] hover:bg-[#3a4aa0] rounded text-xs text-white"
                      title="Play / Pause"
                    >
                      {isPlaying ? "‚è∏ Pause" : "‚ñ∂Ô∏è Play"}
                    </button>
                    <select
                      value={String(stepMs)}
                      onChange={(e) => {
                        const next = Number(e.target.value);
                        if (!Number.isFinite(next) || next <= 0) return;
                        setStepMs(next);
                        setIsPlaying(false);
                        setSelectedTimestamp((prev) =>
                          prev != null
                            ? Math.floor(Number(prev) / next) * next
                            : Math.floor(Number(maxTimestamp) / next) * next,
                        );
                      }}
                      className="bg-[#0f1630] border border-[#26325f] rounded px-2 py-1 text-xs text-[#e7ecff]"
                      title="Time step"
                    >
                      {STEP_OPTIONS.map((opt) => (
                        <option key={opt.label} value={opt.ms}>
                          {opt.label}
                        </option>
                      ))}
                    </select>
                    <select
                      value={playSpeedMs}
                      onChange={(e) => setPlaySpeedMs(Number(e.target.value))}
                      className="bg-[#0f1630] border border-[#26325f] rounded px-2 py-1 text-xs text-[#e7ecff]"
                      title="Playback speed"
                    >
                      <option value={300}>Fast</option>
                      <option value={600}>Normal</option>
                      <option value={1200}>Slow</option>
                    </select>
                    <label className="flex items-center gap-1 text-xs text-[#93a4d6]">
                      <input
                        type="checkbox"
                        checked={loopPlayback}
                        onChange={(e) => setLoopPlayback(e.target.checked)}
                      />
                      Loop
                    </label>
                  </div>
                )}
                {trackedTickers.length > 0 && (
                  <div className="flex items-center gap-2 text-xs text-[#93a4d6]">
                    <span className="text-[#00ffff]">Tracking:</span>
                    <div className="flex flex-wrap gap-1">
                      {trackedTickers.slice(0, 5).map((ticker, idx) => (
                        <span
                          key={idx}
                          className="px-2 py-0.5 bg-[#0f1630] border border-[#26325f] rounded text-[#00ffff]"
                        >
                          {ticker}
                        </span>
                      ))}
                      {trackedTickers.length > 5 && (
                        <span className="px-2 py-0.5 bg-[#0f1630] border border-[#26325f] rounded text-[#93a4d6]">
                          +{trackedTickers.length - 5}
                        </span>
                      )}
                    </div>
                  </div>
                )}
                {tickers.length > 0 && trackedTickers.length === 0 && (
                  <div className="text-xs text-[#93a4d6]">
                    Showing {tickers.length} ticker
                    {tickers.length !== 1 ? "s" : ""}
                  </div>
                )}
              </div>
              {isActive && (
                <div className="text-xs text-[#00ffff] font-semibold text-right">
                  <div>{formatTimestamp(currentValue)}</div>
                  {selectedSym && (
                    <div className="mt-0.5 text-[11px] text-[#93a4d6] font-normal">
                      {selectedSym}:{" "}
                      <span className="text-white font-semibold">
                        {fmtPrice(selectedSnapshotInfo?.price)}
                      </span>
                      {Number.isFinite(selectedSnapshotInfo?.ts) &&
                        selectedSnapshotInfo.ts !== currentValue && (
                          <span className="text-[#6b7a9f]">
                            {` (data @ ${formatTimestamp(selectedSnapshotInfo.ts)})`}
                          </span>
                        )}
                    </div>
                  )}
                </div>
              )}
            </div>

            {isActive && (
              <div className="space-y-2">
                <input
                  type="range"
                  min={minTimestamp}
                  max={maxTimestamp}
                  step={STEP_MS}
                  value={currentValue}
                  onChange={handleTimestampChange}
                  className="w-full h-2 bg-[#0f1630] rounded-lg appearance-none cursor-pointer slider-thumb"
                  style={{
                    background: `linear-gradient(to right, #00ffff 0%, #00ffff ${progress}%, #26325f ${progress}%, #26325f 100%)`,
                  }}
                />
                <div className="flex justify-between text-xs text-[#93a4d6]">
                  <span>{formatTimestamp(minTimestamp)}</span>
                  <span>{formatTimestamp(maxTimestamp)}</span>
                </div>
                {loadingTrails && (
                  <div className="text-xs text-[#93a4d6]">
                    <div className="flex items-center justify-between mb-1">
                      <span>Loading historical data‚Ä¶</span>
                      <span className="tabular-nums">
                        {trailLoadProgress.done}/{trailLoadProgress.total || 0}
                      </span>
                    </div>
                    <div className="w-full h-2 bg-[#0f1630] border border-[#26325f] rounded overflow-hidden">
                      <div
                        className="h-full bg-[#00ffff]"
                        style={{
                          width: `${
                            trailLoadProgress.total > 0
                              ? Math.round(
                                  (trailLoadProgress.done /
                                    trailLoadProgress.total) *
                                    100,
                                )
                              : 0
                          }%`,
                          transition: "width 200ms ease",
                        }}
                      />
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }

      function QuickFilters({ filters, onFilterChange, sectors = [] }) {
        // Groups (seed list) - one row
        const groupPresets = [
          {
            label: "Upticks",
            filter: { group: "UPTICKS" },
            icon: "üìä",
          },
          {
            label: "Super Granny",
            filter: { group: "SuperGranny" },
            icon: "‚≠ê",
          },
          {
            label: "GRNI",
            filter: { group: "GRNI" },
            icon: "üîµ",
          },
          {
            label: "GRNJ",
            filter: { group: "GRNJ" },
            icon: "üü¢",
          },
          {
            label: "GRNY",
            filter: { group: "GRNY" },
            icon: "üü°",
          },
          {
            label: "Social",
            filter: { group: "Social" },
            icon: "üí¨",
          },
          {
            label: "SP Sectors",
            filter: { group: "SP_Sectors" },
            icon: "üìà",
          },
          {
            label: "Futures",
            filter: { group: "Futures" },
            icon: "‚ö°",
          },
          {
            label: "No Group",
            filter: { group: "No Group" },
            icon: "üìã",
          },
        ];

        // Filters - one row
        const filterPresets = [
          {
            label: "Short-Term",
            filter: { horizonBucket: "SHORT_TERM" },
            icon: "‚è±Ô∏è",
          },
          {
            label: "Swing",
            filter: { horizonBucket: "SWING" },
            icon: "üé¢",
          },
          {
            label: "Positional",
            filter: { horizonBucket: "POSITIONAL" },
            icon: "üèîÔ∏è",
          },
          {
            label: "Prime Only",
            filter: { minRank: 75, minRR: 1.5, maxCompletion: 0.4 },
            icon: "‚≠ê",
          },
          {
            label: "In Corridor",
            filter: { inCorridor: true },
            icon: "üéØ",
          },
          {
            label: "Squeeze Release",
            filter: { squeezeRelease: true },
            icon: "‚ö°",
          },
          {
            label: "In Squeeze",
            filter: { inSqueeze: true },
            icon: "üß®",
          },
          {
            label: "Momentum Elite",
            filter: { momentumElite: true },
            icon: "üöÄ",
          },
          {
            label: "Winner Signature",
            filter: { winnerSignature: true },
            icon: "üèÜ",
          },
          {
            label: "Q1: Bull Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "üìà",
          },
          {
            label: "Q2: Bull Momentum",
            filter: { quadrants: ["HTF_BULL_LTF_BULL"] },
            icon: "üöÄ",
          },
          {
            label: "Q3: Bear Momentum",
            filter: { quadrants: ["HTF_BEAR_LTF_BEAR"] },
            icon: "üìâ",
          },
          {
            label: "Q4: Bear Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "üîª",
          },
          {
            label: "Ranked",
            filter: { top40: true },
            icon: "üìä",
          },
          {
            label: "Top Long Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "üìà",
          },
          {
            label: "Top Short Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "üìâ",
          },
          {
            label: "Trades",
            filter: { hasTrades: true },
            icon: "üíº",
          },
          {
            label: "TD9 Setup",
            filter: { td9Setup: "any" },
            icon: "üî¢",
          },
        ];

        const isActive = (preset) => {
          if (preset.label === "Prime Only") {
            return (
              filters.minRank === 75 &&
              filters.minRR === 1.5 &&
              filters.maxCompletion === 0.4
            );
          }
          if (preset.label === "Short-Term") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "SHORT_TERM"
            );
          }
          if (preset.label === "Swing") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "SWING"
            );
          }
          if (preset.label === "Positional") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "POSITIONAL"
            );
          }
          if (preset.label === "In Corridor") {
            return filters.inCorridor === true;
          }
          if (preset.label === "Squeeze Release") {
            return filters.squeezeRelease === true;
          }
          if (preset.label === "In Squeeze") {
            return filters.inSqueeze === true;
          }
          if (preset.label === "Momentum Elite") {
            return filters.momentumElite === true;
          }
          // Check for "Top Long Setup" and "Top Short Setup" specifically
          if (preset.label === "Top Long Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
            );
          }
          if (preset.label === "Top Short Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
            );
          }
          // Check if quadrant filter matches (for Q1, Q2, Q3, Q4 labels)
          if (preset.label.startsWith("Q")) {
            const presetQuadrants = preset.filter.quadrants || [];
            const currentQuadrants = filters.quadrants || [];
            // Check if preset quadrants are the only ones selected
            if (presetQuadrants.length === 1 && currentQuadrants.length === 1) {
              return presetQuadrants[0] === currentQuadrants[0];
            }
            // Check if preset quadrants are subset of current (and no others)
            if (
              presetQuadrants.length === 1 &&
              currentQuadrants.includes(presetQuadrants[0])
            ) {
              return currentQuadrants.length === 1;
            }
          }
          // Check if group filter matches
          if (preset.filter.group) {
            return filters.group === preset.filter.group;
          }
          // Check if Top 40 filter matches
          if (preset.filter.top40) {
            return filters.top40 === true;
          }
          // Check if Trades filter matches
          if (preset.filter.hasTrades) {
            return filters.hasTrades === true;
          }
          // Check if TD9 Setup filter matches
          if (preset.filter.td9Setup) {
            return filters.td9Setup === "any";
          }
          return false;
        };

        const handlePresetClick = (preset) => {
          const active = isActive(preset);
          if (active) {
            // Toggle off - remove this specific filter, keep others
            const newFilters = { ...filters };

            if (preset.label === "Prime Only") {
              // Reset Prime Only filters to defaults
              newFilters.minRank = 0;
              newFilters.minRR = 0;
              newFilters.maxCompletion = 1.01;
            } else if (
              preset.label === "Short-Term" ||
              preset.label === "Swing" ||
              preset.label === "Positional"
            ) {
              delete newFilters.horizonBucket;
            } else if (preset.label === "In Corridor") {
              delete newFilters.inCorridor;
            } else if (preset.label === "Squeeze Release") {
              delete newFilters.squeezeRelease;
            } else if (preset.label === "In Squeeze") {
              delete newFilters.inSqueeze;
            } else if (preset.label === "Momentum Elite") {
              // Explicitly delete to ensure it's removed
              delete newFilters.momentumElite;
              // Set to undefined so handleFilterChange properly removes it
              newFilters.momentumElite = undefined;
            } else if (preset.label === "Top Long Setup") {
              // Restore all quadrants if Top Long Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label === "Top Short Setup") {
              // Restore all quadrants if Top Short Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label.startsWith("Q")) {
              // For Q1-Q4, restore all quadrants if this was the only one
              const presetQuadrants = preset.filter.quadrants || [];
              const currentQuadrants = filters.quadrants || [];
              if (
                presetQuadrants.length === 1 &&
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === presetQuadrants[0]
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.filter.group) {
              // Reset group filter
              newFilters.group = "ALL";
            } else if (preset.filter.top40) {
              delete newFilters.top40;
            } else if (preset.filter.hasTrades) {
              delete newFilters.hasTrades;
            } else if (preset.filter.td9Setup) {
              delete newFilters.td9Setup;
              newFilters.td9Setup = undefined; // Ensure it's cleared
            }

            // Ensure all deleted filters are explicitly set to undefined for proper cleanup
            onFilterChange(newFilters);
          } else {
            // Toggle on - apply filter, merge with existing filters
            const mergedFilters = { ...filters, ...preset.filter };

            // Special handling for quadrant filters - replace, don't merge arrays
            if (preset.filter.quadrants) {
              mergedFilters.quadrants = preset.filter.quadrants;
            }

            onFilterChange(mergedFilters);
          }
        };

        const resetAllFilters = () => {
          // Explicitly reset all filters including boolean flags
          // Use onFilterChange to ensure proper state updates
          const defaultFilters = {
            search: "",
            quadrants: [
              "HTF_BULL_LTF_PULLBACK",
              "HTF_BULL_LTF_BULL",
              "HTF_BEAR_LTF_BEAR",
              "HTF_BEAR_LTF_PULLBACK",
            ],
            minRank: 0,
            minRR: 0,
            maxCompletion: 1.01,
            group: "ALL",
          };
          // Explicitly clear all boolean filters by setting to undefined
          // handleFilterChange will delete undefined values
          onFilterChange({
            ...defaultFilters,
            horizonBucket: undefined,
            inCorridor: undefined,
            squeezeRelease: undefined,
            inSqueeze: undefined,
            momentumElite: undefined,
            winnerSignature: undefined,
            top40: undefined,
            hasTrades: undefined,
            td9Setup: undefined,
            sector: undefined,
          });
        };

        const renderPresetButton = (preset, i) => {
          const active = isActive(preset);
          return (
            <button
              key={i}
              className={`px-4 py-2 rounded-lg border text-sm font-semibold transition-all ${
                active
                  ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                  : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
              }`}
              onClick={() => handlePresetClick(preset)}
            >
              {preset.icon} {preset.label}
            </button>
          );
        };

        return (
          <div className="space-y-3 mb-4">
            {/* Groups Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {groupPresets.map((preset, i) => renderPresetButton(preset, i))}
            </div>
            {/* Filters Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {filterPresets.map((preset, i) => renderPresetButton(preset, i))}
              {/* Reset Filters Button */}
              <button
                onClick={resetAllFilters}
                className="px-4 py-2 rounded-lg border border-red-500/50 bg-red-500/10 hover:bg-red-500/20 text-red-400 text-sm font-semibold transition-all"
                title="Reset all filters to defaults"
              >
                üîÑ Reset Filters
              </button>
            </div>
            {/* Sectors Row */}
            {sectors.length > 0 && (
              <div className="flex gap-2 flex-wrap items-center">
                <span className="text-xs text-[#93a4d6] font-semibold mr-1">
                  Sectors:
                </span>
                {sectors.map((sectorData) => {
                  const sectorName = sectorData.sector || sectorData.name;
                  const rating = sectorData.rating || "neutral";
                  const emoji =
                    rating === "overweight"
                      ? "üí™"
                      : rating === "underweight"
                        ? "üëé"
                        : "üòí";
                  const isActive = filters.sector === sectorName;
                  return (
                    <button
                      key={sectorName}
                      onClick={() => {
                        if (isActive) {
                          // Toggle off - clear sector filter
                          onFilterChange({
                            ...filters,
                            sector: undefined,
                          });
                        } else {
                          // Toggle on - set sector filter
                          onFilterChange({
                            ...filters,
                            sector: sectorName,
                          });
                        }
                      }}
                      className={`px-2 py-1 rounded-lg border text-xs font-semibold transition-all ${
                        isActive
                          ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                          : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
                      }`}
                      title={`${sectorName} - ${
                        rating.charAt(0).toUpperCase() + rating.slice(1)
                      }`}
                    >
                      {emoji} {sectorName}
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Viewport Filter Tags (controls Viewport + Bubble Chart)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function ViewportFilterTags({
        filters,
        onChange,
        sectors = [],
        allData = null,
        trades = [],
      }) {
        const group = String(filters.group || "ALL");
        const horizon = String(filters.horizonBucket || "ALL");
        const opp = String(filters.opportunities || "ALL");
        const quadrants = Array.isArray(filters.quadrants)
          ? filters.quadrants
          : null;
        const sector = String(filters.sector || "ALL");
        const guidance = String(filters.guidanceCategory || "ALL");

        const sectorRatingMap = React.useMemo(() => {
          const map = {};
          if (Array.isArray(sectors)) {
            sectors.forEach((s) => {
              const name = s?.sector || s?.name;
              if (!name) return;
              map[normalizeSectorKey(name)] = String(
                s?.rating || "neutral",
              ).toLowerCase();
            });
          }
          return map;
        }, [sectors]);

        const sectorEmoji = (sectorName) => {
          const rating =
            sectorRatingMap[normalizeSectorKey(sectorName)] || "neutral";
          return rating === "overweight"
            ? "üí™"
            : rating === "underweight"
              ? "üëé"
              : "üòí";
        };

        const QUAD = {
          // Match quadrant presets used elsewhere in the UI
          // Q1: Bull Setup (pullback), Q2: Bull Momentum, Q3: Bear Momentum, Q4: Bear Setup (pullback)
          Q1: "HTF_BULL_LTF_PULLBACK",
          Q2: "HTF_BULL_LTF_BULL",
          Q3: "HTF_BEAR_LTF_BEAR",
          Q4: "HTF_BEAR_LTF_PULLBACK",
        };
        const ALL_QUADS = Object.values(QUAD);

        const isQuadActive = (qKey) => {
          const s = QUAD[qKey];
          if (!s) return false;
          if (!quadrants) return false;
          return quadrants.includes(s);
        };

        // Single-select quadrant behavior:
        // - click Qx => show only that quadrant
        // - click same Qx again => clear quadrant filter (show all)
        const toggleQuadrant = (qKey) => {
          const s = QUAD[qKey];
          if (!s) return;
          const cur = Array.isArray(quadrants) ? quadrants : null;
          const isOnlyThis = cur && cur.length === 1 && cur[0] === s;
          onChange({ quadrants: isOnlyThis ? undefined : [s] });
        };

        const PILL_TOOLTIPS = {
          "üß† Thesis":
            "Thesis preset (Rank‚â•74, RR‚â•1.5, Completion‚â§0.6, Phase‚â§0.6) plus requires a richer winner pattern (computed live in the Worker).",
          "üß® In Squeeze":
            "Currently in squeeze (sq30_on=true and sq30_release=false).",
          "‚ö° Squeeze Release":
            "Squeeze release just fired (sq30_release=true).",
          "üöÄ Momentum Elite":
            "Fundamental/momentum overlay: Momentum Elite flag is on.",
          "üèÜ Winner Signature":
            "High-quality setup snapshot signature (tight, selective).",
        };

        const pillCounts = React.useMemo(() => {
          if (!allData) return null;
          const safeTrades = Array.isArray(trades) ? trades : [];
          const base = filters || {};

          const countWith = (nextFilters) => {
            try {
              const n = applyFilters(allData, nextFilters, safeTrades).length;
              return Number.isFinite(n) ? n : null;
            } catch {
              return null;
            }
          };

          // Guidance
          const guidanceAll = countWith({
            ...base,
            guidanceCategory: undefined,
          });
          const guidanceInitiate = countWith({
            ...base,
            guidanceCategory: "INITIATE",
          });
          const guidanceConsider = countWith({
            ...base,
            guidanceCategory: "CONSIDER",
          });
          const guidanceMonitor = countWith({
            ...base,
            guidanceCategory: "MONITOR",
          });
          const guidanceWait = countWith({ ...base, guidanceCategory: "WAIT" });
          const guidanceExitTrim = countWith({
            ...base,
            guidanceCategory: "EXIT_TRIM",
          });
          const guidanceOther = countWith({
            ...base,
            guidanceCategory: "OTHER",
          });

          // Horizon
          const horizonAll = countWith({ ...base, horizonBucket: undefined });
          const horizonShort = countWith({
            ...base,
            horizonBucket: "SHORT_TERM",
          });
          const horizonSwing = countWith({ ...base, horizonBucket: "SWING" });
          const horizonPos = countWith({
            ...base,
            horizonBucket: "POSITIONAL",
          });

          // Opportunities
          const oppAll = countWith({ ...base, opportunities: undefined });
          const oppEligible = countWith({ ...base, opportunities: "ELIGIBLE" });
          const oppPrime = countWith({ ...base, opportunities: "PRIME" });
          const oppWatch = countWith({ ...base, opportunities: "WATCH" });
          const q1 = countWith({ ...base, quadrants: [QUAD.Q1] });
          const q2 = countWith({ ...base, quadrants: [QUAD.Q2] });
          const q3 = countWith({ ...base, quadrants: [QUAD.Q3] });
          const q4 = countWith({ ...base, quadrants: [QUAD.Q4] });

          // Specials
          const thesisFilters = isThesisModeActive(base)
            ? base
            : { ...base, ...THESIS_PRESET };
          const thesis = countWith(thesisFilters);
          const inSqueeze = countWith({ ...base, inSqueeze: true });
          const squeezeRelease = countWith({ ...base, squeezeRelease: true });
          const momentumElite = countWith({ ...base, momentumElite: true });
          const winnerSignature = countWith({ ...base, winnerSignature: true });
          const flipWatch = countWith({ ...base, flipWatch: true });

          // Kanban Stages
          const kanbanWatch = countWith({ ...base, kanbanStage: "watch" });
          const kanbanFlipWatch = countWith({
            ...base,
            kanbanStage: "flip_watch",
          });
          const kanbanJustFlipped = countWith({
            ...base,
            kanbanStage: "just_flipped",
          });
          const kanbanEnterNow = countWith({
            ...base,
            kanbanStage: "enter_now",
          });
          const kanbanHold = countWith({ ...base, kanbanStage: "hold" });
          const kanbanDefend = countWith({ ...base, kanbanStage: "defend" });
          const kanbanTrim = countWith({ ...base, kanbanStage: "trim" });
          const kanbanExit = countWith({ ...base, kanbanStage: "exit" });
          const kanbanArchive = countWith({ ...base, kanbanStage: "archive" });

          // Action Moves Pattern Groups
          const patternSqueezeMomentum = countWith({
            ...base,
            patternGroup: "Squeeze ‚Üí Momentum",
          });
          const patternMomentumElite = countWith({
            ...base,
            patternGroup: "Momentum Elite",
          });
          const patternCorridorReclaim = countWith({
            ...base,
            patternGroup: "Corridor reclaim",
          });
          const patternSqueezeBuild = countWith({
            ...base,
            patternGroup: "Squeeze pressure build",
          });
          const patternTrendCont = countWith({
            ...base,
            patternGroup: "Trend continuation",
          });
          const patternLateCycle = countWith({
            ...base,
            patternGroup: "Late-cycle / Overextended",
          });
          const patternUnclear = countWith({
            ...base,
            patternGroup: "Unclear / Chop",
          });

          // Groups
          const groupAll = countWith({ ...base, group: "ALL" });
          const groupUpticks = countWith({ ...base, group: "UPTICKS" });
          const groupSuperGranny = countWith({ ...base, group: "SuperGranny" });
          const groupGRNY = countWith({ ...base, group: "GRNY" });
          const groupGRNJ = countWith({ ...base, group: "GRNJ" });
          const groupGRNI = countWith({ ...base, group: "GRNI" });
          const groupSocial = countWith({ ...base, group: "Social" });
          const groupNoGroup = countWith({ ...base, group: "UNGROUPED" });

          // S&P Sectors (group + sector filters)
          const sectorAll = countWith({ ...base, sector: undefined });
          const spSectors = countWith({ ...base, group: "SP_Sectors" });
          const comm = countWith({ ...base, sector: "Communication Services" });
          const consDisc = countWith({
            ...base,
            sector: "Consumer Discretionary",
          });
          const consStaples = countWith({
            ...base,
            sector: "Consumer Staples",
          });
          const energy = countWith({ ...base, sector: "Energy" });
          const financials = countWith({ ...base, sector: "Financials" });
          const healthcare = countWith({ ...base, sector: "Healthcare" });
          const industrials = countWith({ ...base, sector: "Industrials" });
          const tech = countWith({ ...base, sector: "Information Technology" });
          const materials = countWith({ ...base, sector: "Basic Materials" });
          const realEstate = countWith({ ...base, sector: "Real Estate" });
          const utilities = countWith({ ...base, sector: "Utilities" });

          return {
            guidance: {
              ALL: guidanceAll,
              INITIATE: guidanceInitiate,
              CONSIDER: guidanceConsider,
              MONITOR: guidanceMonitor,
              WAIT: guidanceWait,
              EXIT_TRIM: guidanceExitTrim,
              OTHER: guidanceOther,
            },
            horizon: {
              ALL: horizonAll,
              SHORT_TERM: horizonShort,
              SWING: horizonSwing,
              POSITIONAL: horizonPos,
            },
            opp: {
              ALL: oppAll,
              ELIGIBLE: oppEligible,
              PRIME: oppPrime,
              WATCH: oppWatch,
              Q1: q1,
              Q2: q2,
              Q3: q3,
              Q4: q4,
            },
            specials: {
              THESIS: thesis,
              IN_SQUEEZE: inSqueeze,
              SQUEEZE_RELEASE: squeezeRelease,
              MOMENTUM_ELITE: momentumElite,
              WINNER_SIGNATURE: winnerSignature,
              FLIP_WATCH: flipWatch,
            },
            patterns: {
              SQUEEZE_MOMENTUM: patternSqueezeMomentum,
              MOMENTUM_ELITE: patternMomentumElite,
              CORRIDOR_RECLAIM: patternCorridorReclaim,
              SQUEEZE_BUILD: patternSqueezeBuild,
              TREND_CONT: patternTrendCont,
              LATE_CYCLE: patternLateCycle,
              UNCLEAR: patternUnclear,
            },
            kanban: {
              WATCH: kanbanWatch,
              FLIP_WATCH: kanbanFlipWatch,
              JUST_FLIPPED: kanbanJustFlipped,
              ENTER_NOW: kanbanEnterNow,
              HOLD: kanbanHold,
              DEFEND: kanbanDefend,
              TRIM: kanbanTrim,
              EXIT: kanbanExit,
              ARCHIVE: kanbanArchive,
            },
            groups: {
              ALL: groupAll,
              UPTICKS: groupUpticks,
              SuperGranny: groupSuperGranny,
              GRNY: groupGRNY,
              GRNJ: groupGRNJ,
              GRNI: groupGRNI,
              Social: groupSocial,
              UNGROUPED: groupNoGroup,
            },
            sectors: {
              ALL: sectorAll,
              SP_Sectors: spSectors,
              "Communication Services": comm,
              "Consumer Discretionary": consDisc,
              "Consumer Staples": consStaples,
              Energy: energy,
              Financials: financials,
              Healthcare: healthcare,
              Industrials: industrials,
              "Information Technology": tech,
              "Basic Materials": materials,
              "Real Estate": realEstate,
              Utilities: utilities,
            },
          };
        }, [allData, trades, filters]);

        const pillLabelWithCount = (baseLabel, count) => {
          if (!Number.isFinite(count)) return baseLabel;
          return `${baseLabel} (${count})`;
        };

        const pill = (label, active, onClick) => {
          const labelStr = String(label);
          const m = labelStr.match(/^(.*?)(?:\s*\((\d+)\))\s*$/);
          const baseLabel = (m ? m[1] : labelStr).trim();
          const count = m ? Number(m[2]) : null;
          const tip = PILL_TOOLTIPS[baseLabel] || null;
          return (
            <div className="relative group">
              <button
                onClick={onClick}
                className={`px-3 py-1.5 rounded-lg border text-xs font-semibold transition-all ${
                  active
                    ? "border-blue-400 bg-blue-500/20 text-blue-200"
                    : "border-[#26325f] bg-[#0f1630] text-[#93a4d6] hover:text-white"
                }`}
              >
                <span className="inline-flex items-center gap-2">
                  <span>{baseLabel}</span>
                  {Number.isFinite(count) ? (
                    <span
                      className={`px-1.5 py-0.5 rounded-md text-[10px] font-bold border ${
                        active
                          ? "border-blue-400/40 bg-blue-400/10 text-blue-100"
                          : "border-[#26325f] bg-[#121a33] text-[#c8d2ff]"
                      }`}
                      title={`${count} tickers`}
                    >
                      {count}
                    </span>
                  ) : null}
                </span>
              </button>
              {tip ? (
                <div className="pointer-events-none absolute left-1/2 top-full z-50 mt-2 hidden -translate-x-1/2 group-hover:block">
                  <div className="max-w-[280px] rounded-lg border border-[#26325f] bg-[#0b1024] px-3 py-2 text-[11px] leading-snug text-[#c8d2ff] shadow-lg">
                    {tip}
                  </div>
                </div>
              ) : null}
            </div>
          );
        };

        const toggleBool = (key) => {
          const cur = filters[key] === true;
          onChange({ [key]: cur ? undefined : true });
        };

        const isThesisActive = () => {
          return isThesisModeActive(filters);
        };
        const toggleThesis = () => {
          const active = isThesisActive();
          try {
            localStorage.setItem("timedTrading_thesisAuto", active ? "0" : "1");
          } catch {}
          if (active) {
            // Reset only the preset fields (leave other filters intact)
            onChange({
              minRank: 0,
              minRR: 0,
              maxCompletion: 1.01,
              maxPhase: undefined,
            });
          } else {
            onChange({ ...THESIS_PRESET });
          }
        };

        return (
          <div className="space-y-2 mb-2">
            {/* Row 1: Horizon + Kanban Stages */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-y-2 lg:gap-x-2">
              <div className="space-y-1">
                <div className="text-[10px] text-[#6b7a9f] font-semibold">
                  Horizon
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  {pill(
                    pillLabelWithCount("All", pillCounts?.horizon?.ALL),
                    horizon === "ALL",
                    () => onChange({ horizonBucket: undefined }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "Short-Term",
                      pillCounts?.horizon?.SHORT_TERM,
                    ),
                    horizon === "SHORT_TERM",
                    () => onChange({ horizonBucket: "SHORT_TERM" }),
                  )}
                  {pill(
                    pillLabelWithCount("Swing", pillCounts?.horizon?.SWING),
                    horizon === "SWING",
                    () => onChange({ horizonBucket: "SWING" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "Positional",
                      pillCounts?.horizon?.POSITIONAL,
                    ),
                    horizon === "POSITIONAL",
                    () => onChange({ horizonBucket: "POSITIONAL" }),
                  )}
                </div>

                {/* Note: Filter UI intentionally simplified.
                  Additional groups (Quadrants / Premium / Patterns) removed to reduce noise. */}
              </div>

              <div className="space-y-1">
                <div className="text-[10px] text-[#6b7a9f] font-semibold">
                  Kanban Stages
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  {pill(
                    pillLabelWithCount("All", null),
                    !filters.kanbanStage,
                    () => onChange({ kanbanStage: undefined }),
                  )}
                  {pill(
                    pillLabelWithCount("üëÄ Watch", pillCounts?.kanban?.WATCH),
                    filters.kanbanStage === "watch",
                    () => onChange({ kanbanStage: "watch" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "üéØ Flip Watch",
                      pillCounts?.kanban?.FLIP_WATCH,
                    ),
                    filters.kanbanStage === "flip_watch",
                    () => onChange({ kanbanStage: "flip_watch" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "‚ö° Just Flipped",
                      pillCounts?.kanban?.JUST_FLIPPED,
                    ),
                    filters.kanbanStage === "just_flipped",
                    () => onChange({ kanbanStage: "just_flipped" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "üöÄ Enter Now",
                      pillCounts?.kanban?.ENTER_NOW,
                    ),
                    filters.kanbanStage === "enter_now",
                    () => onChange({ kanbanStage: "enter_now" }),
                  )}
                  {pill(
                    pillLabelWithCount("üíé Hold", pillCounts?.kanban?.HOLD),
                    filters.kanbanStage === "hold",
                    () => onChange({ kanbanStage: "hold" }),
                  )}
                  {pill(
                    pillLabelWithCount("üõ° Defend", pillCounts?.kanban?.DEFEND),
                    filters.kanbanStage === "defend",
                    () => onChange({ kanbanStage: "defend" }),
                  )}
                  {pill(
                    pillLabelWithCount("üìä Trim", pillCounts?.kanban?.TRIM),
                    filters.kanbanStage === "trim",
                    () => onChange({ kanbanStage: "trim" }),
                  )}
                  {pill(
                    pillLabelWithCount("üö™ Exit", pillCounts?.kanban?.EXIT),
                    filters.kanbanStage === "exit",
                    () => onChange({ kanbanStage: "exit" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "üóÇ Archive",
                      pillCounts?.kanban?.ARCHIVE,
                    ),
                    filters.kanbanStage === "archive",
                    () => onChange({ kanbanStage: "archive" }),
                  )}
                </div>
              </div>
            </div>

            {/* Row 2: Groups + S&P Sectors */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-y-2 lg:gap-x-2">
              <div className="space-y-1">
                <div className="text-[10px] text-[#6b7a9f] font-semibold">
                  Groups
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  {pill(
                    pillLabelWithCount("All", pillCounts?.groups?.ALL),
                    group === "ALL",
                    () => onChange({ group: "ALL" }),
                  )}
                  {pill(
                    pillLabelWithCount("Upticks", pillCounts?.groups?.UPTICKS),
                    group === "UPTICKS",
                    () => onChange({ group: "UPTICKS" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "Super Granny",
                      pillCounts?.groups?.SuperGranny,
                    ),
                    group === "SuperGranny",
                    () => onChange({ group: "SuperGranny" }),
                  )}
                  {pill(
                    pillLabelWithCount("GRNY", pillCounts?.groups?.GRNY),
                    group === "GRNY",
                    () => onChange({ group: "GRNY" }),
                  )}
                  {pill(
                    pillLabelWithCount("GRNJ", pillCounts?.groups?.GRNJ),
                    group === "GRNJ",
                    () => onChange({ group: "GRNJ" }),
                  )}
                  {pill(
                    pillLabelWithCount("GRNI", pillCounts?.groups?.GRNI),
                    group === "GRNI",
                    () => onChange({ group: "GRNI" }),
                  )}
                  {pill(
                    pillLabelWithCount("Social", pillCounts?.groups?.Social),
                    group === "Social",
                    () => onChange({ group: "Social" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "No Group",
                      pillCounts?.groups?.UNGROUPED,
                    ),
                    group === "UNGROUPED",
                    () => onChange({ group: "UNGROUPED" }),
                  )}
                </div>
              </div>

              <div className="space-y-1">
                <div className="text-[10px] text-[#6b7a9f] font-semibold">
                  S&amp;P Sectors
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  {pill(
                    pillLabelWithCount("All", pillCounts?.sectors?.ALL),
                    sector === "ALL",
                    () => onChange({ sector: undefined }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "S&P Sectors",
                      pillCounts?.sectors?.SP_Sectors,
                    ),
                    group === "SP_Sectors",
                    () => onChange({ group: "SP_Sectors" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Communication Services")} Comm`,
                      pillCounts?.sectors?.["Communication Services"],
                    ),
                    sector === "Communication Services",
                    () => onChange({ sector: "Communication Services" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Consumer Discretionary")} Cons Disc`,
                      pillCounts?.sectors?.["Consumer Discretionary"],
                    ),
                    sector === "Consumer Discretionary",
                    () => onChange({ sector: "Consumer Discretionary" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Consumer Staples")} Cons Staples`,
                      pillCounts?.sectors?.["Consumer Staples"],
                    ),
                    sector === "Consumer Staples",
                    () => onChange({ sector: "Consumer Staples" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Energy")} Energy`,
                      pillCounts?.sectors?.Energy,
                    ),
                    sector === "Energy",
                    () => onChange({ sector: "Energy" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Financials")} Financials`,
                      pillCounts?.sectors?.Financials,
                    ),
                    sector === "Financials",
                    () => onChange({ sector: "Financials" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Healthcare")} Health`,
                      pillCounts?.sectors?.Healthcare,
                    ),
                    sector === "Healthcare",
                    () => onChange({ sector: "Healthcare" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Industrials")} Industrials`,
                      pillCounts?.sectors?.Industrials,
                    ),
                    sector === "Industrials",
                    () => onChange({ sector: "Industrials" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Information Technology")} Tech`,
                      pillCounts?.sectors?.["Information Technology"],
                    ),
                    sector === "Information Technology",
                    () => onChange({ sector: "Information Technology" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Basic Materials")} Materials`,
                      pillCounts?.sectors?.["Basic Materials"],
                    ),
                    sector === "Basic Materials",
                    () => onChange({ sector: "Basic Materials" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Real Estate")} Real Estate`,
                      pillCounts?.sectors?.["Real Estate"],
                    ),
                    sector === "Real Estate",
                    () => onChange({ sector: "Real Estate" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Utilities")} Utilities`,
                      pillCounts?.sectors?.Utilities,
                    ),
                    sector === "Utilities",
                    () => onChange({ sector: "Utilities" }),
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      }

      function ActiveMovesSnapshotPanel({
        tickers = [],
        rankPositions = {},
        onSelectTicker = null,
        allData = null,
        defaultLimit = 12,
        storageKey = "timedTrading_activeMovesSnapshot_v1",
        title = "Active Moves (snapshot)",
      }) {
        // Hover tooltip (replaces tiny default browser "title" tooltip)
        const [hoverTip, setHoverTip] = React.useState(null);
        const [hoverTipPos, setHoverTipPos] = React.useState({ x: 0, y: 0 });

        const updateHoverTipPos = React.useCallback((e) => {
          try {
            const vw =
              typeof window !== "undefined" ? Number(window.innerWidth) : 1200;
            const vh =
              typeof window !== "undefined" ? Number(window.innerHeight) : 800;
            const MAX_W = 360;
            const MAX_H = 220; // conservative clamp (multi-line tips)
            const PAD = 12;
            const x0 = Number(e?.clientX) || 0;
            const y0 = Number(e?.clientY) || 0;
            const x = Math.max(
              PAD,
              Math.min(x0 + 12, Math.max(PAD, vw - MAX_W - PAD)),
            );
            const y = Math.max(
              PAD,
              Math.min(y0 + 12, Math.max(PAD, vh - MAX_H - PAD)),
            );
            setHoverTipPos({ x, y });
          } catch {
            // ignore
          }
        }, []);

        const showHoverTip = React.useCallback(
          (text, e) => {
            const t = String(text || "").trim();
            if (!t) return;
            updateHoverTipPos(e);
            setHoverTip(t);
          },
          [updateHoverTipPos],
        );

        const hideHoverTip = React.useCallback(() => {
          setHoverTip(null);
        }, []);

        const [snap, setSnap] = React.useState(() => {
          try {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || !Array.isArray(parsed.items)) return null;
            return parsed;
          } catch {
            return null;
          }
        });

        const buildSnapshot = React.useCallback(
          (sourceTickers) => {
            const list = Array.isArray(sourceTickers) ? sourceTickers : [];
            const items = [];
            for (const t of list) {
              if (!t?.ticker) continue;
              const mv = getMoveStatusInfo(t);
              // Do not include items without an explicit move_status (prevents snapshot/right-rail mismatch)
              if (!mv.hasMoveStatus) continue;
              if (mv.status !== "ACTIVE") continue;
              const triggerTs = Number(t?.trigger_ts);
              if (!Number.isFinite(triggerTs) || triggerTs <= 0) continue; // only "real" moves
              const sym = String(t.ticker).toUpperCase();
              const rp =
                getRankPositionFromMap(rankPositions, sym) ??
                Number(t?.rank_position);
              const inCorridor = !!entryType(t)?.corridor;
              const rr = Number(t?.rr);
              const flags =
                t?.flags && typeof t.flags === "object" ? t.flags : {};
              const momentumElite = !!flags.momentum_elite;
              const sqRelease = !!flags.sq30_release;
              const inSqueeze = !!flags.sq30_on && !flags.sq30_release;
              const thesis = flags.thesis_match === true;
              const prime = isPrimeBubble(t);
              const winnerSig = isWinnerSignature(t);
              const flipWatch = !!flags.flip_watch;
              const sl = Number(
                t?.sl ??
                  t?.sl_price ??
                  t?.stop_loss ??
                  t?.stop ??
                  t?.trade?.sl ??
                  t?.trade?.sl_price,
              );
              const tpTarget = computeTpTargetPrice(t);
              const tpMax = computeTpMaxPrice(t);
              const tp = Number(
                t?.tp ??
                  t?.tp_price ??
                  tpTarget ??
                  tpMax ??
                  t?.tp_target_price ??
                  t?.tp_max_price,
              );
              const eta = computeEtaDays(t);
              const price = Number(t?.price ?? t?.close ?? t?.c ?? t?.last);
              const intent = classifyEntryIntent(t);
              const progRaw = computeMoveProgressPct(t);
              const comp = completionForSize(t);
              const progress = Number.isFinite(progRaw)
                ? progRaw
                : Number.isFinite(comp)
                  ? comp
                  : null;
              const phase = Number(t?.phase_pct);
              const age = formatAgeFromTs(triggerTs);
              items.push({
                sym,
                rp: Number.isFinite(rp) ? rp : null,
                inCorridor,
                rr: Number.isFinite(rr) ? rr : null,
                progress: Number.isFinite(progress) ? progress : null,
                phase: Number.isFinite(phase) ? phase : null,
                age,
                momentumElite,
                sqRelease,
                inSqueeze,
                thesis,
                prime,
                winnerSig,
                flipWatch,
                sl: Number.isFinite(sl) && sl > 0 ? sl : null,
                tp: Number.isFinite(tp) && tp > 0 ? tp : null,
                eta: Number.isFinite(eta) && eta > 0 ? eta : null,
                price: Number.isFinite(price) && price > 0 ? price : null,
                intent,
                t,
              });
            }
            items.sort((a, b) => {
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              if (a.rp != null) return -1;
              if (b.rp != null) return 1;
              return a.sym.localeCompare(b.sym);
            });
            const out = {
              createdAt: Date.now(),
              items: items.slice(0, Math.max(1, defaultLimit)),
            };
            try {
              localStorage.setItem(storageKey, JSON.stringify(out));
            } catch {}
            return out;
          },
          [defaultLimit, rankPositions, storageKey],
        );

        const MAX_SNAPSHOT_AGE_MS = 60 * 60 * 1000; // 60 minutes

        // Initialize snapshot once when we have data (but do NOT keep it in sync).
        React.useEffect(() => {
          if (snap && Array.isArray(snap.items) && snap.items.length > 0) {
            const ageOk =
              Number.isFinite(Number(snap.createdAt)) &&
              Date.now() - Number(snap.createdAt) <= MAX_SNAPSHOT_AGE_MS;
            if (ageOk) return;
          }
          if (!Array.isArray(tickers) || tickers.length === 0) return;
          setSnap(buildSnapshot(tickers));
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [tickers, buildSnapshot]);

        const onRefresh = React.useCallback(() => {
          setSnap(buildSnapshot(tickers));
        }, [buildSnapshot, tickers]);

        const onClear = React.useCallback(() => {
          setSnap(null);
          try {
            localStorage.removeItem(storageKey);
          } catch {}
        }, [storageKey]);

        const asOf = snap?.createdAt ? new Date(Number(snap.createdAt)) : null;
        const rows = Array.isArray(snap?.items) ? snap.items : [];

        const grouped = React.useMemo(() => {
          const groups = {};
          for (const r of rows) {
            const g = String(r?.intent?.group || "Unclear / Chop");
            if (!groups[g]) groups[g] = [];
            groups[g].push(r);
          }
          const order = [
            "Squeeze ‚Üí Momentum",
            "Momentum Elite",
            "Corridor reclaim",
            "Trend continuation",
            "Squeeze pressure build",
            "Late-cycle / Overextended",
            "Unclear / Chop",
          ];
          const keys = Object.keys(groups);
          keys.sort((a, b) => {
            const ia = order.indexOf(a);
            const ib = order.indexOf(b);
            if (ia !== -1 && ib !== -1) return ia - ib;
            if (ia !== -1) return -1;
            if (ib !== -1) return 1;
            return a.localeCompare(b);
          });
          return keys.map((k) => ({ group: k, items: groups[k] }));
        }, [rows]);

        const actionPill = (action) => {
          const a = String(action || "").toUpperCase();
          if (a === "ENTRY")
            return {
              label: "ENTRY",
              cls: "bg-green-500/15 text-green-300 border-green-500/40",
            };
          if (a === "EXIT")
            return {
              label: "EXIT",
              cls: "bg-red-500/15 text-red-300 border-red-500/40",
            };
          if (a === "WAIT")
            return {
              label: "WAIT",
              cls: "bg-yellow-500/10 text-yellow-200 border-yellow-500/30",
            };
          return {
            label: "HOLD",
            cls: "bg-blue-500/10 text-blue-200 border-blue-500/30",
          };
        };

        if (rows.length === 0) {
          return (
            <div className="text-xs text-[#6b7a9f] p-3 text-center">
              No open positions yet
            </div>
          );
        }

        return (
          <>
            <div className="space-y-4">
              {grouped.map((g) => (
                <div key={`active-group-${g.group}`}>
                  <div className="flex items-center justify-between mb-2">
                    <div className="text-[12px] font-bold text-[#e7ecff]">
                      {g.group}
                    </div>
                    <div className="text-[11px] text-[#6b7a9f]">
                      {g.items.length}
                    </div>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-2">
                    {g.items.map((r) => {
                    const mv = getMoveStatusInfo(r.t);
                    const dir = mv.side || getDirection(r.t)?.text || "";
                    const latest =
                      allData && typeof allData === "object"
                        ? allData[r.sym] ||
                          allData[String(r.sym).toUpperCase()] ||
                          null
                        : null;
                    const curMv = latest ? getMoveStatusInfo(latest) : null;
                    const statusChanged =
                      curMv &&
                      curMv.hasMoveStatus &&
                      curMv.status &&
                      curMv.status !== mv.status;
                    const rrText = r.rr != null ? r.rr.toFixed(2) : "‚Äî";
                    const rpText = r.rp != null ? `#${r.rp}` : "‚Äî";
                    const p =
                      r.progress != null
                        ? Math.max(0, Math.min(1, r.progress))
                        : null;
                    const pPct = p != null ? Math.round(p * 100) : null;
                    const phasePct = Number.isFinite(r.phase)
                      ? Math.round(r.phase * 100)
                      : null;
                    const corridor = r.inCorridor
                      ? "In corridor"
                      : "Out of corridor";
                    const corridorCls = r.inCorridor
                      ? "text-green-300"
                      : "text-yellow-300";
                    const badges = [
                      r.flipWatch ? "üéØ" : null,
                      r.momentumElite ? "üöÄ" : null,
                      r.thesis ? "üß†" : null,
                      r.prime ? "‚≠ê" : null,
                      r.winnerSig ? "üèÜ" : null,
                      r.sqRelease ? "‚ö°" : null,
                      r.inSqueeze ? "üß®" : null,
                    ].filter(Boolean);
                    const emojiText = badges.join("");
                    const pxText =
                      r.price != null ? `$${r.price.toFixed(2)}` : "‚Äî";
                    const slText = r.sl != null ? `$${r.sl.toFixed(2)}` : "‚Äî";
                    const tpText = r.tp != null ? `$${r.tp.toFixed(2)}` : "‚Äî";
                    const etaText =
                      r.eta != null ? `${r.eta.toFixed(1)}d` : "‚Äî";
                    const act = actionPill(r?.intent?.action);
                    const conf = Number(r?.intent?.confidence);
                    const confPct = Number.isFinite(conf)
                      ? Math.round(conf * 100)
                      : null;
                    const why = Array.isArray(r?.intent?.why)
                      ? r.intent.why.slice(0, 3)
                      : [];
                    const meTip = (() => {
                      const crit = r.t?.momentum_elite_criteria;
                      if (!r.momentumElite) return null;
                      if (!crit || typeof crit !== "object")
                        return "Momentum Elite";
                      const c = crit;
                      const parts = [];
                      if (c.priceOver4 != null)
                        parts.push(`Price>=4: ${c.priceOver4 ? "Y" : "N"}`);
                      if (c.adrOver2 != null)
                        parts.push(`ADR>=2: ${c.adrOver2 ? "Y" : "N"}`);
                      if (c.volumeOver2M != null)
                        parts.push(`Vol>=2M: ${c.volumeOver2M ? "Y" : "N"}`);
                      if (c.anyMomentumCriteria != null)
                        parts.push(
                          `1M>=25%: ${c.anyMomentumCriteria ? "Y" : "N"}`,
                        );
                      return parts.length
                        ? `Momentum Elite ‚Ä¢ ${parts.join(" ‚Ä¢ ")}`
                        : "Momentum Elite";
                    })();
                    return (
                      <button
                        key={`active-move-${r.sym}`}
                        className={`w-full text-left rounded-lg border bg-[#121a33] hover:bg-[#16224a] transition-all px-3 py-2 ${
                          r.momentumElite
                            ? "border-purple-500/50 hover:border-purple-400 shadow-[0_0_0_1px_rgba(168,85,247,0.18)]"
                            : "border-[#26325f] hover:border-[#3a4aa0]"
                        }`}
                        onClick={() => {
                          if (typeof onSelectTicker === "function")
                            onSelectTicker(r.sym);
                        }}
                        aria-label={`Open ${r.sym} in right rail`}
                        onMouseLeave={hideHoverTip}
                      >
                        <div className="flex items-start justify-between gap-2">
                          <div className="min-w-0">
                            <div className="flex items-center gap-2 flex-wrap">
                              <div className="font-bold text-white">
                                {r.sym}
                              </div>
                              <span className="px-2 py-0.5 rounded bg-green-500/25 text-green-300 text-[10px] font-bold border border-green-500/60 shadow-sm">
                                OPEN
                              </span>
                              <span
                                className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${act.cls}`}
                              >
                                {act.label}
                                {confPct != null ? (
                                  <span className="ml-1 opacity-80">
                                    {confPct}%
                                  </span>
                                ) : null}
                              </span>
                              <span
                                className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${mv.pillCls}`}
                              >
                                {mv.icon} {mv.status}
                              </span>
                              {statusChanged ? (
                                <span
                                  className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${curMv.pillCls}`}
                                  onMouseEnter={(e) =>
                                    showHoverTip(
                                      "Live status differs from snapshot",
                                      e,
                                    )
                                  }
                                  onMouseMove={updateHoverTipPos}
                                  onMouseLeave={hideHoverTip}
                                >
                                  Now: {curMv.icon} {curMv.status}
                                </span>
                              ) : null}
                              {emojiText ? (
                                <span
                                  className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] font-semibold text-[#e7ecff]"
                                  onMouseEnter={(e) =>
                                    meTip ? showHoverTip(meTip, e) : undefined
                                  }
                                  onMouseMove={updateHoverTipPos}
                                  onMouseLeave={hideHoverTip}
                                >
                                  {emojiText}
                                </span>
                              ) : null}
                              {dir ? (
                                <span className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] text-[#c8d2ff]">
                                  {dir}
                                </span>
                              ) : null}
                              <span className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] text-[#93a4d6]">
                                Rank {rpText}
                              </span>
                              <span className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] text-[#93a4d6]">
                                RR {rrText}
                              </span>
                              {r.age ? (
                                <span className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] text-[#6b7a9f]">
                                  Trigger {r.age} ago
                                </span>
                              ) : null}
                            </div>
                            <div className="mt-1 text-[11px]">
                              <span className={`font-semibold ${corridorCls}`}>
                                {corridor}
                              </span>
                              {mv.headlineReason ? (
                                <span className="text-[#6b7a9f]">
                                  {" "}
                                  ‚Ä¢ {mv.headlineReason}
                                </span>
                              ) : null}
                            </div>
                            {why.length > 0 ? (
                              <div className="mt-1 text-[10px] text-[#6b7a9f]">
                                {why.join(" ‚Ä¢ ")}
                              </div>
                            ) : null}
                            <div className="mt-1 text-[10px] text-[#6b7a9f] flex items-center gap-3 flex-wrap">
                              <span>
                                <span className="text-[#93a4d6]">Px</span>{" "}
                                <span className="text-white font-semibold">
                                  {pxText}
                                </span>
                              </span>
                              <span>
                                <span className="text-[#93a4d6]">SL</span>{" "}
                                <span className="text-red-300 font-semibold">
                                  {slText}
                                </span>
                              </span>
                              <span>
                                <span className="text-[#93a4d6]">TP</span>{" "}
                                <span className="text-green-300 font-semibold">
                                  {tpText}
                                </span>
                              </span>
                              <span>
                                <span className="text-[#93a4d6]">ETA</span>{" "}
                                <span className="text-[#e7ecff] font-semibold">
                                  {etaText}
                                </span>
                              </span>
                            </div>
                          </div>
                          <div className="flex-shrink-0 text-right">
                            <div className="text-[11px] text-[#93a4d6]">
                              Progress
                            </div>
                            <div className="text-[12px] font-bold text-white">
                              {pPct != null ? `${pPct}%` : "‚Äî"}
                            </div>
                          </div>
                        </div>

                        <div className="mt-2">
                          <div className="h-2 rounded bg-[#0f1630] border border-[#26325f] overflow-hidden">
                            <div
                              className="h-full"
                              style={{
                                width: `${pPct != null ? pPct : 0}%`,
                                background:
                                  pPct != null ? "#22c55e" : "#26325f",
                              }}
                            />
                          </div>
                          <div className="mt-1 flex items-center justify-between text-[10px] text-[#6b7a9f]">
                            <span>
                              {phasePct != null
                                ? `Phase ${phasePct}%`
                                : "Phase ‚Äî"}
                            </span>
                            <span>
                              {r.price != null ? `$${r.price.toFixed(2)}` : "‚Äî"}
                            </span>
                          </div>
                        </div>
                      </button>
                    );
                    })}
                  </div>
                </div>
              ))}
            </div>

            {hoverTip && (
              <div
                className="fixed z-[9999] max-w-[360px] pointer-events-none bg-[#0b1020]/95 backdrop-blur-sm border border-[#3a4aa0] rounded-lg shadow-2xl px-3 py-2 text-[12px] leading-snug text-[#e7ecff]"
                style={{ left: hoverTipPos.x, top: hoverTipPos.y }}
                role="tooltip"
              >
                {hoverTip}
              </div>
            )}
          </>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Action Center: Unified panel for Early Movers + Active Positions
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function ActionCenterPanel({
        tickers = [],
        allTickersWithRanks = [],
        rankPositions = {},
        onSelectTicker = null,
        allData = null,
        defaultLimit = 12,
        storageKey = "timedTrading_activeMovesSnapshot_v1",
      }) {
        const [expandedSections, setExpandedSections] = React.useState({
          earlyMovers: true,
          activePositions: true,
        });

        const toggleSection = (section) => {
          setExpandedSections((prev) => ({
            ...prev,
            [section]: !prev[section],
          }));
        };

        // Early Movers logic
        const flipWatch = tickers
          .filter((t) => {
            const flags = t?.flags || {};
            return !!flags.flip_watch;
          })
          .slice(0, 8);

        const justFlipped = tickers
          .filter((t) => {
            const state = String(t?.state || "");
            const isMomentum =
              state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
            if (!isMomentum) return false;
            const seq = t?.seq || {};
            const corridorEntry = seq.corridorEntry_60m === true;
            return corridorEntry;
          })
          .slice(0, 8);

        const highProb = tickers
          .filter((t) => {
            const ent = entryType(t);
            const flags = t?.flags || {};
            return ent?.corridor && flags.sq30_release;
          })
          .slice(0, 8);

        const hasEarlyMovers =
          flipWatch.length > 0 || justFlipped.length > 0 || highProb.length > 0;
        const earlyMoversCount =
          flipWatch.length + justFlipped.length + highProb.length;

        // Active Positions snapshot logic
        const [snap, setSnap] = React.useState(() => {
          try {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || !Array.isArray(parsed.items)) return null;
            return parsed;
          } catch {
            return null;
          }
        });

        const buildSnapshot = React.useCallback(
          (sourceTickers) => {
            const list = Array.isArray(sourceTickers) ? sourceTickers : [];
            const items = [];
            for (const t of list) {
              if (!t?.ticker) continue;
              const mv = getMoveStatusInfo(t);
              if (!mv.hasMoveStatus) continue;
              if (mv.status !== "ACTIVE") continue;
              const triggerTs = Number(t?.trigger_ts);
              if (!Number.isFinite(triggerTs) || triggerTs <= 0) continue;
              const sym = String(t.ticker).toUpperCase();
              const rp =
                getRankPositionFromMap(rankPositions, sym) ??
                Number(t?.rank_position);
              const inCorridor = !!entryType(t)?.corridor;
              const rr = Number(t?.rr);
              const flags =
                t?.flags && typeof t.flags === "object" ? t.flags : {};
              const momentumElite = !!flags.momentum_elite;
              const sqRelease = !!flags.sq30_release;
              const inSqueeze = !!flags.sq30_on && !flags.sq30_release;
              const thesis = flags.thesis_match === true;
              const prime = isPrimeBubble(t);
              const winnerSig = isWinnerSignature(t);
              const flipWatch = !!flags.flip_watch;
              const sl = Number(
                t?.sl ??
                  t?.sl_price ??
                  t?.stop_loss ??
                  t?.stop ??
                  t?.trade?.sl ??
                  t?.trade?.sl_price,
              );
              const tpTarget = computeTpTargetPrice(t);
              const tpMax = computeTpMaxPrice(t);
              const tp = Number(
                t?.tp ??
                  t?.tp_price ??
                  tpTarget ??
                  tpMax ??
                  t?.tp_target_price ??
                  t?.tp_max_price,
              );
              const eta = computeEtaDays(t);
              const price = Number(t?.price ?? t?.close ?? t?.c ?? t?.last);
              const intent = classifyEntryIntent(t);
              const progRaw = computeMoveProgressPct(t);
              const comp = completionForSize(t);
              const progress = Number.isFinite(progRaw)
                ? progRaw
                : Number.isFinite(comp)
                  ? comp
                  : null;
              const phase = Number(t?.phase_pct);
              const age = formatAgeFromTs(triggerTs);
              items.push({
                sym,
                rp: Number.isFinite(rp) ? rp : null,
                inCorridor,
                rr: Number.isFinite(rr) ? rr : null,
                progress: Number.isFinite(progress) ? progress : null,
                phase: Number.isFinite(phase) ? phase : null,
                age,
                momentumElite,
                sqRelease,
                inSqueeze,
                thesis,
                prime,
                winnerSig,
                flipWatch,
                sl: Number.isFinite(sl) && sl > 0 ? sl : null,
                tp: Number.isFinite(tp) && tp > 0 ? tp : null,
                eta: Number.isFinite(eta) && eta > 0 ? eta : null,
                price: Number.isFinite(price) && price > 0 ? price : null,
                intent,
                t,
              });
            }
            items.sort((a, b) => {
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              if (a.rp != null) return -1;
              if (b.rp != null) return 1;
              return a.sym.localeCompare(b.sym);
            });
            const out = {
              createdAt: Date.now(),
              items: items.slice(0, Math.max(1, defaultLimit)),
            };
            try {
              localStorage.setItem(storageKey, JSON.stringify(out));
            } catch {}
            return out;
          },
          [defaultLimit, rankPositions, storageKey],
        );

        const MAX_SNAPSHOT_AGE_MS = 60 * 60 * 1000;

        React.useEffect(() => {
          if (snap && Array.isArray(snap.items) && snap.items.length > 0) {
            const ageOk =
              Number.isFinite(Number(snap.createdAt)) &&
              Date.now() - Number(snap.createdAt) <= MAX_SNAPSHOT_AGE_MS;
            if (ageOk) return;
          }
          if (
            !Array.isArray(allTickersWithRanks) ||
            allTickersWithRanks.length === 0
          )
            return;
          setSnap(buildSnapshot(allTickersWithRanks));
        }, [allTickersWithRanks, buildSnapshot, snap]);

        const onRefresh = React.useCallback(() => {
          setSnap(buildSnapshot(allTickersWithRanks));
        }, [buildSnapshot, allTickersWithRanks]);

        const onClear = React.useCallback(() => {
          setSnap(null);
          try {
            localStorage.removeItem(storageKey);
          } catch {}
        }, [storageKey]);

        const asOf = snap?.createdAt ? new Date(Number(snap.createdAt)) : null;
        const rows = Array.isArray(snap?.items) ? snap.items : [];
        const activePositionsCount = rows.length;
        const rankTotal =
          rankPositions && typeof rankPositions === "object"
            ? Object.keys(rankPositions).length
            : null;

        // Calculate Kanban count for display (EarlyMoversPanel will handle actual categorization)
        const kanbanCount = hasEarlyMovers ? earlyMoversCount : 0;

        // Show panel if we have either early movers or active positions
        if (!hasEarlyMovers && activePositionsCount === 0) {
          return null;
        }

        return (
          <div className="mb-4 rounded-xl border-2 border-[#3a4a7f] bg-[#0a0f24] p-4">
            <div className="mb-4">
              <div className="text-lg font-bold text-white flex items-center gap-2">
                üéØ Action Center
                <span className="text-[13px] font-normal text-[#6b7a9f]">
                  Trading Lifecycle Flow
                </span>
              </div>
              <div className="mt-1 text-[10px] text-[#6b7a9f]">
                Rank = viewport score rank (relative strength)
                {rankTotal ? ` (1‚Äì${rankTotal}, 1 is strongest)` : ""}. ‚ÄúEnter
                Now‚Äù also requires trigger/corridor/completion gates, so a top-5
                name can still be Watch/Hold/Trim.
              </div>
              <div className="mt-1 text-[11px] text-[#93a4d6]">
                {kanbanCount} tickers in play ‚Ä¢ Flip Watch ‚Üí Enter ‚Üí Hold ‚Üí
                Defend ‚Üí Trim ‚Üí Exit
              </div>
            </div>

            {/* Kanban Trading Flow */}
            {kanbanCount > 0 && (
              <div className="mb-4">
                <button
                  onClick={() => toggleSection("earlyMovers")}
                  className="w-full flex items-center justify-between p-3 rounded-lg bg-gradient-to-r from-amber-500/10 via-blue-500/10 to-green-500/10 border-2 border-[#3a4a7f] hover:border-[#4a5a8f] transition-all mb-3"
                >
                  <div className="flex items-center gap-2 flex-wrap">
                    <span className="text-sm font-bold text-white">
                      üìä Trading Pipeline
                    </span>
                    <span className="px-2 py-0.5 rounded bg-purple-500/30 text-purple-200 text-[10px] font-bold border border-purple-400/60">
                      {kanbanCount} active
                    </span>
                    <span className="text-[10px] text-[#93a4d6]">
                      üéØ Watch ‚Üí ‚ö° Flip ‚Üí üöÄ Enter ‚Üí üíé Hold ‚Üí üõ° Defend ‚Üí üìä
                      Trim ‚Üí üö™ Exit
                    </span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-[10px] text-[#6b7a9f]">
                      Horizontal flow
                    </span>
                    <span className="text-[#93a4d6]">
                      {expandedSections.earlyMovers ? "‚ñº" : "‚ñ∂"}
                    </span>
                  </div>
                </button>

                {expandedSections.earlyMovers && (
                  <div className="bg-[#0f1630] rounded-lg p-3 border border-[#26325f]">
                    <EarlyMoversPanel
                      tickers={tickers}
                      onSelectTicker={onSelectTicker}
                      rankPositions={rankPositions}
                      rankTotal={rankTotal}
                    />
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Early Movers Panel: Kanban-style trading flow
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function EarlyMoversPanel({
        tickers = [],
        onSelectTicker = null,
        rankPositions = {},
        rankTotal = null,
      }) {
        const now = Date.now();
        const laneScrollTopRef = React.useRef({});
        const [expandedTicker, setExpandedTicker] = React.useState(null);
        const toggleExpanded = (sym) => {
          const t = String(sym || "").toUpperCase();
          if (!t) return;
          setExpandedTicker((cur) =>
            String(cur || "").toUpperCase() === t ? null : t,
          );
        };

        // Categorize tickers into Kanban columns using Worker-provided stage (with client-side fallback)
        const categories = React.useMemo(() => {
          const watch = [];
          const archive = [];
          const flipWatch = [];
          const justFlipped = [];
          const enterNow = [];
          const hold = [];
          const defend = [];
          const trim = [];
          const exit = [];

          tickers.forEach((t) => {
            // Skip tickers with explicitly null kanban_stage (reset/cleared state)
            if (t?.kanban_stage === null) {
              return;
            }
            
            let stage = String(t?.kanban_stage || "");

            // Fallback: If Worker hasn't assigned stage yet, classify client-side
            if (!stage) {
              const flags = t?.flags || {};
              const state = String(t?.state || "");
              const mv = getMoveStatusInfo(t);
              const intent = classifyEntryIntent(t);
              const action = String(intent?.action || "").toUpperCase();
              const confidence = Number(intent?.confidence) || 0;
              const completion = Number(t?.completion) || 0;
              const phase = Number(t?.phase_pct) || 0;
              const isMomentum =
                state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
              const seq = t?.seq || {};
              const isActive = mv.status === "ACTIVE";
              const rank = Number(t?.rank) || 999;
              const htfScore = Number(t?.htf_score) || 0;
              const ltfScore = Number(t?.ltf_score) || 0;

              // Classify based on same logic as Worker
              if (mv.status === "INVALIDATED" || mv.status === "COMPLETED") {
                stage = "archive";
              } else if (isActive) {
                const severity = mv?.severity || "NONE";
                const reasons = mv?.reasons || [];
                if (
                  severity === "CRITICAL" ||
                  reasons.includes("left_entry_corridor")
                ) {
                  stage = "exit";
                } else if (
                  severity === "WARNING" &&
                  completion < 0.7 &&
                  phase < 0.7
                ) {
                  stage = "defend";
                } else if (
                  completion >= 0.7 ||
                  (phase >= 0.7 && severity === "WARNING")
                ) {
                  stage = "trim";
                } else {
                  stage = "hold";
                }
              } else if (flags.flip_watch) {
                stage = "flip_watch";
              } else if (isMomentum && seq.corridorEntry_60m === true) {
                stage = "just_flipped";
              } else if (isMomentum) {
                const ent = entryType(t);
                if (
                  rank <= 10 ||
                  flags.thesis_match ||
                  flags.momentum_elite ||
                  (Math.abs(htfScore) >= 50 && Math.abs(ltfScore) >= 25) ||
                  (ent?.corridor && flags.sq30_release)
                ) {
                  stage = "enter_now";
                } else {
                  stage = "watch";
                }
              }
            }

            // Assign to column based on stage
            switch (stage) {
              case "watch":
                watch.push(t);
                break;
              case "flip_watch":
                flipWatch.push(t);
                break;
              case "just_flipped":
                justFlipped.push(t);
                break;
              case "enter_now":
                enterNow.push(t);
                break;
              case "hold":
                hold.push(t);
                break;
              case "defend":
                defend.push(t);
                break;
              case "trim":
                trim.push(t);
                break;
              case "exit":
                exit.push(t);
                break;
              case "archive":
                archive.push(t);
                break;
              default:
                // No stage assigned - not in pipeline
                break;
            }
          });

          return {
            watch,
            flipWatch,
            justFlipped,
            enterNow,
            hold,
            defend,
            trim,
            exit,
            archive,
          };
        }, [tickers]);

        const {
          watch,
          flipWatch,
          justFlipped,
          enterNow,
          hold,
          defend,
          trim,
          exit,
          archive,
        } = categories;

        // Compact card renderer for Kanban layout
        const renderCompactCard = (
          t,
          showProgress = false,
          showOpen = false,
          showDetails = false,
        ) => {
          const state = String(t?.state || "");
          const isBullish = state.includes("BULL");
          const dir = isBullish ? "LONG" : "SHORT";
          const dirEmoji = isBullish ? "üìà" : "üìâ";
          const stage = String(t?.kanban_stage || "");
          const sym = String(t?.ticker || "").toUpperCase();
          const isExpanded =
            expandedTicker != null &&
            String(expandedTicker).toUpperCase() === sym;
          const showDetailsCard = !!isExpanded && !!showDetails;
          const flags = t?.flags || {};
          const rank = Number(t?.rank);
          const rankPos = getRankPositionFromMap(
            rankPositions,
            String(t?.ticker || "").toUpperCase(),
          );
          const score = Number(t?.flip_watch_score);
          const completion = Number(t?.completion);
          const phase = Number(t?.phase_pct);
          const price = Number(t?.price);
          const htf = Number(t?.htf_score);
          const ltf = Number(t?.ltf_score);

          // Compute SL/TP using helper functions (works for both positions and opportunities)
          const slRaw = Number(t?.sl ?? t?.sl_price ?? t?.stop_loss ?? t?.stop);
          const sl = Number.isFinite(slRaw) && slRaw > 0 ? slRaw : null;

          // Use computeTpMaxPrice() like the Right Rail does for consistency
          const tpMax = computeTpMaxPrice(t);
          const tp = tpMax || computeTpTargetPrice(t);

          const rr = Number(t?.rr);
          const rrEntryLikely = Number(t?.rr_entry_likely);
          const rrNowLikely = Number(t?.rr_now_likely);
          const slDynamic = Number(t?.sl_dynamic);
          const tpLikely = Number(t?.tp_likely);
          const eta = computeEtaDays(t);

          // Entry tracking and % change
          const entryPriceRaw = numFromAny(t?.entry_price);
          const entryRefRaw = numFromAny(t?.entry_ref);
          const triggerPriceRaw = numFromAny(t?.trigger_price);
          const entryPrice =
            Number.isFinite(entryPriceRaw) && entryPriceRaw > 0
              ? entryPriceRaw
              : Number.isFinite(entryRefRaw) && entryRefRaw > 0
                ? entryRefRaw
                : Number.isFinite(triggerPriceRaw) && triggerPriceRaw > 0
                  ? triggerPriceRaw
                  : null;
          const entryChangePctRaw = numFromAny(t?.entry_change_pct);
          const entryChangePct = Number.isFinite(entryChangePctRaw)
            ? entryChangePctRaw
            : Number.isFinite(entryPrice) &&
                entryPrice > 0 &&
                Number.isFinite(price) &&
                price > 0
              ? dir === "LONG"
                ? ((price - entryPrice) / entryPrice) * 100
                : ((entryPrice - price) / entryPrice) * 100
              : null;
          const showEntryStats =
            stage === "enter_now" ||
            stage === "hold" ||
            stage === "trim" ||
            stage === "exit";

          // Highlight recently transitioned cards
          const prevLane =
            t?.prev_kanban_stage != null ? String(t.prev_kanban_stage) : "";
          const prevLaneTsRaw = Number(t?.prev_kanban_stage_ts);
          // Be tolerant: sometimes timestamps are seconds, sometimes ms.
          const prevLaneTs =
            Number.isFinite(prevLaneTsRaw) && prevLaneTsRaw > 0
              ? prevLaneTsRaw < 1e12
                ? prevLaneTsRaw * 1000
                : prevLaneTsRaw
              : NaN;
          const movedRecently =
            !!prevLane &&
            prevLane !== stage &&
            stage !== "archive" &&
            Number.isFinite(prevLaneTs) &&
            Date.now() - prevLaneTs < 30 * 60 * 1000; // 30m

          // Transition direction (forward progression vs backtrack) for styling.
          const laneOrder = {
            watch: 0,
            flip_watch: 1,
            just_flipped: 2,
            enter_now: 3,
            hold: 4,
            defend: 5,
            trim: 6,
            exit: 7,
            archive: 8,
          };
          const prevIdx =
            prevLane && laneOrder[prevLane] != null
              ? Number(laneOrder[prevLane])
              : -1;
          const curIdx =
            stage && laneOrder[stage] != null ? Number(laneOrder[stage]) : -1;
          const isBacktrack =
            movedRecently && prevIdx >= 0 && curIdx >= 0 && curIdx < prevIdx;
          const isForward =
            movedRecently && prevIdx >= 0 && curIdx >= 0 && curIdx > prevIdx;
          const transitionCardClass = movedRecently
            ? isBacktrack
              ? "border-fuchsia-400/60 ring-1 ring-fuchsia-400/30 shadow-[0_0_0_1px_rgba(217,70,239,0.14)]"
              : isForward
                ? "border-white/40 ring-1 ring-white/15 shadow-[0_0_0_1px_rgba(255,255,255,0.10)]"
                : "border-cyan-400/60 ring-1 ring-cyan-400/30 shadow-[0_0_0_1px_rgba(34,211,238,0.12)]"
            : null;

          // Archive meta (worker-provided)
          const km =
            t?.kanban_meta && typeof t.kanban_meta === "object"
              ? t.kanban_meta
              : null;
          const archiveEmoji = km?.emoji ? String(km.emoji) : "";
          const archiveBucket = km?.bucket ? String(km.bucket) : "";
          const archiveReason = km?.reason ? String(km.reason) : "";

          // Emoji badges for flags
          const badges = [];
          if (flags.flip_watch) badges.push("üéØ");
          if (flags.momentum_elite) badges.push("üöÄ");
          if (flags.thesis_match) badges.push("üß†");
          if (isPrimeBubble(t)) badges.push("‚≠ê");
          if (isWinnerSignature(t)) badges.push("üèÜ");
          if (flags.sq30_release) badges.push("‚ö°");
          if (flags.sq30_on && !flags.sq30_release) badges.push("üß®");
          if (archiveEmoji) badges.push(archiveEmoji);

          // Daily change (for tint + display):
          // Prefer getDailyChange() (staleness-aware), but fall back to raw fields so cards
          // still show a consistent background even when the stale gate hides dayPct.
          const pickNum = (obj, keys) => {
            for (const k of keys) {
              const v = Number(obj?.[k]);
              if (Number.isFinite(v)) return v;
            }
            return null;
          };
          const priceNum = Number(t?.price);
          const prevCloseNum = pickNum(t, [
            "prev_close",
            "previous_close",
            "prior_close",
            "yclose",
            "close_prev",
          ]);
          const baseDaily = getDailyChange(t) || {};
          let dayPct = Number(baseDaily?.dayPct);
          let dayChg = Number(baseDaily?.dayChg);
          if (!Number.isFinite(dayPct)) {
            dayPct = pickNum(t, [
              "day_change_pct",
              "daily_change_pct",
              "session_change_pct",
              "change_pct",
              "pct_change",
              "chp",
            ]);
          }
          if (!Number.isFinite(dayChg)) {
            dayChg = pickNum(t, [
              "day_change",
              "daily_change",
              "session_change",
              "change",
              "chg",
              "ch",
            ]);
          }
          if (
            (!Number.isFinite(dayChg) || !Number.isFinite(dayPct)) &&
            Number.isFinite(priceNum) &&
            priceNum > 0 &&
            Number.isFinite(prevCloseNum) &&
            prevCloseNum > 0
          ) {
            const chg = priceNum - prevCloseNum;
            const pct = (chg / prevCloseNum) * 100;
            if (!Number.isFinite(dayChg)) dayChg = chg;
            if (!Number.isFinite(dayPct)) dayPct = pct;
          }

          // Card background: base tint from daily change (blue/orange intensity),
          // plus a completion "fill" overlay (left->right).
          const dayAbs = Number.isFinite(dayPct)
            ? Math.min(5, Math.abs(dayPct))
            : null;
          const dayIntensity =
            dayAbs != null ? Math.max(0, Math.min(1, dayAbs / 2.5)) : 0; // 0..1 (2.5% => full)
          const tintAlpha = 0.08 + dayIntensity * 0.26; // punchier tint for readability
          const tint =
            Number.isFinite(dayPct) && dayPct !== 0
              ? dayPct >= 0
                ? `rgba(59,130,246,${tintAlpha})`
                : `rgba(249,115,22,${tintAlpha})`
              : "rgba(0,0,0,0)";

          const compP = completionForSize(t);
          const compPct = Number.isFinite(compP)
            ? Math.round(Math.max(0, Math.min(1, compP)) * 100)
            : null;
          const compFill =
            Number.isFinite(compP) && compPct != null
              ? `linear-gradient(90deg, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0.06) ${compPct}%, rgba(255,255,255,0) ${compPct}%, rgba(255,255,255,0) 100%)`
              : null;
          const bgTint = `linear-gradient(0deg, ${tint}, ${tint})`;
          const bgImage = compFill ? `${compFill}, ${bgTint}` : bgTint;

          const badgesText = badges.length > 0 ? badges.join("") : "";
          const dayEdgeClass =
            Number.isFinite(dayPct) && dayPct !== 0
              ? dayPct >= 0
                ? "shadow-[0_0_0_1px_rgba(56,189,248,0.22)]"
                : "shadow-[0_0_0_1px_rgba(251,146,60,0.22)]"
              : "";

          return (
            <div
              key={`kanban-${t.ticker}`}
              role="button"
              tabIndex={0}
              onClick={() => toggleExpanded(sym)}
              onKeyDown={(e) => {
                if (e.key === "Enter" || e.key === " ") {
                  e.preventDefault();
                  toggleExpanded(sym);
                }
              }}
              className={
                // Match Viewport card feel (same surface + hover), with transition overlay applied.
                "w-full text-left px-3 py-2 rounded-lg border transition-all hover:brightness-[1.06] " +
                (movedRecently
                  ? transitionCardClass
                  : "border-[#26325f] hover:border-[#3a4aa0]")
                  .trim() +
                (dayEdgeClass ? ` ${dayEdgeClass}` : "")
              }
              style={{ backgroundColor: "#121a33", backgroundImage: bgImage }}
            >
              {/* Header row: Ticker + LONG/SHORT pill (no emoji) + Previous lane | Open button */}
              <div className="flex items-start justify-between gap-2 mb-1">
                <div className="flex items-center gap-1.5 min-w-0 flex-wrap">
                  <span className="text-xs font-bold text-white truncate">
                    {t.ticker}
                  </span>
                  <span
                    className={
                      "inline-flex items-center px-2 py-0.5 rounded-md text-[10px] font-extrabold tracking-wide border whitespace-nowrap " +
                      (dir === "LONG"
                        ? "bg-cyan-400/15 text-cyan-200 border-cyan-300/50 shadow-[0_0_0_1px_rgba(34,211,238,0.18)]"
                        : "bg-fuchsia-500/15 text-fuchsia-200 border-fuchsia-300/50 shadow-[0_0_0_1px_rgba(217,70,239,0.18)]")
                    }
                    title="Directional bias"
                  >
                    {dir}
                  </span>
                  {(() => {
                    const prev = prevLane;
                    if (!prev) return null;
                    if (prev === stage) return null;
                    if (stage === "archive") return null;
                    const label = prev.replaceAll("_", " ").toUpperCase();
                    return (
                      <span
                        className={
                          "px-1 py-0.5 rounded text-[9px] font-semibold border whitespace-nowrap " +
                          (movedRecently
                            ? isBacktrack
                              ? "bg-fuchsia-500/15 text-fuchsia-200 border-fuchsia-400/30"
                              : isForward
                                ? "bg-white/10 text-white border-white/20"
                                : "bg-cyan-500/15 text-cyan-200 border-cyan-400/30"
                            : "bg-white/5 text-[#9fb0df] border-white/10")
                        }
                        title={`Previous lane: ${label}`}
                      >
                        ‚Üê {label}
                      </span>
                    );
                  })()}
                </div>

                {/* Open full ticker view without toggling accordion */}
                <button
                  type="button"
                  className="px-1 py-0.5 rounded bg-white/5 text-[#9fb0df] text-[10px] border border-white/10 hover:bg-white/10 shrink-0"
                  title="Open ticker details"
                  onClick={(e) => {
                    e.stopPropagation();
                    onSelectTicker?.(t.ticker);
                  }}
                >
                  ‚Üó
                </button>
              </div>

              {/* Collapsed body: Price + Daily change under price | Signals on right */}
              <div className="flex items-start justify-between gap-2 mb-1">
                <div className="min-w-0">
                  <div className="text-white font-semibold text-[11px]">
                    {Number.isFinite(price) ? `$${price.toFixed(2)}` : "‚Äî"}
                  </div>
                  {(() => {
                    const up = Number(dayChg || dayPct || 0) >= 0;
                    const cls = up ? "text-sky-300" : "text-orange-300";
                    const sign = up ? "+" : "-";
                    const chgText = Number.isFinite(dayChg)
                      ? `${sign}${fmtUsdAbs(dayChg)}`
                      : null;
                    const pctText = Number.isFinite(dayPct)
                      ? `${sign}${Math.abs(dayPct).toFixed(2)}%`
                      : null;
                    return (
                      <div className={`text-[9px] ${cls} truncate`}>
                        {chgText || pctText ? (
                          <>
                            {chgText || "‚Äî"}
                            {pctText ? ` (${pctText})` : ""}
                          </>
                        ) : (
                          <span className="opacity-60">‚Äî</span>
                        )}
                      </div>
                    );
                  })()}
                </div>

                <div className="flex flex-col items-end gap-1 shrink-0">
                  {badgesText ? (
                    <div
                      className="px-2 py-0.5 rounded border border-white/10 bg-white/5 text-[10px] font-semibold text-[#e7ecff]"
                      title="Signals"
                    >
                      {badgesText}
                    </div>
                  ) : null}
                </div>
              </div>

              {isExpanded && (
                <>
                  {/* Direction + Badges */}
                  <div className="flex items-center gap-1 mb-1 flex-wrap">
                    <span
                      className={`px-2 py-0.5 rounded text-[10px] font-extrabold tracking-wide border ${
                        isBullish
                          ? "bg-cyan-400/15 text-cyan-200 border-cyan-300/50 shadow-[0_0_0_1px_rgba(34,211,238,0.18)]"
                          : "bg-fuchsia-500/15 text-fuchsia-200 border-fuchsia-300/50 shadow-[0_0_0_1px_rgba(217,70,239,0.18)]"
                      }`}
                    >
                      {dir}
                    </span>
                    {score > 0 && (
                      <span className="px-1.5 py-0.5 rounded bg-amber-500/20 text-amber-300 text-[9px] font-semibold">
                        {score}
                      </span>
                    )}
                    {Number.isFinite(rankPos) && rankPos > 0 && (
                      <span className="px-1.5 py-0.5 rounded bg-purple-500/20 text-purple-200 text-[9px] font-semibold border border-purple-400/40">
                        #{rankPos}
                        {rankTotal ? `/${rankTotal}` : ""}
                      </span>
                    )}
                    {Number.isFinite(rank) && rank > 0 && rank <= 10 && (
                      <span className="px-1.5 py-0.5 rounded bg-blue-500/20 text-blue-300 text-[9px] font-semibold">
                        #{rank}
                      </span>
                    )}
                    {badges.length > 0 && (
                      <span className="text-[10px]">{badges.join("")}</span>
                    )}
                  </div>

                  {/* Viewport-style action line */}
                  {(() => {
                    const ai = getActionDescription(t);
                    if (!ai?.action) return null;
                    return (
                      <div className="text-[10px] text-[#93a4d6] mb-1 whitespace-nowrap overflow-hidden text-ellipsis">
                        <span className="text-[#6b7a9f]">{ai.action}</span>
                      </div>
                    );
                  })()}

                  {/* Viewport-style metrics + bars */}
                  {(() => {
                    const tpTarget = computeTpTargetPrice(t);
                    const tpMax = computeTpMaxPrice(t);
                    const tpDisplay =
                      Number.isFinite(tpTarget) && tpTarget > 0
                        ? tpTarget
                        : Number.isFinite(tpMax) && tpMax > 0
                          ? tpMax
                          : Number.isFinite(tp) && tp > 0
                            ? tp
                            : null;
                    const rrDisplay = Number(t?.rr);
                    const slDisplayRaw = Number(
                      t?.sl ?? t?.sl_price ?? t?.stop_loss ?? t?.stop,
                    );
                    const slDisplay =
                      Number.isFinite(slDisplayRaw) && slDisplayRaw > 0
                        ? slDisplayRaw
                        : null;
                    const phaseP = Math.max(
                      0,
                      Math.min(1, Number(t?.phase_pct) || 0),
                    );
                    const compP2 = completionForSize(t);
                    const phaseColor = phaseToColor(phaseP);
                    const compColor = phaseToColor(compP2);
                    const Bar = ({ label, p, color }) => (
                      <div className="flex items-center gap-2">
                        <div className="w-14 text-[9px] text-[#6b7a9f]">
                          {label}
                        </div>
                        <div className="flex-1 h-1.5 rounded bg-[#0f1630] border border-[#26325f] overflow-hidden">
                          <div
                            className="h-full"
                            style={{
                              width: `${Math.round(p * 100)}%`,
                              background: color,
                            }}
                          />
                        </div>
                        <div className="w-9 text-right text-[9px] text-[#93a4d6]">
                          {Math.round(p * 100)}%
                        </div>
                      </div>
                    );
                    return (
                      <>
                        <div className="mt-1 grid grid-cols-3 gap-2 text-[9px] text-[#93a4d6]">
                          <div>
                            <span className="text-[#6b7a9f]">Score</span>{" "}
                            <span className="text-white font-semibold">
                              {Number.isFinite(score) ? score.toFixed(0) : "‚Äî"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">Rank</span>{" "}
                            <span className="text-white font-semibold">
                              {Number.isFinite(rankPos) && rankPos > 0
                                ? `#${rankPos}`
                                : "‚Äî"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">RR now</span>{" "}
                            <span className="text-white font-semibold">
                              {Number.isFinite(rrNowLikely) && rrNowLikely > 0
                                ? rrNowLikely.toFixed(2)
                                : Number.isFinite(rrDisplay)
                                  ? rrDisplay.toFixed(2)
                                  : "‚Äî"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">SL</span>{" "}
                            <span className="text-red-300 font-semibold">
                              {slDisplay != null ? `$${slDisplay.toFixed(2)}` : "‚Äî"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">TP</span>{" "}
                            <span className="text-green-300 font-semibold">
                              {tpDisplay != null ? `$${tpDisplay.toFixed(2)}` : "‚Äî"}
                            </span>
                          </div>
                          <div />
                        </div>
                        <div className="mt-2 space-y-1">
                          <Bar label="Phase" p={phaseP} color={phaseColor} />
                          <Bar label="Comp" p={compP2} color={compColor} />
                        </div>
                      </>
                    );
                  })()}

                  {/* Scores + Price */}
                  <div className="text-[10px] text-[#6b7a9f] space-y-0.5">
                    {stage === "archive" &&
                      (archiveBucket || archiveReason) && (
                        <div className="text-[9px] text-[#93a4d6]">
                          {archiveEmoji ? `${archiveEmoji} ` : ""}
                          {archiveBucket}
                          {archiveBucket && archiveReason ? ": " : ""}
                          {archiveReason}
                        </div>
                      )}
                    <div className="flex items-center justify-between">
                      <span>
                        HTF {Number.isFinite(htf) ? htf.toFixed(1) : "‚Äî"}
                      </span>
                      <div className="text-right">
                        <div className="text-white font-semibold">
                          ${Number.isFinite(price) ? price.toFixed(2) : "‚Äî"}
                        </div>
                        {(() => {
                          if (
                            !Number.isFinite(dayChg) &&
                            !Number.isFinite(dayPct)
                          )
                            return null;
                          const up = Number(dayChg || dayPct || 0) >= 0;
                          const cls = up ? "text-sky-300" : "text-orange-300";
                          const sign = up ? "+" : "-";
                          return (
                            <div className={`text-[9px] ${cls}`}>
                              {Number.isFinite(dayChg)
                                ? `${sign}${fmtUsdAbs(dayChg)}`
                                : "‚Äî"}
                              {Number.isFinite(dayPct)
                                ? ` (${sign}${Math.abs(dayPct).toFixed(2)}%)`
                                : ""}
                            </div>
                          );
                        })()}
                      </div>
                    </div>
                    <div className="flex items-center justify-between">
                      <span>
                        LTF {Number.isFinite(ltf) ? ltf.toFixed(1) : "‚Äî"}
                      </span>
                      {showProgress && Number.isFinite(completion) && (
                        <span className="text-[#93a4d6]">
                          {Math.round(completion * 100)}% done
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Trading Details (for entry opportunities and open positions) */}
                  {showDetailsCard && (
                    <div className="mt-1.5 pt-1.5 border-t border-[#26325f] text-[9px] text-[#6b7a9f] space-y-0.5">
                      {showEntryStats &&
                        Number.isFinite(entryPrice) &&
                        entryPrice > 0 && (
                          <div className="flex items-center justify-between">
                            <span>Entry</span>
                            <span className="text-cyan-300 font-semibold">
                              ${entryPrice.toFixed(2)}
                            </span>
                          </div>
                        )}
                      {showEntryStats && Number.isFinite(entryChangePct) && (
                        <div className="flex items-center justify-between">
                          <span className="text-[#93a4d6] font-semibold">
                            Since entry
                          </span>
                          <span
                            className={
                              "px-2 py-0.5 rounded border text-[10px] font-extrabold " +
                              (entryChangePct >= 0
                                ? "bg-green-500/15 text-green-200 border-green-400/40"
                                : "bg-red-500/15 text-red-200 border-red-400/40")
                            }
                          >
                            {entryChangePct >= 0 ? "+" : ""}
                            {entryChangePct.toFixed(2)}%
                          </span>
                        </div>
                      )}
                      {sl !== null && (
                        <div className="flex items-center justify-between">
                          <span>SL</span>
                          <span className="text-red-300 font-semibold">
                            ${sl.toFixed(2)}
                          </span>
                        </div>
                      )}
                      <div className="flex items-center justify-between">
                        <span>RR initial</span>
                        <span className="text-[#93a4d6] font-semibold">
                          {Number.isFinite(rrEntryLikely) && rrEntryLikely > 0
                            ? rrEntryLikely.toFixed(2)
                            : "‚Äî"}
                        </span>
                      </div>

                      <div className="flex items-center justify-between">
                        <span>RR now</span>
                        <span className="text-[#93a4d6] font-semibold">
                          {Number.isFinite(rrNowLikely) && rrNowLikely > 0
                            ? rrNowLikely.toFixed(2)
                            : "‚Äî"}
                        </span>
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>
          );
        };

        if (
          watch.length === 0 &&
          flipWatch.length === 0 &&
          justFlipped.length === 0 &&
          enterNow.length === 0 &&
          hold.length === 0 &&
          defend.length === 0 &&
          trim.length === 0 &&
          exit.length === 0 &&
          archive.length === 0
        ) {
          return null;
        }

        // Kanban column component (always render, even if empty)
        const KanbanColumn = ({
          laneKey,
          title,
          subtitle,
          count,
          icon,
          color,
          items,
          showProgress,
          showOpen,
          showDetails,
        }) => {
          const listRef = React.useRef(null);

          // Restore scroll position when re-rendering (prevents auto-jump when Right Rail opens)
          React.useLayoutEffect(() => {
            try {
              const el = listRef.current;
              if (!el) return;
              const saved = laneScrollTopRef.current[laneKey];
              if (Number.isFinite(saved)) el.scrollTop = saved;
            } catch {}
          });

          return (
            <div className="flex-1 min-w-[170px] max-w-[240px]">
              <div
                className={`p-1.5 rounded-t-lg border-t-2 ${color} bg-[#0f1630]`}
              >
                <div className="flex items-center justify-between mb-1">
                  <span className="text-xs font-bold text-white">
                    {icon} {title}
                  </span>
                  <span className="px-1.5 py-0.5 rounded bg-[#26325f] text-[10px] font-semibold text-[#93a4d6]">
                    {count}
                  </span>
                </div>
                {subtitle && (
                  <div className="text-[9px] text-[#6b7a9f]">{subtitle}</div>
                )}
              </div>
              <div
                ref={listRef}
                className="border-l border-r border-b border-[#26325f] rounded-b-lg bg-[#0a0f24] p-1.5 max-h-[560px] overflow-y-auto scrollbar-hide"
                style={{ overflowAnchor: "none" }}
                onScroll={() => {
                  try {
                    const el = listRef.current;
                    if (!el) return;
                    laneScrollTopRef.current[laneKey] = el.scrollTop;
                  } catch {}
                }}
              >
                {Array.isArray(items) && items.length > 0 ? (
                  <div className="space-y-2">
                    {items
                      .slice(0, 50)
                      .map((t) =>
                        renderCompactCard(
                          t,
                          showProgress,
                          showOpen,
                          showDetails,
                        ),
                      )}
                  </div>
                ) : (
                  <div className="text-[10px] text-[#6b7a9f] italic">
                    No tickers right now
                  </div>
                )}
              </div>
            </div>
          );
        };

        return (
          <div>
            <div className="mb-1 text-[10px] text-[#6b7a9f] flex items-center gap-2">
              <span className="text-amber-300">Setup</span>
              <span className="text-green-300">Transition</span>
              <span className="text-cyan-300">Entry</span>
              <span className="text-blue-300">Position</span>
              <span className="text-yellow-300">Take Profit</span>
              <span className="text-red-300">Close</span>
            </div>
            <div className="overflow-x-auto">
              <div className="flex gap-1.5 pb-1.5">
                <KanbanColumn
                  laneKey="watch"
                  title="Watch"
                  subtitle="Momentum-aligned, not entry yet"
                  count={watch.length}
                  icon="üëÄ"
                  color="border-[#3a4a7f]"
                  items={watch}
                />
                <KanbanColumn
                  laneKey="flip_watch"
                  title="Flip Watch"
                  subtitle="About to flip to momentum"
                  count={flipWatch.length}
                  icon="üéØ"
                  color="border-amber-500"
                  items={flipWatch}
                />
                <KanbanColumn
                  laneKey="just_flipped"
                  title="Just Flipped"
                  subtitle="Entered momentum recently"
                  count={justFlipped.length}
                  icon="‚ö°"
                  color="border-green-500"
                  items={justFlipped}
                />
                <KanbanColumn
                  laneKey="enter_now"
                  title="Enter Now"
                  subtitle="High-confidence entries"
                  count={enterNow.length}
                  icon="üöÄ"
                  color="border-cyan-500"
                  items={enterNow}
                  showDetails={true}
                />
                <KanbanColumn
                  laneKey="hold"
                  title="Hold"
                  subtitle="Open positions, early phase"
                  count={hold.length}
                  icon="üíé"
                  color="border-blue-500"
                  items={hold}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                />
                <KanbanColumn
                  laneKey="defend"
                  title="Defend"
                  subtitle="Open positions w/ warnings"
                  count={defend.length}
                  icon="üõ°"
                  color="border-orange-500"
                  items={defend}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                />
                <KanbanColumn
                  laneKey="trim"
                  title="Trim"
                  subtitle="High completion, take profit"
                  count={trim.length}
                  icon="üìä"
                  color="border-yellow-500"
                  items={trim}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                />
                <KanbanColumn
                  laneKey="exit"
                  title="Exit"
                  subtitle="Close position"
                  count={exit.length}
                  icon="üö™"
                  color="border-red-500"
                  items={exit}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                />
                <KanbanColumn
                  laneKey="archive"
                  title="Archive"
                  subtitle="Resolved / not actionable"
                  count={archive.length}
                  icon="üóÇ"
                  color="border-[#55608a]"
                  items={archive}
                  showProgress={true}
                  showOpen={false}
                  showDetails={true}
                />
              </div>
            </div>
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Opportunities Panel: unified (Prime/Eligible/Watch)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function OpportunitiesPanel({
        tickers = [],
        rankPositions = null,
        onSelectTicker,
        defaultView = "prime",
        title = "‚ú® Opportunities",
        maxHeightClass = "max-h-[520px]",
        fillHeight = false,
        onFilteredTickersChange = null,
        showControls = true,
        thesisMode = false,
      }) {
        const [view, setView] = React.useState(defaultView); // prime | eligible | watch | all | today
        const [dir, setDir] = React.useState("ALL"); // ALL | LONG | SHORT
        const [horizon, setHorizon] = React.useState("ALL"); // ALL | SHORT_TERM | SWING | POSITIONAL
        const [moveFilter, setMoveFilter] = React.useState("ALL"); // ALL | ACTIVE | INVALIDATED | COMPLETED
        const [query, setQuery] = React.useState("");
        const [sortBy, setSortBy] = React.useState("RANK"); // RANK | ABC | DCHG
        const [todaySnapshot, setTodaySnapshot] = React.useState(null); // { createdAt, tickers: [], rpBy: {} }

        const todayStorageKey = React.useMemo(() => {
          // Daily key (keeps ‚ÄúToday‚Äù list stable across refreshes)
          const d = new Date();
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, "0");
          const day = String(d.getDate()).padStart(2, "0");
          return `timedTrading_todayBest_${y}-${m}-${day}`;
        }, []);

        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isEligible = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);

          // corridor is a core requirement for entry-readiness
          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct)
            return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct)
            return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf)
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr)
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const toBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const classify = (t) => {
          const prime = isPrimeBubble(t);
          const eligible = isEligible(t);
          const ms =
            t?.move_status && typeof t.move_status === "object"
              ? t.move_status
              : null;
          const moveStatus =
            ms && ms.status ? String(ms.status).toUpperCase() : "ACTIVE";
          return {
            prime,
            eligible,
            bucket: toBucket(t),
            dir: getDirection(t)?.text || "NEUTRAL",
            moveStatus,
          };
        };

        // ‚ÄúToday‚Äôs Best Setups‚Äù (stable snapshot): favor corridor candidates with good RR/phase/completion.
        const isTodayBestSetup = (t) => {
          if (!t) return false;
          const ent = entryType(t);
          if (!ent?.corridor) return false;
          const rr = Number(t?.rr);
          const comp = completionForSize(t);
          const phase = Number(t?.phase_pct);
          const zone = String(t?.phase_zone || "").toUpperCase();
          if (Number.isFinite(rr) && rr < 1.5) return false;
          // Keep this list broad enough to be useful, while avoiding late/extended conditions.
          if (Number.isFinite(comp) && comp > 0.6) return false;
          if (zone === "HIGH" || zone === "EXTREME") return false;
          if (Number.isFinite(phase) && phase > 0.7) return false;
          return true;
        };

        const bestLiveForToday = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const out = [];
          for (const t of list) {
            if (!t?.ticker) continue;
            if (!isTodayBestSetup(t)) continue;
            const sym = String(t.ticker).toUpperCase();
            const rp =
              getRankPositionFromMap(rankPositions, sym) ??
              Number(t?.rank_position);
            out.push({
              sym,
              rp: Number.isFinite(rp) ? rp : null,
            });
          }
          out.sort((a, b) => {
            if (a.rp != null && b.rp != null) return a.rp - b.rp;
            if (a.rp != null) return -1;
            if (b.rp != null) return 1;
            return a.sym.localeCompare(b.sym);
          });
          const top = out.slice(0, 25);
          const rpBy = {};
          for (const x of top) {
            if (x.sym && x.rp != null) rpBy[x.sym] = x.rp;
          }
          return { tickers: top.map((x) => x.sym), rpBy };
        }, [tickers, rankPositions]);

        // Load snapshot from localStorage (per-day).
        React.useEffect(() => {
          try {
            const raw = localStorage.getItem(todayStorageKey);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (parsed && Array.isArray(parsed.tickers)) {
              setTodaySnapshot(parsed);
            }
          } catch {
            // ignore
          }
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [todayStorageKey]);

        const updateTodaySnapshot = React.useCallback(() => {
          const snap = {
            createdAt: Date.now(),
            tickers: bestLiveForToday.tickers,
            rpBy: bestLiveForToday.rpBy,
          };
          setTodaySnapshot(snap);
          try {
            localStorage.setItem(todayStorageKey, JSON.stringify(snap));
          } catch {
            // ignore
          }
        }, [bestLiveForToday, todayStorageKey]);

        // Ensure snapshot exists when user switches to ‚ÄúToday‚Äù.
        React.useEffect(() => {
          if (view !== "today") return;
          if (
            todaySnapshot &&
            Array.isArray(todaySnapshot.tickers) &&
            todaySnapshot.tickers.length > 0
          )
            return;
          if (bestLiveForToday.tickers.length > 0) updateTodaySnapshot();
        }, [view, todaySnapshot, bestLiveForToday, updateTodaySnapshot]);

        const counts = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          let prime = 0;
          let eligibleOnly = 0;
          let watch = 0;
          let active = 0;
          let invalidated = 0;
          let completed = 0;
          for (const t of list) {
            const c = classify(t);
            if (c.prime) prime++;
            else if (c.eligible) eligibleOnly++;
            else watch++;
            if (c.moveStatus === "INVALIDATED") invalidated++;
            else if (c.moveStatus === "COMPLETED") completed++;
            else active++;
          }
          return {
            prime,
            eligibleOnly,
            watch,
            all: list.length,
            active,
            invalidated,
            completed,
          };
        }, [tickers]);

        const filtered = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const q = String(query || "")
            .trim()
            .toUpperCase();

          const itemsAll = list
            .map((t) => {
              const c = classify(t);
              const status = c.prime
                ? "prime"
                : c.eligible
                  ? "eligible"
                  : "watch";
              const score = Number(rankScoreForTicker(t) || 0);
              const sym = String(t?.ticker || "").toUpperCase();
              const rp =
                getRankPositionFromMap(rankPositions, sym) ??
                Number(t?.rank_position);
              return {
                t,
                c,
                status,
                score,
                rp: Number.isFinite(rp) ? rp : null,
                sym,
              };
            })
            .filter(({ t }) => !!t?.ticker);

          // Special mode: stable ‚ÄúToday‚Äù list (snapshot + movement deltas).
          if (view === "today") {
            const bySym = {};
            for (const it of itemsAll) {
              if (it.sym && !bySym[it.sym]) bySym[it.sym] = it;
            }

            const snapTickers =
              todaySnapshot &&
              Array.isArray(todaySnapshot.tickers) &&
              todaySnapshot.tickers.length > 0
                ? todaySnapshot.tickers
                : bestLiveForToday.tickers;
            const snapRpBy =
              todaySnapshot && todaySnapshot.rpBy
                ? todaySnapshot.rpBy
                : bestLiveForToday.rpBy;

            const out = [];
            const inSnap = new Set();
            for (const sym of snapTickers) {
              const S = String(sym || "").toUpperCase();
              if (!S) continue;
              inSnap.add(S);
              const it = bySym[S];
              if (!it) continue;
              out.push({
                ...it,
                snapRp: Number.isFinite(Number(snapRpBy?.[S]))
                  ? Number(snapRpBy[S])
                  : null,
                dropped: !isTodayBestSetup(it.t),
              });
            }

            // Append newly-qualifying setups (so you don‚Äôt miss fresh arrivals) but keep them after the snapshot.
            for (const sym of bestLiveForToday.tickers) {
              const S = String(sym || "").toUpperCase();
              if (!S || inSnap.has(S)) continue;
              const it = bySym[S];
              if (!it) continue;
              out.push({ ...it, snapRp: null, dropped: false, isNew: true });
            }

            // Apply move filter to Today list too (optional, but matches user intent).
            if (moveFilter !== "ALL") {
              return out.filter((it) => it?.c?.moveStatus === moveFilter);
            }
            return out;
          }

          const items = itemsAll
            .filter(({ t, c, status }) => {
              if (!showControls) return true;
              if (view !== "all" && status !== view) return false;
              if (dir !== "ALL" && c.dir !== dir) return false;
              if (moveFilter !== "ALL" && c.moveStatus !== moveFilter)
                return false;
              if (horizon !== "ALL" && c.bucket !== horizon) return false;
              if (q && !String(t.ticker).toUpperCase().includes(q))
                return false;
              return true;
            })
            .sort((a, b) => {
              const mode = String(sortBy || "RANK").toUpperCase();
              if (mode === "ABC") {
                return String(a.t.ticker).localeCompare(String(b.t.ticker));
              }
              if (mode === "DCHG") {
                const ad = Number(getDailyChange(a.t)?.dayPct);
                const bd = Number(getDailyChange(b.t)?.dayPct);
                const aOk = Number.isFinite(ad);
                const bOk = Number.isFinite(bd);
                if (aOk && bOk) return bd - ad; // highest % first
                if (aOk) return -1;
                if (bOk) return 1;
                // fallback to rank
              }

              // Default: Rank-position first (stable + intuitive).
              // If rank position isn't available, fall back to score.
              const ar = a.rp;
              const br = b.rp;
              if (ar != null && br != null) return ar - br;
              if (ar != null) return -1;
              if (br != null) return 1;
              const ds = (b.score || 0) - (a.score || 0);
              if (ds !== 0) return ds;
              return String(a.t.ticker).localeCompare(String(b.t.ticker));
            });

          return items;
        }, [
          tickers,
          view,
          dir,
          moveFilter,
          horizon,
          query,
          rankPositions,
          sortBy,
          todaySnapshot,
          bestLiveForToday,
        ]);

        React.useEffect(() => {
          if (!onFilteredTickersChange) return;
          try {
            onFilteredTickersChange(
              filtered.map((x) => x.t),
              { view, dir, horizon, query, count: filtered.length },
            );
          } catch (e) {
            console.warn("[Viewport] onFilteredTickersChange failed", e);
          }
        }, [filtered, view, dir, horizon, query, onFilteredTickersChange]);

        const Row = ({ item }) => {
          const t = item.t;
          const c = item.c;
          const winnerSig = isWinnerSignature(t);
          const flags = t?.flags || {};
          const isInSqueeze = !!flags.sq30_on && !flags.sq30_release;
          const badgeEmojis = [
            flags.thesis_match === true ? "üß†" : null,
            flags.momentum_elite ? "üöÄ" : null,
            winnerSig ? "üèÜ" : null,
            flags.sq30_release ? "‚ö°" : null,
            isInSqueeze ? "üß®" : null,
            item?.isNew ? "üÜï" : null,
            item?.dropped ? "‚ö†Ô∏è" : null,
          ].filter(Boolean);
          const actionInfo = getActionDescription(t);
          const price = Number(t?.price);
          const rr = Number(t?.rr);
          const eta = computeEtaDays(t);
          const ingestText = formatIngestTime(t);
          const sl = Number(t?.sl ?? t?.sl_price);
          const tpTarget = computeTpTargetPrice(t);
          const tpMax = computeTpMaxPrice(t);
          const tpDisplay =
            Number.isFinite(tpTarget) && tpTarget > 0
              ? tpTarget
              : Number.isFinite(tpMax) && tpMax > 0
                ? tpMax
                : null;

          const dc = getDailyChange(t);
          const stale = dc?.stale;
          const marketOpen = dc?.marketOpen;
          const isStale = !!stale?.isStale;

          const skin = getCardSkin(t);
          const dayChg = skin?.dayChg;
          const dayPct = skin?.dayPct;
          const chgColor =
            isStale && marketOpen
              ? "text-yellow-300"
              : Number(dayChg || dayPct || 0) >= 0
                ? "text-sky-300"
                : "text-orange-300";

          const statusPill =
            item.status === "prime"
              ? {
                  label: "Prime",
                  cls: "bg-yellow-500/15 text-yellow-300 border-yellow-500/40",
                }
              : item.status === "eligible"
                ? {
                    label: "Eligible",
                    cls: "bg-green-500/15 text-green-400 border-green-500/40",
                  }
                : {
                    label: "Watch",
                    cls: "bg-[#26325f] text-[#93a4d6] border-[#26325f]",
                  };

          const dirPill =
            c.dir === "LONG"
              ? {
                  label: "LONG",
                  cls: "bg-cyan-400/15 text-cyan-200 border-cyan-300/50 shadow-[0_0_0_1px_rgba(34,211,238,0.18)]",
                }
              : c.dir === "SHORT"
                ? {
                    label: "SHORT",
                    cls: "bg-fuchsia-500/15 text-fuchsia-200 border-fuchsia-300/50 shadow-[0_0_0_1px_rgba(217,70,239,0.18)]",
                  }
                : {
                    label: c.dir,
                    cls: "bg-[#26325f] text-[#93a4d6] border-[#26325f]",
                  };

          const moveStatus = String(c?.moveStatus || "ACTIVE").toUpperCase();
          const moveEmoji =
            moveStatus === "INVALIDATED"
              ? "‚õî"
              : moveStatus === "COMPLETED"
                ? "‚úÖ"
                : "üü¢";
          const moveTitle = (() => {
            const ms =
              t?.move_status && typeof t.move_status === "object"
                ? t.move_status
                : null;
            if (!ms) return `Move: ${moveStatus}`;
            const reasons = Array.isArray(ms.reasons) ? ms.reasons : [];
            const r = reasons
              .filter((x) => x != null)
              .map((x) => String(x))
              .filter((x) => x.trim())
              .slice(0, 6)
              .join(", ");
            return r ? `Move: ${moveStatus} ‚Äî ${r}` : `Move: ${moveStatus}`;
          })();

          return (
            <button
              key={t.ticker}
              onClick={() => onSelectTicker && onSelectTicker(t.ticker)}
              className={`w-full text-left px-3 py-2 rounded-lg border transition-all hover:brightness-[1.06] ${
                winnerSig
                  ? "border-purple-500/50 hover:border-purple-400 shadow-[0_0_0_1px_rgba(168,85,247,0.15)]"
                  : "border-[#26325f] hover:border-[#3a4aa0]"
              }${skin?.dayEdgeClass ? ` ${skin.dayEdgeClass}` : ""}`}
              style={{
                backgroundColor: "#121a33",
                backgroundImage: skin?.bgImage || undefined,
              }}
              title="Open in right rail"
            >
              <div className="flex items-start justify-between gap-2">
                <div className="min-w-0">
                  <div className="flex items-center gap-2 flex-wrap">
                    <span
                      className="text-[12px]"
                      title={moveTitle}
                      aria-label={`Move status ${moveStatus}`}
                    >
                      {moveEmoji}
                    </span>
                    <div className="font-bold text-white">{t.ticker}</div>
                    {badgeEmojis.length > 0 && (
                      <span className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] font-semibold text-[#e7ecff]">
                        {badgeEmojis.join("")}
                      </span>
                    )}
                    <span
                      className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${statusPill.cls}`}
                    >
                      {statusPill.label}
                    </span>
                    <span
                      className={`px-3 py-1 rounded-md border text-xs font-extrabold tracking-wide ${dirPill.cls}`}
                      title="Directional bias (makes LONG/SHORT stand out)"
                    >
                      {dirPill.label}
                    </span>
                    {c.bucket && c.bucket !== "UNKNOWN" && (
                      <span className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] text-[#93a4d6]">
                        {c.bucket === "SHORT_TERM"
                          ? "‚â§7d"
                          : c.bucket === "SWING"
                            ? "8‚Äì30d"
                            : "31d+"}
                      </span>
                    )}
                  </div>
                  <div className="mt-0.5 text-[11px] text-[#93a4d6] whitespace-nowrap overflow-hidden text-ellipsis">
                    <span className="text-[#6b7a9f]">{actionInfo.action}</span>
                  </div>
                </div>

                <div className="flex-shrink-0 text-right text-[11px]">
                  <div className="text-white">
                    {Number.isFinite(price) ? `$${price.toFixed(2)}` : "‚Äî"}
                  </div>
                  <div className={`mt-0.5 ${chgColor}`}>
                    {Number.isFinite(dayPct)
                      ? `${dayPct >= 0 ? "+" : ""}${dayPct.toFixed(2)}%`
                      : "‚Äî"}{" "}
                    {Number.isFinite(dayChg)
                      ? `(${dayChg >= 0 ? "+" : ""}${fmtUsdAbs(dayChg)})`
                      : ""}
                    {isStale && marketOpen && (
                      <span className="text-yellow-200/80">
                        {` (stale${stale?.ageLabel ? ` ${stale.ageLabel}` : ""})`}
                      </span>
                    )}
                    {!marketOpen && (
                      <span className="text-[#93a4d6] text-[10px]">
                        {stale?.ageLabel
                          ? ` AH ‚Ä¢ as of ${stale.ageLabel}`
                          : " AH"}
                      </span>
                    )}
                  </div>
                  <div className="text-[#6b7a9f]">{ingestText}</div>
                </div>
              </div>

              <div className="mt-1 grid grid-cols-6 gap-2 text-[10px] text-[#93a4d6]">
                <div>
                  <span className="text-[#6b7a9f]">Score</span>{" "}
                  <span className="text-white font-semibold">
                    {(() => {
                      const s = rankScoreForTicker(item);
                      return Number.isFinite(s) ? s.toFixed(1) : "‚Äî";
                    })()}
                  </span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">Rank</span>{" "}
                  <span className="text-white font-semibold">
                    {item.rp != null ? `#${item.rp}` : "‚Äî"}
                    {item.snapRp != null && item.rp != null ? (
                      <span className="ml-1 text-[10px] text-[#6b7a9f]">
                        {item.snapRp > item.rp
                          ? `‚Üë${item.snapRp - item.rp}`
                          : item.snapRp < item.rp
                            ? `‚Üì${item.rp - item.snapRp}`
                            : "‚Üí0"}
                      </span>
                    ) : null}
                  </span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">RR</span>{" "}
                  <span className="text-white font-semibold">
                    {Number.isFinite(rr) ? rr.toFixed(2) : "‚Äî"}
                  </span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">SL</span>{" "}
                  <span className="text-red-400 font-semibold">
                    {Number.isFinite(sl) ? `$${sl.toFixed(2)}` : "‚Äî"}
                  </span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">TP</span>{" "}
                  <span className="text-green-400 font-semibold">
                    {Number.isFinite(tpDisplay)
                      ? `$${tpDisplay.toFixed(2)}`
                      : "‚Äî"}
                  </span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">ETA</span>{" "}
                  <span className="text-white font-semibold">
                    {eta != null ? `${eta.toFixed(1)}d` : "‚Äî"}
                  </span>
                </div>
              </div>

              {(() => {
                const phaseP = Math.max(
                  0,
                  Math.min(1, Number(t?.phase_pct) || 0),
                );
                const compP = completionForSize(t);
                const phaseColor = phaseToColor(phaseP);
                const compColor = phaseToColor(compP);
                const Bar = ({ label, p, color }) => (
                  <div className="flex items-center gap-2">
                    <div className="w-20 text-[10px] text-[#6b7a9f]">
                      {label}
                    </div>
                    <div className="flex-1 h-1.5 rounded bg-[#0f1630] border border-[#26325f] overflow-hidden">
                      <div
                        className="h-full"
                        style={{
                          width: `${Math.round(p * 100)}%`,
                          background: color,
                        }}
                      />
                    </div>
                    <div className="w-10 text-right text-[10px] text-[#93a4d6]">
                      {Math.round(p * 100)}%
                    </div>
                  </div>
                );
                return (
                  <div className="mt-2 space-y-1">
                    <Bar label="Phase" p={phaseP} color={phaseColor} />
                    <Bar label="Completion" p={compP} color={compColor} />
                  </div>
                );
              })()}
            </button>
          );
        };

        const pill = (label, isActive, onClick, count = null) => {
          const hasCount = Number.isFinite(count);
          return (
            <button
              onClick={onClick}
              className={`px-2.5 py-1 rounded-lg border text-xs font-semibold transition-all ${
                isActive
                  ? "border-blue-400 bg-blue-500/20 text-blue-200"
                  : "border-[#26325f] bg-[#0f1630] text-[#93a4d6] hover:text-white"
              }`}
            >
              <span className="inline-flex items-center gap-2">
                <span>{label}</span>
                {hasCount ? (
                  <span
                    className={`px-1.5 py-0.5 rounded-md text-[10px] font-bold border ${
                      isActive
                        ? "border-blue-400/40 bg-blue-400/10 text-blue-100"
                        : "border-[#26325f] bg-[#121a33] text-[#c8d2ff]"
                    }`}
                    title={`${count} tickers`}
                  >
                    {count}
                  </span>
                ) : null}
              </span>
            </button>
          );
        };

        return (
          <div
            className={`bg-[#0f1630] border border-[#26325f] rounded-xl p-3 ${
              fillHeight ? "h-full flex flex-col" : ""
            }`}
          >
            <div className="flex items-start justify-between gap-3 flex-wrap">
              <div>
                <div className="text-sm font-bold text-white">{title}</div>
                <div className="text-[10px] text-[#93a4d6] mt-0.5">
                  Prime {counts.prime} ‚Ä¢ Eligible {counts.eligibleOnly} ‚Ä¢ Watch{" "}
                  {counts.watch} ‚Ä¢ Total {counts.all}
                  <span className="ml-2 text-[#6b7a9f]">
                    ‚Ä¢ üü¢ {counts.active} ‚õî {counts.invalidated} ‚úÖ{" "}
                    {counts.completed}
                  </span>
                </div>
              </div>
              <div className="flex items-center gap-2">
                {showControls && (
                  <input
                    value={query}
                    onChange={(e) => setQuery(e.target.value)}
                    placeholder="Ticker‚Ä¶"
                    className="px-2 py-1 text-xs bg-[#0f1630] border border-[#26325f] rounded text-white w-[110px]"
                  />
                )}
                <select
                  value={sortBy}
                  onChange={(e) => setSortBy(e.target.value)}
                  className="px-2 py-1 text-xs bg-[#0f1630] border border-[#26325f] rounded text-white"
                  title="Sort Viewport"
                >
                  <option value="RANK">Sort: Rank</option>
                  <option value="ABC">Sort: ABC</option>
                  <option value="DCHG">Sort: Daily %</option>
                </select>
                {view === "today" && (
                  <button
                    onClick={updateTodaySnapshot}
                    className="px-2 py-1 text-xs bg-blue-500/15 border border-blue-500/40 rounded text-blue-300 hover:bg-blue-500/25"
                    title="Refresh the Today snapshot (keeps list stable)"
                  >
                    Update snapshot
                  </button>
                )}
              </div>
            </div>

            {showControls && (
              <div className="mt-2 flex items-center gap-2 flex-wrap">
                {pill(
                  "Prime",
                  view === "prime",
                  () => setView("prime"),
                  counts.prime,
                )}
                {pill(
                  "Eligible",
                  view === "eligible",
                  () => setView("eligible"),
                  counts.eligibleOnly,
                )}
                {pill(
                  "Watch",
                  view === "watch",
                  () => setView("watch"),
                  counts.watch,
                )}
                {pill("All", view === "all", () => setView("all"), counts.all)}
                {pill(
                  "üìÖ Today",
                  view === "today",
                  () => setView("today"),
                  todaySnapshot &&
                    Array.isArray(todaySnapshot.tickers) &&
                    todaySnapshot.tickers.length > 0
                    ? todaySnapshot.tickers.length
                    : bestLiveForToday.tickers.length,
                )}
                <div className="w-px h-6 bg-[#26325f] mx-1" />
                {pill("All", dir === "ALL", () => setDir("ALL"))}
                {pill("Long", dir === "LONG", () => setDir("LONG"))}
                {pill("Short", dir === "SHORT", () => setDir("SHORT"))}
                <div className="w-px h-6 bg-[#26325f] mx-1" />
                {pill("Move: All", moveFilter === "ALL", () =>
                  setMoveFilter("ALL"),
                )}
                {pill("üü¢ Active", moveFilter === "ACTIVE", () =>
                  setMoveFilter("ACTIVE"),
                )}
                {pill("‚õî Invalid", moveFilter === "INVALIDATED", () =>
                  setMoveFilter("INVALIDATED"),
                )}
                {pill("‚úÖ Done", moveFilter === "COMPLETED", () =>
                  setMoveFilter("COMPLETED"),
                )}
                <div className="w-px h-6 bg-[#26325f] mx-1" />
                {pill("Any horizon", horizon === "ALL", () =>
                  setHorizon("ALL"),
                )}
                {pill("‚â§7d", horizon === "SHORT_TERM", () =>
                  setHorizon("SHORT_TERM"),
                )}
                {pill("8‚Äì30d", horizon === "SWING", () => setHorizon("SWING"))}
                {pill("31d+", horizon === "POSITIONAL", () =>
                  setHorizon("POSITIONAL"),
                )}
              </div>
            )}

            <div
              className={`mt-3 ${
                fillHeight ? "flex-1" : maxHeightClass
              } overflow-y-auto space-y-2 pr-1`}
            >
              {filtered.length === 0 ? (
                <div className="text-xs text-[#6b7a9f] p-3">No matches.</div>
              ) : (
                filtered.map((item) => <Row key={item.t.ticker} item={item} />)
              )}
            </div>
          </div>
        );
      }

      function ActionPanel({ tickers = [], onSelectTicker }) {
        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isActionable = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);

          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct)
            return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct)
            return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf)
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr)
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const selectWithConstraints = (list, limit) => {
          const maxPerSector = 1;
          const sectorCounts = new Map();
          const picks = [];
          for (const t of list) {
            if (picks.length >= limit) break;
            if (!isActionable(t)) continue;
            const sector =
              t.sector ||
              (t.fundamentals && t.fundamentals.sector) ||
              "UNKNOWN";
            const count = sectorCounts.get(sector) || 0;
            if (count >= maxPerSector) continue;
            sectorCounts.set(sector, count + 1);
            picks.push(t);
          }
          return picks;
        };

        const normBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const byBucket = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const pickWithConstraints = (bucket, limit) => {
            const sorted = list
              .filter((t) => normBucket(t) === bucket)
              .slice()
              .sort(
                (a, b) =>
                  (Number(b.dynamicRank) || 0) - (Number(a.dynamicRank) || 0),
              );
            return selectWithConstraints(sorted, limit);
          };
          return {
            SHORT_TERM: pickWithConstraints("SHORT_TERM", 3),
            SWING: pickWithConstraints("SWING", 3),
            POSITIONAL: pickWithConstraints("POSITIONAL", 2),
          };
        }, [tickers]);

        const renderRow = (label, bucket, items) => {
          return (
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="text-xs font-bold text-[#e7ecff]">{label}</div>
                <div className="text-[10px] text-[#93a4d6]">{bucket}</div>
              </div>
              {items.length === 0 ? (
                <div className="text-xs text-[#6b7a9f]">No matches.</div>
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-2">
                  {items.map((t) => {
                    const eta = computeEtaDays(t);
                    const retPct = computeReturnPct(t);
                    const riskPct = computeRiskPct(t);
                    const conf = getNum(t.eta_confidence);
                    const entryZone = formatEntryZone(t);
                    const sl = Number(t?.sl);
                    const tpTarget = computeTpTargetPrice(t);
                    const tpMax = computeTpMaxPrice(t);
                    const tpDisplay =
                      Number.isFinite(tpTarget) && tpTarget > 0
                        ? tpTarget
                        : Number.isFinite(tpMax) && tpMax > 0
                          ? tpMax
                          : null;
                    const price = Number(t?.price);
                    const staleness = String(t?.staleness || "").toUpperCase();
                    const isStale = staleness && staleness !== "FRESH";
                    const ingestText = formatIngestTime(t);
                    const avgCorr = Number(t?.avg_corr);
                    const diversity = Number(t?.diversity_score);
                    const skin = getCardSkin(t);
                    return (
                      <button
                        key={`${bucket}-${t.ticker}`}
                        onClick={() =>
                          onSelectTicker && onSelectTicker(t.ticker)
                        }
                        className={`text-left px-3 py-2 rounded-lg border border-[#26325f] bg-[#121a33] hover:brightness-[1.06] hover:border-[#3a4aa0] transition-all ${
                          skin?.dayEdgeClass || ""
                        }`}
                        style={{ backgroundImage: skin?.bgImage }}
                        title="Open in right rail"
                      >
                        <div className="flex items-center justify-between gap-2">
                          <div className="font-bold text-white">{t.ticker}</div>
                          <div className="text-[10px] text-[#93a4d6]">
                            Score {rankScoreForTicker(t).toFixed(1)}
                          </div>
                        </div>
                        <div className="mt-0.5 flex items-center justify-between gap-2 text-[10px] text-[#93a4d6]">
                          <div className="text-white">
                            {Number.isFinite(price)
                              ? `$${price.toFixed(2)}`
                              : "‚Äî"}
                          </div>
                          <div className="flex items-center gap-2">
                            {isStale && (
                              <span className="px-1.5 py-0.5 rounded bg-yellow-500/20 text-yellow-300 border border-yellow-500/40">
                                Delayed
                              </span>
                            )}
                            <span className="text-[#6b7a9f]">{ingestText}</span>
                          </div>
                        </div>
                        <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[#93a4d6]">
                          <div>
                            <span className="text-[#6b7a9f]">ETA</span>{" "}
                            <span className="text-white">
                              {eta != null ? `${eta.toFixed(1)}d` : "‚Äî"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">Ret</span>{" "}
                            <span className="text-white">
                              {retPct != null ? `${retPct.toFixed(1)}%` : "‚Äî"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">Risk</span>{" "}
                            <span className="text-white">
                              {riskPct != null ? `${riskPct.toFixed(1)}%` : "‚Äî"}
                            </span>
                          </div>
                        </div>
                        <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[#6b7a9f]">
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">Entry</span>{" "}
                            <span className="text-white whitespace-normal break-words">
                              {entryZone}
                            </span>
                          </div>
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">TP</span>{" "}
                            <span className="text-green-400">
                              {Number.isFinite(tpDisplay)
                                ? `$${tpDisplay.toFixed(2)}`
                                : "‚Äî"}
                            </span>
                          </div>
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">SL</span>{" "}
                            <span className="text-red-400">
                              {Number.isFinite(sl) ? `$${sl.toFixed(2)}` : "‚Äî"}
                            </span>
                          </div>
                        </div>
                        <div className="mt-1 text-[10px] text-[#6b7a9f]">
                          {conf != null ? `ETA conf: ${conf.toFixed(2)}` : ""}
                          {Number.isFinite(diversity) && (
                            <span className="ml-2 text-[#93a4d6]">
                              Div {Math.round(diversity)}
                            </span>
                          )}
                          {Number.isFinite(avgCorr) && (
                            <span className="ml-2 text-[#93a4d6]">
                              Corr {avgCorr.toFixed(2)}
                            </span>
                          )}
                        </div>
                      </button>
                    );
                  })}
                </div>
              )}
            </div>
          );
        };

        return (
          <div className="mb-4 p-3 bg-[#0f1630] border border-[#26325f] rounded-xl">
            <div className="flex items-center justify-between mb-3">
              <div className="text-sm font-bold text-white">
                üéØ Action Panel (Top Picks)
              </div>
              <div className="text-[10px] text-[#93a4d6]">
                Short=‚â§7d ‚Ä¢ Swing=8‚Äì30d ‚Ä¢ Positional=31d+
              </div>
            </div>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
              {renderRow("Short-Term", "SHORT_TERM", byBucket.SHORT_TERM)}
              {renderRow("Swing", "SWING", byBucket.SWING)}
              {renderRow("Positional", "POSITIONAL", byBucket.POSITIONAL)}
            </div>
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Ingestion Status Panel (minimizable)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function IngestionStatusPanel({
        allData,
        filteredTickers,
        onRefresh,
        defaultMinimized = true,
      }) {
        const storageKey = "timedTrading_ingestionPanelMinimized";
        const [minimized, setMinimized] = React.useState(() => {
          try {
            const raw = localStorage.getItem(storageKey);
            if (raw === null) return defaultMinimized;
            return raw === "true";
          } catch {
            return defaultMinimized;
          }
        });

        React.useEffect(() => {
          try {
            localStorage.setItem(storageKey, String(minimized));
          } catch {}
        }, [minimized]);

        const now = Date.now();
        const allTickers = React.useMemo(() => {
          if (!allData || typeof allData !== "object") return [];
          const values = Array.isArray(allData)
            ? allData
            : Object.values(allData);
          return values.filter((t) => t && typeof t === "object" && t.ticker);
        }, [allData]);

        const getMs = (x) => {
          if (!x) return null;
          if (typeof x === "number" && Number.isFinite(x)) return x;
          if (typeof x === "string") {
            const ms = new Date(x).getTime();
            return Number.isFinite(ms) ? ms : null;
          }
          return null;
        };

        const toAgeMin = (t) => {
          // Prefer ingest_ts, then ts
          const ms =
            getMs(t.ingest_ts) ||
            getMs(t.ts) ||
            getMs(t.timestamp) ||
            getMs(t.last_update);
          if (!ms) return null;
          return (now - ms) / 60000;
        };

        const stats = React.useMemo(() => {
          const bucket = {
            total: allTickers.length,
            filtered: Array.isArray(filteredTickers)
              ? filteredTickers.length
              : 0,
            missing: 0,
            fresh: 0,
            warn: 0,
            stale: 0,
            veryStale: 0,
            worst: [],
          };

          const withAge = allTickers
            .map((t) => {
              const ageMin = toAgeMin(t);
              return {
                ticker: t.ticker,
                ageMin,
                ingest_ts: t.ingest_ts,
                ts: t.ts,
              };
            })
            .sort((a, b) => {
              const aa = a.ageMin ?? -1;
              const bb = b.ageMin ?? -1;
              return bb - aa;
            });

          withAge.forEach((r) => {
            if (r.ageMin === null) {
              bucket.missing++;
              return;
            }
            if (r.ageMin <= 10) bucket.fresh++;
            else if (r.ageMin <= 20) bucket.warn++;
            else if (r.ageMin <= 60) bucket.stale++;
            else bucket.veryStale++;
          });

          bucket.worst = withAge.filter((r) => r.ageMin !== null).slice(0, 10);

          return bucket;
        }, [allTickers, filteredTickers, now]);

        const badge = (() => {
          if (stats.total === 0) return "‚Äî";
          if (stats.veryStale > 0 || stats.missing > 0) return "‚ö†Ô∏è";
          if (stats.stale > 0) return "üü°";
          return "‚úÖ";
        })();

        if (minimized) {
          return (
            <div className="fixed bottom-4 left-4 z-50">
              <button
                onClick={() => setMinimized(false)}
                className="px-3 py-2 bg-[#0f1630]/95 backdrop-blur-sm border border-[#26325f] rounded-lg text-xs text-white shadow-lg hover:bg-[#141f3d]"
              >
                üì° Ingestion {badge} ({stats.fresh}/{stats.total})
              </button>
            </div>
          );
        }

        return (
          <div className="fixed bottom-4 left-4 z-50 w-[340px] max-w-[90vw] bg-[#0f1630]/95 backdrop-blur-sm border border-[#26325f] rounded-xl shadow-2xl">
            <div className="flex items-center justify-between px-3 py-2 border-b border-[#26325f]">
              <div className="text-sm font-bold text-white flex items-center gap-2">
                üì° Ingestion Status <span className="text-xs">{badge}</span>
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={onRefresh}
                  className="px-2 py-1 bg-[#26325f] hover:bg-[#3a4aa0] rounded text-xs text-white"
                  title="Refresh data"
                >
                  üîÑ
                </button>
                <button
                  onClick={() => setMinimized(true)}
                  className="px-2 py-1 bg-[#26325f] hover:bg-[#3a4aa0] rounded text-xs text-white"
                  title="Minimize"
                >
                  ‚ñæ
                </button>
              </div>
            </div>

            <div className="p-3 text-xs text-[#93a4d6] space-y-2">
              <div className="flex flex-wrap gap-x-3 gap-y-1">
                <div>
                  <span className="text-white font-semibold">Total:</span>{" "}
                  {stats.total}
                </div>
                <div>
                  <span className="text-white font-semibold">Visible:</span>{" "}
                  {stats.filtered}
                </div>
              </div>

              <div className="grid grid-cols-2 gap-2">
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">Fresh (‚â§10m)</div>
                  <div className="text-[#2ecc71] font-bold">{stats.fresh}</div>
                </div>
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">Warn (10‚Äì20m)</div>
                  <div className="text-[#f39c12] font-bold">{stats.warn}</div>
                </div>
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">Stale (20‚Äì60m)</div>
                  <div className="text-[#e67e22] font-bold">{stats.stale}</div>
                </div>
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">
                    &gt;60m / Missing
                  </div>
                  <div className="text-[#e74c3c] font-bold">
                    {stats.veryStale + stats.missing}
                  </div>
                </div>
              </div>

              <div className="mt-2">
                <div className="text-white font-semibold mb-1">
                  Worst offenders
                </div>
                <div className="max-h-[160px] overflow-y-auto space-y-1 pr-1">
                  {stats.worst.length === 0 ? (
                    <div className="text-[#93a4d6]">No timestamps found.</div>
                  ) : (
                    stats.worst.map((r) => (
                      <div
                        key={r.ticker}
                        className="flex items-center justify-between bg-[#121a33] border border-[#26325f] rounded px-2 py-1"
                      >
                        <div className="text-white font-semibold">
                          {r.ticker}
                        </div>
                        <div className="text-[#93a4d6]">
                          {Math.round(r.ageMin)}m
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>

              <div className="text-[10px] text-[#6b7a9f]">
                Uses `ingest_ts` (preferred) then `ts` to estimate freshness.
              </div>
            </div>
          </div>
        );
      }

      // Helper: Get quadrant from state
      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK")
          return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL")
          return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR")
          return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK")
          return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      // Pattern detection
      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map((p) => p.state).filter(Boolean);
        const safeFlags = flags || {};

        // Pattern 1: Clean Q1‚ÜíQ2 or Q4‚ÜíQ3 transition (ideal entry)
        for (let i = 1; i < states.length; i++) {
          if (
            states[i - 1] === "HTF_BULL_LTF_PULLBACK" &&
            states[i] === "HTF_BULL_LTF_BULL"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1‚ÜíQ2 transition (Bull Entry)",
              quadrant: "Q1‚ÜíQ2",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
          if (
            states[i - 1] === "HTF_BEAR_LTF_PULLBACK" &&
            states[i] === "HTF_BEAR_LTF_BEAR"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4‚ÜíQ3 transition (Bear Entry)",
              quadrant: "Q4‚ÜíQ3",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 2: Momentum Elite + Setup quadrant
        const currentState = states[states.length - 1];
        if (
          (currentState === "HTF_BULL_LTF_PULLBACK" ||
            currentState === "HTF_BEAR_LTF_PULLBACK") &&
          safeFlags.momentum_elite
        ) {
          patterns.push({
            type: "ELITE_SETUP",
            description: "Momentum Elite in Setup Quadrant",
            quadrant: getQuadrantFromState(currentState)?.name,
            confidence: "HIGH",
          });
        }

        // Pattern 3: Squeeze release in setup quadrant
        const lastPoint = trail[trail.length - 1];
        if (lastPoint && lastPoint.flags && lastPoint.flags.sq30_release) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "SQUEEZE_SETUP",
              description: "Squeeze Release in Setup Quadrant",
              quadrant: q.name,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 4: Multiple quadrant visits (chop vs clean)
        const uniqueQuads = new Set(
          states.map((s) => getQuadrantFromState(s)?.q).filter(Boolean),
        );
        if (uniqueQuads.size > 2 && states.length > 5) {
          patterns.push({
            type: "CHOPPY",
            description: "Multiple quadrant visits (choppy action)",
            confidence: "MEDIUM",
          });
        } else if (uniqueQuads.size === 1 && states.length >= 3) {
          patterns.push({
            type: "STABLE",
            description: "Stable quadrant (consistent state)",
            quadrant: getQuadrantFromState(states[0])?.name,
            confidence: "MEDIUM",
          });
        }

        // Pattern 5: Phase zone change in setup
        if (lastPoint && lastPoint.flags && lastPoint.flags.phase_zone_change) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "PHASE_SHIFT",
              description: "Phase zone change in Setup",
              quadrant: q.name,
              confidence: "MEDIUM",
            });
          }
        }

        return patterns;
      }

      // Separate component for Quadrant Progression to properly use hooks
      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = React.useState([]);
        const [loading, setLoading] = React.useState(false); // Start as false
        const [hasLoaded, setHasLoaded] = React.useState(false);

        React.useEffect(() => {
          // Defer trail loading to not block initial render
          // Only load if component is mounted and ticker is valid
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const controller = new AbortController();
                const timeoutId2 = setTimeout(() => controller.abort(), 3000); // 3s timeout (reduced from 5s)

                const response = await fetch(
                  `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                    ticker.ticker,
                  )}`,
                  { signal: controller.signal },
                );

                clearTimeout(timeoutId2);

                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                if (data.ok && Array.isArray(data.trail)) {
                  setTrail(data.trail);
                } else {
                  setTrail([]); // Set empty if no trail data
                }
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.error("Failed to load trail:", e);
                }
                // Set empty trail on error to prevent infinite retries
                setTrail([]);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300); // Slightly longer delay to ensure overlay is rendered first
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);

        const sampledTrail = React.useMemo(
          () => downsampleByInterval(trail, 15 * 60 * 1000),
          [trail],
        );

        const patterns = detectPatterns(sampledTrail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = sampledTrail
          .map((p) => getQuadrantFromState(p.state))
          .filter(Boolean);

        return (
          <div className="mb-4 p-4 bg-[#0f1630] rounded-lg border border-[#26325f]">
            <div className="text-sm font-bold mb-3 text-[#93a4d6]">
              Quadrant Progression (15m increments)
            </div>

            {/* Quadrant Map */}
            <div className="grid grid-cols-2 gap-2 mb-4">
              {/* Q1 - Bull Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 1
                    ? "border-blue-400 bg-blue-500/20"
                    : quadHistory.some((q) => q && q.q === 1)
                      ? "border-blue-500/50 bg-blue-500/10"
                      : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-blue-400">
                  Q1: Bull Setup
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BULL_LTF_PULLBACK
                </div>
              </div>

              {/* Q2 - Bull Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 2
                    ? "border-green-400 bg-green-500/20"
                    : quadHistory.some((q) => q && q.q === 2)
                      ? "border-green-500/50 bg-green-500/10"
                      : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-green-400">
                  Q2: Bull Momentum
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BULL_LTF_BULL
                </div>
              </div>

              {/* Q4 - Bear Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 4
                    ? "border-orange-400 bg-orange-500/20"
                    : quadHistory.some((q) => q && q.q === 4)
                      ? "border-orange-500/50 bg-orange-500/10"
                      : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-orange-400">
                  Q4: Bear Setup
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BEAR_LTF_PULLBACK
                </div>
              </div>

              {/* Q3 - Bear Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 3
                    ? "border-red-400 bg-red-500/20"
                    : quadHistory.some((q) => q && q.q === 3)
                      ? "border-red-500/50 bg-red-500/10"
                      : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-red-400">
                  Q3: Bear Momentum
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BEAR_LTF_BEAR
                </div>
              </div>
            </div>

            {/* Path Visualization */}
            {trail.length > 0 && (
              <div className="mb-4">
                <div className="text-xs font-semibold text-[#93a4d6] mb-2">
                  Path ({trail.length} points)
                </div>
                <div className="flex items-center gap-1 flex-wrap">
                  {quadHistory.map((q, idx) => {
                    if (!q) return null;
                    const isLast = idx === quadHistory.length - 1;
                    const colorClasses = {
                      blue: isLast
                        ? "bg-blue-500/30 border-2 border-blue-400 text-blue-300"
                        : "bg-blue-500/10 border border-blue-500/50 text-blue-400",
                      green: isLast
                        ? "bg-green-500/30 border-2 border-green-400 text-green-300"
                        : "bg-green-500/10 border border-green-500/50 text-green-400",
                      red: isLast
                        ? "bg-red-500/30 border-2 border-red-400 text-red-300"
                        : "bg-red-500/10 border border-red-500/50 text-red-400",
                      orange: isLast
                        ? "bg-orange-500/30 border-2 border-orange-400 text-orange-300"
                        : "bg-orange-500/10 border border-orange-500/50 text-orange-400",
                    };
                    return (
                      <React.Fragment key={idx}>
                        <div
                          className={`px-2 py-1 rounded text-[10px] font-bold ${
                            colorClasses[q.color] || colorClasses.blue
                          }`}
                        >
                          {q.name}
                        </div>
                        {idx < quadHistory.length - 1 && (
                          <span className="text-[#93a4d6] text-xs">‚Üí</span>
                        )}
                      </React.Fragment>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Pattern Detection */}
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs font-bold text-yellow-400 mb-2">
                  üéØ Detected Patterns
                </div>
                <div className="space-y-2">
                  {patterns.map((pattern, idx) => (
                    <div
                      key={idx}
                      className={`p-2 rounded border ${
                        pattern.confidence === "HIGH"
                          ? "bg-yellow-500/20 border-yellow-400/50"
                          : "bg-blue-500/10 border-blue-500/30"
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="text-xs font-bold text-white">
                            {pattern.description}
                          </div>
                          {pattern.quadrant && (
                            <div className="text-[10px] text-[#93a4d6] mt-0.5">
                              {pattern.quadrant}
                            </div>
                          )}
                        </div>
                        <span
                          className={`text-[10px] px-1.5 py-0.5 rounded ${
                            pattern.confidence === "HIGH"
                              ? "bg-yellow-500/30 text-yellow-300"
                              : "bg-blue-500/30 text-blue-300"
                          }`}
                        >
                          {pattern.confidence}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {loading && (
              <div className="text-xs text-[#93a4d6] text-center py-2">
                Loading history...
              </div>
            )}
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Unified Ticker Detail Right Rail Component
      // Reusable component that shows comprehensive ticker information
      // and optionally trade history if a trade is associated
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function TickerDetailRightRail({
        ticker,
        trade = null,
        onClose,
        allLoadedData = null,
        rankedTickers = null,
        rankedTickerPositions = null,
        rankAsOfMs = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
      }) {
        const tickerSymbol = ticker?.ticker ? String(ticker.ticker) : "";

        // Fetch full latest payload for Right Rail (ensures `context` shows even when /timed/all is context-light).
        const [latestTicker, setLatestTicker] = useState(null);
        const [latestTickerLoading, setLatestTickerLoading] = useState(false);
        const [latestTickerError, setLatestTickerError] = useState(null);

        const [ledgerTrades, setLedgerTrades] = useState([]);
        const [ledgerTradesLoading, setLedgerTradesLoading] = useState(false);
        const [ledgerTradesError, setLedgerTradesError] = useState(null);

        const [bubbleJourney, setBubbleJourney] = useState([]);
        const [bubbleJourneyLoading, setBubbleJourneyLoading] = useState(false);
        const [bubbleJourneyError, setBubbleJourneyError] = useState(null);

        const [railTab, setRailTab] = useState("ANALYSIS"); // ANALYSIS | CHART | TECHNICALS | JOURNEY | TRADE_HISTORY

        // Right Rail: multi-timeframe candles chart (fetched on-demand)
        const [chartTf, setChartTf] = useState("60"); // Default to 1H
        const [chartCandles, setChartCandles] = useState([]);
        const [chartLoading, setChartLoading] = useState(false);
        const [chartError, setChartError] = useState(null);
        const [crosshair, setCrosshair] = useState(null);
        const chartScrollRef = useRef(null);
        
        // Accordion states (MUST be at component level, not inside IIFE blocks)
        const [scoreExpanded, setScoreExpanded] = useState(false);
        const [tpExpanded, setTpExpanded] = useState(false);

        // Prevent stale crosshair data from crashing renders when switching
        // tickers/timeframes/tabs quickly (e.g. clicking Chart right after selecting a ticker).
        useEffect(() => {
          setCrosshair(null);
        }, [tickerSymbol, chartTf, railTab]);

        // Default to Analysis when switching tickers
        useEffect(() => {
          setRailTab("ANALYSIS");
        }, [tickerSymbol]);

        useEffect(() => {
          setChartCandles([]);
          setChartError(null);
          setChartLoading(false);
        }, [tickerSymbol]);

        // Auto-scroll chart to most recent candle when data loads
        useEffect(() => {
          if (chartScrollRef.current && chartCandles.length > 0 && railTab === "ANALYSIS") {
            setTimeout(() => {
              if (chartScrollRef.current) {
                chartScrollRef.current.scrollLeft = chartScrollRef.current.scrollWidth;
              }
            }, 100);
          }
        }, [chartCandles.length, railTab]);

        useEffect(() => {
          const sym = String(tickerSymbol || "")
            .trim()
            .toUpperCase();
          if (railTab !== "ANALYSIS" || !sym) return;

          let cancelled = false;
          const run = async () => {
            try {
              setChartLoading(true);
              setChartError(null);
              const qs = new URLSearchParams();
              qs.set("ticker", sym);
              qs.set("tf", String(chartTf || "30"));
              qs.set("limit", "200");
              const res = await fetch(`${API_BASE}/timed/candles?${qs.toString()}`, {
                cache: "no-store",
              });
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok) throw new Error(json.error || "candles_failed");
              const candles = Array.isArray(json.candles) ? json.candles : [];
              if (!cancelled) setChartCandles(candles);
            } catch (e) {
              if (!cancelled) {
                setChartCandles([]);
                setChartError(String(e?.message || e));
              }
            } finally {
              if (!cancelled) setChartLoading(false);
            }
          };
          run();
          return () => {
            cancelled = true;
          };
        }, [railTab, tickerSymbol, chartTf]);

        useEffect(() => {
          const sym = String(tickerSymbol || "")
            .trim()
            .toUpperCase();
          if (!sym) {
            setLatestTicker(null);
            setLatestTickerError(null);
            setLatestTickerLoading(false);
            return;
          }

          let cancelled = false;
          const fetchLatest = async () => {
            try {
              setLatestTickerLoading(true);
              setLatestTickerError(null);
              const qs = new URLSearchParams();
              qs.set("ticker", sym);
              const res = await fetch(
                `${API_BASE}/timed/latest?${qs.toString()}`,
                { cache: "no-store" },
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok) throw new Error(json.error || "latest_failed");
              const data =
                (json.latestData && typeof json.latestData === "object"
                  ? json.latestData
                  : json.data && typeof json.data === "object"
                    ? json.data
                    : null) || null;
              if (!cancelled) setLatestTicker(data);
            } catch (e) {
              if (!cancelled) {
                setLatestTicker(null);
                setLatestTickerError(String(e?.message || e));
              }
            } finally {
              if (!cancelled) setLatestTickerLoading(false);
            }
          };
          fetchLatest();
          return () => {
            cancelled = true;
          };
        }, [tickerSymbol]);

        useEffect(() => {
          const sym = String(tickerSymbol || "")
            .trim()
            .toUpperCase();
          if (!sym) {
            setLedgerTrades([]);
            setLedgerTradesError(null);
            setLedgerTradesLoading(false);
            return;
          }

          let cancelled = false;
          const fetchLedgerTrades = async () => {
            try {
              setLedgerTradesLoading(true);
              setLedgerTradesError(null);
              const qs = new URLSearchParams();
              qs.set("ticker", sym);
              qs.set("limit", "20");
              const res = await fetch(
                `${API_BASE}/timed/ledger/trades?${qs.toString()}`,
                { cache: "no-store" },
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok)
                throw new Error(json.error || "ledger_trades_failed");
              const trades = Array.isArray(json.trades) ? json.trades : [];
              if (!cancelled) setLedgerTrades(trades);
            } catch (e) {
              if (!cancelled) {
                setLedgerTrades([]);
                setLedgerTradesError(String(e.message || e));
              }
            } finally {
              if (!cancelled) setLedgerTradesLoading(false);
            }
          };

          fetchLedgerTrades();
          return () => {
            cancelled = true;
          };
        }, [tickerSymbol]);

        useEffect(() => {
          const sym = String(tickerSymbol || "")
            .trim()
            .toUpperCase();
          if (!sym) {
            setBubbleJourney([]);
            setBubbleJourneyError(null);
            setBubbleJourneyLoading(false);
            return;
          }

          let cancelled = false;

          const toMs = (v) => {
            if (v == null) return NaN;
            if (typeof v === "number") return v;
            const n = Number(v);
            if (Number.isFinite(n)) return n;
            const d = new Date(String(v));
            const ms = d.getTime();
            return Number.isFinite(ms) ? ms : NaN;
          };

          const fetchBubbleJourney = async () => {
            try {
              setBubbleJourneyLoading(true);
              setBubbleJourneyError(null);
              const qs = new URLSearchParams();
              qs.set("ticker", sym);
              // Server may return oldest->newest; grab a reasonable window and sort client-side.
              qs.set("limit", "250");
              const res = await fetch(
                `${API_BASE}/timed/trail?${qs.toString()}`,
                {
                  cache: "no-store",
                },
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok) throw new Error(json.error || "trail_failed");
              const raw = Array.isArray(json.trail) ? json.trail : [];
              const normalized = normalizeTrailPoints(raw);
              const withTs = normalized
                .map((p) => {
                  const ts = toMs(
                    p.ts ?? p.timestamp ?? p.ingest_ts ?? p.ingest_time,
                  );
                  if (!Number.isFinite(ts)) return null;
                  return { ...p, __ts_ms: ts };
                })
                .filter(Boolean)
                .sort((a, b) => a.__ts_ms - b.__ts_ms);
              const last20 = withTs.slice(-20);
              if (!cancelled) setBubbleJourney(last20);
            } catch (e) {
              if (!cancelled) {
                setBubbleJourney([]);
                setBubbleJourneyError(String(e.message || e));
              }
            } finally {
              if (!cancelled) setBubbleJourneyLoading(false);
            }
          };

          fetchBubbleJourney();
          return () => {
            cancelled = true;
          };
        }, [tickerSymbol]);

        const safeTicker =
          ticker && typeof ticker === "object" ? ticker : null;
        const patternFlags = safeTicker?.flags || {};

        // IMPORTANT: Keep hooks unconditional (no early returns before hooks),
        // otherwise React will throw "Rendered more hooks than during the previous render".
        const detectedPatterns = React.useMemo(
          () => detectPatterns(bubbleJourney, patternFlags || {}),
          [bubbleJourney, patternFlags],
        );

        if (!safeTicker || !tickerSymbol) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = patternFlags;
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);
        const decisionSummary = summarizeEntryDecision(ticker);
        // Accordion states (must be at component level to avoid hooks errors)
        const [scoreExpanded, setScoreExpanded] = React.useState(false);
        const [tpExpanded, setTpExpanded] = React.useState(false);

        const triggerItems = (() => {
          const items = [];

          // Prefer explicit triggers from script payload
          if (Array.isArray(ticker.triggers)) {
            for (const t of ticker.triggers) {
              if (typeof t === "string" && t.trim()) items.push(t.trim());
            }
          }

          // Fallback to known fields/flags (backward compatible)
          if (items.length === 0) {
            const trigReason = String(ticker.trigger_reason || "").trim();
            const trigDir = String(ticker.trigger_dir || "").trim();
            const trigTf = String(ticker.trigger_tf || "").trim();
            if (trigReason) {
              const uncorroborated =
                ticker.trigger_reason_corroborated === false &&
                (trigReason === "EMA_CROSS_1H_13_48" ||
                  trigReason === "EMA_CROSS_30M_13_48");
              items.push(
                trigTf
                  ? `${trigReason}${trigDir ? " (" + trigDir + ")" : ""} [${trigTf}]${
                      uncorroborated ? " ‚ö†Ô∏è unconfirmed" : ""
                    }`
                  : `${trigReason}${trigDir ? " (" + trigDir + ")" : ""}${
                      uncorroborated ? " ‚ö†Ô∏è unconfirmed" : ""
                    }`,
              );
            }
            if (flags.sq30_release) items.push("SQUEEZE_RELEASE_30M");
            if (flags.st_flip_30m) items.push("ST_FLIP_30M");
            if (flags.st_flip_1h) items.push("ST_FLIP_1H");
            if (flags.ema_cross_1h_13_48) items.push("EMA_CROSS_1H_13_48");
            if (flags.buyable_dip_1h_13_48) items.push("BUYABLE_DIP_1H_13_48");
          }

          // Dedup
          return Array.from(new Set(items));
        })();
        const tfTech =
          ticker.tf_tech && typeof ticker.tf_tech === "object"
            ? ticker.tf_tech
            : null;
        const tfOrder = [
          { k: "W", label: "W" },
          { k: "D", label: "D" },
          { k: "4H", label: "4H" },
          { k: "1H", label: "1H" },
          { k: "30", label: "30m" },
          { k: "10", label: "10m" },
          { k: "3", label: "3m" },
        ];
        const emaLevels = [5, 13, 21, 48, 89, 200, 233];
        const divIcon = (code) =>
          code === "B" ? "üêÇ" : code === "S" ? "üêª" : "";
        const phaseDotLabel = (code) => {
          switch (code) {
            case "P100":
              return "‚ÜòÔ∏é +100";
            case "P618":
              return "‚ÜòÔ∏é +61.8";
            case "N618":
              return "‚ÜóÔ∏é -61.8";
            case "N100":
              return "‚ÜóÔ∏é -100";
            default:
              return code || "";
          }
        };

        const baseScore = Number(ticker.rank) || 0;
        const displayScore = rankScoreForTicker(ticker);
        const sortedByRank =
          rankedTickers && rankedTickers.length > 0
            ? rankedTickers
            : getRankedTickers(allLoadedData);
        const rankPosition =
          getRankPositionFromMap(rankedTickerPositions, tickerSymbol) ??
          getRankPosition(sortedByRank, tickerSymbol);
        const totalTickers = sortedByRank.length;
        const rankTotal =
          Number.isFinite(Number(ticker.rank_total)) &&
          Number(ticker.rank_total) > 0
            ? Number(ticker.rank_total)
            : totalTickers;

        const rankAsOfText = (() => {
          const ms = Number(rankAsOfMs);
          if (!Number.isFinite(ms)) return null;
          try {
            return new Date(ms).toLocaleTimeString("en-US", {
              hour: "numeric",
              minute: "2-digit",
              hour12: true,
            });
          } catch {
            return null;
          }
        })();

        return (
          <div className="w-full h-full flex flex-col">
            <div
              className="bg-[#121a33] border-2 border-[#26325f] rounded-xl w-full h-full flex flex-col shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Scrollable Content Area */}
              <div className="flex-1 overflow-y-auto">
                <div className="sticky top-0 z-30 bg-[#121a33] border-b border-[#26325f] px-6 py-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-xl font-bold">{tickerSymbol}</h3>
                      {ticker.price && (
                        <div className="text-sm text-white mt-1">
                          ${Number(ticker.price).toFixed(2)}
                        </div>
                      )}
                      {(() => {
                        const { dayChg, dayPct, stale, marketOpen } =
                          getDailyChange(ticker);
                        if (
                          !Number.isFinite(dayChg) &&
                          !Number.isFinite(dayPct)
                        )
                          return null;
                        const sign =
                          Number(dayChg || dayPct || 0) >= 0 ? "+" : "-";
                        const cls =
                          Number(dayChg || dayPct || 0) >= 0
                            ? "text-green-400"
                            : "text-red-400";
                        return (
                          <div className={`text-xs mt-0.5 ${cls}`}>
                            {Number.isFinite(dayChg)
                              ? `${sign}${fmtUsdAbs(dayChg)}`
                              : "‚Äî"}{" "}
                            {Number.isFinite(dayPct)
                              ? `(${sign}${Math.abs(dayPct).toFixed(2)}%)`
                              : ""}
                            {!marketOpen && (
                              <span className="ml-2 text-[10px] text-[#93a4d6]">
                                AH
                                {stale?.ageLabel
                                  ? ` ‚Ä¢ as of ${stale.ageLabel}`
                                  : ""}
                              </span>
                            )}
                          </div>
                        );
                      })()}
                      {(() => {
                        const stage = String(ticker?.kanban_stage || "");
                        const showEntryStats =
                          stage === "enter_now" ||
                          stage === "hold" ||
                          stage === "trim" ||
                          stage === "exit";
                        if (!showEntryStats) return null;
                        const price = numFromAny(ticker?.price);
                        const entryPriceRaw = numFromAny(ticker?.entry_price);
                        const entryRefRaw = numFromAny(ticker?.entry_ref);
                        const triggerRaw = numFromAny(ticker?.trigger_price);
                        const entryPx =
                          Number.isFinite(entryPriceRaw) && entryPriceRaw > 0
                            ? entryPriceRaw
                            : Number.isFinite(entryRefRaw) && entryRefRaw > 0
                              ? entryRefRaw
                              : Number.isFinite(triggerRaw) && triggerRaw > 0
                                ? triggerRaw
                                : null;
                        const dir = getDirectionFromState(ticker);
                        const entryPctRaw = numFromAny(
                          ticker?.entry_change_pct,
                        );
                        const entryPct = Number.isFinite(entryPctRaw)
                          ? entryPctRaw
                          : Number.isFinite(entryPx) &&
                              entryPx > 0 &&
                              Number.isFinite(price) &&
                              price > 0
                            ? dir === "SHORT"
                              ? ((entryPx - price) / entryPx) * 100
                              : ((price - entryPx) / entryPx) * 100
                            : null;
                        if (
                          !Number.isFinite(entryPx) &&
                          !Number.isFinite(entryPct)
                        )
                          return null;
                        return (
                          <div className="text-[11px] mt-1 text-cyan-300/90">
                            {Number.isFinite(entryPx)
                              ? `Entry $${Number(entryPx).toFixed(2)}`
                              : "Entry ‚Äî"}
                            {Number.isFinite(entryPct)
                              ? ` ‚Ä¢ Since entry ${entryPct >= 0 ? "+" : ""}${entryPct.toFixed(2)}%`
                              : ""}
                          </div>
                        );
                      })()}
                      
                      {/* Bias - Inline */}
                      {(() => {
                        const dir = getDirection(ticker);
                        return (
                          <div className="mt-2">
                            <span
                              className={`inline-block px-3 py-1 rounded-lg font-bold text-sm ${dir.bg} ${dir.color} border border-current/30`}
                            >
                              {dir.text === "LONG"
                                ? "üìà LONG"
                                : dir.text === "SHORT"
                                  ? "üìâ SHORT"
                                  : dir.text}
                            </span>
                          </div>
                        );
                      })()}
                      
                      {/* Groups - Inline */}
                      {(() => {
                        try {
                          const gs = groupsForTicker(ticker.ticker);
                          if (!Array.isArray(gs) || gs.length === 0)
                            return null;
                          const ordered = Array.isArray(GROUP_ORDER)
                            ? [...gs].sort(
                                (a, b) =>
                                  GROUP_ORDER.indexOf(a) -
                                  GROUP_ORDER.indexOf(b),
                              )
                            : gs;
                          return (
                            <div className="mt-2 flex flex-wrap gap-1.5">
                              {ordered.map((g) => {
                                const label = GROUP_LABELS[g] || g;
                                const isSocial = g === "Social";
                                return (
                                  <span
                                    key={`group-${g}`}
                                    className={`text-[9px] px-1.5 py-0.5 rounded border ${
                                      isSocial
                                        ? "bg-purple-500/15 border-purple-500/40 text-purple-200"
                                        : "bg-[#121a33] border-[#26325f] text-[#e7ecff]"
                                    }`}
                                  >
                                    {label}
                                  </span>
                                );
                              })}
                            </div>
                          );
                        } catch {
                          return null;
                        }
                      })()}
                    </div>
                    <button
                      onClick={onClose}
                      className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-8 h-8 flex items-center justify-center rounded hover:bg-[#26325f]"
                    >
                      ‚úï
                    </button>
                  </div>

                  {/* Last Ingest Date/Time */}
                  {(() => {
                    const ingestTime =
                      ticker.ingest_ts || ticker.ingest_time || ticker.ts;
                    if (!ingestTime) return null;
                    try {
                      const timeValue =
                        typeof ingestTime === "string"
                          ? new Date(ingestTime)
                          : new Date(Number(ingestTime));
                      if (isNaN(timeValue.getTime())) return null;
                      const displayDate = timeValue.toLocaleDateString(
                        "en-US",
                        {
                          month: "short",
                          day: "numeric",
                          year: "numeric",
                        },
                      );
                      const displayTime = timeValue.toLocaleTimeString(
                        "en-US",
                        {
                          hour: "numeric",
                          minute: "2-digit",
                          hour12: true,
                        },
                      );
                      const ageMs = Date.now() - timeValue.getTime();
                      const ageMinutes = Math.floor(ageMs / 60000);
                      const ageHours = Math.floor(ageMinutes / 60);
                      const ageDays = Math.floor(ageHours / 24);
                      let ageText;
                      let ageColor = "text-green-400";
                      if (ageMinutes < 5) {
                        ageText = `${ageMinutes}m ago`;
                        ageColor = "text-green-400";
                      } else if (ageMinutes < 60) {
                        ageText = `${ageMinutes}m ago`;
                        ageColor = "text-yellow-400";
                      } else if (ageHours < 24) {
                        ageText = `${ageHours}h ago`;
                        ageColor =
                          ageHours < 2 ? "text-yellow-400" : "text-orange-400";
                      } else {
                        ageText = `${ageDays}d ago`;
                        ageColor = "text-red-400";
                      }
                      return (
                        <div className="mt-2 text-xs flex items-center gap-2">
                          <span className="text-[#93a4d6]">Last Ingest:</span>
                          <span className="text-white font-semibold">
                            {displayDate} {displayTime}
                          </span>
                          <span className={`font-semibold ${ageColor}`}>
                            ({ageText})
                          </span>
                        </div>
                      );
                    } catch {
                      return null;
                    }
                  })()}

                  {/* Move status (Active / Invalidated / Completed) */}
                  {(() => {
                    const ms =
                      ticker?.move_status &&
                      typeof ticker.move_status === "object"
                        ? ticker.move_status
                        : null;
                    if (!ms || !ms.status) return null;

                    const status = String(ms.status || "").toUpperCase();
                    const severity = String(ms.severity || "").toUpperCase();
                    const reasonsRaw = Array.isArray(ms.reasons)
                      ? ms.reasons
                      : [];
                    const marketOpen = isNyRegularMarketOpen();
                    const staleInfo = getStaleInfo(ticker, {
                      maxAgeMin: marketOpen ? 90 : 72 * 60,
                    });

                    const pretty = (r) => {
                      const key = String(r || "").trim();
                      const map = {
                        sl_breached: "SL breached",
                        tp_reached: "TP reached",
                        daily_ema_regime_break: "Daily EMA regime break",
                        ichimoku_regime_break: "Ichimoku regime break",
                        late_cycle: "Late-cycle",
                        overextended: "Overextended",
                        left_entry_corridor: "Left entry corridor",
                      };
                      return map[key] || key.replace(/_/g, " ");
                    };

                    const pill =
                      status === "INVALIDATED"
                        ? "bg-red-500/15 text-red-300 border-red-500/40"
                        : status === "COMPLETED"
                          ? "bg-purple-500/15 text-purple-300 border-purple-500/40"
                          : "bg-green-500/10 text-green-300 border-green-500/30";

                    const icon =
                      status === "INVALIDATED"
                        ? "‚õî"
                        : status === "COMPLETED"
                          ? "‚úÖ"
                          : "üü¢";

                    const reasons = reasonsRaw
                      .filter((x) => x != null)
                      .map((x) => String(x))
                      .filter((x) => x.trim())
                      .slice(0, 8);

                    const freshnessLabel = (() => {
                      const isStale = !!staleInfo?.isStale;
                      const age = staleInfo?.ageLabel
                        ? ` (${staleInfo.ageLabel})`
                        : "";
                      return `${isStale ? "Stale" : "Fresh"}${age}`;
                    })();
                    const freshnessCls = staleInfo?.isStale
                      ? "text-yellow-300"
                      : "text-green-300";
                    const headlineReason =
                      reasons.length > 0 ? pretty(reasons[0]) : null;
                    const kanbanStageRaw = String(
                      ticker?.kanban_stage || "",
                    ).trim();
                    const kanbanStage = kanbanStageRaw
                      ? kanbanStageRaw.toUpperCase()
                      : "";
                    const kanbanPill =
                      kanbanStage === "EXIT"
                        ? "bg-red-500/15 text-red-300 border-red-500/40"
                        : kanbanStage === "TRIM"
                          ? "bg-yellow-500/15 text-yellow-300 border-yellow-500/40"
                          : kanbanStage === "DEFEND"
                            ? "bg-orange-500/15 text-orange-300 border-orange-500/40"
                            : kanbanStage === "HOLD"
                              ? "bg-blue-500/15 text-blue-300 border-blue-500/40"
                              : kanbanStage === "ENTER_NOW"
                                ? "bg-green-500/15 text-green-300 border-green-500/40"
                                : "bg-white/5 text-[#93a4d6] border-white/10";

                    return (
                      <div className="mt-2">
                        <div className="flex items-center gap-2 flex-wrap text-[11px]">
                          <span className="text-[#93a4d6]">Move:</span>
                          <span
                            className={`px-2 py-0.5 rounded border font-semibold ${pill}`}
                          >
                            {icon} {status}
                            {severity ? (
                              <span className="ml-1 text-[10px] opacity-80">
                                ({severity})
                              </span>
                            ) : null}
                          </span>
                          {kanbanStage ? (
                            <>
                              <span className="text-[#93a4d6]">Action:</span>
                              <span
                                className={`px-2 py-0.5 rounded border font-semibold ${kanbanPill}`}
                              >
                                {kanbanStage}
                              </span>
                            </>
                          ) : null}
                        </div>
                        <div className="mt-1 text-[10px] text-[#6b7a9f]">
                          <span className={`font-semibold ${freshnessCls}`}>
                            {freshnessLabel}
                          </span>
                          {(status === "INVALIDATED" ||
                            status === "COMPLETED") &&
                          headlineReason ? (
                            <span>
                              {" "}
                              ‚Ä¢{" "}
                              <span className="text-[#93a4d6]">
                                {status === "INVALIDATED"
                                  ? "Invalidated"
                                  : "Completed"}
                                :
                              </span>{" "}
                              <span className="text-[#e7ecff]">
                                {headlineReason}
                              </span>
                            </span>
                          ) : null}
                          {status === "ACTIVE" &&
                          headlineReason &&
                          severity &&
                          severity !== "NONE" ? (
                            <span>
                              {" "}
                              ‚Ä¢ <span className="text-[#93a4d6]">
                                Reason:
                              </span>{" "}
                              <span className="text-[#e7ecff]">
                                {headlineReason}
                              </span>
                            </span>
                          ) : null}
                        </div>
                        {status === "INVALIDATED" && reasons.length > 0 ? (
                          <div className="mt-1 flex flex-wrap gap-1.5">
                            {reasons.map((r, idx) => (
                              <span
                                key={`inv-reason-${idx}`}
                                className="px-2 py-0.5 rounded border border-red-500/20 bg-red-500/10 text-[10px] text-red-200"
                              >
                                {pretty(r)}
                              </span>
                            ))}
                          </div>
                        ) : null}
                        {status === "COMPLETED" && reasons.length > 0 ? (
                          <div className="mt-1 flex flex-wrap gap-1.5">
                            {reasons.map((r, idx) => (
                              <span
                                key={`comp-reason-${idx}`}
                                className="px-2 py-0.5 rounded border border-purple-500/20 bg-purple-500/10 text-[10px] text-purple-200"
                              >
                                {pretty(r)}
                              </span>
                            ))}
                          </div>
                        ) : null}
                      </div>
                    );
                  })()}

                  {/* Right Rail Tabs */}
                  <div className="mt-3 flex items-center gap-2 flex-wrap">
                    {[
                      { k: "ANALYSIS", label: "Analysis" },
                      { k: "TECHNICALS", label: "Technicals" },
                      { k: "JOURNEY", label: "Journey" },
                      {
                        k: "TRADE_HISTORY",
                        label: `Trade History (${Array.isArray(ledgerTrades) ? ledgerTrades.length : 0})`,
                      },
                    ].map((t) => {
                      const active = railTab === t.k;
                      return (
                        <button
                          key={`rail-tab-${t.k}`}
                          onClick={() => setRailTab(t.k)}
                          className={`px-3 py-1 rounded-lg border text-[11px] font-semibold transition-all ${
                            active
                              ? "border-blue-400 bg-blue-500/20 text-blue-200"
                              : "border-[#26325f] bg-[#0f1630] text-[#93a4d6] hover:text-white"
                          }`}
                        >
                          {t.label}
                        </button>
                      );
                    })}
                  </div>
                </div>

                {/* Padded body content (keeps header top-aligned) */}
                <div className="p-6 pt-4">
                  {railTab === "ANALYSIS" ? (
                    <>
                      {/* Context (optional enrichment from /timed/ingest-context) */}
                      {(() => {
                        const baseCtx =
                          ticker?.context && typeof ticker.context === "object"
                            ? ticker.context
                            : null;
                        const latestCtx =
                          latestTicker?.context &&
                          typeof latestTicker.context === "object"
                            ? latestTicker.context
                            : null;
                        const ctx =
                          baseCtx || latestCtx
                            ? { ...(baseCtx || {}), ...(latestCtx || {}) }
                            : null;
                        if (!ctx) return null;
                        const clean = (v) =>
                          v == null
                            ? ""
                            : String(v)
                                // Some capture strings can contain stray control chars (e.g. \r),
                                // which render oddly in the browser.
                                .replace(/\\r/g, "r")
                                .replace(/\r/g, "r")
                                .trim();

                        const name = clean(ctx.name);
                        const description = clean(ctx.description);
                        const sector = clean(ctx.sector);
                        const industry = clean(ctx.industry);
                        const country = clean(ctx.country);
                        const tr =
                          ctx.technical_rating &&
                          typeof ctx.technical_rating === "object"
                            ? ctx.technical_rating
                            : null;
                        const trStatus =
                          tr && tr.status ? String(tr.status) : null;
                        const trValue =
                          tr && Number.isFinite(Number(tr.value))
                            ? Number(tr.value)
                            : null;
                        const events =
                          ctx.events && typeof ctx.events === "object"
                            ? ctx.events
                            : null;
                        const lastEarnTs =
                          events &&
                          Number.isFinite(Number(events.last_earnings_ts))
                            ? Number(events.last_earnings_ts)
                            : null;
                        const lastDivTs =
                          events &&
                          Number.isFinite(Number(events.last_dividend_ts))
                            ? Number(events.last_dividend_ts)
                            : null;

                        const fmtDate = (ms) => {
                          if (!Number.isFinite(Number(ms))) return "‚Äî";
                          try {
                            return new Date(Number(ms)).toLocaleDateString(
                              "en-US",
                              {
                                month: "short",
                                day: "numeric",
                                year: "numeric",
                              },
                            );
                          } catch {
                            return "‚Äî";
                          }
                        };

                        return (
                          <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                            <div className="text-sm text-[#93a4d6] mb-2">
                              Context
                            </div>
                            {latestTickerLoading ? (
                              <div className="text-xs text-[#6b7a9f]">
                                Loading context‚Ä¶
                              </div>
                            ) : null}
                            {latestTickerError ? (
                              <div className="text-xs text-yellow-300">
                                Context unavailable: {latestTickerError}
                              </div>
                            ) : null}
                            {name ? (
                              <div className="text-sm font-semibold text-white leading-snug">
                                {name}
                              </div>
                            ) : null}
                            {description ? (
                              <div className="mt-1 text-xs text-[#93a4d6] leading-snug">
                                {description}
                              </div>
                            ) : null}
                            <div className="mt-1 text-[11px] text-[#93a4d6]">
                              {[sector, industry, country]
                                .filter(Boolean)
                                .join(" ‚Ä¢ ") || "‚Äî"}
                            </div>

                            {(trStatus || trValue != null || lastEarnTs || events?.next_earnings_ts) ? (
                              <div className="mt-2 grid grid-cols-2 gap-2 text-[10px]">
                                {(trStatus || trValue != null) ? (
                                  <div className="p-2 bg-[#121a33] border border-[#26325f] rounded">
                                    <div className="text-[9px] text-[#93a4d6] mb-1" title="Normalized score: 0=Strong Sell, 0.5=Neutral, 1=Strong Buy">
                                      Tech Rating {trValue != null ? `(${trValue.toFixed(2)})` : ''}
                                    </div>
                                    <div className="text-xs font-semibold text-white no-ligatures">
                                      {trStatus || "‚Äî"}
                                    </div>
                                  </div>
                                ) : null}
                                {events?.next_earnings_ts ? (
                                  <div className="p-2 bg-blue-500/10 border border-blue-500/30 rounded">
                                    <div className="text-[9px] text-blue-400 mb-1">
                                      Next Earnings
                                    </div>
                                    <div className="text-xs font-semibold text-white">
                                      {fmtDate(events.next_earnings_ts)}
                                    </div>
                                  </div>
                                ) : lastEarnTs ? (
                                  <div className="p-2 bg-[#121a33] border border-[#26325f] rounded">
                                    <div className="text-[9px] text-[#93a4d6] mb-1">
                                      Last Earnings
                                    </div>
                                    <div className="text-xs font-semibold text-white">
                                      {fmtDate(lastEarnTs)}
                                    </div>
                                  </div>
                                ) : null}
                              </div>
                            ) : null}
                          </div>
                        );
                      })()}

                      {prime && (
                        <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                          ‚≠ê PRIME SETUP ‚≠ê
                        </div>
                      )}

                      {/* Sector and Rating */}
                      {(() => {
                        const tickerSectorRaw =
                          getTickerSector(ticker.ticker) ||
                          ticker.sector ||
                          ticker.fundamentals?.sector ||
                          "";
                        const sectorKey = normalizeSectorKey(tickerSectorRaw);
                        if (sectorKey && sectors.length > 0) {
                          const sectorInfo = sectors.find((s) => {
                            const name = s?.sector || s?.name || "";
                            return normalizeSectorKey(name) === sectorKey;
                          });
                          const displaySector =
                            sectorInfo?.sector ||
                            sectorInfo?.name ||
                            sectorKeyToCanonicalName(sectorKey);
                          const rating = String(
                            sectorInfo?.rating || "neutral",
                          ).toLowerCase();
                          const boost =
                            sectorInfo?.boost != null
                              ? Number(sectorInfo.boost)
                              : null;
                          // Match emojis used in the filter pills
                          const emoji =
                            rating === "overweight"
                              ? "üí™"
                              : rating === "underweight"
                                ? "üëé"
                                : "üòí";
                          return (
                            <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                              <div className="text-sm text-[#93a4d6] mb-2">
                                Sector
                              </div>
                              <div className="flex items-center gap-2 flex-wrap">
                                <span className="text-base">{emoji}</span>
                                <span className="font-semibold text-white text-sm">
                                  {displaySector}
                                </span>
                                <span
                                  className={`text-[10px] px-2 py-0.5 rounded ${
                                    rating === "overweight"
                                      ? "bg-green-500/20 text-green-400"
                                      : rating === "underweight"
                                        ? "bg-red-500/20 text-red-400"
                                        : "bg-[#26325f] text-[#93a4d6]"
                                  }`}
                                >
                                  {rating.charAt(0).toUpperCase() +
                                    rating.slice(1)}
                                </span>
                                {Number.isFinite(boost) && boost !== 0 && (
                                  <span className="text-[9px] text-[#93a4d6]">
                                    Boost {boost > 0 ? `+${boost}` : boost}
                                  </span>
                                )}
                              </div>
                            </div>
                          );
                        }
                        return null;
                      })()}

                      {/* Merged Guidance + System Decision */}
                      <div
                        className={`mb-4 p-4 rounded-lg border-2 ${actionInfo.bg} border-current/30`}
                      >
                        <div className="flex items-center justify-between mb-3">
                          <div className="text-sm text-[#93a4d6] font-semibold">
                            System Guidance
                          </div>
                          {decisionSummary && (
                            <span
                              className={`px-2 py-0.5 rounded text-[10px] font-semibold ${decisionSummary.bg} ${decisionSummary.tone}`}
                            >
                              {decisionSummary.status}
                            </span>
                          )}
                        </div>
                        <div
                          className={`text-lg font-bold mb-2 ${actionInfo.color}`}
                        >
                          {actionInfo.action}
                        </div>
                        <div className="text-sm text-[#cbd5ff] leading-relaxed">
                          {actionInfo.description}
                        </div>
                        
                        {/* Stop Loss, Target Prices, R:R */}
                        {(() => {
                          const sl = ticker.sl ? Number(ticker.sl) : null;
                          const tpTarget = computeTpTargetPrice(ticker);
                          const tpMax = computeTpMaxPrice(ticker);
                          const rr = ticker.rr ? Number(ticker.rr) : null;
                          
                          const hasTargets = Number.isFinite(sl) || Number.isFinite(tpTarget) || Number.isFinite(tpMax) || Number.isFinite(rr);
                          if (!hasTargets) return null;
                          
                          return (
                            <div className="mt-3 pt-3 border-t border-current/20">
                              <div className="grid grid-cols-2 gap-2 text-xs">
                                {Number.isFinite(sl) && (
                                  <div className="p-2 bg-red-500/10 border border-red-500/30 rounded">
                                    <div className="text-[10px] text-red-300 mb-0.5">Stop Loss</div>
                                    <div className="font-semibold text-red-400">${sl.toFixed(2)}</div>
                                  </div>
                                )}
                                {Number.isFinite(tpTarget) && (
                                  <div className="p-2 bg-green-500/10 border border-green-500/30 rounded">
                                    <div className="text-[10px] text-green-300 mb-0.5">Target Price</div>
                                    <div className="font-semibold text-green-400">${tpTarget.toFixed(2)}</div>
                                  </div>
                                )}
                                {Number.isFinite(tpMax) && Math.abs(tpMax - (tpTarget || 0)) > 0.01 && (
                                  <div className="p-2 bg-green-500/10 border border-green-500/30 rounded">
                                    <div className="text-[10px] text-green-300 mb-0.5">Stretch Goal</div>
                                    <div className="font-semibold text-green-400">${tpMax.toFixed(2)}</div>
                                  </div>
                                )}
                                {Number.isFinite(rr) && (
                                  <div className="p-2 bg-blue-500/10 border border-blue-500/30 rounded">
                                    <div className="text-[10px] text-blue-300 mb-0.5">Risk:Reward</div>
                                    <div className="font-semibold text-blue-400">{rr.toFixed(2)}:1</div>
                                  </div>
                                )}
                              </div>
                            </div>
                          );
                        })()}

                        {/* Plain English Reasons */}
                        {(() => {
                          const ms = ticker?.move_status && typeof ticker.move_status === "object" ? ticker.move_status : null;
                          const reasonsRaw = Array.isArray(ms?.reasons) ? ms.reasons : [];
                          const reasons = reasonsRaw.filter((x) => x != null && String(x).trim()).slice(0, 5);
                          
                          const translateReason = (r) => {
                            const key = String(r || "").trim().toLowerCase();
                            const translations = {
                              'sl_breached': 'Stop loss price was hit',
                              'tp_reached': 'Target price was reached',
                              'daily_ema_regime_break': 'Price broke below key moving average support',
                              'ichimoku_regime_break': 'Trend structure weakened significantly',
                              'late_cycle': 'Move is in late stage, risk of reversal',
                              'overextended': 'Price stretched too far too fast',
                              'left_entry_corridor': 'Price moved outside ideal entry zone',
                              'corridor': 'Price is in ideal entry zone',
                              'aligned': 'All timeframes show same direction',
                              'prime': 'Setup meets all quality criteria',
                              'sq30_release': 'Consolidation breakout detected',
                              'momentum_elite': 'Stock has strong fundamental momentum',
                              'high_rank': 'Ranks highly vs other opportunities',
                              'good_rr': 'Favorable risk vs reward ratio'
                            };
                            return translations[key] || key.replace(/_/g, ' ');
                          };
                          
                          if (reasons.length === 0) return null;
                          
                          return (
                            <div className="mt-3 pt-3 border-t border-current/20">
                              <div className="text-xs text-[#93a4d6] mb-2 font-semibold">
                                Key Factors:
                              </div>
                              <div className="space-y-1.5">
                                {reasons.map((reason, idx) => (
                                  <div key={`reason-${idx}`} className="flex gap-2 text-xs text-[#cbd5ff]">
                                    <span className="text-cyan-400">‚Ä¢</span>
                                    <span>{translateReason(reason)}</span>
                                  </div>
                                ))}
                              </div>
                            </div>
                          );
                        })()}
                      </div>

                      {/* Score and Ranking */}
                      <div className="space-y-2.5 text-sm">
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Score</span>
                          <span className="font-semibold text-blue-400 text-lg">
                            {Number.isFinite(displayScore)
                              ? displayScore.toFixed(1)
                              : "‚Äî"}
                          </span>
                        </div>
                        {rankTotal > 0 && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">Rank</span>
                            <span className="font-semibold">
                              {rankPosition > 0
                                ? `#${rankPosition} of ${rankTotal}`
                                : "‚Äî"}
                              {rankAsOfText && (
                                <span className="ml-2 text-[10px] text-[#93a4d6] font-normal">
                                  (as of {rankAsOfText})
                                </span>
                              )}
                            </span>
                          </div>
                        )}
                        {/* Model Score (Worker-provided) */}
                        {(() => {
                          const ml =
                            ticker?.ml ||
                            ticker?.model ||
                            ticker?.model_v1 ||
                            ticker?.ml_v1 ||
                            null;
                          if (!ml || typeof ml !== "object") return null;
                          const p4h = Number(
                            ml?.p_win_4h ?? ml?.p4h ?? ml?.pWin4h,
                          );
                          const ev4h = Number(ml?.ev_4h ?? ml?.ev4h);
                          const p1d = Number(
                            ml?.p_win_1d ?? ml?.p1d ?? ml?.pWin1d,
                          );
                          const ev1d = Number(ml?.ev_1d ?? ml?.ev1d);
                          const has4h =
                            Number.isFinite(p4h) || Number.isFinite(ev4h);
                          const has1d =
                            Number.isFinite(p1d) || Number.isFinite(ev1d);
                          if (!has4h && !has1d) return null;
                          const fmtPct = (x) =>
                            Number.isFinite(x) ? `${(x * 100).toFixed(1)}%` : "‚Äî";
                          const fmtEv = (x) =>
                            Number.isFinite(x) ? `${x.toFixed(2)}%` : "‚Äî";
                          
                          // Plain English interpretation
                          const interpretML = (pWin, ev) => {
                            const p = Number(pWin) * 100;
                            const e = Number(ev);
                            if (!Number.isFinite(p) || !Number.isFinite(e)) return null;
                            
                            // Strong signals
                            if (p >= 70 && e >= 15) return { text: "üéØ Strong buy - high win%, great reward", color: "text-green-400", bg: "bg-green-500/10" };
                            if (p >= 60 && e >= 10) return { text: "‚úÖ Good setup - favorable odds", color: "text-green-400", bg: "bg-green-500/10" };
                            
                            // Positive but cautious
                            if (e >= 5 && p >= 55) return { text: "üü¢ Decent - small edge, manage risk", color: "text-blue-400", bg: "bg-blue-500/10" };
                            if (e >= 0 && p >= 60) return { text: "‚öñÔ∏è Neutral - breakeven odds", color: "text-yellow-400", bg: "bg-yellow-500/10" };
                            
                            // Warning signals
                            if (p >= 70 && e < 0) return { text: "‚ö†Ô∏è Too late - missed the entry", color: "text-orange-400", bg: "bg-orange-500/10" };
                            if (e < -5 && p >= 50) return { text: "üõë Skip - poor risk/reward", color: "text-red-400", bg: "bg-red-500/10" };
                            if (p < 45) return { text: "‚ùå Avoid - low probability", color: "text-red-400", bg: "bg-red-500/10" };
                            
                            // Default
                            return { text: "ü§î Unclear signal - use caution", color: "text-gray-400", bg: "bg-gray-500/10" };
                          };
                          
                          const interp4h = has4h ? interpretML(p4h, ev4h) : null;
                          const interp1d = has1d ? interpretML(p1d, ev1d) : null;
                          
                          return (
                            <>
                              {has4h && (
                                <>
                                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                    <span className="text-[#93a4d6]">
                                      Model (4h)
                                    </span>
                                    <span className="font-semibold text-purple-300">
                                      pWin {fmtPct(p4h)} ‚Ä¢ EV {fmtEv(ev4h)}
                                    </span>
                                  </div>
                                  {interp4h && (
                                    <div className={`text-xs py-2 px-3 rounded ${interp4h.bg} border border-${interp4h.color.replace('text-', '')}/30 mb-2`}>
                                      <span className={interp4h.color}>{interp4h.text}</span>
                                    </div>
                                  )}
                                </>
                              )}
                              {has1d && (
                                <>
                                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                    <span className="text-[#93a4d6]">
                                      Model (1d)
                                    </span>
                                    <span className="font-semibold text-purple-300">
                                      pWin {fmtPct(p1d)} ‚Ä¢ EV {fmtEv(ev1d)}
                                    </span>
                                  </div>
                                  {interp1d && (
                                    <div className={`text-xs py-2 px-3 rounded ${interp1d.bg} border border-${interp1d.color.replace('text-', '')}/30 mb-2`}>
                                      <span className={interp1d.color}>{interp1d.text}</span>
                                    </div>
                                  )}
                                </>
                              )}
                            </>
                          );
                        })()}
                        
                        {/* Momentum Elite (near scores) */}
                        {(() => {
                          const mp = ticker?.momentum_pct || {};
                          const hasMomentumData =
                            mp.week != null ||
                            mp.month != null ||
                            mp.three_months != null ||
                            mp.six_months != null;
                          const adr14 = Number(ticker?.adr_14);
                          const avgVol30 = Number(ticker?.avg_vol_30);
                          
                          if (!hasMomentumData && !flags.momentum_elite) return null;

                          const okAdr = Number.isFinite(adr14) && adr14 >= 2;
                          const okVol = Number.isFinite(avgVol30) && avgVol30 >= 2_000_000;

                          const w = mp.week != null ? Number(mp.week) : null;
                          const m = mp.month != null ? Number(mp.month) : null;
                          const m3 = mp.three_months != null ? Number(mp.three_months) : null;
                          const m6 = mp.six_months != null ? Number(mp.six_months) : null;
                          const okW = Number.isFinite(w) && w >= 10;
                          const okM = Number.isFinite(m) && m >= 25;
                          const ok3 = Number.isFinite(m3) && m3 >= 50;
                          const ok6 = Number.isFinite(m6) && m6 >= 100;
                          const okAnyMomentum = okW || okM || ok3 || ok6;

                          const okBase = okAdr && okVol;
                          const computedElite = okBase && okAnyMomentum;
                          const elite = !!flags.momentum_elite || computedElite;

                          const fmtVol = (v) => {
                            const n = Number(v);
                            if (!Number.isFinite(n) || n <= 0) return "‚Äî";
                            if (n >= 1_000_000) return `${(n / 1_000_000).toFixed(2)}M`;
                            if (n >= 1_000) return `${(n / 1_000).toFixed(0)}K`;
                            return String(Math.round(n));
                          };
                          
                          if (!elite) return null;

                          return (
                            <div className="border-t border-[#26325f] my-3 pt-3">
                              <div className="flex items-center gap-2 mb-2">
                                <span className="text-xs text-purple-300 font-bold">üöÄ Momentum Elite</span>
                                <span className="text-[9px] px-1.5 py-0.5 rounded border bg-purple-500/20 border-purple-500/40 text-purple-200">
                                  ACTIVE
                                </span>
                              </div>
                              <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                                {Number.isFinite(w) && (
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">1W:</span>
                                    <span className={`font-semibold ${okW ? 'text-green-400' : 'text-[#93a4d6]'}`}>
                                      {w.toFixed(1)}%
                                    </span>
                                  </div>
                                )}
                                {Number.isFinite(m) && (
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">1M:</span>
                                    <span className={`font-semibold ${okM ? 'text-green-400' : 'text-[#93a4d6]'}`}>
                                      {m.toFixed(1)}%
                                    </span>
                                  </div>
                                )}
                                {Number.isFinite(m3) && (
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">3M:</span>
                                    <span className={`font-semibold ${ok3 ? 'text-green-400' : 'text-[#93a4d6]'}`}>
                                      {m3.toFixed(1)}%
                                    </span>
                                  </div>
                                )}
                                {Number.isFinite(m6) && (
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">6M:</span>
                                    <span className={`font-semibold ${ok6 ? 'text-green-400' : 'text-[#93a4d6]'}`}>
                                      {m6.toFixed(1)}%
                                    </span>
                                  </div>
                                )}
                              </div>
                            </div>
                          );
                        })()}

                        {/* Score Breakdown (Accordion) */}
                        {(() => {
                          const breakdown = calculateScoreBreakdown(ticker);
                          const breakdownComponents = [
                            {
                              label: "Base Score",
                              value: breakdown.base,
                              color: "text-blue-400",
                            },
                            breakdown.corridor > 0
                              ? {
                                  label: "In Corridor",
                                  value: `+${breakdown.corridor}`,
                                  color: "text-cyan-400",
                                }
                              : null,
                            breakdown.corridorAligned > 0
                              ? {
                                  label: "Aligned + Corridor",
                                  value: `+${breakdown.corridorAligned}`,
                                  color: "text-green-400",
                                }
                              : null,
                            breakdown.htfStrength > 0
                              ? {
                                  label: "HTF Strength",
                                  value: `+${breakdown.htfStrength.toFixed(2)}`,
                                  color: "text-cyan-400",
                                }
                              : null,
                            breakdown.ltfStrength > 0
                              ? {
                                  label: "LTF Strength",
                                  value: `+${breakdown.ltfStrength.toFixed(2)}`,
                                  color: "text-cyan-400",
                                }
                              : null,
                            breakdown.completion !== 0
                              ? {
                                  label: "Completion",
                                  value:
                                    breakdown.completion > 0
                                      ? `+${breakdown.completion}`
                                      : `${breakdown.completion}`,
                                  color:
                                    breakdown.completion > 0
                                      ? "text-yellow-400"
                                      : "text-red-400",
                                }
                              : null,
                            breakdown.phase !== 0
                              ? {
                                  label: "Phase",
                                  value:
                                    breakdown.phase > 0
                                      ? `+${breakdown.phase}`
                                      : `${breakdown.phase}`,
                                  color:
                                    breakdown.phase > 0
                                      ? "text-green-400"
                                      : "text-red-400",
                                }
                              : null,
                            breakdown.squeezeRelease > 0
                              ? {
                                  label: "Squeeze Release (Corridor)",
                                  value: `+${breakdown.squeezeRelease}`,
                                  color: "text-purple-400",
                                }
                              : null,
                            breakdown.squeezeOn > 0
                              ? {
                                  label: "Squeeze On (Corridor)",
                                  value: `+${breakdown.squeezeOn}`,
                                  color: "text-yellow-400",
                                }
                              : null,
                            breakdown.phaseZoneChange > 0
                              ? {
                                  label: "Phase Zone Change",
                                  value: `+${breakdown.phaseZoneChange}`,
                                  color: "text-blue-400",
                                }
                              : null,
                            breakdown.rr !== 0
                              ? {
                                  label: "Risk/Reward",
                                  value: `+${breakdown.rr}`,
                                  color: "text-green-400",
                                }
                              : null,
                          ].filter(Boolean);

                          return breakdownComponents.length > 0 ? (
                            <div className="border-t border-[#26325f] my-3 pt-3">
                              <button
                                onClick={() => setScoreExpanded(!scoreExpanded)}
                                className="w-full flex items-center justify-between text-xs text-[#93a4d6] mb-2 font-semibold hover:text-white transition-colors"
                              >
                                <span>Score Breakdown</span>
                                <span className="text-base">{scoreExpanded ? "‚ñº" : "‚ñ∂"}</span>
                              </button>
                              {scoreExpanded && (
                                <div className="space-y-1.5">
                                  {breakdownComponents.map((comp, idx) => (
                                    <div
                                      key={idx}
                                      className="flex justify-between items-center text-xs"
                                    >
                                      <span className="text-[#93a4d6]">
                                        {comp.label}
                                      </span>
                                      <span
                                        className={`font-semibold ${comp.color}`}
                                      >
                                        {comp.value}
                                      </span>
                                    </div>
                                  ))}
                                  <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                                    <span className="text-[#93a4d6] font-semibold">
                                      Total Score
                                    </span>
                                    <span className="text-blue-400 font-bold text-base">
                                      {Number.isFinite(breakdown.total)
                                        ? breakdown.total.toFixed(1)
                                        : "‚Äî"}
                                    </span>
                                  </div>
                                </div>
                              )}
                            </div>
                          ) : null;
                        })()}

                        {/* Momentum Elite (Compact) */}
                        {(() => {
                          const mp = ticker?.momentum_pct || {};
                          const adr14 = Number(ticker?.adr_14);
                          const avgVol30 = Number(ticker?.avg_vol_30);
                          const w = mp.week != null ? Number(mp.week) : null;
                          const m = mp.month != null ? Number(mp.month) : null;
                          const m3 = mp.three_months != null ? Number(mp.three_months) : null;
                          const m6 = mp.six_months != null ? Number(mp.six_months) : null;
                          
                          const okAdr = Number.isFinite(adr14) && adr14 >= 2;
                          const okVol = Number.isFinite(avgVol30) && avgVol30 >= 2_000_000;
                          const okW = Number.isFinite(w) && w >= 10;
                          const okM = Number.isFinite(m) && m >= 25;
                          const ok3 = Number.isFinite(m3) && m3 >= 50;
                          const ok6 = Number.isFinite(m6) && m6 >= 100;
                          const okAnyMomentum = okW || okM || ok3 || ok6;
                          const okBase = okAdr && okVol;
                          const computedElite = okBase && okAnyMomentum;
                          const elite = !!flags.momentum_elite || computedElite;
                          
                          if (!elite) return null;
                          
                          return (
                            <div className="border-t border-[#26325f] my-3 pt-3">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xs text-[#93a4d6] font-semibold">üöÄ Momentum Elite</span>
                                <span className="text-[10px] px-2 py-0.5 rounded border bg-purple-500/20 border-purple-500/40 text-purple-200">
                                  ACTIVE
                                </span>
                              </div>
                              <div className="text-[10px] text-purple-200/70 space-y-0.5">
                                {okAdr && <div>‚úÖ ADR(14D) ‚â• $2 ‚Ä¢ ${adr14.toFixed(2)}</div>}
                                {okVol && <div>‚úÖ Vol(30D) ‚â• 2M ‚Ä¢ {(avgVol30 / 1_000_000).toFixed(2)}M</div>}
                                {okW && <div>‚úÖ 1W momentum {w.toFixed(1)}%</div>}
                                {okM && <div>‚úÖ 1M momentum {m.toFixed(1)}%</div>}
                                {ok3 && <div>‚úÖ 3M momentum {m3.toFixed(1)}%</div>}
                                {ok6 && <div>‚úÖ 6M momentum {m6.toFixed(1)}%</div>}
                              </div>
                            </div>
                          );
                        })()}

                        {/* TP Levels Array (Accordion) */}
                        {(() => {
                          const tpLevels = ticker.tp_levels || [];
                          if (!Array.isArray(tpLevels) || tpLevels.length === 0) return null;
                          
                          // Extract prices from tp_levels (handle both object and number formats)
                          const tpPrices = tpLevels
                            .map((tpItem) => {
                              if (
                                typeof tpItem === "object" &&
                                tpItem !== null &&
                                tpItem.price != null
                              ) {
                                return {
                                  price: Number(tpItem.price),
                                  source: tpItem.source || "ATR Level",
                                  type: tpItem.type || "ATR_FIB",
                                  timeframe: tpItem.timeframe || "D",
                                  label: tpItem.label || "TP",
                                };
                              }
                              return {
                                price:
                                  typeof tpItem === "number"
                                    ? Number(tpItem)
                                    : Number(tpItem),
                                source: "ATR Level",
                                type: "ATR_FIB",
                                timeframe: "D",
                                label: "TP",
                              };
                            })
                            .filter(
                              (p) => Number.isFinite(p.price) && p.price > 0,
                            );

                          if (tpPrices.length === 0) return null;
                          
                          // Sort by price (ascending for LONG, descending for SHORT)
                          const direction = ticker.state?.includes("BULL")
                            ? "LONG"
                            : ticker.state?.includes("BEAR")
                              ? "SHORT"
                              : null;
                          const isLong = direction === "LONG";
                          tpPrices.sort((a, b) =>
                            isLong ? a.price - b.price : b.price - a.price,
                          );

                          return (
                            <div className="border-t border-[#26325f] my-3 pt-3">
                              <button
                                onClick={() => setTpExpanded(!tpExpanded)}
                                className="w-full flex items-center justify-between text-xs text-[#93a4d6] mb-2 font-semibold hover:text-white transition-colors"
                              >
                                <span>TP Levels ({tpPrices.length})</span>
                                <span className="text-base">{tpExpanded ? "‚ñº" : "‚ñ∂"}</span>
                              </button>
                              {tpExpanded && (
                                <div className="space-y-1.5 max-h-48 overflow-y-auto">
                                  {tpPrices.map((tpItem, idx) => {
                                    const tf = tpItem.timeframe || "D";
                                    const tfLabel =
                                      tf === "W"
                                        ? "W"
                                        : tf === "D"
                                          ? "D"
                                          : tf === "240" || tf === "4H"
                                            ? "4H"
                                            : tf;
                                    return (
                                      <div
                                        key={idx}
                                        className="flex justify-between items-center text-xs bg-[#0f1630] rounded px-2 py-1.5 border border-[#26325f]/30"
                                      >
                                        <div className="flex items-center gap-2">
                                          <span className="text-green-400 font-semibold">
                                            ${tpItem.price.toFixed(2)}
                                          </span>
                                          <span className="text-[#93a4d6] text-[10px]">
                                            {tpItem.source !== "ATR Level"
                                              ? tpItem.source
                                              : ""}
                                            {tpItem.timeframe
                                              ? ` (${tfLabel})`
                                              : ""}
                                          </span>
                                        </div>
                                        <span className="text-[#93a4d6] text-[10px]">
                                          {tpItem.type !== "ATR_FIB"
                                            ? tpItem.type
                                            : ""}
                                        </span>
                                      </div>
                                    );
                                  })}
                                </div>
                              )}
                            </div>
                          );
                        })()}
                      </div>

                      {/* Chart */}
                      <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                        <div className="flex items-center justify-between gap-2 mb-3">
                          <div className="text-sm text-[#93a4d6]">Chart</div>
                          <div className="flex items-center gap-1 flex-wrap">
                            {[
                              { tf: "1", label: "1m" },
                              { tf: "3", label: "3m" },
                              { tf: "5", label: "5m" },
                              { tf: "10", label: "10m" },
                              { tf: "30", label: "30m" },
                              { tf: "60", label: "1H" },
                              { tf: "240", label: "4H" },
                              { tf: "D", label: "D" },
                              { tf: "W", label: "W" },
                            ].map((t) => {
                              const active = String(chartTf) === String(t.tf);
                              return (
                                <button
                                  key={`tf-${t.tf}`}
                                  onClick={() => setChartTf(String(t.tf))}
                                  className={`px-2 py-1 rounded border text-[11px] font-semibold transition-all ${
                                    active
                                      ? "border-blue-400 bg-blue-500/20 text-blue-200"
                                      : "border-[#26325f] bg-[#121a33] text-[#93a4d6] hover:text-white"
                                  }`}
                                  title={`Show ${t.label} candles`}
                                >
                                  {t.label}
                                </button>
                              );
                            })}
                          </div>
                        </div>

                        {chartLoading ? (
                          <div className="text-xs text-[#93a4d6]">
                            Loading candles‚Ä¶
                          </div>
                        ) : chartError ? (
                          <div className="text-xs text-yellow-300">
                            Failed to load candles: {chartError}
                          </div>
                        ) : !Array.isArray(chartCandles) ||
                          chartCandles.length < 2 ? (
                          <div className="text-xs text-[#93a4d6]">
                            No candles yet for this timeframe.
                          </div>
                        ) : (
                          (() => {
                            try {
                              const toMs = (v) => {
                                if (v == null) return NaN;
                                if (typeof v === "number") {
                                  return v > 1e12 ? v : v * 1000;
                                }
                                const n = Number(v);
                                if (Number.isFinite(n)) return n > 1e12 ? n : n * 1000;
                                const d = new Date(String(v));
                                const ms = d.getTime();
                                return Number.isFinite(ms) ? ms : NaN;
                              };

                              const norm = (c) => {
                                const tsRaw = c?.ts ?? c?.t ?? c?.time ?? c?.timestamp;
                                const tsMs = toMs(tsRaw);
                                const o = Number(c?.o ?? c?.open);
                                const h = Number(c?.h ?? c?.high);
                                const l = Number(c?.l ?? c?.low);
                                const cl = Number(c?.c ?? c?.close);
                                if (
                                  !Number.isFinite(tsMs) ||
                                  !Number.isFinite(o) ||
                                  !Number.isFinite(h) ||
                                  !Number.isFinite(l) ||
                                  !Number.isFinite(cl)
                                )
                                  return null;
                                return { ...c, ts: tsMs, __ts_ms: tsMs, o, h, l, c: cl };
                              };

                              let candles = (Array.isArray(chartCandles) ? chartCandles : [])
                                .slice(-400)
                                .map(norm)
                                .filter(Boolean);

                              candles.sort((a, b) => Number(a.__ts_ms) - Number(b.__ts_ms));

                              const weekStartUtcMs = (tsMs) => {
                                const d0 = new Date(Number(tsMs));
                                const day = d0.getUTCDay();
                                const daysSinceMon = (day + 6) % 7;
                                const d = new Date(
                                  d0.getTime() - daysSinceMon * 24 * 60 * 60 * 1000,
                                );
                                d.setUTCHours(0, 0, 0, 0);
                                return d.getTime();
                              };

                              if (String(chartTf) === "W") {
                                const byWeek = new Map();
                                for (const c of candles) {
                                  const wk = weekStartUtcMs(c.__ts_ms);
                                  const prev = byWeek.get(wk);
                                  if (!prev) {
                                    byWeek.set(wk, {
                                      ts: wk,
                                      __ts_ms: wk,
                                      o: Number(c.o),
                                      h: Number(c.h),
                                      l: Number(c.l),
                                      c: Number(c.c),
                                      _last_ts: Number(c.__ts_ms),
                                    });
                                  } else {
                                    prev.h = Math.max(Number(prev.h), Number(c.h));
                                    prev.l = Math.min(Number(prev.l), Number(c.l));
                                    if (Number(c.__ts_ms) >= Number(prev._last_ts)) {
                                      prev.c = Number(c.c);
                                      prev._last_ts = Number(c.__ts_ms);
                                    }
                                  }
                                }
                                candles = Array.from(byWeek.values())
                                  .sort((a, b) => Number(a.__ts_ms) - Number(b.__ts_ms))
                                  .map((c) => {
                                    const out = { ...c };
                                    delete out._last_ts;
                                    return out;
                                  });
                              } else {
                                const byTs = new Map();
                                for (const c of candles) byTs.set(Number(c.__ts_ms), c);
                                candles = Array.from(byTs.values()).sort(
                                  (a, b) => Number(a.__ts_ms) - Number(b.__ts_ms),
                                );
                              }

                              const n = candles.length;
                              if (n < 2) {
                                return (
                                  <div className="text-xs text-[#93a4d6]">
                                    Candle data loaded, but not in expected format.
                                  </div>
                                );
                              }

                              const lows = candles.map((c) => Number(c.l));
                              const highs = candles.map((c) => Number(c.h));
                              let minL = Math.min(...lows);
                              let maxH = Math.max(...highs);
                              if (!Number.isFinite(minL) || !Number.isFinite(maxH))
                                throw new Error("invalid_minmax");
                              if (maxH <= minL) {
                                maxH = minL + 1;
                              }
                              const pad = (maxH - minL) * 0.05;
                              minL -= pad;
                              maxH += pad;

                            const H = 280;
                            const leftMargin = 10;
                            const rightMargin = 70;
                            const candleW = 8;
                            const candleGap = 2;
                            const candleStep = candleW + candleGap;
                            const plotW = n * candleStep;
                            const W = plotW + leftMargin + rightMargin;
                            const plotH = H;
                            const y = (p) =>
                              plotH - ((p - minL) / (maxH - minL)) * plotH;
                            const bodyW = candleW * 0.9;

                            const priceStep = (maxH - minL) / 5;
                            const priceTicks = [];
                            for (let i = 0; i <= 5; i++) {
                              priceTicks.push(minL + priceStep * i);
                            }

                              const handleMouseMove = (e) => {
                                const svg = e.currentTarget;
                                const rect = svg.getBoundingClientRect();
                                if (!rect || rect.width <= 0 || rect.height <= 0) return;
                                
                                const pt = svg.createSVGPoint();
                                pt.x = e.clientX;
                                pt.y = e.clientY;
                                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                                const svgX = svgP.x;
                                const svgY = svgP.y;
                                
                                if (svgX < leftMargin || svgX > W - rightMargin) return;
                                const idx = Math.floor(((svgX - leftMargin) / plotW) * n);
                                if (idx >= 0 && idx < n) {
                                  const c = candles[idx];
                                  if (!c) return;
                                  const price =
                                    minL + ((H - svgY) / plotH) * (maxH - minL);
                                  setCrosshair({ x: svgX, y: svgY, candle: c, price });
                                }
                              };

                            return (
                              <div className="w-full relative -mx-3 px-3">
                                <div
                                  ref={chartScrollRef}
                                  className="overflow-x-auto overflow-y-hidden bg-[#0b1020]"
                                  style={{
                                    scrollbarWidth: "thin",
                                    scrollbarColor: "#26325f #0b1020",
                                    WebkitOverflowScrolling: "touch"
                                  }}
                                >
                                  <svg
                                    viewBox={`0 0 ${W} ${H}`}
                                    preserveAspectRatio="none"
                                    style={{ width: `${W}px`, height: `${H}px`, display: "block", minWidth: "100%" }}
                                    className="cursor-crosshair"
                                    onMouseMove={handleMouseMove}
                                    onMouseLeave={() => setCrosshair(null)}
                                  >
                                  {priceTicks.map((p, i) => {
                                    const yPos = y(p);
                                    return (
                                      <g key={`grid-${i}`}>
                                        <line
                                          x1={leftMargin}
                                          y1={yPos}
                                          x2={W - rightMargin}
                                          y2={yPos}
                                          stroke="rgba(38,50,95,0.5)"
                                          strokeWidth="1"
                                        />
                                        <text
                                          x={W - rightMargin + 6}
                                          y={yPos + 4}
                                          fontSize="11"
                                          fill="#93a4d6"
                                          fontFamily="monospace"
                                        >
                                          ${p.toFixed(2)}
                                        </text>
                                      </g>
                                    );
                                  })}

                                  {candles.map((c, i) => {
                                    const o = Number(c.o);
                                    const h = Number(c.h);
                                    const l = Number(c.l);
                                    const cl = Number(c.c);
                                    const up = cl >= o;
                                    const stroke = up
                                      ? "rgba(56,189,248,0.95)"
                                      : "rgba(251,146,60,0.95)";
                                    const fill = up
                                      ? "rgba(56,189,248,0.90)"
                                      : "rgba(251,146,60,0.90)";

                                    const cx = leftMargin + i * candleStep + candleStep / 2;
                                    const yH = y(h);
                                    const yL = y(l);
                                    const yO = y(o);
                                    const yC = y(cl);
                                    const top = Math.min(yO, yC);
                                    const bot = Math.max(yO, yC);
                                    const bodyH = Math.max(1.5, bot - top);

                                    return (
                                      <g key={`c-${Number(c.ts)}-${i}`}>
                                        <line
                                          x1={cx}
                                          y1={yH}
                                          x2={cx}
                                          y2={yL}
                                          stroke={stroke}
                                          strokeWidth="1.2"
                                        />
                                        <rect
                                          x={cx - bodyW / 2}
                                          y={top}
                                          width={bodyW}
                                          height={bodyH}
                                          fill={fill}
                                          stroke="none"
                                          rx="0.5"
                                        />
                                      </g>
                                    );
                                  })}

                                  {crosshair ? (
                                    <>
                                      <line
                                        x1={leftMargin}
                                        y1={crosshair.y}
                                        x2={W - rightMargin}
                                        y2={crosshair.y}
                                        stroke="rgba(147,164,214,0.5)"
                                        strokeWidth="1"
                                        strokeDasharray="4 4"
                                      />
                                      <line
                                        x1={crosshair.x}
                                        y1={0}
                                        x2={crosshair.x}
                                        y2={H}
                                        stroke="rgba(147,164,214,0.5)"
                                        strokeWidth="1"
                                        strokeDasharray="4 4"
                                      />
                                      {(() => {
                                        const yLabel = Math.max(
                                          10,
                                          Math.min(H - 10, Number(crosshair.y)),
                                        );
                                        const price = Number(crosshair.price);
                                        const priceText = Number.isFinite(price)
                                          ? `$${price.toFixed(2)}`
                                          : "‚Äî";
                                        return (
                                          <g>
                                            <rect
                                              x={W - rightMargin + 2}
                                              y={yLabel - 10}
                                              width={rightMargin - 4}
                                              height={20}
                                              fill="rgba(18,26,51,0.92)"
                                              stroke="rgba(38,50,95,0.9)"
                                              strokeWidth="1"
                                              rx="4"
                                            />
                                            <text
                                              x={W - rightMargin + (rightMargin - 4) / 2}
                                              y={yLabel + 4}
                                              fontSize="11"
                                              fill="#fbbf24"
                                              fontFamily="monospace"
                                              fontWeight="700"
                                              textAnchor="middle"
                                            >
                                              {priceText}
                                            </text>
                                          </g>
                                        );
                                      })()}
                                    </>
                                  ) : null}
                                  </svg>
                                </div>

                                {crosshair && crosshair.candle ? (
                                  <div
                                    className="absolute top-2 left-2 px-3 py-2 bg-[#121a33]/95 border border-[#26325f] rounded-lg text-[11px] pointer-events-none z-10"
                                    style={{
                                      backdropFilter: "blur(8px)",
                                      boxShadow: "0 4px 12px rgba(0,0,0,0.3)",
                                    }}
                                  >
                                    <div className="font-semibold text-white mb-1">
                                      {(() => {
                                        try {
                                          const ts = Number(
                                            crosshair?.candle?.__ts_ms ??
                                              crosshair?.candle?.ts,
                                          );
                                          if (!Number.isFinite(ts)) return "‚Äî";
                                          const d = new Date(ts);
                                          return d.toLocaleString("en-US", {
                                            month: "short",
                                            day: "numeric",
                                            hour: "numeric",
                                            minute: "2-digit",
                                          });
                                        } catch {
                                          return "‚Äî";
                                        }
                                      })()}
                                    </div>
                                    <div className="grid grid-cols-2 gap-x-3 gap-y-0.5 text-[10px]">
                                      <div className="text-[#93a4d6]">O:</div>
                                      <div className="text-white font-mono">
                                        ${Number(crosshair.candle.o).toFixed(2)}
                                      </div>
                                      <div className="text-[#93a4d6]">H:</div>
                                      <div className="text-sky-300 font-mono">
                                        ${Number(crosshair.candle.h).toFixed(2)}
                                      </div>
                                      <div className="text-[#93a4d6]">L:</div>
                                      <div className="text-orange-300 font-mono">
                                        ${Number(crosshair.candle.l).toFixed(2)}
                                      </div>
                                      <div className="text-[#93a4d6]">C:</div>
                                      <div
                                        className={`font-mono font-semibold ${
                                          Number(crosshair.candle.c) >=
                                          Number(crosshair.candle.o)
                                            ? "text-sky-300"
                                            : "text-orange-300"
                                        }`}
                                      >
                                        ${Number(crosshair.candle.c).toFixed(2)}
                                      </div>
                                    </div>
                                  </div>
                                ) : null}

                                <div className="mt-2 text-[10px] text-[#93a4d6] flex items-center justify-between">
                                  <span>
                                    {String(chartTf) === "D"
                                      ? "Daily"
                                      : String(chartTf) === "W"
                                        ? "Weekly"
                                        : `${chartTf}m`}{" "}
                                    ‚Ä¢ {candles.length} bars
                                  </span>
                                  <span className="font-mono">
                                    ${minL.toFixed(2)} ‚Äì ${maxH.toFixed(2)}
                                  </span>
                                </div>
                              </div>
                            );
                            } catch (e) {
                              console.error("[RightRail Chart] render failed:", e);
                              return (
                                <div className="text-xs text-yellow-300">
                                  Chart render error. Check console for details.
                                </div>
                              );
                            }
                          })()
                        )}
                      </div>
                    </>
                  ) : null}

                  {railTab === "TECHNICALS" ? (
                    <>
                      {/* Triggers */}
                      <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                        <div className="text-sm font-bold text-[#93a4d6] mb-4">
                          ‚ö° Triggers
                        </div>
                        <div className="p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          {triggerItems.length > 0 ? (
                            <div className="space-y-2">
                              {triggerItems.slice(0, 12).map((t, idx) => {
                                const translateTrigger = (raw) => {
                                  const s = String(raw || "").trim();
                                  const translations = {
                                    'SQUEEZE_RELEASE_30M': 'Consolidation breakout (30min)',
                                    'ST_FLIP_30M': 'Momentum flip detected (30min)',
                                    'ST_FLIP_1H': 'Momentum flip detected (1hr)',
                                    'EMA_CROSS_1H_13_48': 'Moving average crossover (1hr)',
                                    'BUYABLE_DIP_1H_13_48': 'Pullback entry opportunity (1hr)',
                                    'EMA_CROSS_30M_13_48': 'Moving average crossover (30min)'
                                  };
                                  
                                  // Check for exact match first
                                  if (translations[s]) return translations[s];
                                  
                                  // Pattern matching for complex triggers
                                  if (s.includes('EMA_CROSS') && s.includes('BULL')) {
                                    return s.replace(/EMA_CROSS_(\w+)_\d+_\d+.*BULL.*/i, 'Bullish moving average cross ($1)');
                                  }
                                  if (s.includes('EMA_CROSS') && s.includes('BEAR')) {
                                    return s.replace(/EMA_CROSS_(\w+)_\d+_\d+.*BEAR.*/i, 'Bearish moving average cross ($1)');
                                  }
                                  if (s.includes('SQUEEZE_RELEASE')) {
                                    return 'Consolidation breakout';
                                  }
                                  if (s.includes('ST_FLIP')) {
                                    return 'Momentum flip detected';
                                  }
                                  
                                  // Keep unconfirmed warning
                                  if (s.includes('‚ö†Ô∏è')) {
                                    const base = s.replace('‚ö†Ô∏è unconfirmed', '').trim();
                                    return `${translateTrigger(base)} (unconfirmed)`;
                                  }
                                  
                                  // Fallback: make it readable
                                  return s.replace(/_/g, ' ').toLowerCase();
                                };
                                
                                return (
                                  <div
                                    key={idx}
                                    className="flex items-start gap-2 text-xs"
                                  >
                                    <span className="text-cyan-400 mt-0.5">‚Ä¢</span>
                                    <span className="text-[#e7ecff] flex-1">{translateTrigger(t)}</span>
                                  </div>
                                );
                              })}
                            </div>
                          ) : (
                            <div className="text-xs text-[#93a4d6]">
                              No trigger signals detected.
                            </div>
                          )}
                        </div>
                      </div>

                      {/* Timeframes (Per-TF technicals) */}
                      <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                        <div className="text-sm font-bold text-[#93a4d6] mb-4">
                          ‚è± Timeframes
                        </div>
                        <div className="p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          {tfTech ? (
                            <div className="space-y-3">
                              {tfOrder.map(({ k, label }) => {
                                const row = tfTech[k] || null;
                                const atr = row && row.atr ? row.atr : null;
                                const ema = row && row.ema ? row.ema : null;
                                const ph = row && row.ph ? row.ph : null;
                                const sq = row && row.sq ? row.sq : null;
                                const rsi = row && row.rsi ? row.rsi : null;

                                const vis =
                                  ema && Number.isFinite(Number(ema.vis))
                                    ? Number(ema.vis)
                                    : 0;
                                const sig =
                                  ema && Number.isFinite(Number(ema.sig))
                                    ? Number(ema.sig)
                                    : 0;
                                const sigLabel =
                                  sig === 1
                                    ? "Bullish"
                                    : sig === -1
                                      ? "Bearish"
                                      : "Neutral";

                                const sqIcons =
                                  (sq && sq.c ? "üóúÔ∏è" : "") +
                                  (sq && sq.s ? "üß®" : "") +
                                  (sq && sq.r ? "‚ö°Ô∏è" : "");

                                const atrBand = (() => {
                                  if (!atr) return null;
                                  const side = Number(atr.s) === -1 ? "-" : "+";
                                  const lo =
                                    atr.lo != null ? String(atr.lo) : null;
                                  const hi =
                                    atr.hi != null ? String(atr.hi) : null;
                                  if (!lo) return null;
                                  return hi
                                    ? `${side}${lo}‚Äì${hi}`
                                    : `${side}${lo}+`;
                                })();

                                const atrLastCross = (() => {
                                  if (!atr || atr.x == null) return null;
                                  const dir =
                                    atr.xd === "dn"
                                      ? "‚Üì"
                                      : atr.xd === "up"
                                        ? "‚Üë"
                                        : "";
                                  const side =
                                    Number(atr.xs) === -1 ? "-" : "+";
                                  return dir ? `${dir} ${side}${atr.x}` : null;
                                })();

                                return (
                                  <div
                                    key={k}
                                    className="bg-[#121a33] border border-[#26325f] rounded-lg p-3"
                                  >
                                    <div className="flex items-center justify-between mb-2">
                                      <div className="text-sm font-semibold text-white">
                                        {label}
                                      </div>
                                      <div className="text-xs text-[#93a4d6] flex items-center gap-2">
                                        <span>{sqIcons}</span>
                                        <span
                                          className={`font-semibold ${
                                            sig === 1
                                              ? "text-green-400"
                                              : sig === -1
                                                ? "text-red-400"
                                                : "text-[#93a4d6]"
                                          }`}
                                        >
                                          {sigLabel}
                                        </span>
                                      </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-3">
                                      <div>
                                        <div className="text-[11px] text-[#93a4d6] mb-1">
                                          ATR band / last cross
                                        </div>
                                        <div className="text-xs text-white">
                                          {atrBand ? (
                                            <>
                                              <span className="font-semibold">
                                                {atrBand}
                                              </span>
                                              {atrLastCross ? (
                                                <span className="ml-2 text-[#93a4d6]">
                                                  {atrLastCross}
                                                </span>
                                              ) : null}
                                            </>
                                          ) : (
                                            <span className="text-[#93a4d6]">
                                              ‚Äî
                                            </span>
                                          )}
                                        </div>
                                      </div>

                                      <div>
                                        <div className="text-[11px] text-[#93a4d6] mb-1">
                                          EMA visibility / stack
                                        </div>
                                        <div className="flex flex-wrap gap-1 items-center">
                                          {emaLevels.map((n, idx) => {
                                            const on = (vis & (1 << idx)) !== 0;
                                            return (
                                              <span
                                                key={n}
                                                className={`px-1.5 py-0.5 rounded text-[10px] border ${
                                                  on
                                                    ? "bg-green-500/15 border-green-500/30 text-green-300"
                                                    : "bg-red-500/10 border-red-500/30 text-red-300"
                                                }`}
                                                title={`Price ${on ? "‚â•" : "<"} EMA${n}`}
                                              >
                                                {n}
                                              </span>
                                            );
                                          })}
                                          {ema && ema.stack != null && (
                                            <span className="ml-2 text-[10px] text-[#93a4d6]">
                                              stack:{" "}
                                              <span className="text-white font-semibold">
                                                {ema.stack}
                                              </span>
                                            </span>
                                          )}
                                        </div>
                                      </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-3 mt-3">
                                      <div>
                                        <div className="text-[11px] text-[#93a4d6] mb-1">
                                          Phase Level
                                        </div>
                                        <div className="text-xs text-white font-semibold">
                                          {ph && ph.v != null ? ph.v : "‚Äî"}
                                        </div>
                                        <div className="mt-1.5">
                                          <div className="text-[10px] text-[#93a4d6]">
                                            Last 5 dots (recent first):
                                          </div>
                                          <div className="text-xs text-[#cbd5ff] mt-0.5">
                                            {(() => {
                                              const dots = (ph && Array.isArray(ph.dots) ? ph.dots : []).slice(0, 5);
                                              if (dots.length === 0) return "‚Äî";
                                              
                                              const dotLabels = dots.map((code) => {
                                                switch (code) {
                                                  case "P100": return "+100";
                                                  case "P618": return "+61.8";
                                                  case "N618": return "-61.8";
                                                  case "N100": return "-100";
                                                  default: return code || "";
                                                }
                                              }).filter(Boolean);
                                              
                                              return dotLabels.join(", ");
                                            })()}
                                          </div>
                                        </div>
                                      </div>
                                      <div>
                                        <div className="text-[11px] text-[#93a4d6] mb-1">
                                          Divergence
                                        </div>
                                        <div className="text-base">
                                          {(() => {
                                            const divs = (ph && Array.isArray(ph.div) ? ph.div : []).slice(0, 3);
                                            if (divs.length === 0) return <span className="text-xs text-[#93a4d6]">None</span>;
                                            
                                            const mostRecent = divs[0];
                                            const emoji = mostRecent === "B" ? "üêÇ" : mostRecent === "S" ? "üêª" : "";
                                            const label = mostRecent === "B" ? "Bullish" : mostRecent === "S" ? "Bearish" : "";
                                            const color = mostRecent === "B" ? "text-green-400" : "text-red-400";
                                            
                                            return (
                                              <div className={`font-semibold ${color}`}>
                                                {emoji} {label}
                                              </div>
                                            );
                                          })()}
                                        </div>
                                      </div>
                                      <div>
                                        <div className="text-[11px] text-[#93a4d6] mb-1">
                                          RSI(5/14) / div
                                        </div>
                                        <div className="text-xs text-white">
                                          <span className="font-semibold">
                                            {rsi && rsi.r5 != null
                                              ? rsi.r5
                                              : "‚Äî"}
                                          </span>
                                          <span className="text-[#93a4d6]">
                                            {" "}
                                            /{" "}
                                          </span>
                                          <span className="font-semibold">
                                            {rsi && rsi.r14 != null
                                              ? rsi.r14
                                              : "‚Äî"}
                                          </span>
                                          <span className="ml-2">
                                            {(rsi && Array.isArray(rsi.div)
                                              ? rsi.div
                                              : []
                                            )
                                              .slice(0, 2)
                                              .map(divIcon)
                                              .filter(Boolean)
                                              .join(" ")}
                                          </span>
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                          ) : (
                            <div className="text-xs text-[#93a4d6]">
                              No per-timeframe technicals available yet (update
                              TradingView script + refresh data).
                            </div>
                          )}
                        </div>
                      </div>

                      {ticker.td_sequential &&
                        (() => {
                          const tdSeq = ticker.td_sequential;
                          return (
                            <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                              <div className="text-sm font-bold text-[#93a4d6] mb-4">
                                üìà TD Sequential
                              </div>

                              {/* Counts */}
                              <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                <div className="text-xs text-[#93a4d6] mb-2">
                                  Counts
                                </div>
                                <div className="grid grid-cols-2 gap-2 text-xs">
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">
                                      Bullish Prep:
                                    </span>
                                    <span
                                      className={`font-semibold ${
                                        Number(tdSeq.bullish_prep_count || 0) >=
                                        6
                                          ? "text-yellow-400"
                                          : Number(
                                                tdSeq.bullish_prep_count || 0,
                                              ) >= 3
                                            ? "text-green-400"
                                            : "text-[#93a4d6]"
                                      }`}
                                    >
                                      {tdSeq.bullish_prep_count || 0}/9
                                    </span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">
                                      Bearish Prep:
                                    </span>
                                    <span
                                      className={`font-semibold ${
                                        Number(tdSeq.bearish_prep_count || 0) >=
                                        6
                                          ? "text-yellow-400"
                                          : Number(
                                                tdSeq.bearish_prep_count || 0,
                                              ) >= 3
                                            ? "text-red-400"
                                            : "text-[#93a4d6]"
                                      }`}
                                    >
                                      {tdSeq.bearish_prep_count || 0}/9
                                    </span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">
                                      Bullish Leadup:
                                    </span>
                                    <span
                                      className={`font-semibold ${
                                        Number(
                                          tdSeq.bullish_leadup_count || 0,
                                        ) >= 6
                                          ? "text-yellow-400"
                                          : Number(
                                                tdSeq.bullish_leadup_count || 0,
                                              ) >= 3
                                            ? "text-green-400"
                                            : "text-[#93a4d6]"
                                      }`}
                                    >
                                      {tdSeq.bullish_leadup_count || 0}/13
                                    </span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span className="text-[#93a4d6]">
                                      Bearish Leadup:
                                    </span>
                                    <span
                                      className={`font-semibold ${
                                        Number(
                                          tdSeq.bearish_leadup_count || 0,
                                        ) >= 6
                                          ? "text-yellow-400"
                                          : Number(
                                                tdSeq.bearish_leadup_count || 0,
                                              ) >= 3
                                            ? "text-red-400"
                                            : "text-[#93a4d6]"
                                      }`}
                                    >
                                      {tdSeq.bearish_leadup_count || 0}/13
                                    </span>
                                  </div>
                                </div>
                              </div>

                              {/* Signals */}
                              <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                <div className="text-xs text-[#93a4d6] mb-2">
                                  Signals
                                </div>
                                <div className="space-y-2">
                                  {(tdSeq.td9_bullish === true ||
                                    tdSeq.td9_bullish === "true") && (
                                    <div className="flex items-center gap-2">
                                      <span className="text-green-400 font-bold">
                                        TD9
                                      </span>
                                      <span className="text-xs text-[#93a4d6]">
                                        Bullish (Prep Complete)
                                      </span>
                                    </div>
                                  )}
                                  {(tdSeq.td9_bearish === true ||
                                    tdSeq.td9_bearish === "true") && (
                                    <div className="flex items-center gap-2">
                                      <span className="text-red-400 font-bold">
                                        TD9
                                      </span>
                                      <span className="text-xs text-[#93a4d6]">
                                        Bearish (Prep Complete)
                                      </span>
                                    </div>
                                  )}
                                  {(tdSeq.td13_bullish === true ||
                                    tdSeq.td13_bullish === "true") && (
                                    <div className="flex items-center gap-2">
                                      <span className="text-green-400 font-bold">
                                        TD13
                                      </span>
                                      <span className="text-xs text-[#93a4d6]">
                                        Bullish (Leadup Complete)
                                      </span>
                                    </div>
                                  )}
                                  {(tdSeq.td13_bearish === true ||
                                    tdSeq.td13_bearish === "true") && (
                                    <div className="flex items-center gap-2">
                                      <span className="text-red-400 font-bold">
                                        TD13
                                      </span>
                                      <span className="text-xs text-[#93a4d6]">
                                        Bearish (Leadup Complete)
                                      </span>
                                    </div>
                                  )}
                                  {!tdSeq.td9_bullish &&
                                    !tdSeq.td9_bearish &&
                                    !tdSeq.td13_bullish &&
                                    !tdSeq.td13_bearish && (
                                      <div className="text-xs text-[#93a4d6]">
                                        No TD9/TD13 signals active
                                      </div>
                                    )}
                                </div>
                              </div>

                              {/* Exit Signals */}
                              {(tdSeq.exit_long === true ||
                                tdSeq.exit_long === "true" ||
                                tdSeq.exit_short === true ||
                                tdSeq.exit_short === "true") && (
                                <div
                                  className={`mb-4 p-3 rounded-lg border-2 ${
                                    tdSeq.exit_long === true ||
                                    tdSeq.exit_long === "true"
                                      ? "bg-red-500/20 border-red-500/50"
                                      : "bg-red-500/20 border-red-500/50"
                                  }`}
                                >
                                  <div className="flex items-center justify-between">
                                    <span className="text-xs text-[#93a4d6]">
                                      Exit Signal
                                    </span>
                                    <span className="font-bold text-sm text-red-400">
                                      {tdSeq.exit_long === true ||
                                      tdSeq.exit_long === "true"
                                        ? "EXIT LONG"
                                        : "EXIT SHORT"}
                                    </span>
                                  </div>
                                  <div className="text-xs text-[#93a4d6] mt-1">
                                    TD Sequential exhaustion/reversal detected
                                  </div>
                                </div>
                              )}

                              {/* Boost */}
                              {tdSeq.boost !== undefined &&
                                tdSeq.boost !== null &&
                                Number(tdSeq.boost) !== 0 && (
                                  <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                    <div className="flex justify-between items-center">
                                      <span className="text-xs text-[#93a4d6]">
                                        Score Boost
                                      </span>
                                      <span
                                        className={`font-semibold ${
                                          Number(tdSeq.boost) > 0
                                            ? "text-green-400"
                                            : "text-red-400"
                                        }`}
                                      >
                                        {Number(tdSeq.boost) > 0 ? "+" : ""}
                                        {Number(tdSeq.boost).toFixed(1)}
                                      </span>
                                    </div>
                                  </div>
                                )}
                            </div>
                          );
                        })()}

                      {/* RSI & Divergence */}
                      {ticker.rsi &&
                        (() => {
                          const rsi = ticker.rsi;
                          const rsiValue = Number(rsi.value || 0);
                          const rsiLevel = rsi.level || "neutral";
                          const divergence = rsi.divergence || {};
                          const divType = divergence.type || "none";
                          const divStrength = Number(divergence.strength || 0);

                          const rsiColor =
                            rsiValue >= 70
                              ? "text-red-400"
                              : rsiValue <= 30
                                ? "text-green-400"
                                : rsiValue >= 50
                                  ? "text-yellow-400"
                                  : "text-blue-400";
                          const levelColor =
                            rsiLevel === "overbought"
                              ? "text-red-400"
                              : rsiLevel === "oversold"
                                ? "text-green-400"
                                : rsiLevel === "bullish"
                                  ? "text-yellow-400"
                                  : "text-blue-400";

                          return (
                            <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                              <div className="text-sm font-bold text-[#93a4d6] mb-4">
                                üìä RSI & Divergence
                              </div>

                              {/* RSI Value */}
                              <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                <div className="flex justify-between items-center mb-2">
                                  <span className="text-xs text-[#93a4d6]">
                                    RSI (14)
                                  </span>
                                  <span
                                    className={`font-bold text-lg ${rsiColor}`}
                                  >
                                    {rsiValue.toFixed(2)}
                                  </span>
                                </div>
                                <div className="flex justify-between items-center">
                                  <span className="text-xs text-[#93a4d6]">
                                    Level
                                  </span>
                                  <span
                                    className={`text-xs font-semibold ${levelColor}`}
                                  >
                                    {rsiLevel.charAt(0).toUpperCase() +
                                      rsiLevel.slice(1)}
                                  </span>
                                </div>
                                {/* RSI Visual Bar */}
                                <div className="mt-2 h-2 bg-[#26325f] rounded-full overflow-hidden">
                                  <div
                                    className={`h-full rounded-full transition-all ${
                                      rsiValue >= 70
                                        ? "bg-red-500"
                                        : rsiValue <= 30
                                          ? "bg-green-500"
                                          : rsiValue >= 50
                                            ? "bg-yellow-500"
                                            : "bg-blue-500"
                                    }`}
                                    style={{ width: `${rsiValue}%` }}
                                  />
                                </div>
                                <div className="flex justify-between text-[10px] text-[#93a4d6] mt-1">
                                  <span>0</span>
                                  <span>30</span>
                                  <span>50</span>
                                  <span>70</span>
                                  <span>100</span>
                                </div>
                              </div>

                              {/* Divergence */}
                              {divType !== "none" && (
                                <div
                                  className={`mb-4 p-3 rounded-lg border-2 ${
                                    divType === "bullish"
                                      ? "bg-green-500/20 border-green-500/50"
                                      : "bg-red-500/20 border-red-500/50"
                                  }`}
                                >
                                  <div className="flex items-center justify-between mb-1">
                                    <span className="text-xs text-[#93a4d6]">
                                      Divergence
                                    </span>
                                    <span
                                      className={`font-bold text-sm ${
                                        divType === "bullish"
                                          ? "text-green-400"
                                          : "text-red-400"
                                      }`}
                                    >
                                      {divType === "bullish"
                                        ? "üîº BULLISH"
                                        : "üîΩ BEARISH"}
                                    </span>
                                  </div>
                                  <div className="text-xs text-[#93a4d6]">
                                    {divType === "bullish"
                                      ? "Price lower low, RSI higher low (potential reversal up)"
                                      : "Price higher high, RSI lower high (potential reversal down)"}
                                  </div>
                                  {divStrength > 0 && (
                                    <div className="text-xs text-[#93a4d6] mt-1">
                                      Strength: {divStrength.toFixed(2)}
                                    </div>
                                  )}
                                </div>
                              )}
                              {divType === "none" && (
                                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                  <div className="text-xs text-[#93a4d6]">
                                    No divergence detected
                                  </div>
                                </div>
                              )}
                            </div>
                          );
                        })()}

                      {/* State, Horizon, Detected Patterns */}
                      <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                        <div className="text-sm text-[#93a4d6] mb-2">
                          State & Horizon
                        </div>
                        <div className="space-y-2 text-xs">
                          <div className="flex justify-between items-center">
                            <span className="text-[#93a4d6]">State</span>
                            <span className="font-semibold">
                              {ticker.state || "‚Äî"}
                            </span>
                          </div>
                          <div className="flex justify-between items-center">
                            <span className="text-[#93a4d6]">Horizon</span>
                            <span className="font-semibold">
                              {(() => {
                                const bucket = String(
                                  ticker.horizon_bucket || "",
                                )
                                  .trim()
                                  .toUpperCase();
                                if (bucket) return bucket.replace("_", " ");
                                const eta = computeEtaDays(ticker);
                                if (!Number.isFinite(eta)) return "‚Äî";
                                if (eta <= 7) return "SHORT TERM";
                                if (eta <= 30) return "SWING";
                                return "POSITIONAL";
                              })()}
                            </span>
                          </div>
                        </div>
                        {detectedPatterns && detectedPatterns.length > 0 && (
                          <div className="mt-3 pt-3 border-t border-[#26325f]">
                            <div className="text-xs font-semibold text-yellow-400 mb-2">
                              Detected Patterns
                            </div>
                            <div className="space-y-2">
                              {detectedPatterns.map((pattern, idx) => (
                                <div
                                  key={`pattern-${idx}`}
                                  className="p-2 rounded border bg-[#121a33] border-[#26325f]"
                                >
                                  <div className="flex items-center justify-between">
                                    <div className="text-xs text-white font-semibold">
                                      {pattern.description}
                                    </div>
                                    <span className="text-[10px] px-1.5 py-0.5 rounded bg-yellow-500/20 text-yellow-300">
                                      {pattern.confidence}
                                    </span>
                                  </div>
                                  {pattern.quadrant && (
                                    <div className="text-[10px] text-[#93a4d6] mt-0.5">
                                      {pattern.quadrant}
                                    </div>
                                  )}
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>

                      {/* EMA Cloud Positions */}
                      {(ticker.daily_ema_cloud ||
                        ticker.fourh_ema_cloud ||
                        ticker.oneh_ema_cloud) &&
                        (() => {
                          const daily = ticker.daily_ema_cloud;
                          const fourH = ticker.fourh_ema_cloud;
                          const oneH = ticker.oneh_ema_cloud;

                          const getPositionColor = (position) => {
                            if (position === "above") return "text-green-400";
                            if (position === "below") return "text-red-400";
                            return "text-yellow-400";
                          };

                          const getPositionEmoji = (position) => {
                            if (position === "above") return "üîº";
                            if (position === "below") return "üîΩ";
                            return "‚û°Ô∏è";
                          };

                          return (
                            <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                              <div className="text-sm font-bold text-[#93a4d6] mb-4">
                                ‚òÅÔ∏è EMA Cloud Positions
                              </div>

                              {daily && (
                                <div className="mb-3 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                  <div className="text-xs text-[#93a4d6] mb-2 font-semibold">
                                    Daily (5-8 EMA)
                                  </div>
                                  <div className="flex justify-between items-center mb-1">
                                    <span className="text-xs text-[#93a4d6]">
                                      Position
                                    </span>
                                    <span
                                      className={`text-xs font-semibold ${getPositionColor(
                                        daily.position,
                                      )}`}
                                    >
                                      {getPositionEmoji(daily.position)}{" "}
                                      {daily.position.toUpperCase()}
                                    </span>
                                  </div>
                                  <div className="grid grid-cols-2 gap-2 text-xs mt-2">
                                    <div className="flex justify-between">
                                      <span className="text-[#93a4d6]">
                                        Upper:
                                      </span>
                                      <span className="text-white">
                                        ${Number(daily.upper).toFixed(2)}
                                      </span>
                                    </div>
                                    <div className="flex justify-between">
                                      <span className="text-[#93a4d6]">
                                        Lower:
                                      </span>
                                      <span className="text-white">
                                        ${Number(daily.lower).toFixed(2)}
                                      </span>
                                    </div>
                                    <div className="flex justify-between col-span-2">
                                      <span className="text-[#93a4d6]">
                                        Price:
                                      </span>
                                      <span className="text-white font-semibold">
                                        ${Number(daily.price).toFixed(2)}
                                      </span>
                                    </div>
                                  </div>
                                </div>
                              )}

                              {fourH && (
                                <div className="mb-3 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                  <div className="text-xs text-[#93a4d6] mb-2 font-semibold">
                                    4H (8-13 EMA)
                                  </div>
                                  <div className="flex justify-between items-center mb-1">
                                    <span className="text-xs text-[#93a4d6]">
                                      Position
                                    </span>
                                    <span
                                      className={`text-xs font-semibold ${getPositionColor(
                                        fourH.position,
                                      )}`}
                                    >
                                      {getPositionEmoji(fourH.position)}{" "}
                                      {fourH.position.toUpperCase()}
                                    </span>
                                  </div>
                                  <div className="grid grid-cols-2 gap-2 text-xs mt-2">
                                    <div className="flex justify-between">
                                      <span className="text-[#93a4d6]">
                                        Upper:
                                      </span>
                                      <span className="text-white">
                                        ${Number(fourH.upper).toFixed(2)}
                                      </span>
                                    </div>
                                    <div className="flex justify-between">
                                      <span className="text-[#93a4d6]">
                                        Lower:
                                      </span>
                                      <span className="text-white">
                                        ${Number(fourH.lower).toFixed(2)}
                                      </span>
                                    </div>
                                    <div className="flex justify-between col-span-2">
                                      <span className="text-[#93a4d6]">
                                        Price:
                                      </span>
                                      <span className="text-white font-semibold">
                                        ${Number(fourH.price).toFixed(2)}
                                      </span>
                                    </div>
                                  </div>
                                </div>
                              )}

                              {oneH && (
                                <div className="mb-3 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                  <div className="text-xs text-[#93a4d6] mb-2 font-semibold">
                                    1H (13-21 EMA)
                                  </div>
                                  <div className="flex justify-between items-center mb-1">
                                    <span className="text-xs text-[#93a4d6]">
                                      Position
                                    </span>
                                    <span
                                      className={`text-xs font-semibold ${getPositionColor(
                                        oneH.position,
                                      )}`}
                                    >
                                      {getPositionEmoji(oneH.position)}{" "}
                                      {oneH.position.toUpperCase()}
                                    </span>
                                  </div>
                                  <div className="grid grid-cols-2 gap-2 text-xs mt-2">
                                    <div className="flex justify-between">
                                      <span className="text-[#93a4d6]">
                                        Upper:
                                      </span>
                                      <span className="text-white">
                                        ${Number(oneH.upper).toFixed(2)}
                                      </span>
                                    </div>
                                    <div className="flex justify-between">
                                      <span className="text-[#93a4d6]">
                                        Lower:
                                      </span>
                                      <span className="text-white">
                                        ${Number(oneH.lower).toFixed(2)}
                                      </span>
                                    </div>
                                    <div className="flex justify-between col-span-2">
                                      <span className="text-[#93a4d6]">
                                        Price:
                                      </span>
                                      <span className="text-white font-semibold">
                                        ${Number(oneH.price).toFixed(2)}
                                      </span>
                                    </div>
                                  </div>
                                </div>
                              )}
                            </div>
                          );
                        })()}

                      {/* Fundamental & Valuation Metrics */}
                      {ticker.fundamentals &&
                        (() => {
                          const fund = ticker.fundamentals;
                          const hasValuationData =
                            fund.pe_ratio !== null ||
                            fund.peg_ratio !== null ||
                            fund.eps_growth_rate !== null;

                          if (!hasValuationData) return null;

                          const valuationSignal =
                            fund.valuation_signal || "fair";
                          const signalColor =
                            valuationSignal === "undervalued"
                              ? "text-green-400"
                              : valuationSignal === "overvalued"
                                ? "text-red-400"
                                : "text-yellow-400";
                          const signalBg =
                            valuationSignal === "undervalued"
                              ? "bg-green-500/20 border-green-500/50"
                              : valuationSignal === "overvalued"
                                ? "bg-red-500/20 border-red-500/50"
                                : "bg-yellow-500/20 border-yellow-500/50";

                          return (
                            <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                              <div className="text-sm font-bold text-[#93a4d6] mb-4">
                                üìä Fundamental & Valuation
                              </div>

                              {/* Valuation Signal Badge */}
                              {fund.valuation_signal && (
                                <div
                                  className={`mb-4 p-3 rounded-lg border-2 ${signalBg}`}
                                >
                                  <div className="flex items-center justify-between">
                                    <span className="text-xs text-[#93a4d6]">
                                      Valuation Signal
                                    </span>
                                    <span
                                      className={`font-bold text-sm ${signalColor}`}
                                    >
                                      {fund.valuation_signal.toUpperCase()}
                                    </span>
                                  </div>
                                  {fund.valuation_confidence && (
                                    <div className="text-xs text-[#93a4d6] mt-1">
                                      Confidence:{" "}
                                      <span className="font-semibold">
                                        {fund.valuation_confidence}
                                      </span>
                                    </div>
                                  )}
                                  {fund.valuation_reasons &&
                                    fund.valuation_reasons.length > 0 && (
                                      <div className="mt-2 pt-2 border-t border-current/30">
                                        <div className="text-[10px] text-[#93a4d6] mb-1">
                                          Reasons:
                                        </div>
                                        {fund.valuation_reasons.map(
                                          (reason, idx) => (
                                            <div
                                              key={idx}
                                              className="text-[10px] text-[#93a4d6]/80 mb-0.5"
                                            >
                                              ‚Ä¢ {reason}
                                            </div>
                                          ),
                                        )}
                                      </div>
                                    )}
                                </div>
                              )}

                              {/* Basic Metrics */}
                              <div className="space-y-2 text-sm mb-4">
                                {fund.pe_ratio !== null && (
                                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                    <span className="text-[#93a4d6]">
                                      P/E Ratio
                                    </span>
                                    <span className="font-semibold">
                                      {Number(fund.pe_ratio).toFixed(2)}
                                    </span>
                                  </div>
                                )}
                                {fund.peg_ratio !== null && (
                                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                    <span className="text-[#93a4d6]">
                                      PEG Ratio
                                    </span>
                                    <span
                                      className={`font-semibold ${
                                        fund.peg_ratio < 0.8
                                          ? "text-green-400"
                                          : fund.peg_ratio < 1.0
                                            ? "text-yellow-400"
                                            : fund.peg_ratio > 1.5
                                              ? "text-red-400"
                                              : "text-[#93a4d6]"
                                      }`}
                                    >
                                      {Number(fund.peg_ratio).toFixed(2)}
                                    </span>
                                  </div>
                                )}
                                {fund.eps !== null && (
                                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                    <span className="text-[#93a4d6]">
                                      EPS (TTM)
                                    </span>
                                    <span className="font-semibold">
                                      ${Number(fund.eps).toFixed(2)}
                                    </span>
                                  </div>
                                )}
                                {fund.eps_growth_rate !== null && (
                                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                    <span className="text-[#93a4d6]">
                                      EPS Growth (Annual)
                                    </span>
                                    <span
                                      className={`font-semibold ${
                                        fund.eps_growth_rate > 20
                                          ? "text-green-400"
                                          : fund.eps_growth_rate > 10
                                            ? "text-yellow-400"
                                            : fund.eps_growth_rate > 0
                                              ? "text-[#93a4d6]"
                                              : "text-red-400"
                                      }`}
                                    >
                                      {Number(fund.eps_growth_rate).toFixed(1)}%
                                    </span>
                                  </div>
                                )}
                                {(() => {
                                  const marketCap = fund.market_cap;
                                  const isValid =
                                    marketCap !== null &&
                                    marketCap !== undefined &&
                                    marketCap !== "" &&
                                    (typeof marketCap === "number" ||
                                      typeof marketCap === "string") &&
                                    !isNaN(Number(marketCap)) &&
                                    Number(marketCap) > 0;
                                  if (!isValid) return null;
                                  const numCap = Number(marketCap);
                                  let formatted;
                                  if (numCap >= 1e12) {
                                    formatted = `$${(numCap / 1e12).toFixed(2)}T`;
                                  } else if (numCap >= 1e9) {
                                    formatted = `$${(numCap / 1e9).toFixed(2)}B`;
                                  } else if (numCap >= 1e6) {
                                    formatted = `$${(numCap / 1e6).toFixed(2)}M`;
                                  } else {
                                    formatted = `$${numCap.toLocaleString()}`;
                                  }
                                  return (
                                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                      <span className="text-[#93a4d6]">
                                        Market Cap
                                      </span>
                                      <span className="font-semibold">
                                        {formatted}
                                      </span>
                                    </div>
                                  );
                                })()}
                                {fund.industry && (
                                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                    <span className="text-[#93a4d6]">
                                      Industry
                                    </span>
                                    <span className="font-semibold text-xs">
                                      {fund.industry}
                                    </span>
                                  </div>
                                )}
                              </div>

                              {/* Fair Value */}
                              {fund.fair_value_price !== null &&
                                fund.fair_value_price > 0 && (
                                  <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                    <div className="text-xs text-[#93a4d6] mb-2">
                                      Fair Value
                                    </div>
                                    <div className="flex items-center justify-between mb-2">
                                      <span className="text-sm text-[#93a4d6]">
                                        Fair Value Price
                                      </span>
                                      <span className="font-bold text-lg text-blue-400">
                                        $
                                        {Number(fund.fair_value_price).toFixed(
                                          2,
                                        )}
                                      </span>
                                    </div>
                                    {fund.premium_discount_pct !== null && (
                                      <div className="flex items-center justify-between">
                                        <span className="text-xs text-[#93a4d6]">
                                          Premium/Discount
                                        </span>
                                        <span
                                          className={`font-semibold ${
                                            fund.premium_discount_pct < -10
                                              ? "text-green-400"
                                              : fund.premium_discount_pct < 0
                                                ? "text-yellow-400"
                                                : fund.premium_discount_pct > 10
                                                  ? "text-red-400"
                                                  : "text-[#93a4d6]"
                                          }`}
                                        >
                                          {fund.premium_discount_pct > 0
                                            ? "+"
                                            : ""}
                                          {Number(
                                            fund.premium_discount_pct,
                                          ).toFixed(1)}
                                          %
                                        </span>
                                      </div>
                                    )}
                                    {fund.fair_value_pe &&
                                      fund.fair_value_pe.preferred && (
                                        <div className="mt-2 pt-2 border-t border-[#26325f] text-xs text-[#93a4d6]">
                                          Fair P/E:{" "}
                                          <span className="font-semibold">
                                            {Number(
                                              fund.fair_value_pe.preferred,
                                            ).toFixed(2)}
                                          </span>
                                        </div>
                                      )}
                                  </div>
                                )}

                              {/* Historical P/E Percentiles */}
                              {fund.pe_percentiles && (
                                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                  <div className="text-xs text-[#93a4d6] mb-2">
                                    Historical P/E Percentiles
                                  </div>
                                  <div className="grid grid-cols-2 gap-2 text-xs">
                                    {fund.pe_percentiles.p10 !== null && (
                                      <div className="flex justify-between">
                                        <span className="text-[#93a4d6]">
                                          10th:
                                        </span>
                                        <span className="font-semibold">
                                          {Number(
                                            fund.pe_percentiles.p10,
                                          ).toFixed(1)}
                                        </span>
                                      </div>
                                    )}
                                    {fund.pe_percentiles.p25 !== null && (
                                      <div className="flex justify-between">
                                        <span className="text-[#93a4d6]">
                                          25th:
                                        </span>
                                        <span className="font-semibold">
                                          {Number(
                                            fund.pe_percentiles.p25,
                                          ).toFixed(1)}
                                        </span>
                                      </div>
                                    )}
                                    {fund.pe_percentiles.p50 !== null && (
                                      <div className="flex justify-between">
                                        <span className="text-[#93a4d6]">
                                          50th (Median):
                                        </span>
                                        <span className="font-semibold text-blue-400">
                                          {Number(
                                            fund.pe_percentiles.p50,
                                          ).toFixed(1)}
                                        </span>
                                      </div>
                                    )}
                                    {fund.pe_percentiles.p75 !== null && (
                                      <div className="flex justify-between">
                                        <span className="text-[#93a4d6]">
                                          75th:
                                        </span>
                                        <span className="font-semibold">
                                          {Number(
                                            fund.pe_percentiles.p75,
                                          ).toFixed(1)}
                                        </span>
                                      </div>
                                    )}
                                    {fund.pe_percentiles.p90 !== null && (
                                      <div className="flex justify-between">
                                        <span className="text-[#93a4d6]">
                                          90th:
                                        </span>
                                        <span className="font-semibold">
                                          {Number(
                                            fund.pe_percentiles.p90,
                                          ).toFixed(1)}
                                        </span>
                                      </div>
                                    )}
                                    {fund.pe_percentiles.avg !== null && (
                                      <div className="flex justify-between col-span-2 pt-1 border-t border-[#26325f]">
                                        <span className="text-[#93a4d6]">
                                          Average:
                                        </span>
                                        <span className="font-semibold">
                                          {Number(
                                            fund.pe_percentiles.avg,
                                          ).toFixed(1)}
                                        </span>
                                      </div>
                                    )}
                                  </div>
                                  {fund.pe_percentile_position && (
                                    <div className="mt-2 pt-2 border-t border-[#26325f] text-xs">
                                      <span className="text-[#93a4d6]">
                                        Current Position:{" "}
                                      </span>
                                      <span
                                        className={`font-semibold ${
                                          fund.pe_percentile_position.includes(
                                            "Bottom",
                                          )
                                            ? "text-green-400"
                                            : fund.pe_percentile_position.includes(
                                                  "Top",
                                                )
                                              ? "text-red-400"
                                              : "text-[#93a4d6]"
                                        }`}
                                      >
                                        {fund.pe_percentile_position}
                                      </span>
                                    </div>
                                  )}
                                </div>
                              )}

                              {/* Valuation Boost in Rank */}
                              {ticker.rank_components &&
                                ticker.rank_components.valuation_boost !==
                                  undefined &&
                                ticker.rank_components.valuation_boost !==
                                  0 && (
                                  <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                                    <div className="text-xs text-[#93a4d6] mb-1">
                                      Rank Components
                                    </div>
                                    <div className="flex justify-between items-center text-xs">
                                      <span className="text-[#93a4d6]">
                                        Base Rank
                                      </span>
                                      <span className="font-semibold">
                                        {ticker.rank_components.base_rank ||
                                          baseScore}
                                      </span>
                                    </div>
                                    <div className="flex justify-between items-center text-xs mt-1">
                                      <span className="text-[#93a4d6]">
                                        Valuation Boost
                                      </span>
                                      <span
                                        className={`font-semibold ${
                                          ticker.rank_components
                                            .valuation_boost > 0
                                            ? "text-green-400"
                                            : "text-red-400"
                                        }`}
                                      >
                                        {ticker.rank_components
                                          .valuation_boost > 0
                                          ? "+"
                                          : ""}
                                        {ticker.rank_components.valuation_boost}
                                      </span>
                                    </div>
                                    <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                                      <span className="text-[#93a4d6] font-semibold">
                                        Final Rank
                                      </span>
                                      <span className="font-bold text-blue-400">
                                        {baseScore}
                                      </span>
                                    </div>
                                  </div>
                                )}
                            </div>
                          );
                        })()}

                      {/* Trade Journey (Ledger trades) */}
                    </>
                  ) : null}

                  {railTab === "CHART" ? (
                    <>
                      <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                        <div className="flex items-center justify-between gap-2 mb-3">
                          <div className="text-sm text-[#93a4d6]">Chart</div>
                          <div className="flex items-center gap-1 flex-wrap">
                            {[
                              { tf: "1", label: "1m" },
                              { tf: "3", label: "3m" },
                              { tf: "5", label: "5m" },
                              { tf: "10", label: "10m" },
                              { tf: "30", label: "30m" },
                              { tf: "60", label: "1H" },
                              { tf: "240", label: "4H" },
                              { tf: "D", label: "D" },
                              { tf: "W", label: "W" },
                            ].map((t) => {
                              const active = String(chartTf) === String(t.tf);
                              return (
                                <button
                                  key={`tf-${t.tf}`}
                                  onClick={() => setChartTf(String(t.tf))}
                                  className={`px-2 py-1 rounded border text-[11px] font-semibold transition-all ${
                                    active
                                      ? "border-blue-400 bg-blue-500/20 text-blue-200"
                                      : "border-[#26325f] bg-[#121a33] text-[#93a4d6] hover:text-white"
                                  }`}
                                  title={`Show ${t.label} candles`}
                                >
                                  {t.label}
                                </button>
                              );
                            })}
                          </div>
                        </div>

                        {chartLoading ? (
                          <div className="text-xs text-[#93a4d6]">
                            Loading candles‚Ä¶
                          </div>
                        ) : chartError ? (
                          <div className="text-xs text-yellow-300">
                            Failed to load candles: {chartError}
                          </div>
                        ) : !Array.isArray(chartCandles) ||
                          chartCandles.length < 2 ? (
                          <div className="text-xs text-[#93a4d6]">
                            No candles yet for this timeframe. (Waiting for the
                            TradingView candle capture feed.)
                          </div>
                        ) : (
                          (() => {
                            try {
                              const toMs = (v) => {
                                if (v == null) return NaN;
                                if (typeof v === "number") {
                                  // Heuristic: seconds vs ms
                                  return v > 1e12 ? v : v * 1000;
                                }
                                const n = Number(v);
                                if (Number.isFinite(n)) return n > 1e12 ? n : n * 1000;
                                const d = new Date(String(v));
                                const ms = d.getTime();
                                return Number.isFinite(ms) ? ms : NaN;
                              };

                              const norm = (c) => {
                                const tsRaw = c?.ts ?? c?.t ?? c?.time ?? c?.timestamp;
                                const tsMs = toMs(tsRaw);
                                const o = Number(c?.o ?? c?.open);
                                const h = Number(c?.h ?? c?.high);
                                const l = Number(c?.l ?? c?.low);
                                const cl = Number(c?.c ?? c?.close);
                                if (
                                  !Number.isFinite(tsMs) ||
                                  !Number.isFinite(o) ||
                                  !Number.isFinite(h) ||
                                  !Number.isFinite(l) ||
                                  !Number.isFinite(cl)
                                )
                                  return null;
                                return { ...c, ts: tsMs, __ts_ms: tsMs, o, h, l, c: cl };
                              };

                              let candles = (Array.isArray(chartCandles) ? chartCandles : [])
                                .slice(-400)
                                .map(norm)
                                .filter(Boolean);

                              // Sort + dedupe/aggregate to prevent duplicate bars (common on W captures).
                              candles.sort((a, b) => Number(a.__ts_ms) - Number(b.__ts_ms));

                              const weekStartUtcMs = (tsMs) => {
                                const d0 = new Date(Number(tsMs));
                                const day = d0.getUTCDay(); // 0=Sun..6=Sat
                                const daysSinceMon = (day + 6) % 7; // Mon->0, Tue->1, ... Sun->6
                                const d = new Date(
                                  d0.getTime() - daysSinceMon * 24 * 60 * 60 * 1000,
                                );
                                d.setUTCHours(0, 0, 0, 0);
                                return d.getTime();
                              };

                              if (String(chartTf) === "W") {
                                // If the backend sends multiple snapshots within a week, aggregate them
                                // into a single weekly candle: O=first, H=max, L=min, C=last.
                                const byWeek = new Map(); // weekStartMs -> candle
                                for (const c of candles) {
                                  const wk = weekStartUtcMs(c.__ts_ms);
                                  const prev = byWeek.get(wk);
                                  if (!prev) {
                                    byWeek.set(wk, {
                                      ts: wk,
                                      __ts_ms: wk,
                                      o: Number(c.o),
                                      h: Number(c.h),
                                      l: Number(c.l),
                                      c: Number(c.c),
                                      _last_ts: Number(c.__ts_ms),
                                    });
                                  } else {
                                    prev.h = Math.max(Number(prev.h), Number(c.h));
                                    prev.l = Math.min(Number(prev.l), Number(c.l));
                                    if (Number(c.__ts_ms) >= Number(prev._last_ts)) {
                                      prev.c = Number(c.c);
                                      prev._last_ts = Number(c.__ts_ms);
                                    }
                                  }
                                }
                                candles = Array.from(byWeek.values())
                                  .sort((a, b) => Number(a.__ts_ms) - Number(b.__ts_ms))
                                  .map((c) => {
                                    const out = { ...c };
                                    delete out._last_ts;
                                    return out;
                                  });
                              } else {
                                // Dedupe by timestamp (keep the latest sample per ts)
                                const byTs = new Map();
                                for (const c of candles) byTs.set(Number(c.__ts_ms), c);
                                candles = Array.from(byTs.values()).sort(
                                  (a, b) => Number(a.__ts_ms) - Number(b.__ts_ms),
                                );
                              }

                              const n = candles.length;
                              if (n < 2) {
                                return (
                                  <div className="text-xs text-[#93a4d6]">
                                    Candle data loaded, but it‚Äôs not in the expected OHLC format yet.
                                    (Waiting for valid captures.)
                                  </div>
                                );
                              }

                              const lows = candles.map((c) => Number(c.l));
                              const highs = candles.map((c) => Number(c.h));
                              let minL = Math.min(...lows);
                              let maxH = Math.max(...highs);
                              if (!Number.isFinite(minL) || !Number.isFinite(maxH))
                                throw new Error("invalid_minmax");
                              if (maxH <= minL) {
                                maxH = minL + 1;
                              }
                              const pad = (maxH - minL) * 0.05;
                              minL -= pad;
                              maxH += pad;

                            const H = 320;
                            const leftMargin = 5;
                            const rightMargin = 65;
                            const candleW = 8; // Fixed candle width
                            const candleGap = 2; // Gap between candles
                            const candleStep = candleW + candleGap;
                            const plotW = n * candleStep;
                            const W = plotW + leftMargin + rightMargin;
                            const plotH = H;
                            const y = (p) =>
                              plotH - ((p - minL) / (maxH - minL)) * plotH;
                            const bodyW = candleW * 0.9;

                            const priceStep = (maxH - minL) / 5;
                            const priceTicks = [];
                            for (let i = 0; i <= 5; i++) {
                              priceTicks.push(minL + priceStep * i);
                            }

                              const handleMouseMove = (e) => {
                                const svg = e.currentTarget;
                                const rect = svg.getBoundingClientRect();
                                if (!rect || rect.width <= 0 || rect.height <= 0) return;
                                
                                // Get mouse position relative to SVG element
                                const mx = e.clientX - rect.left;
                                const my = e.clientY - rect.top;
                                
                                // Use SVG's getScreenCTM() for accurate coordinate mapping
                                const pt = svg.createSVGPoint();
                                pt.x = e.clientX;
                                pt.y = e.clientY;
                                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                                const svgX = svgP.x;
                                const svgY = svgP.y;
                                
                                if (svgX < leftMargin || svgX > W - rightMargin) return;
                                const idx = Math.floor(((svgX - leftMargin) / plotW) * n);
                                if (idx >= 0 && idx < n) {
                                  const c = candles[idx];
                                  if (!c) return;
                                  const price =
                                    minL + ((H - svgY) / plotH) * (maxH - minL);
                                  setCrosshair({ x: svgX, y: svgY, candle: c, price });
                                }
                              };

                            return (
                              <div className="w-full relative">
                                <div
                                  ref={chartScrollRef}
                                  className="overflow-x-auto overflow-y-hidden rounded border border-[#26325f] bg-[#0b1020] scrollbar-hide"
                                  style={{
                                    scrollbarWidth: "thin",
                                    scrollbarColor: "#26325f #0b1020"
                                  }}
                                >
                                  <svg
                                    viewBox={`0 0 ${W} ${H}`}
                                    preserveAspectRatio="none"
                                    style={{ minWidth: `${Math.max(760, W)}px`, width: `${W}px`, height: "320px" }}
                                    className="cursor-crosshair"
                                    role="img"
                                    aria-label="Candlestick chart"
                                    onMouseMove={handleMouseMove}
                                    onMouseLeave={() => setCrosshair(null)}
                                  >
                                  {/* Price grid lines */}
                                  {priceTicks.map((p, i) => {
                                    const yPos = y(p);
                                    return (
                                      <g key={`grid-${i}`}>
                                        <line
                                          x1={leftMargin}
                                          y1={yPos}
                                          x2={W - rightMargin}
                                          y2={yPos}
                                          stroke="rgba(38,50,95,0.5)"
                                          strokeWidth="1"
                                        />
                                        <text
                                          x={W - rightMargin + 6}
                                          y={yPos + 4}
                                          fontSize="11"
                                          fill="#93a4d6"
                                          fontFamily="monospace"
                                        >
                                          ${p.toFixed(2)}
                                        </text>
                                      </g>
                                    );
                                  })}

                                  {/* Candles */}
                                  {candles.map((c, i) => {
                                    const o = Number(c.o);
                                    const h = Number(c.h);
                                    const l = Number(c.l);
                                    const cl = Number(c.c);
                                    const up = cl >= o;
                                    const stroke = up
                                      ? "rgba(56,189,248,0.95)"
                                      : "rgba(251,146,60,0.95)";
                                    const fill = up
                                      ? "rgba(56,189,248,0.90)"
                                      : "rgba(251,146,60,0.90)";

                                    const cx = leftMargin + i * candleStep + candleStep / 2;
                                    const yH = y(h);
                                    const yL = y(l);
                                    const yO = y(o);
                                    const yC = y(cl);
                                    const top = Math.min(yO, yC);
                                    const bot = Math.max(yO, yC);
                                    const bodyH = Math.max(1.5, bot - top);

                                    return (
                                      <g key={`c-${Number(c.ts)}-${i}`}>
                                        <line
                                          x1={cx}
                                          y1={yH}
                                          x2={cx}
                                          y2={yL}
                                          stroke={stroke}
                                          strokeWidth="1.2"
                                        />
                                        <rect
                                          x={cx - bodyW / 2}
                                          y={top}
                                          width={bodyW}
                                          height={bodyH}
                                          fill={fill}
                                          stroke="none"
                                          rx="0.5"
                                        />
                                      </g>
                                    );
                                  })}

                                  {/* Crosshair */}
                                  {crosshair ? (
                                    <>
                                      <line
                                        x1={leftMargin}
                                        y1={crosshair.y}
                                        x2={W - rightMargin}
                                        y2={crosshair.y}
                                        stroke="rgba(147,164,214,0.5)"
                                        strokeWidth="1"
                                        strokeDasharray="4 4"
                                      />
                                      <line
                                        x1={crosshair.x}
                                        y1={0}
                                        x2={crosshair.x}
                                        y2={H}
                                        stroke="rgba(147,164,214,0.5)"
                                        strokeWidth="1"
                                        strokeDasharray="4 4"
                                      />
                                      {/* Crosshair price label (right side) */}
                                      {(() => {
                                        const yLabel = Math.max(
                                          10,
                                          Math.min(H - 10, Number(crosshair.y)),
                                        );
                                        const price = Number(crosshair.price);
                                        const priceText = Number.isFinite(price)
                                          ? `$${price.toFixed(2)}`
                                          : "‚Äî";
                                        return (
                                          <g>
                                            <rect
                                              x={W - rightMargin + 2}
                                              y={yLabel - 10}
                                              width={rightMargin - 4}
                                              height={20}
                                              fill="rgba(18,26,51,0.92)"
                                              stroke="rgba(38,50,95,0.9)"
                                              strokeWidth="1"
                                              rx="4"
                                            />
                                            <text
                                              x={W - rightMargin + (rightMargin - 4) / 2}
                                              y={yLabel + 4}
                                              fontSize="11"
                                              fill="#fbbf24"
                                              fontFamily="monospace"
                                              fontWeight="700"
                                              textAnchor="middle"
                                            >
                                              {priceText}
                                            </text>
                                          </g>
                                        );
                                      })()}
                                    </>
                                  ) : null}
                                  </svg>
                                </div>

                                {/* Crosshair tooltip */}
                                {crosshair && crosshair.candle ? (
                                  <div
                                    className="absolute top-2 left-2 px-3 py-2 bg-[#121a33]/95 border border-[#26325f] rounded-lg text-[11px] pointer-events-none z-10"
                                    style={{
                                      backdropFilter: "blur(8px)",
                                      boxShadow: "0 4px 12px rgba(0,0,0,0.3)",
                                    }}
                                  >
                                    <div className="font-semibold text-white mb-1">
                                      {(() => {
                                        try {
                                          const ts = Number(
                                            crosshair?.candle?.__ts_ms ??
                                              crosshair?.candle?.ts,
                                          );
                                          if (!Number.isFinite(ts)) return "‚Äî";
                                          if (String(chartTf) === "W") {
                                            // Weekly candles: show the start-of-week (Monday) label
                                            const d0 = new Date(ts);
                                            const day = d0.getDay(); // 0=Sun..6=Sat
                                            const daysSinceMon = (day + 6) % 7; // Mon->0, Tue->1, ... Sun->6
                                            const d = new Date(
                                              d0.getTime() - daysSinceMon * 24 * 60 * 60 * 1000,
                                            );
                                            d.setHours(0, 0, 0, 0);
                                            return `Week of ${d.toLocaleDateString("en-US", {
                                              month: "short",
                                              day: "numeric",
                                              year: "numeric",
                                            })}`;
                                          }
                                          const d = new Date(ts);
                                          return d.toLocaleString("en-US", {
                                            month: "short",
                                            day: "numeric",
                                            hour: "numeric",
                                            minute: "2-digit",
                                          });
                                        } catch {
                                          return "‚Äî";
                                        }
                                      })()}
                                    </div>
                                    <div className="grid grid-cols-2 gap-x-3 gap-y-0.5 text-[10px]">
                                      <div className="text-[#93a4d6]">Price:</div>
                                      <div className="text-yellow-300 font-mono font-semibold">
                                        ${Number(crosshair.price).toFixed(2)}
                                      </div>
                                      <div className="text-[#93a4d6]">O:</div>
                                      <div className="text-white font-mono">
                                        ${Number(crosshair.candle.o).toFixed(2)}
                                      </div>
                                      <div className="text-[#93a4d6]">H:</div>
                                      <div className="text-sky-300 font-mono">
                                        ${Number(crosshair.candle.h).toFixed(2)}
                                      </div>
                                      <div className="text-[#93a4d6]">L:</div>
                                      <div className="text-orange-300 font-mono">
                                        ${Number(crosshair.candle.l).toFixed(2)}
                                      </div>
                                      <div className="text-[#93a4d6]">C:</div>
                                      <div
                                        className={`font-mono font-semibold ${
                                          Number(crosshair.candle.c) >=
                                          Number(crosshair.candle.o)
                                            ? "text-sky-300"
                                            : "text-orange-300"
                                        }`}
                                      >
                                        ${Number(crosshair.candle.c).toFixed(2)}
                                      </div>
                                    </div>
                                  </div>
                                ) : null}

                                <div className="mt-2 text-[10px] text-[#93a4d6] flex items-center justify-between">
                                  <span>
                                    {String(chartTf) === "D"
                                      ? "Daily"
                                      : String(chartTf) === "W"
                                        ? "Weekly"
                                        : `${chartTf}m`}{" "}
                                    ‚Ä¢ {candles.length} bars
                                  </span>
                                  <span className="font-mono">
                                    ${minL.toFixed(2)} ‚Äì ${maxH.toFixed(2)}
                                  </span>
                                </div>
                              </div>
                            );
                            } catch (e) {
                              console.error("[RightRail Chart] render failed:", e);
                              return (
                                <div className="text-xs text-yellow-300">
                                  Chart render error (data may be malformed). Check console for details.
                                </div>
                              );
                            }
                          })()
                        )}
                      </div>
                    </>
                  ) : null}

                  {railTab === "TRADE_HISTORY" ? (
                    <>
                      <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                        <div className="flex items-center justify-between mb-2">
                          <div className="text-sm text-[#93a4d6]">
                            Trade Journey
                          </div>
                          <a
                            href={`simulation-dashboard.html?ticker=${encodeURIComponent(
                              String(tickerSymbol).toUpperCase(),
                            )}`}
                            className="text-xs px-2 py-1 rounded bg-blue-500/20 border border-blue-500/30 text-blue-300 hover:bg-blue-500/30"
                            title="Open full Trade Tracker"
                          >
                            Open
                          </a>
                        </div>
                        {(() => {
                          const stage = String(
                            ticker?.kanban_stage || "",
                          ).trim();
                          if (!stage) return null;
                          const up = stage.toLowerCase();
                          const label = up.replaceAll("_", " ").toUpperCase();
                          const cls =
                            up === "exit"
                              ? "bg-red-500/15 text-red-300 border-red-500/40"
                              : up === "trim"
                                ? "bg-yellow-500/15 text-yellow-300 border-yellow-500/40"
                                : up === "defend"
                                  ? "bg-orange-500/15 text-orange-300 border-orange-500/40"
                                  : up === "hold"
                                    ? "bg-blue-500/15 text-blue-300 border-blue-500/40"
                                    : up === "enter_now"
                                      ? "bg-green-500/15 text-green-300 border-green-500/40"
                                      : "bg-white/5 text-[#93a4d6] border-white/10";
                          return (
                            <div className="mb-2 text-[11px] flex items-center gap-2">
                              <span className="text-[#93a4d6]">Now:</span>
                              <span
                                className={`px-2 py-0.5 rounded border font-semibold ${cls}`}
                              >
                                {label}
                              </span>
                              <span className="text-[#6b7a9f]">
                                (ledger may still show an open trade while we
                                are in an exit lane)
                              </span>
                            </div>
                          );
                        })()}
                        {ledgerTradesLoading ? (
                          <div className="text-xs text-[#93a4d6] flex items-center gap-2">
                            <div className="loading-spinner"></div>
                            Loading ledger trades‚Ä¶
                          </div>
                        ) : ledgerTradesError ? (
                          <div className="text-xs text-red-400">
                            Ledger unavailable: {ledgerTradesError}
                          </div>
                        ) : ledgerTrades.length === 0 ? (
                          <div className="text-xs text-[#93a4d6]">
                            No ledger trades found for this ticker.
                          </div>
                        ) : (
                          <div className="space-y-3">
                            {ledgerTrades.slice(0, 5).map((t) => {
                              const isClosed =
                                t.status === "WIN" || t.status === "LOSS";
                              const pnl = Number(t.pnl || 0);
                              const entryPrice = Number(t.entry_price || 0);
                              const exitPrice = Number(t.exit_price || 0);
                              const quantity = Number(t.quantity || 0);
                              
                              const formatDateTime = (ts) => {
                                if (!ts) return "‚Äî";
                                try {
                                  const d = new Date(Number(ts));
                                  return d.toLocaleString('en-US', {
                                    month: 'short',
                                    day: 'numeric',
                                    hour: 'numeric',
                                    minute: '2-digit',
                                    hour12: true
                                  });
                                } catch {
                                  return "‚Äî";
                                }
                              };
                              
                              return (
                                <div
                                  key={t.trade_id}
                                  className="p-3 bg-[#121a33] border border-[#26325f] rounded"
                                >
                                  {/* Header: Status and P&L */}
                                  <div className="flex items-center justify-between mb-2">
                                    <div className="flex items-center gap-2">
                                      {isClosed ? (
                                        <span
                                          className={`px-2 py-0.5 rounded text-[10px] font-semibold ${
                                            t.status === "WIN"
                                              ? "bg-green-500/20 text-green-400 border border-green-500/30"
                                              : "bg-red-500/20 text-red-400 border border-red-500/30"
                                          }`}
                                        >
                                          {t.status}
                                        </span>
                                      ) : (
                                        <span className="px-2 py-0.5 rounded text-[10px] font-semibold bg-blue-500/15 text-blue-300 border border-blue-500/30">
                                          OPEN
                                        </span>
                                      )}
                                      <span
                                        className={`text-xs font-semibold ${
                                          t.direction === "LONG"
                                            ? "text-green-400"
                                            : "text-red-400"
                                        }`}
                                      >
                                        {t.direction}
                                      </span>
                                    </div>
                                    {isClosed && (
                                      <div
                                        className={`text-sm font-bold ${
                                          pnl >= 0
                                            ? "text-green-400"
                                            : "text-red-400"
                                        }`}
                                      >
                                        {pnl >= 0 ? "+" : ""}${pnl.toFixed(2)}
                                      </div>
                                    )}
                                  </div>
                                  
                                  {/* Entry */}
                                  <div className="space-y-1 text-xs">
                                    <div className="flex items-center justify-between">
                                      <span className="text-[#93a4d6]">Entered:</span>
                                      <span className="text-white font-semibold">
                                        {formatDateTime(t.entry_ts)}
                                      </span>
                                    </div>
                                    <div className="flex items-center justify-between">
                                      <span className="text-[#93a4d6]">Entry Price:</span>
                                      <span className="text-green-400 font-semibold">
                                        ${entryPrice > 0 ? entryPrice.toFixed(2) : "‚Äî"}
                                      </span>
                                    </div>
                                    {quantity > 0 && (
                                      <div className="flex items-center justify-between">
                                        <span className="text-[#93a4d6]">Quantity:</span>
                                        <span className="text-white font-semibold">
                                          {quantity.toFixed(0)} shares
                                        </span>
                                      </div>
                                    )}
                                    
                                    {/* Exit (if closed) */}
                                    {isClosed && (
                                      <>
                                        <div className="border-t border-[#26325f]/50 my-1.5"></div>
                                        <div className="flex items-center justify-between">
                                          <span className="text-[#93a4d6]">Exited:</span>
                                          <span className="text-white font-semibold">
                                            {formatDateTime(t.exit_ts)}
                                          </span>
                                        </div>
                                        <div className="flex items-center justify-between">
                                          <span className="text-[#93a4d6]">Exit Price:</span>
                                          <span className="text-red-400 font-semibold">
                                            ${exitPrice > 0 ? exitPrice.toFixed(2) : "‚Äî"}
                                          </span>
                                        </div>
                                      </>
                                    )}
                                  </div>
                                </div>
                              );
                            })}
                            {ledgerTrades.length > 5 && (
                              <div className="text-[10px] text-[#6b7a9f] text-center">
                                Showing 5 of {ledgerTrades.length} recent trades
                              </div>
                            )}
                          </div>
                        )}
                      </div>

                      {/* Completion, Phase, Dynamic ETA */}
                    </>
                  ) : null}

                  {railTab === "JOURNEY" ? (
                    <>
                      {/* Performance Overview */}
                      {(() => {
                        const currentPrice = Number(ticker.price);
                        if (!Number.isFinite(currentPrice) || currentPrice <= 0) return null;
                        
                        // Calculate performance for different time periods
                        const calculatePerformance = (daysBack) => {
                          const now = Date.now();
                          const cutoff = now - (daysBack * 24 * 60 * 60 * 1000);
                          
                          // Find price at cutoff from bubbleJourney
                          let oldPrice = null;
                          if (Array.isArray(bubbleJourney) && bubbleJourney.length > 0) {
                            const sorted = bubbleJourney
                              .filter(p => {
                                const ts = Number(p.__ts_ms || p.ts);
                                return Number.isFinite(ts) && ts >= cutoff;
                              })
                              .sort((a, b) => {
                                const tsA = Number(a.__ts_ms || a.ts);
                                const tsB = Number(b.__ts_ms || b.ts);
                                return tsA - tsB;
                              });
                            
                            if (sorted.length > 0) {
                              const p = Number(sorted[0].price);
                              if (Number.isFinite(p) && p > 0) {
                                oldPrice = p;
                              }
                            }
                          }
                          
                          if (!oldPrice) return null;
                          
                          const changePct = ((currentPrice - oldPrice) / oldPrice) * 100;
                          const changePoints = currentPrice - oldPrice;
                          
                          return {
                            oldPrice,
                            changePct,
                            changePoints,
                            isUp: changePct >= 0
                          };
                        };
                        
                        const periods = [
                          { label: 'Today', days: 1 },
                          { label: '5D', days: 5 },
                          { label: '15D', days: 15 },
                          { label: '30D', days: 30 },
                          { label: '90D', days: 90 }
                        ];
                        
                        const performanceData = periods.map(p => ({
                          ...p,
                          perf: calculatePerformance(p.days)
                        })).filter(p => p.perf !== null);
                        
                        if (performanceData.length === 0) {
                          return (
                            <div className="mb-4 p-3 bg-[#0f1630] border border-[#26325f] rounded-lg text-xs text-[#93a4d6]">
                              Performance data loading... Check back after we collect more history.
                            </div>
                          );
                        }
                        
                        return (
                          <div className="mb-4 space-y-3">
                            {performanceData.map((item, idx) => {
                              const { label, days, perf } = item;
                              const { changePct, changePoints, isUp } = perf;
                              
                              // Generate LLM-style interpretation
                              const getInterpretation = () => {
                                const absChg = Math.abs(changePct);
                                const tickerSymbol = String(ticker.ticker).toUpperCase();
                                
                                if (absChg < 2) {
                                  return `${tickerSymbol} is trading relatively flat over the past ${label.toLowerCase()}, showing ${absChg.toFixed(1)}% ${isUp ? 'gain' : 'loss'}. Price action suggests consolidation.`;
                                } else if (absChg < 5) {
                                  return `${tickerSymbol} is ${isUp ? 'up' : 'down'} ${absChg.toFixed(1)}% over the past ${label.toLowerCase()}, showing ${isUp ? 'modest bullish momentum' : 'mild weakness'}. Watch for ${isUp ? 'continuation or profit-taking' : 'support levels'}.`;
                                } else if (absChg < 10) {
                                  return `${tickerSymbol} has ${isUp ? 'gained' : 'lost'} ${absChg.toFixed(1)}% in the past ${label.toLowerCase()}, indicating ${isUp ? 'strong momentum' : 'significant selling pressure'}. ${isUp ? 'Momentum players may be accumulating' : 'Consider risk management'}.`;
                                } else if (absChg < 20) {
                                  return `${tickerSymbol} is showing ${isUp ? 'explosive' : 'severe'} ${isUp ? 'upside' : 'downside'} with a ${absChg.toFixed(1)}% ${isUp ? 'rally' : 'decline'} over ${label.toLowerCase()}. ${isUp ? 'High volatility suggests strong interest' : 'Caution warranted at these levels'}.`;
                                } else {
                                  return `${tickerSymbol} has ${isUp ? 'surged' : 'plunged'} ${absChg.toFixed(1)}% in ${label.toLowerCase()}‚Äîa ${isUp ? 'parabolic' : 'dramatic'} move. ${isUp ? 'Extreme momentum, watch for exhaustion' : 'Oversold conditions may present opportunity'}.`;
                                }
                              };
                              
                              return (
                                <div
                                  key={label}
                                  className="p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg"
                                >
                                  <div className="flex items-center justify-between mb-2">
                                    <span className="text-xs font-bold text-[#93a4d6]">{label}</span>
                                    <div className="text-right">
                                      <div className={`text-lg font-bold ${isUp ? 'text-green-400' : 'text-red-400'}`}>
                                        {isUp ? '+' : ''}{changePct.toFixed(2)}%
                                      </div>
                                      <div className={`text-xs ${isUp ? 'text-green-300/70' : 'text-red-300/70'}`}>
                                        {isUp ? '+' : ''}${changePoints.toFixed(2)} pts
                                      </div>
                                    </div>
                                  </div>
                                  <div className="text-xs text-[#cbd5ff] leading-relaxed bg-[#121a33] p-2 rounded border border-[#26325f]/50">
                                    {getInterpretation()}
                                  </div>
                                </div>
                              );
                            })}
                          </div>
                        );
                      })()}

                      {/* Bubble Journey (15m increments) */}
                      <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                        <div className="flex items-center justify-between mb-2">
                          <div className="text-sm text-[#93a4d6]">
                            Bubble Journey (15m increments)
                          </div>
                          <a
                            href={`index-react.html?timeTravel=1&ticker=${encodeURIComponent(
                              String(tickerSymbol).toUpperCase(),
                            )}`}
                            className="text-xs px-2 py-1 rounded bg-purple-500/20 border border-purple-500/30 text-purple-300 hover:bg-purple-500/30"
                            title="Open Time Travel (if supported)"
                          >
                            Time Travel
                          </a>
                        </div>

                        {bubbleJourneyLoading ? (
                          <div className="text-xs text-[#93a4d6] flex items-center gap-2">
                            <div className="loading-spinner"></div>
                            Loading trail‚Ä¶
                          </div>
                        ) : bubbleJourneyError ? (
                          <div className="text-xs text-red-400">
                            Trail unavailable: {bubbleJourneyError}
                          </div>
                        ) : bubbleJourney.length === 0 ? (
                          <div className="text-xs text-[#93a4d6]">
                            No trail points found for this ticker.
                          </div>
                        ) : (
                          <div className="space-y-1 max-h-64 overflow-y-auto pr-1">
                            {downsampleByInterval(bubbleJourney, 15 * 60 * 1000)
                              .slice()
                              .reverse()
                              .slice(0, 40)
                              .map((p, idx) => {
                                const ts = Number(p.__ts_ms);
                                const state =
                                  p.state || p.quadrant || p.zone || "‚Äî";
                                const phasePct =
                                  p.phase_pct != null
                                    ? `${Math.round(Number(p.phase_pct) * 100)}%`
                                    : "‚Äî";
                                const htf =
                                  p.htf_score != null &&
                                  Number.isFinite(Number(p.htf_score))
                                    ? Number(p.htf_score).toFixed(1)
                                    : "‚Äî";
                                const ltf =
                                  p.ltf_score != null &&
                                  Number.isFinite(Number(p.ltf_score))
                                    ? Number(p.ltf_score).toFixed(1)
                                    : "‚Äî";
                                const rank =
                                  p.rank != null ? String(p.rank) : "‚Äî";
                                const rr =
                                  p.rr != null && Number.isFinite(Number(p.rr))
                                    ? Number(p.rr).toFixed(2)
                                    : p.rr_at_alert != null &&
                                        Number.isFinite(Number(p.rr_at_alert))
                                      ? Number(p.rr_at_alert).toFixed(2)
                                      : "‚Äî";
                                const isSelected =
                                  selectedJourneyTs != null &&
                                  Number.isFinite(ts) &&
                                  Number(ts) === Number(selectedJourneyTs);

                                const pointForChart = {
                                  ts: Number.isFinite(ts) ? ts : null,
                                  htf_score:
                                    p.htf_score != null
                                      ? Number(p.htf_score)
                                      : null,
                                  ltf_score:
                                    p.ltf_score != null
                                      ? Number(p.ltf_score)
                                      : null,
                                  phase_pct:
                                    p.phase_pct != null
                                      ? Number(p.phase_pct)
                                      : null,
                                  completion:
                                    p.completion != null
                                      ? Number(p.completion)
                                      : null,
                                  rank: p.rank != null ? Number(p.rank) : null,
                                  rr: p.rr != null ? Number(p.rr) : null,
                                  state: p.state || null,
                                };
                                return (
                                  <div
                                    key={`${ts}-${idx}`}
                                    className={`px-2 py-1 bg-[#121a33] border rounded flex items-center justify-between gap-2 cursor-pointer transition-colors ${
                                      isSelected
                                        ? "border-cyan-400/80 bg-cyan-500/10"
                                        : "border-[#26325f] hover:border-cyan-400/40 hover:bg-[#16224a]"
                                    }`}
                                    onMouseEnter={() => {
                                      if (onJourneyHover)
                                        onJourneyHover(pointForChart);
                                    }}
                                    onMouseLeave={() => {
                                      if (onJourneyHover) onJourneyHover(null);
                                    }}
                                    onClick={() => {
                                      if (onJourneySelect)
                                        onJourneySelect(pointForChart);
                                    }}
                                  >
                                    <div className="min-w-0">
                                      <div className="text-[10px] text-[#93a4d6]">
                                        {Number.isFinite(ts)
                                          ? new Date(ts).toLocaleString()
                                          : "‚Äî"}
                                      </div>
                                      <div className="text-xs text-white truncate">
                                        {state}
                                        <span className="text-[#6b7a9f]">
                                          {" "}
                                          ‚Ä¢{" "}
                                        </span>
                                        <span className="text-[#93a4d6]">
                                          Phase
                                        </span>{" "}
                                        {phasePct}
                                      </div>
                                      <div className="text-[10px] text-[#93a4d6]">
                                        <span className="text-[#6b7a9f]">
                                          HTF
                                        </span>{" "}
                                        <span className="text-white font-semibold">
                                          {htf}
                                        </span>
                                        <span className="text-[#6b7a9f]">
                                          {" "}
                                          ‚Ä¢{" "}
                                        </span>
                                        <span className="text-[#6b7a9f]">
                                          LTF
                                        </span>{" "}
                                        <span className="text-white font-semibold">
                                          {ltf}
                                        </span>
                                      </div>
                                    </div>
                                    <div className="text-right text-[10px] text-[#93a4d6] whitespace-nowrap">
                                      <div>
                                        <span className="text-[#6b7a9f]">
                                          Rank
                                        </span>{" "}
                                        <span className="text-white font-semibold">
                                          {rank}
                                        </span>
                                      </div>
                                      <div>
                                        <span className="text-[#6b7a9f]">
                                          RR
                                        </span>{" "}
                                        <span className="text-white font-semibold">
                                          {rr}
                                        </span>
                                      </div>
                                    </div>
                                  </div>
                                );
                              })}
                          </div>
                        )}
                      </div>

                      {/* Current State Summary */}
                      <div className="mb-4 p-3 bg-[#0f1630] border border-[#26325f] rounded-lg">
                        <div className="text-xs text-[#93a4d6] mb-2 font-semibold">Current Status</div>
                        <div className="grid grid-cols-3 gap-2 text-xs">
                          <div>
                            <div className="text-[#93a4d6] text-[10px]">Phase</div>
                            <div className="text-white font-semibold" style={{ color: phaseColor }}>
                              {(phase * 100).toFixed(0)}%
                            </div>
                          </div>
                          <div>
                            <div className="text-[#93a4d6] text-[10px]">Completion</div>
                            <div className="text-white font-semibold">
                              {ticker.completion != null
                                ? `${(Number(ticker.completion) * 100).toFixed(0)}%`
                                : "‚Äî"}
                            </div>
                          </div>
                          <div>
                            <div className="text-[#93a4d6] text-[10px]">ETA</div>
                            <div className="text-white font-semibold">
                              {(() => {
                                const eta = computeEtaDays(ticker);
                                return Number.isFinite(eta) ? `${eta.toFixed(1)}d` : "‚Äî";
                              })()}
                            </div>
                          </div>
                        </div>
                      </div>
                    </>
                  ) : null}
                </div>
              </div>

              {/* Fixed Footer */}
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[#26325f] bg-[#121a33]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(
                    tickerSymbol,
                  )}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  üìä Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // Legacy TickerDetails component - kept for backward compatibility but now uses unified component
      function TickerDetails({
        ticker,
        onClose,
        allTickers = [],
        allLoadedData = null,
      }) {
        if (!ticker) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);

        // Convert allLoadedData (object) to array if provided, otherwise use allTickers
        // allLoadedData contains ALL loaded tickers (unfiltered), while allTickers is filtered
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) {
              return allLoadedData;
            } else {
              // Convert object to array: { "GOOGL": {...}, "MSFT": {...} } -> [...]
              return Object.values(allLoadedData).filter(
                (t) => t && typeof t === "object" && t.ticker,
              );
            }
          }
          // Fallback to allTickers if allLoadedData not provided
          return allTickers || [];
        })();

        return (
          <div className="w-full h-full flex flex-col">
            {/* Detail Card - slides in from right, positioned in hero layout */}
            <div
              className="bg-[#121a33] border-2 border-[#26325f] rounded-xl w-full h-full flex flex-col shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Scrollable Content Area */}
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button
                    onClick={onClose}
                    className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
                  >
                    ‚úï
                  </button>
                </div>

                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      üöÄ MOMENTUM ELITE üöÄ
                    </div>
                    <div className="text-xs text-purple-200/80 font-normal mb-2">
                      High-quality momentum stock with strong fundamentals
                    </div>
                    {ticker.momentum_pct && (
                      <div className="mt-2 pt-2 border-t border-purple-400/30">
                        <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">
                          Momentum Performance:
                        </div>
                        <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                          {ticker.momentum_pct.week != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1W:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.week) >= 10
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.week).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.month != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.month) >= 25
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.month).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.three_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">3M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.three_months) >= 50
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(
                                  ticker.momentum_pct.three_months,
                                ).toFixed(1)}
                                %
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.six_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">6M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.six_months) >= 100
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.six_months).toFixed(
                                  1,
                                )}
                                %
                              </span>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                    ‚≠ê PRIME SETUP ‚≠ê
                  </div>
                )}

                {/* Bias/Direction - Prominent */}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                      <div className="text-sm text-[#93a4d6] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}
                      >
                        {dir.text === "LONG"
                          ? "üìà LONG"
                          : dir.text === "SHORT"
                            ? "üìâ SHORT"
                            : dir.text}
                      </div>
                    </div>
                  );
                })()}

                {/* Action Description */}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[#93a4d6]">
                    {actionInfo.description}
                  </div>
                </div>

                {/* Quadrant Progression Visualization */}
                <QuadrantProgression ticker={ticker} flags={flags} />

                {/* Phase indicator */}
                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[#93a4d6]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                      {ticker.phase_zone && ` (${ticker.phase_zone})`}
                    </span>
                  </div>
                  <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                        boxShadow: `0 0 8px ${phaseColor}40`,
                      }}
                    />
                  </div>
                </div>

                <div className="space-y-2.5 text-sm">
                  {(() => {
                    const baseScore = Number(ticker.rank) || 0; // Base Score from worker
                    const sortedByRank = getRankedTickers(
                      allLoadedTickersArray,
                    );
                    const rankPosition = getRankPosition(
                      sortedByRank,
                      ticker.ticker,
                    );
                    const totalTickersRaw = sortedByRank.length;
                    const totalTickers =
                      Number.isFinite(Number(ticker.rank_total)) &&
                      Number(ticker.rank_total) > 0
                        ? Number(ticker.rank_total)
                        : totalTickersRaw;

                    return (
                      <>
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Base Score</span>
                          <span className="font-semibold text-blue-400">
                            {baseScore}
                          </span>
                        </div>
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Rank</span>
                          <span className="font-semibold">
                            {rankPosition > 0
                              ? `#${rankPosition} of ${totalTickers}`
                              : "‚Äî"}
                          </span>
                        </div>
                      </>
                    );
                  })()}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const breakdownComponents = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return breakdownComponents.length > 0 ? (
                      <>
                        <div className="border-t border-[#26325f] my-3 pt-3">
                          <div className="text-xs text-[#93a4d6] mb-3 font-semibold">
                            Score Breakdown
                          </div>
                          <div className="space-y-1.5">
                            {breakdownComponents.map((comp, idx) => (
                              <div
                                key={idx}
                                className="flex justify-between items-center text-xs"
                              >
                                <span className="text-[#93a4d6]">
                                  {comp.label}
                                </span>
                                <span className={`font-semibold ${comp.color}`}>
                                  {comp.value}
                                </span>
                              </div>
                            ))}
                            <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                              <span className="text-[#93a4d6] font-semibold">
                                Total Score
                              </span>
                              <span className="text-blue-400 font-bold text-base">
                                {Math.round(breakdown.total)}
                              </span>
                            </div>
                          </div>
                        </div>
                      </>
                    ) : null;
                  })()}

                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "‚Äî"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">State</span>
                    <span className="font-semibold">{ticker.state || "‚Äî"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Completion</span>
                    <span className="font-semibold">
                      {Math.round(completionForSize(ticker) * 100)}%
                    </span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                        {ent.side}
                      </span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Current Price</span>
                    <span className="font-semibold text-lg">
                      {ticker.price
                        ? `$${Number(ticker.price).toFixed(2)}`
                        : "‚Äî"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">TP (Primary)</span>
                    <span className="font-semibold">
                      {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "‚Äî"}
                      {ticker.tp_levels &&
                        Array.isArray(ticker.tp_levels) &&
                        ticker.tp_levels.length > 0 &&
                        (() => {
                          const firstTp = ticker.tp_levels[0];
                          const tpInfo =
                            typeof firstTp === "object" && firstTp !== null
                              ? firstTp
                              : { price: firstTp };
                          if (tpInfo.label) {
                            const refParts = [];
                            if (tpInfo.timeframe)
                              refParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              refParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`,
                              );
                            }
                            const refStr =
                              refParts.length > 0
                                ? ` (${tpInfo.label} - ${refParts.join(", ")})`
                                : ` (${tpInfo.label})`;
                            return refStr;
                          }
                          return "";
                        })()}
                    </span>
                  </div>
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 1 &&
                    (() => {
                      // Calculate max TP
                      const tpPrices = ticker.tp_levels
                        .map((tpItem) => {
                          if (
                            typeof tpItem === "object" &&
                            tpItem !== null &&
                            tpItem.price != null
                          ) {
                            return Number(tpItem.price);
                          }
                          return typeof tpItem === "number"
                            ? tpItem
                            : Number(tpItem);
                        })
                        .filter((p) => Number.isFinite(p));

                      if (tpPrices.length > 0) {
                        const maxTP = Math.max(...tpPrices);
                        const primaryTP = Number(ticker.tp) || tpPrices[0];

                        if (maxTP > primaryTP) {
                          return (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">TP (Max)</span>
                              <span className="font-semibold text-green-400">
                                ${maxTP.toFixed(2)}
                              </span>
                            </div>
                          );
                        }
                      }
                      return null;
                    })()}
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 0 && (
                      <div className="py-1 border-b border-[#26325f]/50">
                        <div className="text-[#93a4d6] text-xs mb-2 font-semibold">
                          TP Levels
                        </div>
                        <div className="space-y-1.5 max-h-48 overflow-y-auto">
                          {ticker.tp_levels.map((tp, idx) => {
                            // Handle both old format (just price) and new format (object with metadata)
                            const tpInfo =
                              typeof tp === "object" && tp !== null
                                ? tp
                                : { price: tp, label: `TP${idx + 1}` };
                            const price = Number(tpInfo.price || tp);
                            const label = tpInfo.label || `TP${idx + 1}`;
                            const source = tpInfo.source || "";
                            const type = tpInfo.type || "";
                            const confidence = tpInfo.confidence || null;

                            // Build reference string from all available metadata
                            const referenceParts = [];
                            if (tpInfo.timeframe)
                              referenceParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              referenceParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`,
                              );
                            }
                            if (tpInfo.source)
                              referenceParts.push(tpInfo.source);
                            if (tpInfo.type) referenceParts.push(tpInfo.type);
                            const referenceStr =
                              referenceParts.length > 0
                                ? referenceParts.join(" ‚Ä¢ ")
                                : null;

                            return (
                              <div
                                key={idx}
                                className="flex items-start justify-between p-1.5 rounded bg-[#0f1630] border border-[#26325f]/50 hover:border-[#3a4aa0] transition-colors"
                              >
                                <div className="flex-1">
                                  <div className="flex items-center gap-2 flex-wrap">
                                    <span className="text-xs font-semibold text-green-400">
                                      {label}
                                    </span>
                                    <span className="text-xs font-mono text-white font-bold">
                                      ${price.toFixed(2)}
                                    </span>
                                    {confidence !== null && (
                                      <span
                                        className={`text-[10px] px-1 py-0.5 rounded ${
                                          confidence >= 0.8
                                            ? "bg-green-500/20 text-green-400"
                                            : confidence >= 0.6
                                              ? "bg-yellow-500/20 text-yellow-400"
                                              : "bg-orange-500/20 text-orange-400"
                                        }`}
                                      >
                                        {Math.round(confidence * 100)}%
                                      </span>
                                    )}
                                  </div>
                                  {referenceStr && (
                                    <div className="text-[10px] text-[#93a4d6] mt-1 italic">
                                      {referenceStr}
                                    </div>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">SL</span>
                    <span className="font-semibold">
                      {ticker.sl ? Number(ticker.sl).toFixed(2) : "‚Äî"}
                    </span>
                  </div>
                </div>

                {/* Flags */}
                {(flags.sq30_on ||
                  flags.sq30_release ||
                  flags.phase_dot ||
                  flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[#93a4d6] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && (
                        <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                          üß® Squeeze ON
                        </span>
                      )}
                      {flags.sq30_release && (
                        <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                          ‚ö° Squeeze Release
                        </span>
                      )}
                      {flags.phase_dot && (
                        <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                          Phase Dot
                        </span>
                      )}
                      {flags.phase_zone_change && (
                        <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                          Zone Change
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </div>

              {/* Fixed Footer - Open in TradingView button */}
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[#26325f] bg-[#121a33]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(
                    ticker.ticker,
                  )}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  üìä Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // AI Chat Interface Component
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const AIChatInterface = ({ isOpen, onClose, tickerData }) => {
        const [messages, setMessages] = useState([
          {
            role: "assistant",
            content:
              "üëã Hi! I'm your AI trading assistant. I can help you analyze tickers, understand setups, and provide insights. What would you like to know?",
            timestamp: new Date(),
          },
        ]);
        const [input, setInput] = useState("");
        const [loading, setLoading] = useState(false);
        const [periodicUpdates, setPeriodicUpdates] = useState([]);
        const [showUpdates, setShowUpdates] = useState(false);
        const messagesEndRef = useRef(null);
        const inputRef = useRef(null);

        const scrollToBottom = () => {
          if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
          }
        };

        useEffect(() => {
          scrollToBottom();
        }, [messages]);

        useEffect(() => {
          if (isOpen && inputRef.current) {
            inputRef.current.focus();
          }
        }, [isOpen]);

        // Load periodic updates when chat opens
        useEffect(() => {
          if (isOpen) {
            const fetchUpdates = async () => {
              try {
                const timestamp = Date.now();
                const res = await fetch(
                  `${API_BASE}/timed/ai/updates?limit=5&_t=${timestamp}`,
                  {
                    cache: "no-store",
                    headers: {
                      "Cache-Control": "no-cache, no-store, must-revalidate",
                      Pragma: "no-cache",
                      Expires: "0",
                    },
                  },
                );
                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && data.updates) {
                    setPeriodicUpdates(data.updates);
                  }
                }
              } catch (err) {
                console.warn("Failed to fetch periodic updates:", err);
              }
            };
            fetchUpdates();
          }
        }, [isOpen]);

        const handleMonitor = async () => {
          setLoading(true);

          const monitorMessage = {
            role: "user",
            content: "üîç Run market monitoring analysis",
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, monitorMessage]);

          try {
            const timestamp = Date.now();
            const response = await fetch(
              `${API_BASE}/timed/ai/monitor?_t=${timestamp}`,
              {
                method: "GET",
                cache: "no-store",
                headers: {
                  "Content-Type": "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                },
              },
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "Monitoring service error");
            }

            const assistantMessage = {
              role: "assistant",
              content: `üìä **Market Monitoring Analysis**\n\n${data.analysis}\n\n---\n**Stats:** ${data.stats.primeSetups} prime setups, ${data.stats.highRiskPositions} high-risk positions, ${data.stats.momentumElite} Momentum Elite`,
              timestamp: new Date(),
              sources: [
                `Monitoring data: ${data.stats.totalTickers} tickers, ${data.stats.recentActivity} events`,
              ],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Monitor error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "‚ö†Ô∏è AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `‚ùå Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const handleSend = async (e) => {
          e.preventDefault();
          if (!input.trim() || loading) return;

          const userMessage = {
            role: "user",
            content: input.trim(),
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, userMessage]);
          setInput("");
          setLoading(true);

          try {
            // Fetch recent activity for context
            let activityData = [];
            try {
              const activityRes = await fetch(
                `${API_BASE}/timed/activity?limit=20`,
              );
              if (activityRes.ok) {
                const activityJson = await activityRes.json();
                if (activityJson.ok && Array.isArray(activityJson.events)) {
                  activityData = activityJson.events;
                }
              }
            } catch (e) {
              console.warn("Failed to fetch activity for chat:", e);
            }

            const timestamp = Date.now();
            const response = await fetch(
              `${API_BASE}/timed/ai/chat?_t=${timestamp}`,
              {
                method: "POST",
                cache: "no-store",
                headers: {
                  "Content-Type": "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                },
                body: JSON.stringify({
                  message: userMessage.content,
                  conversationHistory: messages.slice(-10).map((m) => ({
                    role: m.role,
                    content: m.content,
                  })),
                  tickerData: tickerData
                    ? Object.keys(tickerData).slice(0, 50)
                    : [],
                  activityData: activityData,
                }),
              },
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "AI service error");
            }

            const assistantMessage = {
              role: "assistant",
              content:
                data.response || "Sorry, I couldn't process that request.",
              timestamp: new Date(),
              sources: data.sources || [],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Chat error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "‚ö†Ô∏è AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `‚ùå Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const formatMessage = (content) => {
          // Simple markdown-like formatting
          const lines = content.split("\n");
          return lines.map((line, i) => {
            let formatted = line;
            // Bold
            formatted = formatted.replace(
              /\*\*(.+?)\*\*/g,
              '<strong class="font-semibold">$1</strong>',
            );
            // Code blocks
            formatted = formatted.replace(
              /`(.+?)`/g,
              '<code class="bg-[#26325f] px-1 py-0.5 rounded text-xs">$1</code>',
            );
            // Links
            formatted = formatted.replace(
              /\[(.+?)\]\((.+?)\)/g,
              '<a href="$2" target="_blank" class="text-blue-400 hover:underline">$1</a>',
            );
            // Use React.createElement instead of JSX for better Babel compatibility
            return React.createElement("p", {
              key: i,
              dangerouslySetInnerHTML: { __html: formatted },
            });
          });
        };

        if (!isOpen) return null;

        return (
          <div className="fixed right-0 top-0 h-full w-96 bg-[#0f1630] border-l border-[#26325f] flex flex-col shadow-2xl z-50 slide-in-right">
            {/* Header */}
            <div className="flex items-center justify-between p-4 border-b border-[#26325f] bg-[#121a33]">
              <div className="flex items-center gap-2">
                <div className="w-8 h-8 rounded-full bg-gradient-to-br from-blue-500 to-purple-500 flex items-center justify-center text-white font-bold text-sm">
                  AI
                </div>
                <div>
                  <h3 className="text-sm font-semibold text-white">
                    Trading Assistant
                  </h3>
                  <p className="text-xs text-[#93a4d6]">Powered by OpenAI</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                {periodicUpdates.length > 0 && (
                  <button
                    onClick={() => setShowUpdates(!showUpdates)}
                    className="px-3 py-1.5 text-xs bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/30 rounded-lg text-purple-400 font-semibold transition-colors relative"
                    title="View periodic updates"
                  >
                    üìÖ Updates
                    {periodicUpdates.length > 0 && (
                      <span className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full text-[8px] flex items-center justify-center text-white">
                        {periodicUpdates.length}
                      </span>
                    )}
                  </button>
                )}
                <button
                  onClick={handleMonitor}
                  disabled={loading}
                  className="px-3 py-1.5 text-xs bg-green-500/20 hover:bg-green-500/30 disabled:bg-[#26325f] disabled:text-[#6b7a9f] border border-green-500/30 rounded-lg text-green-400 font-semibold transition-colors disabled:cursor-not-allowed"
                  title="Run market monitoring analysis"
                >
                  üîç Monitor
                </button>
                <button
                  onClick={onClose}
                  className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
                >
                  ‚úï
                </button>
              </div>
            </div>

            {/* Periodic Updates Panel */}
            {showUpdates && periodicUpdates.length > 0 && (
              <div className="border-b border-[#26325f] bg-[#0f1630] max-h-64 overflow-y-auto">
                <div className="p-3">
                  <h4 className="text-xs font-semibold text-white mb-2">
                    üìÖ Periodic Updates
                  </h4>
                  <div className="space-y-2">
                    {periodicUpdates.map((update, idx) => (
                      <div
                        key={idx}
                        className="p-2 bg-[#121a33] border border-[#26325f] rounded-lg cursor-pointer hover:bg-[#1a2550] transition-colors"
                        onClick={() => {
                          setMessages((prev) => [
                            ...prev,
                            {
                              role: "assistant",
                              content: `üìÖ **${update.updateTime}**\n\n${update.analysis}\n\n---\n**Stats:** ${update.stats.primeSetups} prime setups, ${update.stats.highRiskPositions} high-risk positions`,
                              timestamp: new Date(update.timestamp),
                            },
                          ]);
                          setShowUpdates(false);
                        }}
                      >
                        <div className="text-xs font-semibold text-purple-400">
                          {update.updateTime}
                        </div>
                        <div className="text-xs text-[#93a4d6] mt-1 line-clamp-2">
                          {update.analysis.substring(0, 100)}...
                        </div>
                        <div className="text-[10px] text-[#6b7a9f] mt-1">
                          {new Date(update.timestamp).toLocaleString()}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
              {messages.map((msg, idx) => (
                <div
                  key={idx}
                  className={`flex ${
                    msg.role === "user" ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[80%] rounded-lg p-3 ${
                      msg.role === "user"
                        ? "bg-blue-500/20 border border-blue-500/30 text-white"
                        : msg.error
                          ? "bg-red-500/20 border border-red-500/30 text-red-300"
                          : "bg-[#121a33] border border-[#26325f] text-[#e7ecff]"
                    }`}
                  >
                    <div className="text-sm whitespace-pre-wrap">
                      {formatMessage(msg.content)}
                    </div>
                    {msg.sources && msg.sources.length > 0 && (
                      <div className="mt-2 pt-2 border-t border-[#26325f]">
                        <p className="text-xs text-[#93a4d6] mb-1">Sources:</p>
                        <ul className="text-xs text-[#93a4d6] space-y-1">
                          {msg.sources.map((source, i) => (
                            <li key={i}>‚Ä¢ {source}</li>
                          ))}
                        </ul>
                      </div>
                    )}
                    <div className="text-xs text-[#6b7a9f] mt-1">
                      {new Date(msg.timestamp).toLocaleTimeString()}
                    </div>
                  </div>
                </div>
              ))}
              {loading && (
                <div className="flex justify-start">
                  <div className="bg-[#121a33] border border-[#26325f] rounded-lg p-3">
                    <div className="flex items-center gap-2 text-[#93a4d6] text-sm">
                      <div className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"></div>
                      <div
                        className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"
                        style={{ animationDelay: "0.2s" }}
                      ></div>
                      <div
                        className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"
                        style={{ animationDelay: "0.4s" }}
                      ></div>
                      <span>Thinking...</span>
                    </div>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <form
              onSubmit={handleSend}
              className="p-4 border-t border-[#26325f] bg-[#121a33]"
            >
              <div className="flex gap-2">
                <input
                  ref={inputRef}
                  type="text"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="Ask about tickers, setups, or market conditions..."
                  className="flex-1 px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6] focus:outline-none focus:border-[#3a4aa0]"
                  disabled={loading}
                />
                <button
                  type="submit"
                  disabled={loading || !input.trim()}
                  className="px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-[#26325f] disabled:text-[#6b7a9f] rounded-lg text-white font-semibold transition-colors disabled:cursor-not-allowed"
                >
                  Send
                </button>
              </div>
              <div className="flex items-center justify-between mt-2">
                <p className="text-xs text-[#6b7a9f]">
                  üí° Try: "What's the status of AAPL?" or "Show me prime setups"
                </p>
              </div>
            </form>
          </div>
        );
      };

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // TickerDetailsLoader - must be defined before App
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const TickerDetailsLoader = ({
        tickerSymbol,
        onClose,
        rankAsOfMs = null,
        rankedTickers = null,
        rankedTickerPositions = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
      }) => {
        const [tickerData, setTickerData] = useState(null);
        const [allLoadedData, setAllLoadedData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              // Fetch both the ticker data and all tickers for absolute ranking
              const timestamp = Date.now();
              const [tickerRes, allRes] = await Promise.all([
                fetch(
                  `${API_BASE}/timed/latest?ticker=${encodeURIComponent(
                    tickerSymbol,
                  )}&_t=${timestamp}`,
                  {
                    cache: "no-store",
                    headers: {
                      "Cache-Control": "no-cache, no-store, must-revalidate",
                      Pragma: "no-cache",
                      Expires: "0",
                    },
                  },
                ),
                fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
                  cache: "no-store",
                  headers: {
                    "Cache-Control": "no-cache, no-store, must-revalidate",
                    Pragma: "no-cache",
                    Expires: "0",
                  },
                }),
              ]);

              if (!tickerRes.ok) throw new Error(`HTTP ${tickerRes.status}`);
              const tickerJson = await tickerRes.json();
              if (!tickerJson.ok || !tickerJson.latestData) {
                throw new Error(tickerJson.error || "Ticker not found");
              }

              // Try to get all tickers for ranking (may fail, that's okay)
              let allData = null;
              try {
                if (allRes.ok) {
                  const allJson = await allRes.json();
                  if (allJson.ok && allJson.data) {
                    allData = allJson.data;
                  }
                }
              } catch (e) {
                console.warn("Failed to fetch all tickers for ranking:", e);
              }

              setTickerData(tickerJson.latestData);
              setAllLoadedData(allData);
            } catch (err) {
              console.error("Failed to fetch ticker:", err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };

          fetchTicker();
        }, [tickerSymbol]);

        if (loading) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-[#26325f] rounded-xl p-6">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[#93a4d6]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }

        if (error || !tickerData) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-red-500 rounded-xl p-6">
              <div className="text-center">
                <div className="text-red-400 mb-2">
                  Failed to load {tickerSymbol}
                </div>
                <div className="text-[#93a4d6] text-sm mb-4">
                  {error || "No data available"}
                </div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-[#26325f] hover:bg-[#3a4aa0] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }

        return (
          <TickerDetailRightRail
            ticker={tickerData}
            trade={null}
            onClose={onClose}
            allLoadedData={allLoadedData}
            rankedTickers={rankedTickers}
            rankedTickerPositions={rankedTickerPositions}
            rankAsOfMs={rankAsOfMs}
            sectors={sectors}
            onJourneyHover={onJourneyHover}
            onJourneySelect={onJourneySelect}
            selectedJourneyTs={selectedJourneyTs}
          />
        );
      };

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // OverlayPortal - must be defined before App
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const OverlayPortal = ({
        selectedTicker,
        tickers,
        data,
        onClose,
        rankedTickers = null,
        rankedTickerPositions = null,
        rankAsOfMs = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
      }) => {
        if (!selectedTicker) return null;

        try {
          // Normalize ticker name
          const tickerUpper = String(selectedTicker).toUpperCase();

          // Search in filtered tickers first
          let foundTicker = tickers.find((t) => {
            if (!t || typeof t !== "object") return false;
            const tTicker = String(t.ticker || "").toUpperCase();
            return tTicker === tickerUpper;
          });

          // If not found, search in original data object
          if (!foundTicker && data && typeof data === "object") {
            if (Array.isArray(data)) {
              foundTicker = data.find((t) => {
                if (!t || typeof t !== "object") return false;
                const tTicker = String(t.ticker || "").toUpperCase();
                return tTicker === tickerUpper;
              });
            } else {
              // Object format: check if ticker is a key (data structure: { "ETHA": {...}, ... })
              if (data[tickerUpper]) {
                foundTicker = data[tickerUpper];
              } else {
                // Search through all values in case structure is different
                const dataArray = Object.values(data);
                foundTicker = dataArray.find((t) => {
                  if (!t || typeof t !== "object") return false;
                  const tTicker = String(t.ticker || "").toUpperCase();
                  return tTicker === tickerUpper;
                });
              }
            }
          }

          // If still not found, fetch from API
          if (!foundTicker) {
            console.warn(
              "Ticker not found in local data, fetching from API:",
              tickerUpper,
            );
            return (
              <TickerDetailsLoader
                tickerSymbol={tickerUpper}
                onClose={onClose}
                rankedTickers={rankedTickers}
                rankedTickerPositions={rankedTickerPositions}
                rankAsOfMs={rankAsOfMs}
                sectors={sectors}
                onJourneyHover={onJourneyHover}
                onJourneySelect={onJourneySelect}
                selectedJourneyTs={selectedJourneyTs}
              />
            );
          }

          // TEMPORARILY DISABLE PORTAL - render inline to avoid freeze issues
          // TODO: Re-enable portal once freeze is resolved
          return (
            <TickerDetailRightRail
              ticker={foundTicker}
              trade={null}
              onClose={onClose}
              allLoadedData={data}
              rankedTickers={rankedTickers}
              rankedTickerPositions={rankedTickerPositions}
              rankAsOfMs={rankAsOfMs}
              sectors={sectors}
              onJourneyHover={onJourneyHover}
              onJourneySelect={onJourneySelect}
              selectedJourneyTs={selectedJourneyTs}
            />
          );

          /* Portal code - disabled for now
          const overlayContent = (
            <TickerDetails
              ticker={foundTicker}
              onClose={onClose}
            />
          );
          
          // Use portal to render at document body level, but only if available
          if (ReactDOM && ReactDOM.createPortal && document && document.body) {
            try {
              return ReactDOM.createPortal(overlayContent, document.body);
            } catch (portalError) {
              console.error('Portal error:', portalError);
              // Fallback to inline rendering
              return overlayContent;
            }
          }
          // Fallback if portal not available
          return overlayContent;
          */
        } catch (error) {
          console.error("OverlayPortal error:", error);
          return null;
        }
      };

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Main App
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function App() {
        const {
          data,
          loading,
          error,
          lastUpdate,
          versionInfo,
          tickersWithoutScores,
          refetch,
        } = useTickerData();
        const { trades } = useTrades();
        const { sectors } = useSectors();
        const [filters, setFilters] = useState(() => {
          // Safety check: reset to defaults if localStorage was cleared
          return {
            search: "",
            tickerFilter: "", // Comma-separated ticker symbols for filtering specific tickers
            quadrants: [
              "HTF_BULL_LTF_PULLBACK",
              "HTF_BULL_LTF_BULL",
              "HTF_BEAR_LTF_BEAR",
              "HTF_BEAR_LTF_PULLBACK",
            ],
            minRank: 0,
            minRR: 0,
            maxCompletion: 1.01,
            group: "ALL",
            sector: null, // Filter by sector name
            td9Setup: null, // Filter by TD9 setup: "bullish", "bearish", or null for all
          };
        });
        const thesisAppliedRef = useRef(false);
        const [selectedTicker, setSelectedTicker] = useState(null);
        const [selectedTrail, setSelectedTrail] = useState(null);
        const [hoveredTicker, setHoveredTicker] = useState(null);
        const [journeyHoverPoint, setJourneyHoverPoint] = useState(null);
        const [journeySelectedPoint, setJourneySelectedPoint] = useState(null);
        // AI Assistant removed (unused)
        const [showWelcomeDashboard, setShowWelcomeDashboard] = useState(() => {
          // Check if user has seen dashboard welcome page before
          const hasSeenWelcome = localStorage.getItem(
            "timedTrading_welcomeSeen",
          );
          return !hasSeenWelcome;
        });

        const [showWelcomeTracker, setShowWelcomeTracker] = useState(false);
        const [missingIngest, setMissingIngest] = useState([]);
        const [missingIngestLoading, setMissingIngestLoading] = useState(false);
        const [missingIngestError, setMissingIngestError] = useState(null);
        const [missingIngestOpen, setMissingIngestOpen] = useState(false);
        const [ingestAudit, setIngestAudit] = useState(null);
        const [ingestAuditLoading, setIngestAuditLoading] = useState(false);
        const [ingestAuditError, setIngestAuditError] = useState(null);
        const [ingestAuditOpen, setIngestAuditOpen] = useState(false);

        const fetchMissingIngest = useCallback(async () => {
          try {
            setMissingIngestLoading(true);
            setMissingIngestError(null);
            const res = await fetch(`${API_BASE}/timed/ingest-status`, {
              cache: "no-store",
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ingest_status_failed");
            const missing = Array.isArray(json.missing) ? json.missing : [];
            setMissingIngest(missing);
          } catch (e) {
            setMissingIngest([]);
            setMissingIngestError(String(e.message || e));
          } finally {
            setMissingIngestLoading(false);
          }
        }, []);

        const fetchIngestAudit = useCallback(async () => {
          try {
            setIngestAuditLoading(true);
            setIngestAuditError(null);
            const until = Date.now();
            const since = until - 6 * 60 * 60 * 1000;
            const res = await fetch(
              `${API_BASE}/timed/ingest-audit?since=${since}&until=${until}&bucket=5`,
              { cache: "no-store" },
            );
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ingest_audit_failed");
            setIngestAudit(json);
          } catch (e) {
            setIngestAudit(null);
            setIngestAuditError(String(e.message || e));
          } finally {
            setIngestAuditLoading(false);
          }
        }, []);

        const ingestAuditSummary = useMemo(() => {
          const rows = Array.isArray(ingestAudit?.perTicker)
            ? ingestAudit.perTicker
            : [];
          if (rows.length === 0) return null;
          let expected = 0;
          let received = 0;
          rows.forEach((r) => {
            expected += Number(r.expectedBuckets || 0);
            received += Number(r.receiptBuckets || 0);
          });
          const coveragePct = expected > 0 ? (received / expected) * 100 : 0;
          const worst = [...rows]
            .sort(
              (a, b) =>
                Number(b.missingReceipts || 0) - Number(a.missingReceipts || 0),
            )
            .slice(0, 12);
          return { expected, received, coveragePct, worst };
        }, [ingestAudit]);

        // Fetch trail data when ticker is selected
        useEffect(() => {
          if (selectedTicker) {
            // Reset any journey highlight when switching tickers
            setJourneyHoverPoint(null);
            setJourneySelectedPoint(null);

            // ‚úÖ Immediately set to empty array to trigger selected-only view
            setSelectedTrail([]);

            const controller = new AbortController();
            // Trail payloads can be large; request a small window and allow a bit more time.
            const timeoutId = setTimeout(() => controller.abort(), 8000);

            const fetchSelectedTrail = async () => {
              const qs = new URLSearchParams();
              qs.set("ticker", String(selectedTicker || "").toUpperCase());
              // We only need recent history for Bubble Journey rendering
              qs.set("limit", "250");
              const url = `${API_BASE}/timed/trail?${qs.toString()}`;

              // A couple of light retries on 429/5xx to survive transient limits.
              for (let attempt = 0; attempt < 2; attempt++) {
                try {
                  const res = await fetch(url, {
                    signal: controller.signal,
                    cache: "no-store",
                  });

                  if (res.status === 429) {
                    // Respect Retry-After if present (seconds)
                    const retryAfterHeader = res.headers.get("Retry-After");
                    const retryAfterSec = retryAfterHeader
                      ? Math.min(60, Math.max(1, Number(retryAfterHeader)))
                      : 5;
                    await new Promise((r) =>
                      setTimeout(r, retryAfterSec * 1000),
                    );
                    continue;
                  }

                  if (!res.ok) {
                    // Retry once on 5xx; otherwise stop.
                    if (res.status >= 500 && attempt === 0) {
                      await new Promise((r) => setTimeout(r, 500));
                      continue;
                    }
                    setSelectedTrail([]);
                    return;
                  }

                  const data = await res.json();
                  if (data.ok && Array.isArray(data.trail)) {
                    const normalized = normalizeTrailPoints(data.trail);
                    const last20 =
                      normalized.length > 20
                        ? normalized.slice(-20)
                        : normalized;
                    // One-time sample log to confirm keys look right
                    if (!window._trailSampleLogged) {
                      window._trailSampleLogged = true;
                      console.log(`[TRAIL SAMPLE] ${selectedTicker}`, {
                        first: last20[0],
                        rawFirst: Array.isArray(data.trail)
                          ? data.trail[0]
                          : null,
                        rawKeys:
                          data.trail && data.trail[0]
                            ? Object.keys(data.trail[0])
                            : [],
                      });
                    }
                    setSelectedTrail(last20);
                    return;
                  }

                  setSelectedTrail([]);
                  return;
                } catch (err) {
                  if (err.name === "AbortError") return;
                  if (attempt === 0) {
                    await new Promise((r) => setTimeout(r, 300));
                    continue;
                  }
                  console.error("Failed to load trail:", err);
                  setSelectedTrail([]);
                  return;
                }
              }

              // If we exhausted retries, keep empty
              setSelectedTrail([]);
            };

            fetchSelectedTrail().finally(() => clearTimeout(timeoutId));
          } else {
            setSelectedTrail(null);
          }
        }, [selectedTicker]);

        // Debug: Log when selectedTicker changes
        React.useEffect(() => {
          console.log(`[SELECTED TICKER STATE] Changed to:`, selectedTicker, {
            isTruthy: !!selectedTicker,
            type: typeof selectedTicker,
            value: selectedTicker,
          });
        }, [selectedTicker]);

        // Safe setter for selectedTicker to prevent infinite loops
        const handleTickerSelect = useCallback((ticker) => {
          try {
            console.log(`[CLICK HANDLER] Setting selectedTicker to:`, ticker);
            setSelectedTicker(ticker);
            console.log(
              `[CLICK HANDLER] selectedTicker set, should trigger re-render`,
            );
          } catch (error) {
            console.error("Error setting selected ticker:", error);
          }
        }, []);

        const debouncedSearch = useDebounce(filters.search, 300);
        const effectiveFilters = { ...filters, search: debouncedSearch };

        const [timeTravelTickers, setTimeTravelTickers] = useState(null);

        const tickers = useMemo(() => {
          // If time travel is active, use time travel tickers, otherwise use filtered tickers
          if (timeTravelTickers !== null) {
            console.log('[TICKERS MEMO] Using timeTravelTickers:', timeTravelTickers.length);
            return timeTravelTickers;
          }
          
          const dataKeys = Object.keys(data || {});
          console.log('[TICKERS MEMO] Input data:', {
            inputDataKeys: dataKeys.length,
            firstKeys: dataKeys.slice(0, 5),
            dataType: typeof data,
            isObject: data && typeof data === 'object'
          });
          
          const filtered = applyFilters(data, effectiveFilters, trades);
          console.log('[TICKERS MEMO] Filtered tickers:', {
            inputDataKeys: dataKeys.length,
            filteredCount: filtered.length,
            effectiveFilters: effectiveFilters,
            tradesCount: (trades || []).length
          });
          return filtered;
        }, [data, effectiveFilters, trades, timeTravelTickers]);

        // Base filtered tickers for Time Travel slider controls.
        // IMPORTANT: Hooks must never be called conditionally inside JSX.
        const timeTravelBaseTickers = useMemo(() => {
          return applyFilters(data, effectiveFilters, trades);
        }, [data, effectiveFilters, trades]);

        // Compute dynamic ranks once for all tickers to ensure consistency
        // IMPORTANT: Use ALL tickers from data, not filtered tickers, for ranking
        const allTickersForRanking = useMemo(() => {
          if (!data || typeof data !== "object") return [];
          return Object.values(data).filter(
            (t) =>
              t &&
              typeof t === "object" &&
              t.ticker &&
              t.rank !== undefined &&
              t.rank !== null,
          );
        }, [data]);

        // Use dynamicScore from API (backend calculation) - no frontend calculation needed
        const allTickersWithRanks = useMemo(() => {
          const withRanks = allTickersForRanking.map((t) => ({
            ...t,
            dynamicRank: t.dynamicScore || computeDynamicRank(t), // Use API value, fallback to calculation if missing
          }));

          return withRanks;
        }, [allTickersForRanking]);

        // Stabilize Rank display using 15-minute buckets.
        // Goal: keep ranks consistent across 1m ingests, and only refresh every 15m.
        const RANK_BUCKET_MS = 15 * 60 * 1000;
        const rankAsOfMs = useMemo(() => {
          const baseMs =
            lastUpdate && typeof lastUpdate.getTime === "function"
              ? lastUpdate.getTime()
              : Date.now();
          return Math.floor(baseMs / RANK_BUCKET_MS) * RANK_BUCKET_MS;
        }, [lastUpdate]);

        const rankSnapshotRef = React.useRef({
          asOfMs: null,
          ranked: [],
          positions: {},
        });

        const { ranked: rankedTickers, positions: rankedTickerPositions } =
          useMemo(() => {
            const prev = rankSnapshotRef.current;
            if (
              prev &&
              prev.asOfMs === rankAsOfMs &&
              Array.isArray(prev.ranked) &&
              prev.ranked.length > 0
            ) {
              return { ranked: prev.ranked, positions: prev.positions || {} };
            }

            const ranked = getRankedTickers(allTickersWithRanks);
            const positions = {};
            ranked.forEach((t, idx) => {
              const sym = String(t.ticker || "")
                .trim()
                .toUpperCase();
              const pos = Number(t?.rank_position);
              const rankPos = Number.isFinite(pos) && pos > 0 ? pos : idx + 1;
              if (sym && positions[sym] == null) {
                positions[sym] = rankPos;
              }
            });

            rankSnapshotRef.current = { asOfMs: rankAsOfMs, ranked, positions };
            return { ranked, positions };
          }, [allTickersWithRanks, rankAsOfMs]);

        // Use dynamicScore from API (backend calculation) - no frontend calculation needed
        const tickersWithRanks = useMemo(() => {
          return tickers.map((t) => ({
            ...t,
            dynamicRank: t.dynamicScore || computeDynamicRank(t), // Use API value, fallback to calculation if missing
          }));
        }, [tickers]);

        const primeTickers = useMemo(
          () => tickersWithRanks.filter(isPrimeBubble),
          [tickersWithRanks],
        );

        const handleFilterChange = useCallback((newFilters) => {
          setFilters((prev) => {
            // Create a new object to ensure React detects the change
            const updated = { ...prev };
            // Apply new filters
            Object.keys(newFilters).forEach((key) => {
              if (newFilters[key] === undefined || newFilters[key] === null) {
                // Explicitly delete undefined/null values to clear filters
                delete updated[key];
              } else {
                updated[key] = newFilters[key];
              }
            });
            return updated;
          });
        }, []);

        const [showAdvancedFilters, setShowAdvancedFilters] = useState(() => {
          try {
            const v = localStorage.getItem("timedTrading_showAdvancedFilters");
            if (v === "1") return true;
            if (v === "0") return false;
          } catch {}
          return false; // default: simpler
        });
        const toggleAdvancedFilters = useCallback(() => {
          setShowAdvancedFilters((v) => {
            const next = !v;
            try {
              localStorage.setItem(
                "timedTrading_showAdvancedFilters",
                next ? "1" : "0",
              );
            } catch {}
            return next;
          });
        }, []);

        // Disable auto-apply thesis preset (user wants no default filters)
        useEffect(() => {
          // Clear the auto-thesis flag and disable auto-apply
          try {
            localStorage.setItem("timedTrading_thesisAuto", "0");
          } catch {
            // ignore
          }
          thesisAppliedRef.current = true; // Mark as applied so it never triggers
        }, []);

        const handleWelcomeDashboardClose = () => {
          setShowWelcomeDashboard(false);
          localStorage.setItem("timedTrading_welcomeSeen", "true");
        };

        const handleWelcomeTrackerClose = () => {
          setShowWelcomeTracker(false);
        };

        return (
          <>
            {/* Welcome Modals */}
            {showWelcomeDashboard && (
              <DashboardWelcomeModal onClose={handleWelcomeDashboardClose} />
            )}
            {showWelcomeTracker && (
              <TrackerWelcomeModal onClose={handleWelcomeTrackerClose} />
            )}

            <div className="min-h-screen p-0 pt-2">
              {/* Light page gutter: avoid edge bleed but keep width for Kanban lanes (14" MBP). */}
              <div className="mx-auto w-full px-2 sm:px-4 lg:px-5">
                {/* Header */}
                <header className="mb-4">
                  <div className="flex items-center justify-between gap-4 flex-wrap mb-2">
                    <h1 className="text-3xl font-bold">Timed Trading</h1>
                    <div className="flex items-center gap-2 flex-wrap">
                      <a
                        href="index-react.html"
                        className="px-3 py-2 rounded-lg bg-blue-500/20 border border-blue-500 text-sm text-blue-300 font-semibold hover:bg-blue-500/30 transition-colors"
                        title="Dashboard"
                      >
                        Dashboard
                      </a>
                      <a
                        href="simulation-dashboard.html"
                        className="px-3 py-2 rounded-lg bg-[#0f1630] border border-[#26325f] text-sm text-[#93a4d6] hover:text-white hover:bg-[#1a2550] transition-colors"
                        title="Trade Tracker"
                      >
                        Trade Tracker
                      </a>
                      <button
                        onClick={() => setShowWelcomeDashboard(true)}
                        className="px-3 py-2 rounded-lg bg-purple-500/15 border border-purple-500/50 text-sm text-purple-300 font-semibold hover:bg-purple-500/25 transition-colors"
                        title="Show Dashboard Guide (Trading Concepts)"
                      >
                        üìö Guide
                      </button>
                      <button
                        onClick={() => setShowWelcomeTracker(true)}
                        className="px-3 py-2 rounded-lg bg-blue-500/10 border border-blue-500/50 text-sm text-blue-300 font-semibold hover:bg-blue-500/20 transition-colors"
                        title="Show Trade Tracker Guide (Simulated Trades)"
                      >
                        üìä Tracker
                      </button>
                      <button
                        onClick={refetch}
                        className="px-3 py-2 bg-[#1a2550] border border-[#26325f] rounded-lg hover:bg-[#26325f] transition-colors text-sm"
                        title="Refresh data"
                      >
                        Refresh
                      </button>
                      {lastUpdate && (
                        <span className="text-sm text-[#93a4d6]">
                          Updated {lastUpdate.toLocaleTimeString()}
                        </span>
                      )}
                      {loading && <div className="loading-spinner"></div>}
                      {error && (
                        <div className="px-3 py-2 bg-red-500/20 border border-red-500 rounded-lg text-red-300 text-sm">
                          Error: {error}
                        </div>
                      )}
                    </div>
                  </div>

                  <div className="flex items-center justify-between gap-3 flex-wrap">
                    <div className="flex items-center gap-4 flex-wrap">
                      <div className="flex gap-3 text-sm items-center flex-wrap">
                        <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                          <span className="text-[#93a4d6]">Tickers: </span>
                          <span className="font-bold text-white">
                            {tickers.length}
                          </span>
                        </div>
                        <div className="px-3 py-1.5 rounded-lg bg-green-500/10 border border-green-500/30">
                          <span className="text-green-400">Prime: </span>
                          <span className="font-bold text-green-400">
                            {primeTickers.length}
                          </span>
                        </div>
                        {versionInfo && (
                          <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                            <span className="text-[#93a4d6]">Version: </span>
                            <span className="font-bold text-blue-400">
                              {versionInfo.currentDataVersion ||
                                versionInfo.storedVersion}
                            </span>
                            {versionInfo.versionFiltered > 0 && (
                              <span className="text-yellow-400 ml-2 text-xs">
                                ({versionInfo.versionFiltered} filtered)
                              </span>
                            )}
                          </div>
                        )}
                        {tickers.length > 0 && (
                          <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                            <span className="text-[#93a4d6]">
                              In Corridor:{" "}
                            </span>
                            <span className="font-bold text-white">
                              {
                                tickers.filter((t) => entryType(t).corridor)
                                  .length
                              }
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Global Search (applies to Action Center + Bubble Chart) */}
                  <div className="mt-3 mb-3">
                    <input
                      type="text"
                      placeholder="Search tickers, filters, or conditions... (e.g., 'AAPL, GOOGL, TSLA' or 'top 40' or 'rank over 75')"
                      value={filters.search}
                      onChange={(e) => {
                        const value = e.target.value;
                        handleFilterChange({ search: value });
                        // Also update tickerFilter if it looks like a simple ticker list (for Time Travel compatibility)
                        // Only if it's comma-separated and doesn't contain filter keywords
                        if (
                          value.includes(",") &&
                          !value.match(
                            /rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup|above|over|below|under/,
                          )
                        ) {
                          handleFilterChange({ tickerFilter: value });
                        } else if (!value.trim()) {
                          handleFilterChange({ tickerFilter: "" });
                        }
                      }}
                      className="w-full px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6]"
                    />
                    <div className="mt-1 text-xs text-[#6b7a9f]">
                      üí° Examples: "AAPL, GOOGL, TSLA" ‚Ä¢ "top 40" ‚Ä¢ "rank over
                      75" ‚Ä¢ "RR above 2"
                    </div>
                  </div>

                  {/* Filter Groups (under Search, above Action Center) */}
                  <div className="mt-1 mb-3 rounded-xl border border-[#26325f] bg-[#0f1630] p-2">
                    <div className="flex items-center justify-between gap-3 flex-wrap mb-1">
                      <div className="text-xs font-semibold text-[#93a4d6]">
                        Filter groups
                      </div>
                      <button
                        onClick={toggleAdvancedFilters}
                        className="px-3 py-1.5 rounded-lg border border-[#26325f] bg-[#121a33] text-xs font-semibold text-[#93a4d6] hover:text-white hover:bg-[#16224a]"
                        title="Show/hide advanced filter tags"
                      >
                        {showAdvancedFilters ? "Hide" : "Show"}
                      </button>
                    </div>
                    {showAdvancedFilters ? (
                      <ViewportFilterTags
                        filters={filters}
                        onChange={handleFilterChange}
                        sectors={sectors}
                        allData={data}
                        trades={trades}
                      />
                    ) : (
                      <div className="text-xs text-[#93a4d6] bg-[#121a33] border border-[#26325f] rounded-lg px-2 py-1">
                        <span className="font-semibold text-yellow-300">Tip:</span>{" "}
                        use these to narrow the universe before scanning the{" "}
                        <span className="text-white font-semibold">
                          Action Center
                        </span>
                        .
                      </div>
                    )}
                  </div>

                  {/* Action Center (below Search + Filter Groups) */}
                  <div className="mb-4">
                    <ActionCenterPanel
                      tickers={tickers}
                      allTickersWithRanks={allTickersWithRanks}
                      rankPositions={rankedTickerPositions}
                      onSelectTicker={handleTickerSelect}
                      allData={data}
                      defaultLimit={12}
                    />
                  </div>
                </header>

                {/* Error Display */}
                {error && (
                  <div className="mb-4 p-4 bg-red-500/20 border-2 border-red-500 rounded-xl">
                    <div className="flex items-center justify-between">
                      <div>
                        <h3 className="text-lg font-bold text-red-400 mb-2">
                          Error Loading Data
                        </h3>
                        <p className="text-red-300">{error}</p>
                      </div>
                      <button
                        onClick={refetch}
                        className="px-4 py-2 bg-red-500 hover:bg-red-600 rounded-lg text-white font-semibold"
                      >
                        Retry
                      </button>
                    </div>
                  </div>
                )}

                {/* Ingestion Status Panel (minimizable, always accessible) */}
                <IngestionStatusPanel
                  allData={data}
                  filteredTickers={applyFilters(data, effectiveFilters, trades)}
                  onRefresh={refetch}
                />

                {/* Main Content - Hero Layout: Activity Feed (left) | Bubble Chart (center) | Detail (right) */}
                {!error && (
                  <div className="space-y-4">
                    {/* Hero Section: Activity Feed | Bubble Chart | Detail View */}
                    <div className="flex flex-col lg:flex-row gap-4 items-stretch">
                      {/* Viewport - Left side */}
                      <div className="w-full lg:w-[440px] lg:flex-shrink-0 h-[600px] sm:h-[700px] md:h-[800px] lg:h-[900px]">
                        <OpportunitiesPanel
                          tickers={tickersWithRanks}
                          rankPositions={rankedTickerPositions}
                          onSelectTicker={handleTickerSelect}
                          title="üî≠ Viewport"
                          maxHeightClass="max-h-[900px]"
                          fillHeight={true}
                          showControls={false}
                          thesisMode={isThesisModeActive(filters)}
                        />
                      </div>

                      {/* Bubble Chart - Center Hero (flexible, takes remaining space) */}
                      <div
                        className={`w-full lg:flex-1 lg:min-w-0 transition-all ${
                          selectedTicker ? "lg:mr-[470px]" : ""
                        }`}
                      >
                        <TimeTravelSlider
                          tickers={timeTravelBaseTickers}
                          allTickers={data}
                          data={data}
                          onTimeChange={setTimeTravelTickers}
                          tickerFilter={filters.tickerFilter}
                          selectedTicker={selectedTicker}
                        />
                        <div className="h-[600px] sm:h-[700px] md:h-[800px] lg:h-[900px]">
                          {loading && tickers.length === 0 ? (
                            <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] flex items-center justify-center">
                              <div className="text-center">
                                <div className="loading-spinner mx-auto mb-4"></div>
                                <div className="text-[#93a4d6]">
                                  Loading tickers...
                                </div>
                              </div>
                            </div>
                          ) : (
                            <BubbleChart
                              tickers={tickers}
                              onBubbleClick={handleTickerSelect}
                              hoveredTicker={hoveredTicker}
                              onHover={setHoveredTicker}
                              selectedTicker={selectedTicker}
                              selectedTrail={selectedTrail}
                              isTimeTravelActive={timeTravelTickers !== null}
                              highlightTrailPoint={
                                journeyHoverPoint || journeySelectedPoint
                              }
                              allData={data}
                              rankedTickers={rankedTickers}
                              rankedTickerPositions={rankedTickerPositions}
                              thesisMode={isThesisModeActive(filters)}
                            />
                          )}
                        </div>
                      </div>
                    </div>

                    {/* Right Rail - Detail View (slides in from right, fixed to viewport) */}
                    {selectedTicker && (
                      <>
                        {/* Backdrop: click outside closes Right Rail */}
                        <div
                          className="fixed inset-0 z-30"
                          onMouseDown={() => handleTickerSelect(null)}
                        />
                        <div
                          className="fixed right-0 top-0 w-full sm:w-[450px] h-screen bg-[#0f1630] border-l border-[#26325f] z-40 slide-in-right shadow-2xl overflow-y-auto"
                          onMouseDown={(e) => e.stopPropagation()}
                        >
                          <OverlayPortal
                            selectedTicker={selectedTicker}
                            tickers={tickers}
                            data={data}
                            onClose={() => handleTickerSelect(null)}
                            rankedTickers={rankedTickers}
                            rankedTickerPositions={rankedTickerPositions}
                            rankAsOfMs={rankAsOfMs}
                            sectors={sectors}
                            onJourneyHover={setJourneyHoverPoint}
                            onJourneySelect={(p) => {
                              setJourneySelectedPoint(p);
                            }}
                            selectedJourneyTs={journeySelectedPoint?.ts ?? null}
                          />
                        </div>
                      </>
                    )}
                  </div>
                )}
              </div>
            </div>
          </>
        );
      }

      // Make App accessible from outside the Babel script
      window.App = App;
    </script>

    <!-- Initialize app - separate script to avoid Babel parsing issues -->
    <script>
      // Render with error handling
      // Wait for all scripts to load before rendering
      function initializeApp() {
        try {
          // Check if React and ReactDOM are loaded
          if (typeof React === "undefined") {
            throw new Error("React not loaded. Check CDN connection.");
          }
          if (typeof ReactDOM === "undefined") {
            throw new Error("ReactDOM not loaded. Check CDN connection.");
          }

          const rootElement = document.getElementById("root");
          if (!rootElement) {
            throw new Error("Root element not found");
          }

          // Check if App component is available (from Babel script)
          if (typeof window.App === "undefined") {
            throw new Error(
              "App component not loaded. Babel may not have finished processing.",
            );
          }

          // Check if React 18 createRoot is available
          if (ReactDOM.createRoot) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(React.createElement(window.App));
          } else {
            // Fallback for React 17
            ReactDOM.render(React.createElement(window.App), rootElement);
          }

          console.log("[App] Dashboard initialized successfully");
        } catch (error) {
          console.error("Error rendering app:", error);
          const rootElement = document.getElementById("root");
          if (rootElement) {
            rootElement.innerHTML = `
              <div style="padding: 40px; text-align: center; color: #e7ecff; max-width: 800px; margin: 0 auto;">
                <h2 style="color: #e74c3c; margin-bottom: 20px;">Error Loading Dashboard</h2>
                <p style="margin-bottom: 20px; color: #ff6b6b;">${error.message}</p>
                <div style="background: #1a2440; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left; color: #93a4d6;">
                  <h3 style="color: #e7ecff; margin-bottom: 10px;">Troubleshooting:</h3>
                  <ul style="list-style: disc; padding-left: 20px; line-height: 1.8;">
                    <li>Open browser console (F12 or Cmd+Option+I) to see detailed errors</li>
                    <li>Check your internet connection - CDN resources need to load</li>
                    <li>Try refreshing the page (Cmd+R or Ctrl+R)</li>
                    <li>Check if React is loaded: <code style="background: #26325f; padding: 2px 6px; border-radius: 4px;">typeof React !== 'undefined'</code></li>
                    <li>Check if API is reachable: <a href="https://timed-trading-ingest.shashant.workers.dev/timed/health" target="_blank" style="color: #4a9eff;">API Health Check</a></li>
                  </ul>
                </div>
                <button 
                  onclick="window.location.reload()" 
                  style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;"
                >
                  Reload Page
                </button>
              </div>
            `;
          }
        }
      }

      // Wait for DOM and scripts to be ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
          // Wait a bit for Babel to process
          setTimeout(initializeApp, 100);
        });
      } else {
        // DOM already loaded
        setTimeout(initializeApp, 100);
      }

      // Fallback: If React still isn't loaded after 5 seconds, show error
      setTimeout(function () {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          const rootElement = document.getElementById("root");
          if (
            rootElement &&
            rootElement.innerHTML.includes("Loading dashboard")
          ) {
            rootElement.innerHTML = `
          <div style="padding: 40px; text-align: center; color: #e7ecff;">
                <h2 style="color: #e74c3c;">CDN Resources Not Loading</h2>
                <p style="margin: 20px 0; color: #93a4d6;">
                  React or other CDN resources failed to load. This may be due to:
                </p>
                <ul style="text-align: left; display: inline-block; color: #93a4d6; margin: 20px 0;">
                  <li>Network connectivity issues</li>
                  <li>Ad blockers blocking CDN scripts</li>
                  <li>Corporate firewall blocking unpkg.com</li>
                </ul>
                <p style="margin-top: 20px;">
                  <button onclick="window.location.reload()" style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Retry
                  </button>
            </p>
          </div>
        `;
          }
        }
      }, 5000);
    </script>
  </body>
</html>
