<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ticker Management — Timed Trading</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="auth-gate.js?v=20260219a"></script>
    <style>
      body { margin: 0; background: #0a0a0f; color: #e5e7eb; font-family: 'Inter', sans-serif; }
      @keyframes spin { to { transform: rotate(360deg); } }
      @keyframes pulse-badge {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.15); }
      }
      ::-webkit-scrollbar { width: 6px; height: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
      ::-webkit-scrollbar-thumb:hover { background: #4b5563; }
      /* Admin-only nav links: hidden for non-admin users */
      body:not([data-user-role="admin"]) a[data-admin-only] {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef } = React;

      const API_BASE = "";  // same-origin — proxied by Pages Function
      // Auth via CF Access JWT cookie (sent automatically with credentials: "include")
      const TFS = ["M", "W", "D", "240", "60", "30", "10", "5"];
      const TF_LABELS = { M: "M", W: "W", D: "D", "240": "4H", "60": "1H", "30": "30m", "10": "10m", "5": "5m" };
      const TV_TICKERS = new Set(["ES1!", "NQ1!", "GOLD", "SILVER", "US500", "VX1!", "GC1!", "SI1!"]);

      // ── Company Names ──
      const COMPANY_NAMES = {
        AAPL:"Apple",AAPU:"Apple 2x ETF",ADBE:"Adobe",AEE:"Ameren",AEP:"American Electric",AEHR:"Aehr Test",AGQ:"Silver 2x ETF",
        ALLY:"Ally Financial",ALB:"Albemarle",AMD:"AMD",AMGN:"Amgen",AMZN:"Amazon",ANET:"Arista Networks",APD:"Air Products",
        APLD:"Applied Digital",APP:"AppLovin",ASTS:"AST SpaceMobile",AVAV:"AeroVironment",AVGO:"Broadcom",AWI:"Armstrong World",
        AXP:"American Express",AXON:"Axon Enterprise",AYI:"Acuity Brands",B:"Barnes Group",BA:"Boeing",BABA:"Alibaba",
        BE:"Bloom Energy",BK:"BNY Mellon",BMNR:"Bitmine Immersion",BTCUSD:"Bitcoin",BWXT:"BWX Technologies",
        CAT:"Caterpillar",CCJ:"Cameco",CDNS:"Cadence Design",CLS:"Celestica",CMCSA:"Comcast",COIN:"Coinbase",COST:"Costco",
        CRM:"Salesforce",CRS:"Carpenter Tech",CRCL:"Circle",CRWV:"CrowdWave",CRVS:"Corvus Pharma",CRWD:"CrowdStrike",
        CSCO:"Cisco",CSX:"CSX Corp",D:"Dominion Energy",DCI:"Donaldson",DE:"Deere & Co",DUK:"Duke Energy",DY:"Dycom",
        ECL:"Ecolab",EME:"EMCOR",EMR:"Emerson Electric",ENS:"EnerSys",ES:"Eversource",ETHA:"iShares Ethereum",
        ETHT:"ProShares Ether",ETHUSD:"Ethereum",ETN:"Eaton Corp",ETR:"Entergy",EXC:"Exceleron",EXPE:"Expedia",
        EWBC:"East West Bancorp",FDX:"FedEx",FE:"FirstEnergy",FIG:"Simplify MBS",FIX:"Comfort Systems",GDX:"Gold Miners ETF",
        GDXJ:"Jr Gold Miners ETF",GE:"GE Aerospace",GEV:"GE Vernova",GILD:"Gilead",GLD:"Gold ETF",GLXY:"Galaxy Digital",
        GOOGL:"Alphabet",GRNY:"Greenery",GS:"Goldman Sachs",HD:"Home Depot",HIMS:"Hims & Hers",HII:"HII Inc",
        HL:"Hecla Mining",HOOD:"Robinhood",IAU:"iShares Gold",IBP:"Installed Building",IBRX:"ImmunityBio",
        IESC:"IES Holdings",INTC:"Intel",INTU:"Intuit",IONQ:"IonQ",IOT:"Samsara",IREN:"IREN",ITT:"ITT Inc",
        IWM:"Russell 2000 ETF",JCI:"Johnson Controls",JOBY:"Joby Aviation",JPM:"JPMorgan",KLAC:"KLA Corp",
        KO:"Coca-Cola",KTOS:"Kratos Defense",LIN:"Linde",LITE:"Lumentum",LRCX:"Lam Research",LOW:"Lowe's",
        MA:"Mastercard",MCD:"McDonald's",MDB:"MongoDB",META:"Meta",MLI:"Mueller Industries",MNST:"Monster Beverage",
        MP:"MP Materials",MSFT:"Microsoft",MSTR:"MicroStrategy",MTB:"M&T Bank",MTZ:"MasTec",MU:"Micron",
        NBIS:"Nebius Group",NEE:"NextEra Energy",NEU:"NewMarket",NFLX:"Netflix",NKE:"Nike",NXT:"Nextracker",
        NVDA:"Nvidia",ON:"ON Semi",ONDS:"Ondas Holdings",PANW:"Palo Alto Networks",PATH:"UiPath",PEG:"PSEG",
        PEGA:"Pegasystems",PH:"Parker-Hannifin",PI:"Impinj",PLTR:"Palantir",PNC:"PNC Financial",
        PSTG:"Pure Storage",PWR:"Quanta Services",QLYS:"Qualys",QQQ:"Nasdaq 100 ETF",RBLX:"Roblox",
        RDDT:"Reddit",RGLD:"Royal Gold",RIOT:"Riot Platforms",RKLB:"Rocket Lab",SANM:"Sanmina",
        SBET:"SharpLink Gaming",SBUX:"Starbucks",SCHW:"Charles Schwab",SGI:"Surgalign",SHOP:"Shopify",
        SHW:"Sherwin-Williams",SLB:"SLB",SLV:"Silver ETF",SN:"SharkNinja",SO:"Southern Company",
        SOFI:"SoFi",SOXL:"Semis 3x ETF",SPGI:"S&P Global",SPG:"Simon Property",SPY:"S&P 500 ETF",
        SRE:"Sempra",STRL:"Sterling Infra",STX:"Seagate",STZ:"Constellation Brands",SWK:"Stanley Black&Decker",
        T:"AT&T",TFC:"Truist Financial",TGT:"Target",TJX:"TJX Companies",TLN:"Talen Energy",TMO:"Thermo Fisher",
        TNA:"Small Cap 3x ETF",TSLA:"Tesla",TSM:"TSMC",TT:"Trane Technologies",TWLO:"Twilio",TXN:"Texas Instruments",
        ULTA:"Ulta Beauty",UNH:"UnitedHealth",UNP:"Union Pacific",UPS:"UPS",USB:"U.S. Bancorp",UTHR:"United Therapeutics",
        UUUU:"Energy Fuels",VICI:"VICI Properties",        VRTX:"Vertex Pharma",VST:"Vistra Energy",VZ:"Verizon",
        W:"Wayfair",WAL:"Western Alliance",WEC:"WEC Energy",WELL:"Welltower",WFC:"Wells Fargo",WMT:"Walmart",WTS:"Watts Water",
        XEL:"Xcel Energy",XLB:"Materials ETF",XLC:"Comms ETF",XLE:"Energy ETF",XLF:"Financials ETF",
        XLI:"Industrials ETF",XLK:"Tech ETF",XLP:"Staples ETF",XLRE:"Real Estate ETF",XLU:"Utilities ETF",
        XLV:"Healthcare ETF",XLY:"Disc ETF",XOM:"Exxon Mobil",XYZ:"Block Inc",
        "ES1!":"E-mini S&P","NQ1!":"E-mini Nasdaq","GC1!":"Gold Futures","SI1!":"Silver Futures",GOLD:"Gold Futures",SILVER:"Silver Futures",
        VIX:"VIX Index","US500":"US 500",GLD:"Gold ETF",
        ADBE:"Adobe",LIN:"Linde",APD:"Air Products",FDX:"FedEx",CMCSA:"Comcast",
        CRM:"Salesforce",ECL:"Ecolab",SHW:"Sherwin-Williams",
      };

      // ── Groups (GRNY/GRNI/GRNJ loaded dynamically from ETF sync) ──
      const GROUPS = {
        UPTICKS: new Set([
          "RDDT","AMZN","BABA","TSLA","KO","WMT","ETHA","BRK-B","GLXY","MTB",
          "SPGI","AMGN","GILD","CSX","GEV","HII","JCI","PH","PWR","TT",
          "APP","CLS","FSLR","PANW","CRS","VST",
        ]),
        GRNI: new Set(),
        GRNJ: new Set(),
        GRNY: new Set(),
        SP_Sectors: new Set([
          "XLK","XLF","XLY","XLP","XLC","XLI","XLB","XLE","XLRE","XLU","XLV",
        ]),
        Futures: new Set(["ES1!","NQ1!","RTY1!","YM1!","GC1!","SI1!","CL1!","BTCUSD","ETHUSD","VX1!"]),
      };
      // ETF weight map: { "AAPL": { GRNY: 2.50, GRNI: 2.55 }, ... }
      let _etfWeightMap = {};
      const GROUP_ORDER = ["SP_Sectors","Futures","UPTICKS","GRNI","GRNJ","GRNY"];

      // Load ETF groups dynamically from backend
      async function loadETFGroups() {
        try {
          const resp = await fetch("/timed/etf/groups");
          const data = await resp.json();
          if (data.ok && data.groups) {
            for (const [etf, tickers] of Object.entries(data.groups)) {
              if (GROUPS[etf]) {
                GROUPS[etf] = new Set(tickers.map(t => String(t).toUpperCase()));
              }
            }
          }
          // Also load weight map for badges
          const wResp = await fetch("/timed/etf/holdings/GRNY");
          const wData = await wResp.json();
          // Build weight map from all ETF holdings
          for (const etf of ["GRNY","GRNJ","GRNI"]) {
            try {
              const r = await fetch(`/timed/etf/holdings/${etf}`);
              const d = await r.json();
              if (d.ok && d.holdings) {
                for (const h of d.holdings) {
                  if (!_etfWeightMap[h.ticker]) _etfWeightMap[h.ticker] = {};
                  _etfWeightMap[h.ticker][etf] = h.weight;
                }
              }
            } catch {}
          }
        } catch (e) {
          console.warn("[ETF GROUPS] Failed to load dynamic groups:", e);
        }
      }

      function groupsForTicker(t) {
        const T = String(t || "").toUpperCase();
        const out = [];
        for (const [g, set] of Object.entries(GROUPS)) {
          if (set.has(T)) out.push(g);
        }
        return out;
      }

      // Get ETF weight badge text for a ticker (e.g. "2.5%")
      function etfWeightBadge(ticker, group) {
        const w = _etfWeightMap[String(ticker).toUpperCase()]?.[group];
        return w ? `${w.toFixed(1)}%` : "";
      }

      // ── Helpers ──
      function pctColor(pct) {
        if (pct >= 80) return "#22c55e";
        if (pct >= 40) return "#f59e0b";
        return "#ef4444";
      }

      function pctBg(pct) {
        if (pct >= 80) return "rgba(34,197,94,0.12)";
        if (pct >= 40) return "rgba(245,158,11,0.12)";
        return "rgba(239,68,68,0.12)";
      }

      function formatAge(ts) {
        if (!ts) return "—";
        const now = Date.now();
        const ageMs = now - ts;
        if (ageMs < 0) return "now";
        const mins = Math.floor(ageMs / 60000);
        if (mins < 60) return `${mins}m ago`;
        const hrs = Math.floor(mins / 60);
        if (hrs < 24) return `${hrs}h ago`;
        const days = Math.floor(hrs / 24);
        if (days < 7) return `${days}d ago`;
        return new Date(ts).toLocaleDateString("en-US", { month: "short", day: "numeric" });
      }

      function formatDate(ts) {
        if (!ts) return "—";
        return new Date(ts).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "2-digit" });
      }

      // ── UPTICKS Manager ──
      function UptickManager() {
        const [tickers, setTickers] = useState([...GROUPS.UPTICKS]);
        const [input, setInput] = useState("");
        const [saving, setSaving] = useState(false);
        const [msg, setMsg] = useState(null);
        const [open, setOpen] = useState(false);

        useEffect(() => {
          fetch(`${API_BASE}/timed/admin/upticks`, { credentials: "include" })
            .then(r => r.json())
            .then(d => { if (d.ok && d.tickers?.length) setTickers(d.tickers); })
            .catch(() => {});
        }, []);

        const addTickers = () => {
          const raw = input.toUpperCase().split(/[,\s]+/).filter(Boolean);
          if (!raw.length) return;
          setTickers(prev => [...new Set([...prev, ...raw])]);
          setInput("");
        };
        const removeTicker = (t) => setTickers(prev => prev.filter(x => x !== t));
        const save = async () => {
          setSaving(true);
          setMsg(null);
          try {
            const r = await fetch(`${API_BASE}/timed/admin/upticks`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              credentials: "include",
              body: JSON.stringify({ tickers }),
            });
            const d = await r.json();
            if (d.ok) {
              setMsg({ type: "success", text: `Saved ${d.count} tickers` });
              GROUPS.UPTICKS = new Set(tickers);
            } else {
              setMsg({ type: "error", text: d.error || "Save failed" });
            }
          } catch (e) {
            setMsg({ type: "error", text: e.message });
          } finally { setSaving(false); }
        };

        return (
          <div className="mt-6 pt-4 border-t border-white/[0.06]">
            <button onClick={() => setOpen(v => !v)} className="flex items-center gap-2 text-left w-full group">
              <span className="text-[11px] text-emerald-400 uppercase tracking-wide font-semibold">✦ TT Selected — UPTICKS</span>
              <span className="text-[10px] text-gray-500 bg-white/[0.04] px-1.5 py-0.5 rounded">{tickers.length}</span>
              <span className="text-gray-600 text-xs group-hover:text-white ml-auto">{open ? "▲" : "▼"}</span>
            </button>
            {open && (
              <div className="mt-3 space-y-3">
                <div className="flex flex-wrap gap-1.5">
                  {tickers.sort().map(t => (
                    <span key={t} className="inline-flex items-center gap-1 px-2 py-1 rounded-md bg-emerald-500/10 border border-emerald-500/20 text-[11px] text-emerald-300 font-medium">
                      {t}
                      <button onClick={() => removeTicker(t)} className="text-emerald-500/60 hover:text-red-400 ml-0.5 text-[10px]">✕</button>
                    </span>
                  ))}
                </div>
                <div className="flex items-center gap-2">
                  <input
                    value={input}
                    onChange={e => setInput(e.target.value)}
                    onKeyDown={e => e.key === "Enter" && addTickers()}
                    placeholder="Add tickers: AAPL, MSFT..."
                    className="bg-white/5 border border-white/10 rounded px-3 py-1.5 text-sm text-white placeholder-gray-600 w-64 focus:outline-none focus:border-emerald-500/50"
                  />
                  <button onClick={addTickers} disabled={!input.trim()} className="px-3 py-1.5 bg-emerald-600/60 hover:bg-emerald-600 rounded text-xs font-medium text-white disabled:opacity-40">Add</button>
                  <button onClick={save} disabled={saving} className="px-3 py-1.5 bg-blue-600/60 hover:bg-blue-600 rounded text-xs font-medium text-white disabled:opacity-40 ml-auto">
                    {saving ? "Saving..." : "Save Changes"}
                  </button>
                </div>
                {msg && (
                  <div className={`text-xs px-2 py-1 rounded ${msg.type === "success" ? "text-green-400 bg-green-900/20" : "text-red-400 bg-red-900/20"}`}>
                    {msg.text}
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }

      // ── Sector Ratings Manager ──
      const RATING_OPTIONS = ["overweight", "neutral", "underweight"];
      const RATING_COLORS = { overweight: "text-green-400", neutral: "text-gray-400", underweight: "text-red-400" };
      const RATING_BG = { overweight: "bg-green-900/20 border-green-800/30", neutral: "bg-white/[0.03] border-white/[0.06]", underweight: "bg-red-900/20 border-red-800/30" };

      function SectorRatingsManager() {
        const [ratings, setRatings] = useState({});
        const [saving, setSaving] = useState(false);
        const [msg, setMsg] = useState(null);
        const [open, setOpen] = useState(false);

        useEffect(() => {
          fetch(`${API_BASE}/timed/admin/sector-ratings`, { credentials: "include" })
            .then(r => r.json())
            .then(d => { if (d.ok && d.ratings) setRatings(d.ratings); })
            .catch(() => {});
        }, []);

        const updateField = (sector, field, value) => {
          setRatings(prev => ({
            ...prev,
            [sector]: { ...prev[sector], [field]: field === "rating" ? value : Number(value) || 0 },
          }));
        };

        const save = async () => {
          setSaving(true);
          setMsg(null);
          try {
            const r = await fetch(`${API_BASE}/timed/admin/sector-ratings`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              credentials: "include",
              body: JSON.stringify({ ratings }),
            });
            const d = await r.json();
            if (d.ok) setMsg({ type: "success", text: `Updated ${d.updated} sectors` });
            else setMsg({ type: "error", text: d.error || "Save failed" });
          } catch (e) {
            setMsg({ type: "error", text: e.message });
          } finally { setSaving(false); }
        };

        const sectors = Object.keys(ratings).filter(s => !["ETF", "Crypto", "Precious Metals"].includes(s));

        return (
          <div className="mt-6 pt-4 border-t border-white/[0.06]">
            <button onClick={() => setOpen(v => !v)} className="flex items-center gap-2 text-left w-full group">
              <span className="text-[11px] text-blue-400 uppercase tracking-wide font-semibold">S&P Sector Ratings</span>
              <span className="text-[10px] text-gray-500 bg-white/[0.04] px-1.5 py-0.5 rounded">{sectors.length} sectors</span>
              <span className="text-gray-600 text-xs group-hover:text-white ml-auto">{open ? "▲" : "▼"}</span>
            </button>
            {open && (
              <div className="mt-3 space-y-2">
                <div className="overflow-x-auto">
                  <table className="text-sm w-full" style={{ maxWidth: 900 }}>
                    <thead>
                      <tr className="text-[10px] text-gray-500 uppercase border-b border-white/[0.06]">
                        <th className="text-left py-1.5 px-2 w-[180px]">Sector</th>
                        <th className="text-center py-1.5 px-2 w-[130px]">Rating</th>
                        <th className="text-center py-1.5 px-2 w-[80px]">Boost</th>
                        <th className="text-center py-1.5 px-2 w-[90px]">S&P Wt%</th>
                        <th className="text-center py-1.5 px-2 w-[90px]">FSI Wt%</th>
                        <th className="text-center py-1.5 px-2 w-[80px]">Delta</th>
                      </tr>
                    </thead>
                    <tbody>
                      {sectors.sort((a, b) => (ratings[b]?.delta || 0) - (ratings[a]?.delta || 0)).map(sector => {
                        const r = ratings[sector] || {};
                        const ratingCls = RATING_BG[r.rating] || RATING_BG.neutral;
                        return (
                          <tr key={sector} className={`border-b border-white/[0.03] ${ratingCls}`}>
                            <td className="py-1.5 px-2 text-[12px] text-white font-medium">{sector}</td>
                            <td className="py-1 px-2 text-center">
                              <select
                                value={r.rating || "neutral"}
                                onChange={e => updateField(sector, "rating", e.target.value)}
                                className={`bg-transparent border border-white/10 rounded px-2 py-0.5 text-[11px] font-semibold focus:outline-none ${RATING_COLORS[r.rating] || "text-gray-400"}`}
                                style={{ background: "rgba(10,10,15,0.8)" }}
                              >
                                {RATING_OPTIONS.map(o => <option key={o} value={o} style={{ background: "#1a1a24" }}>{o.charAt(0).toUpperCase() + o.slice(1)}</option>)}
                              </select>
                            </td>
                            <td className="py-1 px-2 text-center">
                              <input
                                type="number"
                                value={r.boost ?? 0}
                                onChange={e => updateField(sector, "boost", e.target.value)}
                                className="bg-white/5 border border-white/10 rounded px-2 py-0.5 text-[11px] text-white w-16 text-center focus:outline-none focus:border-blue-500/50"
                                step={1}
                              />
                            </td>
                            <td className="py-1 px-2 text-center">
                              <input
                                type="number"
                                value={r.spWeight ?? 0}
                                onChange={e => updateField(sector, "spWeight", e.target.value)}
                                className="bg-white/5 border border-white/10 rounded px-2 py-0.5 text-[11px] text-white w-16 text-center focus:outline-none"
                                step={0.1}
                              />
                            </td>
                            <td className="py-1 px-2 text-center">
                              <input
                                type="number"
                                value={r.fsiWeight ?? 0}
                                onChange={e => updateField(sector, "fsiWeight", e.target.value)}
                                className="bg-white/5 border border-white/10 rounded px-2 py-0.5 text-[11px] text-white w-16 text-center focus:outline-none"
                                step={0.1}
                              />
                            </td>
                            <td className="py-1 px-2 text-center">
                              <span className={`text-[11px] font-semibold tabular-nums ${(r.delta || 0) > 0 ? "text-green-400" : (r.delta || 0) < 0 ? "text-red-400" : "text-gray-500"}`}>
                                {Number.isFinite(r.delta) ? (r.delta > 0 ? "+" : "") + r.delta.toFixed(1) + "%" : "—"}
                              </span>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
                <div className="flex items-center gap-2">
                  <button onClick={save} disabled={saving} className="px-3 py-1.5 bg-blue-600/60 hover:bg-blue-600 rounded text-xs font-medium text-white disabled:opacity-40">
                    {saving ? "Saving..." : "Save Ratings"}
                  </button>
                  {msg && (
                    <span className={`text-xs ${msg.type === "success" ? "text-green-400" : "text-red-400"}`}>
                      {msg.text}
                    </span>
                  )}
                </div>
              </div>
            )}
          </div>
        );
      }

      // ── Main App ──
      function App() {
        const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [search, setSearch] = useState("");
        const [sectorFilter, setSectorFilter] = useState("all");
        const [sortCol, setSortCol] = useState("ticker");
        const [sortDir, setSortDir] = useState("asc");
        const [selected, setSelected] = useState(new Set());
        const [addInput, setAddInput] = useState("");
        const [actionStatus, setActionStatus] = useState(null);
        const [backfillStatus, setBackfillStatus] = useState({});
        const [priceData, setPriceData] = useState({});
        const [contextData, setContextData] = useState({}); // ticker -> {name, sector, industry, market_cap}
        const [pendingTickers, setPendingTickers] = useState(new Set()); // Optimistic: tickers just added, show until they appear from API
        const pollUntilRef = useRef(null); // When to stop polling after add
        const addRef = useRef(null);

        // Watchlist ticker list (GET /timed/tickers) — merged with ingestion-status so tickers
        // that are in the watchlist but missing from ingestion-status (e.g. eventual consistency)
        // still show until the next refresh.
        const [watchlistTickers, setWatchlistTickers] = useState([]);

        // Helper: get ticker context from enrichment data, fallback to hardcoded
        const getTickerName = useCallback((ticker) => {
          const ctx = contextData[ticker];
          if (ctx?.name) return ctx.name;
          return COMPANY_NAMES[ticker] || "—";
        }, [contextData]);
        const getTickerIndustry = useCallback((ticker) => {
          const ctx = contextData[ticker];
          return ctx?.industry || "";
        }, [contextData]);
        const getTickerMCap = useCallback((ticker) => {
          const ctx = contextData[ticker];
          const v = ctx?.market_cap ? Number(ctx.market_cap) : null;
          if (!v || !Number.isFinite(v) || v <= 0) return null;
          return v;
        }, [contextData]);
        const fmtMCap = (v) => {
          if (!v) return "—";
          if (v >= 1e12) return `$${(v / 1e12).toFixed(1)}T`;
          if (v >= 1e9) return `$${(v / 1e9).toFixed(1)}B`;
          if (v >= 1e6) return `$${(v / 1e6).toFixed(0)}M`;
          return `$${v.toLocaleString()}`;
        };

        // ── Fetch data ──
        const fetchData = useCallback(async (clearPendingFromResponse = true, skipLoading = false) => {
          if (!skipLoading) setLoading(true);
          setError(null);
          try {
            const [statusRes, priceRes, tickersRes, allRes] = await Promise.all([
              fetch(`${API_BASE}/timed/admin/ingestion-status?_t=${Date.now()}`, { credentials: "include" }),
              fetch(`${API_BASE}/timed/prices?_t=${Date.now()}`),
              fetch(`${API_BASE}/timed/tickers?_t=${Date.now()}`),
              fetch(`${API_BASE}/timed/all?_t=${Date.now()}`),
            ]);
            const json = await statusRes.json();
            if (!json.ok) throw new Error(json.error || "Failed to fetch");
            setData(json);
            if (clearPendingFromResponse && json.tickers && json.tickers.length) {
              setPendingTickers(prev => {
                const next = new Set(prev);
                json.tickers.forEach(t => next.delete(t.ticker));
                return next;
              });
            }
            try {
              const tJson = await tickersRes.json();
              if (tJson.ok && Array.isArray(tJson.tickers)) setWatchlistTickers(tJson.tickers);
            } catch (_) {}
            try {
              const pJson = await priceRes.json();
              if (pJson.ok && pJson.prices) {
                setPriceData({ prices: pJson.prices, updated_at: pJson.updated_at });
              }
            } catch (_) {}
            // Extract context (name, sector, industry, market_cap) from /timed/all
            try {
              const allJson = await allRes.json();
              if (allJson.ok && allJson.data) {
                const ctx = {};
                for (const [sym, obj] of Object.entries(allJson.data)) {
                  if (obj?.context && typeof obj.context === "object") {
                    ctx[sym] = obj.context;
                  }
                }
                setContextData(ctx);
              }
            } catch (_) {}
          } catch (e) {
            setError(e.message);
          } finally {
            if (!skipLoading) setLoading(false);
          }
        }, []);

        useEffect(() => { loadETFGroups().then(() => fetchData()); }, [fetchData]);

        // After adding tickers: poll ingestion-status every 4s for ~2 min so coverage updates in real time
        useEffect(() => {
          if (pendingTickers.size === 0 || !pollUntilRef.current) return;
          const interval = setInterval(() => {
            if (Date.now() > pollUntilRef.current) {
              pollUntilRef.current = null;
              return;
            }
            fetchData(true, true);
          }, 4000);
          return () => clearInterval(interval);
        }, [pendingTickers.size, fetchData]);

        // ── Derived data: merge ingestion-status with watchlist + optimistic placeholders ──
        // So tickers in GET /timed/tickers but missing from ingestion-status (e.g. W, eventual consistency)
        // still show and persist when navigating away and back.
        const tickers = useMemo(() => {
          const fromApi = data?.tickers || [];
          const fromApiSet = new Set(fromApi.map(t => t.ticker));
          const missingFromApi = new Set([
            ...pendingTickers,
            ...(watchlistTickers || []).filter(t => !fromApiSet.has(t)),
          ]);
          const placeholders = [...missingFromApi]
            .filter(t => t && !fromApiSet.has(t))
            .map(t => ({
              ticker: String(t).toUpperCase(),
              sector: "Unknown",
              pct: 0,
              quality: 0,
              missing: [...TFS],
              tfs: {},
              backfilling: true,
            }));
          const combined = [...fromApi, ...placeholders];
          const seen = new Set();
          const deduped = combined.filter(r => {
            const k = (r.ticker || "").toUpperCase();
            if (seen.has(k)) return false;
            seen.add(k);
            return true;
          });
          return deduped.sort((a, b) => (a.ticker || "").localeCompare(b.ticker || ""));
        }, [data, pendingTickers, watchlistTickers]);

        const sectors = useMemo(() => {
          const s = new Set(tickers.map(t => t.sector).filter(Boolean));
          return ["all", ...Array.from(s).sort()];
        }, [tickers]);

        const filtered = useMemo(() => {
          let items = tickers;
          if (search) {
            const q = search.toUpperCase();
            items = items.filter(t => {
              if (t.ticker.includes(q)) return true;
              const name = getTickerName(t.ticker);
              if (name && name.toUpperCase().includes(q)) return true;
              const ind = getTickerIndustry(t.ticker);
              if (ind && ind.toUpperCase().includes(q)) return true;
              return false;
            });
          }
          if (sectorFilter !== "all") {
            items = items.filter(t => t.sector === sectorFilter);
          }
          // Sort
          items = [...items].sort((a, b) => {
            let va, vb;
            if (sortCol === "ticker") { va = a.ticker; vb = b.ticker; }
            else if (sortCol === "sector") { va = a.sector || ""; vb = b.sector || ""; }
            else if (sortCol === "industry") { va = getTickerIndustry(a.ticker) || ""; vb = getTickerIndustry(b.ticker) || ""; }
            else if (sortCol === "mcap") { va = getTickerMCap(a.ticker) || 0; vb = getTickerMCap(b.ticker) || 0; }
            else if (sortCol === "pct") { va = a.pct; vb = b.pct; }
            else if (sortCol === "price") {
              va = priceData?.prices?.[a.ticker]?.p ?? -1;
              vb = priceData?.prices?.[b.ticker]?.p ?? -1;
            }
            else if (sortCol === "change") {
              va = priceData?.prices?.[a.ticker]?.dp ?? -999;
              vb = priceData?.prices?.[b.ticker]?.dp ?? -999;
            }
            else if (TFS.includes(sortCol)) {
              va = a.tfs?.[sortCol]?.pct ?? -1;
              vb = b.tfs?.[sortCol]?.pct ?? -1;
            } else { va = a.ticker; vb = b.ticker; }
            if (typeof va === "string") {
              return sortDir === "asc" ? va.localeCompare(vb) : vb.localeCompare(va);
            }
            return sortDir === "asc" ? va - vb : vb - va;
          });
          return items;
        }, [tickers, search, sectorFilter, sortCol, sortDir, contextData, getTickerName, getTickerIndustry, getTickerMCap]);

        // ── Sort handler ──
        function handleSort(col) {
          if (sortCol === col) {
            setSortDir(d => d === "asc" ? "desc" : "asc");
          } else {
            setSortCol(col);
            setSortDir(col === "ticker" || col === "sector" ? "asc" : "desc");
          }
        }

        function sortArrow(col) {
          if (sortCol !== col) return "";
          return sortDir === "asc" ? " \u25B2" : " \u25BC";
        }

        // ── Selection ──
        function toggleSelect(ticker) {
          setSelected(prev => {
            const next = new Set(prev);
            if (next.has(ticker)) next.delete(ticker);
            else next.add(ticker);
            return next;
          });
        }

        function toggleSelectAll() {
          if (selected.size === filtered.length) {
            setSelected(new Set());
          } else {
            setSelected(new Set(filtered.map(t => t.ticker)));
          }
        }

        // ── Add ticker ──
        async function handleAdd() {
          const raw = addInput.trim().toUpperCase();
          if (!raw) return;
          const toAdd = raw.split(/[,\s]+/).filter(Boolean);
          setActionStatus({ type: "info", msg: `Adding ${toAdd.join(", ")}...` });
          try {
            const res = await fetch(`${API_BASE}/timed/watchlist/add`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              credentials: "include",
              body: JSON.stringify({ tickers: toAdd }),
            });
            const json = await res.json();
            if (json.ok) {
              const addedList = Array.isArray(json.addedTickers) ? json.addedTickers : (json.added > 0 ? toAdd : []);
              if (addedList.length > 0) {
                setPendingTickers(prev => new Set([...prev, ...addedList]));
                pollUntilRef.current = Date.now() + 120000; // Poll for 2 min so coverage updates
              }
              const parts = [];
              if (json.added > 0) parts.push(`${json.added} ticker(s) added`);
              if (json.reactivated > 0) parts.push(`${json.reactivated} reactivated`);
              const bfTickers = Array.isArray(json.backfillTriggered) ? json.backfillTriggered : [];
              if (bfTickers.length > 0) parts.push(`Candle backfill started for ${bfTickers.join(", ")}`);
              const msg = parts.length > 0 ? parts.join(". ") + "." : "No changes needed.";
              setActionStatus({ type: "success", msg });
              setAddInput("");
              fetchData();
            } else {
              const msg = (json.error === "alpaca_symbol_not_found" || json.error === "symbol_not_found") && json.message
                ? json.message
                : (json.invalid?.length ? `Symbol not found: ${json.invalid.join(", ")}. Try another symbol.` : json.error);
              setActionStatus({ type: "error", msg });
            }
          } catch (e) {
            setActionStatus({ type: "error", msg: e.message });
          }
        }

        // ── Remove tickers ──
        async function handleRemove(tickerList) {
          if (!tickerList || tickerList.length === 0) return;
          const confirmed = window.confirm(`Remove ${tickerList.length} ticker(s)?\n${tickerList.join(", ")}\n\nThis removes from the index (candle data in D1 is preserved).`);
          if (!confirmed) return;

          setActionStatus({ type: "info", msg: `Removing ${tickerList.join(", ")}...` });
          try {
            const res = await fetch(`${API_BASE}/timed/watchlist/remove`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              credentials: "include",
              body: JSON.stringify({ tickers: tickerList }),
            });
            const json = await res.json();
            if (json.ok) {
              setActionStatus({ type: "success", msg: `Removed ${json.removed} ticker(s).` });
              setSelected(new Set());
              fetchData();
            } else {
              setActionStatus({ type: "error", msg: json.error });
            }
          } catch (e) {
            setActionStatus({ type: "error", msg: e.message });
          }
        }

        // ── Sequential backfill state ──
        const [seqBackfill, setSeqBackfill] = useState(null); // { running, current, index, total, log, cancelled }
        const seqCancelRef = useRef(false);

        // ── Fill gaps (backfill) — single ticker ──
        async function handleFillGaps(ticker) {
          const isTV = TV_TICKERS.has(ticker);
          if (isTV) return;

          if (ticker === "__SEQ_ALL__") {
            return handleFillAllSequential();
          }

          setBackfillStatus(prev => ({ ...prev, [ticker]: "running" }));
          try {
            const endpoint = `${API_BASE}/timed/admin/alpaca-backfill?tf=all&ticker=${ticker}`;
            const res = await fetch(endpoint, { method: "POST", credentials: "include" });
            const json = await res.json();
            if (json.ok) {
              setBackfillStatus(prev => ({ ...prev, [ticker]: "started" }));
              // Poll for completion, then refresh
              const pollDone = async () => {
                for (let attempt = 0; attempt < 60; attempt++) {
                  await new Promise(r => setTimeout(r, 3000));
                  try {
                    const s = await fetch(`${API_BASE}/timed/admin/backfill-status`, { credentials: "include" }).then(r => r.json());
                    const phase = s?.status?.phase;
                    if (phase === "done" || !phase) break;
                    setBackfillStatus(prev => ({
                      ...prev,
                      [ticker]: `${s.status.tf || ""} ${s.status.upserted || 0} bars`,
                    }));
                  } catch { break; }
                }
                setBackfillStatus(prev => { const n = { ...prev }; delete n[ticker]; return n; });
                fetchData();
              };
              pollDone();
            } else {
              setBackfillStatus(prev => ({ ...prev, [ticker]: `error: ${json.error || "unknown"}` }));
            }
          } catch (e) {
            setBackfillStatus(prev => ({ ...prev, [ticker]: `error: ${e.message}` }));
          }
        }

        // ── Fill ALL tickers sequentially, one at a time ──
        async function handleFillAllSequential() {
          if (seqBackfill?.running) return;
          seqCancelRef.current = false;

          // Get non-TV tickers that need filling (quality < 100)
          const tickersToFill = (data?.tickers || [])
            .filter(t => !TV_TICKERS.has(t.ticker) && (t.quality ?? t.pct) < 100)
            .map(t => t.ticker);

          if (tickersToFill.length === 0) {
            setActionStatus({ type: "success", msg: "All tickers already at 100% quality." });
            return;
          }

          const log = [];
          setSeqBackfill({ running: true, current: tickersToFill[0], index: 0, total: tickersToFill.length, log, cancelled: false });

          for (let i = 0; i < tickersToFill.length; i++) {
            if (seqCancelRef.current) {
              log.push(`Cancelled at ${i}/${tickersToFill.length}`);
              setSeqBackfill(prev => ({ ...prev, running: false, cancelled: true, log: [...log] }));
              fetchData();
              return;
            }

            const ticker = tickersToFill[i];
            setSeqBackfill(prev => ({ ...prev, current: ticker, index: i, log: [...log] }));
            setBackfillStatus(prev => ({ ...prev, [ticker]: "running" }));

            try {
              // Trigger backfill for this ticker
              const res = await fetch(`${API_BASE}/timed/admin/alpaca-backfill?tf=all&ticker=${ticker}`, { method: "POST", credentials: "include" });
              const json = await res.json();
              if (!json.ok) {
                log.push(`${ticker}: error — ${json.error || "unknown"}`);
                setBackfillStatus(prev => ({ ...prev, [ticker]: "error" }));
                continue;
              }

              // Poll for this ticker's backfill to complete
              let finalBars = 0;
              for (let attempt = 0; attempt < 120; attempt++) {
                await new Promise(r => setTimeout(r, 2000));
                if (seqCancelRef.current) break;
                try {
                  const s = await fetch(`${API_BASE}/timed/admin/backfill-status`, { credentials: "include" }).then(r => r.json());
                  const phase = s?.status?.phase;
                  const upserted = s?.status?.upserted || 0;
                  const tf = s?.status?.tf || "";
                  const tfIdx = s?.status?.tfIndex || 0;
                  const tfTotal = s?.status?.tfTotal || 9;
                  finalBars = upserted;

                  setBackfillStatus(prev => ({
                    ...prev,
                    [ticker]: `TF ${tf} (${tfIdx}/${tfTotal}) — ${upserted} bars`,
                  }));
                  setSeqBackfill(prev => ({
                    ...prev,
                    progress: `TF ${tf} (${tfIdx}/${tfTotal}) — ${upserted} bars`,
                    log: [...log],
                  }));

                  if (phase === "done" || !phase) break;
                } catch { break; }
              }

              log.push(`${ticker}: ${finalBars} bars`);
              setBackfillStatus(prev => { const n = { ...prev }; delete n[ticker]; return n; });
            } catch (e) {
              log.push(`${ticker}: error — ${e.message}`);
              setBackfillStatus(prev => ({ ...prev, [ticker]: "error" }));
            }
          }

          setSeqBackfill(prev => ({ ...prev, running: false, current: null, log: [...log] }));
          fetchData();
        }

        // ── TF cell (shows quality, not just count-based pct) ──
        function TFCell({ tfData }) {
          if (!tfData || tfData.count === 0) {
            return (
              <td className="px-1 py-1 text-center" style={{ minWidth: 52 }}>
                <div className="text-[9px] text-gray-600">—</div>
              </td>
            );
          }
          // Use quality score if available, fall back to pct
          const q = tfData.quality != null ? tfData.quality : tfData.pct;
          const gapDays = tfData.gap_days;
          const hasGaps = gapDays != null && gapDays > 3;
          const freshHrs = tfData.freshness_hours;
          const isStale = freshHrs != null && freshHrs > 72;

          // Tooltip with detailed info
          const tip = [
            `Count: ${tfData.count}/${tfData.expected}`,
            freshHrs != null ? `Freshness: ${freshHrs < 1 ? '<1h' : freshHrs < 24 ? Math.round(freshHrs) + 'h' : Math.round(freshHrs/24) + 'd'} ago` : null,
            gapDays != null ? `Gap days (30d): ${gapDays}` : null,
            tfData.recent_dates != null ? `Trading dates (30d): ${tfData.recent_dates}` : null,
            `Quality: ${q}%`,
          ].filter(Boolean).join('\n');

          return (
            <td className="px-1 py-1 text-center" style={{ background: pctBg(q), minWidth: 52 }} title={tip}>
              <div className="text-[11px] font-semibold leading-tight" style={{ color: pctColor(q) }}>
                {q}%
                {hasGaps && <span className="text-[8px] text-amber-400 ml-0.5" title={`${gapDays} gap days`}>⚠</span>}
              </div>
              <div className="text-[8px] leading-tight" style={{ color: isStale ? '#ef4444' : '#6b7280' }} title={formatDate(tfData.max_ts)}>
                {formatAge(tfData.max_ts)}
              </div>
            </td>
          );
        }

        // ── Render ──
        return (
          <div className="min-h-screen bg-[#0a0a0f]">
            {/* Unified Nav Bar */}
            <nav className="sticky top-0 z-50 border-b border-white/[0.06]" style={{background:"rgba(10,10,15,0.95)",backdropFilter:"blur(12px)"}}>
              <div className="flex items-center justify-between px-4 py-2.5">
                <div className="flex items-center gap-3 md:gap-5 min-w-0">
                  <a href="index-react.html" className="flex items-center gap-2 no-underline shrink-0">
                    <div className="w-[28px] h-[28px] md:w-[32px] md:h-[32px] rounded-[8px] flex items-center justify-center" style={{background:"linear-gradient(135deg, #00c853, #00e676, #69f0ae)"}}>
                      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                        <polyline points="22 7 13.5 15.5 8.5 10.5 2 17" />
                        <polyline points="16 7 22 7 22 13" />
                      </svg>
                    </div>
                    <span className="text-[14px] md:text-[15px] font-bold text-white hidden sm:inline" style={{letterSpacing:"-0.03em"}}>Timed Trading</span>
                  </a>
                  <div className="hidden lg:flex items-center gap-0.5">
                    <a href="index-react.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Active Trader</a>
                    <a href="investor-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Investor</a>
                    <a href="simulation-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Trades</a>
                    <a href="system-intelligence.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">System Intelligence</a>
                    <a href="screener.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Screener</a>
                    <a href="ticker-management.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-white bg-white/[0.07] font-medium">Tickers</a>
                    <a href="daily-brief.html" id="nav-daily-brief" className="relative px-3 py-1 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium">
                      Daily Brief
                      <span id="brief-badge" className="hidden absolute -top-0.5 -right-0.5 w-2 h-2 rounded-full bg-[#f59e0b]" style={{animation: "pulse-badge 2s ease-in-out infinite"}} />
                    </a>
                  </div>
                </div>
                <div className="flex items-center gap-1.5 md:gap-2 shrink-0">
                  <a href="/faq.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</a>
                  <a href="/faq.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">FAQ</a>
                  <a href="index-react.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#60a5fa] hover:text-[#93bbfc] hover:bg-[#60a5fa]/[0.06] transition-all font-medium">Ask AI</a>
                  {(window.TimedAuthHelpers?.getStoredSession()?.role === 'admin' || window.TimedAuthHelpers?.getStoredSession()?.tier === 'admin') && (
                    <a href="admin-clients.html" data-admin-only="true" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#a78bfa]/80 hover:text-[#a78bfa] font-medium">Admin</a>
                  )}
                  {data?.summary && (
                    <span className="hidden sm:inline text-[11px] text-[#6b7280]">
                      {data.summary.tickers_with_candle_data} with data / {data.summary.total_tickers_in_system} total
                    </span>
                  )}
                  <button
                    onClick={fetchData}
                    disabled={loading}
                    className="px-2 md:px-3 py-1.5 bg-white/5 border border-white/10 rounded text-xs text-gray-300 hover:bg-white/10 disabled:opacity-50"
                  >
                    {loading ? "Loading..." : "Refresh"}
                  </button>
                  {window.TimedNotificationCenter && <window.TimedNotificationCenter apiBase="" />}
                  {window.TimedUserBadge && <window.TimedUserBadge user={window.TimedAuthHelpers?.getStoredSession()} compact />}
                  <button onClick={() => setMobileMenuOpen(v => !v)} className="lg:hidden p-1.5 rounded-md text-[#6b7280] hover:text-white hover:bg-white/[0.06] transition-all" aria-label="Toggle menu">
                    {mobileMenuOpen ? (
                      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    ) : (
                      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                    )}
                  </button>
                </div>
              </div>
              {mobileMenuOpen && (
                <div className="lg:hidden border-t border-white/[0.06] px-4 py-2 flex flex-col gap-0.5" style={{background:"rgba(10,10,15,0.98)"}}>
                  <a href="index-react.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Active Trader</a>
                  <a href="investor-dashboard.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Investor</a>
                  <a href="simulation-dashboard.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Trades</a>
                  <a href="system-intelligence.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>System Intelligence</a>
                  <a href="screener.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Screener</a>
                  <a href="ticker-management.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-white bg-white/[0.07] font-medium" onClick={() => setMobileMenuOpen(false)}>Tickers</a>
                  <a href="daily-brief.html" className="px-3 py-2 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium" onClick={() => setMobileMenuOpen(false)}>Daily Brief</a>
                  <div className="border-t border-white/[0.06] mt-1 pt-1 flex items-center gap-2">
                    <a href="/faq.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</a>
                    <a href="/faq.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">FAQ</a>
                    <a href="index-react.html" className="px-3 py-2 rounded-md text-[12px] text-[#60a5fa] hover:text-white hover:bg-white/[0.04] transition-all">Ask AI</a>
                    <a href="mailto:support@timed-trading.com" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Contact</a>
                  </div>
                </div>
              )}
            </nav>

            <div className="max-w-[1800px] mx-auto px-4 py-4 space-y-4">
              {/* Action bar */}
              <div className="flex flex-wrap items-center gap-3">
                {/* Add ticker */}
                <div className="flex items-center gap-1.5">
                  <input
                    ref={addRef}
                    type="text"
                    value={addInput}
                    onChange={e => setAddInput(e.target.value)}
                    onKeyDown={e => e.key === "Enter" && handleAdd()}
                    placeholder="Add ticker(s): AAPL, MSFT..."
                    className="bg-white/5 border border-white/10 rounded px-3 py-1.5 text-sm text-white placeholder-gray-600 w-64 focus:outline-none focus:border-blue-500/50"
                  />
                  <button
                    onClick={handleAdd}
                    disabled={!addInput.trim()}
                    className="px-3 py-1.5 bg-blue-600/80 hover:bg-blue-600 rounded text-xs font-medium text-white disabled:opacity-40"
                  >
                    Add
                  </button>
                </div>

                {/* Search */}
                <input
                  type="text"
                  value={search}
                  onChange={e => setSearch(e.target.value)}
                  placeholder="Search tickers..."
                  className="bg-white/5 border border-white/10 rounded px-3 py-1.5 text-sm text-white placeholder-gray-600 w-48 focus:outline-none focus:border-blue-500/50"
                />

                {/* Sector filter */}
                <select
                  value={sectorFilter}
                  onChange={e => setSectorFilter(e.target.value)}
                  className="bg-white/5 border border-white/10 rounded px-3 py-1.5 text-sm text-gray-300 focus:outline-none"
                >
                  {sectors.map(s => (
                    <option key={s} value={s} style={{ background: "#1a1a24" }}>
                      {s === "all" ? "All Sectors" : s}
                    </option>
                  ))}
                </select>

                {/* Bulk actions */}
                {selected.size > 0 && (
                  <div className="flex items-center gap-2 ml-2">
                    <span className="text-xs text-gray-400">{selected.size} selected</span>
                    <button
                      onClick={() => handleRemove([...selected])}
                      className="px-3 py-1.5 bg-red-600/60 hover:bg-red-600 rounded text-xs font-medium text-white"
                    >
                      Remove Selected
                    </button>
                    <button
                      onClick={() => setSelected(new Set())}
                      className="px-2 py-1.5 text-xs text-gray-500 hover:text-gray-300"
                    >
                      Clear
                    </button>
                  </div>
                )}

                {/* Fill all gaps — sequential */}
                <div className="ml-auto flex items-center gap-2">
                  {seqBackfill?.running && (
                    <div className="flex items-center gap-2">
                      <div className="text-xs text-amber-400 max-w-[300px] truncate">
                        {seqBackfill.current} ({seqBackfill.index + 1}/{seqBackfill.total})
                        {seqBackfill.progress && <span className="text-gray-500 ml-1">{seqBackfill.progress}</span>}
                      </div>
                      <button
                        onClick={() => { seqCancelRef.current = true; }}
                        className="px-2 py-1 text-[10px] bg-red-900/40 hover:bg-red-800/60 text-red-400 rounded"
                      >
                        Stop
                      </button>
                    </div>
                  )}
                  {!seqBackfill?.running && seqBackfill?.log?.length > 0 && (
                    <span className="text-xs text-gray-500">
                      Last run: {seqBackfill.log.length} tickers {seqBackfill.cancelled ? "(cancelled)" : "done"}
                    </span>
                  )}
                  <button
                    onClick={() => handleFillGaps("__SEQ_ALL__")}
                    disabled={seqBackfill?.running}
                    className="px-3 py-1.5 bg-[#00c853]/60 hover:bg-[#00c853] rounded text-xs font-medium text-white disabled:opacity-40"
                  >
                    {seqBackfill?.running ? `Filling ${seqBackfill.index + 1}/${seqBackfill.total}...` : "Fill All Gaps"}
                  </button>
                </div>
              </div>

              {/* Status message */}
              {actionStatus && (
                <div className={`px-3 py-2 rounded text-sm ${
                  actionStatus.type === "success" ? "bg-green-900/30 text-green-400 border border-green-800/40" :
                  actionStatus.type === "error" ? "bg-red-900/30 text-red-400 border border-red-800/40" :
                  "bg-blue-900/30 text-blue-400 border border-blue-800/40"
                }`}>
                  {actionStatus.msg}
                  <button onClick={() => setActionStatus(null)} className="ml-3 text-xs opacity-60 hover:opacity-100">Dismiss</button>
                </div>
              )}

              {/* Summary stats */}
              {data?.summary && (
                <div className="flex gap-4 text-xs">
                  <div className="bg-white/[0.03] border border-white/5 rounded px-4 py-2">
                    <div className="text-gray-500">In System</div>
                    <div className="text-white font-semibold text-lg">{data.summary.total_tickers_in_system}</div>
                  </div>
                  <div className="bg-white/[0.03] border border-white/5 rounded px-4 py-2">
                    <div className="text-gray-500">With Data</div>
                    <div className="text-white font-semibold text-lg">{data.summary.tickers_with_candle_data}</div>
                  </div>
                  <div className="bg-white/[0.03] border border-white/5 rounded px-4 py-2">
                    <div className="text-gray-500">No Data</div>
                    <div className={`font-semibold text-lg ${data.summary.tickers_no_data > 0 ? "text-red-400" : "text-green-400"}`}>
                      {data.summary.tickers_no_data}
                    </div>
                  </div>
                  <div className="bg-white/[0.03] border border-white/5 rounded px-4 py-2">
                    <div className="text-gray-500">Showing</div>
                    <div className="text-white font-semibold text-lg">{filtered.length}</div>
                  </div>
                </div>
              )}

              {/* Error */}
              {error && (
                <div className="bg-red-900/20 border border-red-800/40 rounded px-4 py-3 text-red-400 text-sm">
                  Error: {error}
                  <button onClick={fetchData} className="ml-3 underline text-xs">Retry</button>
                </div>
              )}

              {/* Table */}
              {!loading && filtered.length > 0 && (
                <div className="overflow-x-auto border border-white/5 rounded-lg">
                  <table className="text-sm" style={{ minWidth: 1700 }}>
                    <thead>
                      <tr className="bg-white/[0.03] border-b border-white/5">
                        <th className="px-2 py-2 text-left w-8">
                          <input
                            type="checkbox"
                            checked={selected.size === filtered.length && filtered.length > 0}
                            onChange={toggleSelectAll}
                            className="accent-blue-500"
                          />
                        </th>
                        <th
                          className="px-3 py-2 text-left text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                          onClick={() => handleSort("ticker")}
                        >
                          Ticker{sortArrow("ticker")}
                        </th>
                        <th className="px-2 py-2 text-left text-xs font-medium text-gray-400">Name</th>
                        <th
                          className="px-2 py-2 text-left text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                          onClick={() => handleSort("sector")}
                        >
                          Sector{sortArrow("sector")}
                        </th>
                        <th
                          className="px-2 py-2 text-left text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                          onClick={() => handleSort("industry")}
                        >
                          Industry{sortArrow("industry")}
                        </th>
                        <th
                          className="px-2 py-2 text-right text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                          onClick={() => handleSort("mcap")}
                        >
                          MCap{sortArrow("mcap")}
                        </th>
                        <th className="px-2 py-2 text-left text-xs font-medium text-gray-400">Groups</th>
                        <th
                          className="px-2 py-2 text-center text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                          onClick={() => handleSort("pct")}
                        >
                          Avg{sortArrow("pct")}
                        </th>
                        <th
                          className="px-2 py-2 text-right text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                          onClick={() => handleSort("price")}
                        >
                          Price{sortArrow("price")}
                        </th>
                        <th
                          className="px-2 py-2 text-right text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                          onClick={() => handleSort("change")}
                        >
                          Chg% / As Of{sortArrow("change")}
                        </th>
                        {TFS.map(tf => (
                          <th
                            key={tf}
                            className="px-2 py-2 text-center text-xs font-medium text-gray-400 cursor-pointer hover:text-white select-none"
                            onClick={() => handleSort(tf)}
                          >
                            {TF_LABELS[tf]}{sortArrow(tf)}
                          </th>
                        ))}
                        <th className="px-3 py-2 text-center text-xs font-medium text-gray-400">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {filtered.map((t, idx) => {
                        const isTV = TV_TICKERS.has(t.ticker);
                        const bfStatus = backfillStatus[t.ticker];
                        return (
                          <tr
                            key={t.ticker}
                            className={`border-b border-white/[0.03] hover:bg-white/[0.02] ${
                              selected.has(t.ticker) ? "bg-blue-900/10" : ""
                            } ${t.backfilling ? "bg-blue-900/5" : ""} ${idx % 2 === 0 ? "" : "bg-white/[0.01]"}`}
                          >
                            <td className="px-2 py-1.5">
                              <input
                                type="checkbox"
                                checked={selected.has(t.ticker)}
                                onChange={() => toggleSelect(t.ticker)}
                                className="accent-blue-500"
                              />
                            </td>
                            <td className="px-3 py-1.5">
                              <a
                                href={`index-react.html#ticker=${encodeURIComponent(t.ticker)}`}
                                className="font-semibold text-blue-400 hover:text-blue-300 text-xs cursor-pointer hover:underline"
                                title={`View ${t.ticker} details on Dashboard`}
                              >{t.ticker}</a>
                              {t.backfilling && <span className="ml-1.5 text-[9px] px-1 py-0.5 rounded bg-amber-900/40 text-amber-400" title="Backfill in progress; coverage will update shortly">Backfilling</span>}
                              {isTV && !t.backfilling && <span className="ml-1.5 text-[9px] px-1 py-0.5 rounded bg-purple-900/40 text-purple-400">TV</span>}
                            </td>
                            <td className="px-2 py-1 text-[11px] text-gray-400 max-w-[140px] truncate" title={getTickerName(t.ticker)}>{getTickerName(t.ticker)}</td>
                            <td className="px-2 py-1 text-[11px] text-gray-400 max-w-[100px] truncate" title={t.sector}>{t.sector || "—"}</td>
                            <td className="px-2 py-1 text-[11px] text-gray-500 max-w-[130px] truncate" title={getTickerIndustry(t.ticker)}>{getTickerIndustry(t.ticker) || "—"}</td>
                            <td className="px-2 py-1 text-[11px] text-right text-gray-500 tabular-nums whitespace-nowrap">
                              {(() => {
                                const mcap = getTickerMCap(t.ticker);
                                if (!mcap) return <span className="text-gray-600">—</span>;
                                const color = mcap >= 200e9 ? "text-blue-400" : mcap >= 10e9 ? "text-teal-400" : mcap >= 2e9 ? "text-gray-400" : "text-gray-500";
                                return <span className={color}>{fmtMCap(mcap)}</span>;
                              })()}
                            </td>
                            <td className="px-2 py-1">
                              {(() => {
                                const grps = groupsForTicker(t.ticker);
                                if (grps.length === 0) return <span className="text-[10px] text-gray-600">—</span>;
                                return (
                                  <div className="flex flex-wrap gap-0.5">
                                    {grps.map(g => {
                                      const wb = etfWeightBadge(t.ticker, g);
                                      return (
                                        <span key={g} className="text-[9px] px-1 py-0 rounded bg-gray-800 text-gray-400" title={wb ? `${g} weight: ${wb}` : g}>
                                          {g}{wb ? <span className="ml-0.5 text-[#00e676]">{wb}</span> : null}
                                        </span>
                                      );
                                    })}
                                  </div>
                                );
                              })()}
                            </td>
                            <td className="px-2 py-1.5 text-center" title={t.backfilling ? "Backfill in progress" : `Count-based: ${t.pct}% | Quality: ${t.quality ?? t.pct}%`}>
                              {t.backfilling ? (
                                <span className="text-[10px] text-amber-400">…</span>
                              ) : (
                                <span
                                  className="text-xs font-bold px-2 py-0.5 rounded"
                                  style={{ color: pctColor(t.quality ?? t.pct), background: pctBg(t.quality ?? t.pct) }}
                                >
                                  {t.quality ?? t.pct}%
                                </span>
                              )}
                            </td>
                            {(() => {
                              const pd = priceData?.prices?.[t.ticker];
                              const price = pd?.p;
                              const chgPct = pd?.dp;
                              const chg = pd?.dc;
                              const pc = pd?.pc;
                              // When current price is missing but daily change is present, derive price from prev_close + dc
                              const displayPrice = (Number(price) > 0)
                                ? price
                                : (Number.isFinite(pc) && Number.isFinite(chg))
                                  ? pc + chg
                                  : null;
                              const isUp = chgPct > 0;
                              const isDown = chgPct < 0;
                              return (
                                <>
                                  <td className="px-2 py-1 text-right text-[11px] text-white font-medium tabular-nums">
                                    {displayPrice != null && displayPrice > 0 ? `$${Number(displayPrice).toFixed(2)}` : <span className="text-gray-600">—</span>}
                                  </td>
                                  <td className="px-2 py-1 text-right text-[11px] tabular-nums">
                                    {Number.isFinite(chgPct) && chgPct !== 0 ? (
                                      <div>
                                        <span style={{ color: isUp ? "#22c55e" : isDown ? "#ef4444" : "#9ca3af" }}>
                                          {isUp ? "+" : ""}{chgPct.toFixed(2)}%
                                          <span className="text-[9px] text-gray-500 ml-0.5">
                                            ({isUp ? "+" : ""}{chg?.toFixed(2)})
                                          </span>
                                        </span>
                                        {(pd?.t > 0 || priceData?.updated_at > 0) && (
                                          <div className="text-[9px] text-gray-600">{formatAge(pd?.t || priceData?.updated_at)}</div>
                                        )}
                                      </div>
                                    ) : <span className="text-gray-600">—</span>}
                                  </td>
                                </>
                              );
                            })()}
                            {TFS.map(tf => (
                              <TFCell key={tf} tfData={t.tfs?.[tf]} />
                            ))}
                            <td className="px-2 py-1.5 text-center">
                              <div className="flex items-center justify-center gap-1">
                                {(t.quality ?? t.pct) < 100 && (
                                  isTV ? (
                                    <span className="text-[9px] text-gray-600" title="TV-sourced: re-export from TradingView">TV</span>
                                  ) : (
                                    <button
                                      onClick={() => handleFillGaps(t.ticker)}
                                      disabled={bfStatus === "running"}
                                      className="px-2 py-0.5 text-[10px] bg-[#00c853]/20 hover:bg-[#00c853]/40 text-[#00e676] rounded disabled:opacity-40"
                                      title="Fill data gaps via backfill"
                                    >
                                      {bfStatus === "running" ? "..." : bfStatus === "started" ? "OK" : "Fill"}
                                    </button>
                                  )
                                )}
                                <button
                                  onClick={() => handleRemove([t.ticker])}
                                  className="px-2 py-0.5 text-[10px] bg-red-900/30 hover:bg-red-800/50 text-red-400 rounded"
                                  title="Remove from index"
                                >
                                  Remove
                                </button>
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              )}

              {/* Loading state */}
              {loading && (
                <div className="flex items-center justify-center py-20">
                  <div className="text-gray-500 text-sm">Loading coverage data...</div>
                </div>
              )}

              {/* Empty state */}
              {!loading && filtered.length === 0 && !error && (
                <div className="flex items-center justify-center py-20">
                  <div className="text-gray-500 text-sm">
                    {search || sectorFilter !== "all" ? "No tickers match your filters." : "No ticker data found."}
                  </div>
                </div>
              )}

              {/* ── TT Selected / UPTICKS Management ── */}
              <UptickManager />

              {/* ── S&P Sector Ratings ── */}
              <SectorRatingsManager />

              {/* Admin Tools — access Brand Kit and Debug from here */}
              <div className="mt-6 pt-4 border-t border-white/[0.06]">
                <div className="flex items-center gap-3">
                  <span className="text-[11px] text-[#4b5563] uppercase tracking-wide">Admin Tools</span>
                  <a
                    href="brand-kit.html"
                    className="px-3 py-1.5 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.06] border border-white/[0.08] transition-all"
                  >
                    Brand Kit
                  </a>
                  <a
                    href="debug-dashboard.html"
                    className="px-3 py-1.5 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.06] border border-white/[0.08] transition-all"
                  >
                    Debug Dashboard
                  </a>
                </div>
              </div>
            </div>
          </div>
        );
      }

      const _AuthGate = window.TimedAuthGate;
      const _tickerApp = _AuthGate
        ? <_AuthGate apiBase={API_BASE} requiredTier="admin">{(user) => <App user={user} />}</_AuthGate>
        : <App />;
      ReactDOM.createRoot(document.getElementById("root")).render(_tickerApp);
    </script>
    <script>
      (function() {
        fetch("/timed/daily-brief/badge", { cache: "no-store" })
          .then(r => r.json())
          .then(d => {
            if (d?.badge?.ts) {
              const seen = Number(localStorage.getItem("tt_brief_seen") || 0);
              if (d.badge.ts > seen) {
                const el = document.getElementById("brief-badge");
                if (el) el.classList.remove("hidden");
              }
            }
          })
          .catch(() => {});
      })();
    </script>
  </body>
</html>
