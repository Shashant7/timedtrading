<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timed Trading - Trade Tracker</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        background: #0a0f1e;
        color: #e7ecff;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }
      .loading-spinner {
        border: 3px solid #26325f;
        border-top: 3px solid #3b82f6;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .slide-in-right {
        animation: slideInRight 0.3s ease-out;
      }
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, memo } = React;

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Constants
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const API_BASE = "https://timed-trading-ingest.shashant.workers.dev";
      const API_KEY = "AwesomeSauce"; // TODO: Move to environment variable or secure storage
      const TRADE_SIZE = 1000; // $1000 per trade
      const FUTURES_TICKERS = new Set(["ES", "NQ", "YM", "RTY", "CL", "GC", "SI", "HG", "NG"]);

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Hooks
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);

        const fetchData = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/all`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && json.data) {
              setData(json.data);
              setLastUpdate(new Date());
            } else {
              throw new Error(json.error || "Invalid response");
            }
          } catch (err) {
            setError(err.message);
            console.error("Fetch error:", err);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 180000); // Refresh every 3 minutes
          return () => clearInterval(interval);
        }, [fetchData]);

        return { data, loading, error, lastUpdate, refetch: fetchData };
      }

      function useSimulatedTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        // Fetch trades from Worker
        const fetchTrades = useCallback(async (version = null) => {
          try {
            setLoading(true);
            setError(null);
            const url = version ? `${API_BASE}/timed/trades?version=${encodeURIComponent(version)}` : `${API_BASE}/timed/trades`;
            console.log(`[UI] Fetching trades from ${url}`);
            const res = await fetch(url);
            console.log(`[UI] Response status: ${res.status}, ok: ${res.ok}`);
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[UI] HTTP ${res.status} error:`, errorText);
              throw new Error(`HTTP ${res.status}: ${errorText.substring(0, 100)}`);
            }
            const json = await res.json();
            console.log(`[UI] Response:`, { 
              ok: json.ok, 
              count: json.count, 
              totalCount: json.totalCount, 
              tradesLength: json.trades?.length,
              versions: json.versions 
            });
            if (json.ok && Array.isArray(json.trades)) {
              console.log(`[UI] ‚úÖ Setting ${json.trades.length} trades`);
              setTrades(json.trades);
            } else {
              console.error(`[UI] ‚ùå Invalid response:`, json);
              setTrades([]); // Set empty array instead of throwing
              throw new Error(json.error || "Invalid response format");
            }
          } catch (err) {
            setError(err.message);
            console.error("[UI] Fetch trades error:", err);
            setTrades([]); // Ensure trades is set to empty array on error
          } finally {
            setLoading(false);
          }
        }, []);

        // Load trades on mount
        useEffect(() => {
          fetchTrades();
        }, [fetchTrades]);

        // Save trade to Worker
        const saveTrade = useCallback(async (trade) => {
          try {
            const res = await fetch(`${API_BASE}/timed/trades?key=${API_KEY}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(trade),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) {
              // Refresh trades list
              await fetchTrades();
              return json.trade;
            }
            throw new Error(json.error || "Failed to save trade");
          } catch (err) {
            console.error("Save trade error:", err);
            throw err;
          }
        }, [fetchTrades]);

        const addTrade = useCallback(async (trade) => {
          await saveTrade(trade);
        }, [saveTrade]);

        const updateTrade = useCallback(async (tradeId, updates) => {
          const existingTrade = trades.find((t) => t.id === tradeId);
          if (!existingTrade) {
            console.error("Trade not found:", tradeId);
            return;
          }
          const updatedTrade = { ...existingTrade, ...updates };
          await saveTrade(updatedTrade);
        }, [trades, saveTrade]);

        const clearTrades = useCallback(async () => {
          if (confirm("Clear all simulated trades? This cannot be undone.")) {
            // Delete all trades one by one (Worker doesn't have bulk delete)
            for (const trade of trades) {
              try {
                await fetch(`${API_BASE}/timed/trades/${trade.id}?key=${API_KEY}`, {
                  method: "DELETE",
                });
              } catch (err) {
                console.error("Error deleting trade:", trade.id, err);
              }
            }
            await fetchTrades();
          }
        }, [trades, fetchTrades]);

        return { trades, loading, error, addTrade, updateTrade, clearTrades, refetch: fetchTrades };
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Trade Simulation Logic
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function shouldTriggerTrade(ticker, prevData) {
        // Skip futures
        if (FUTURES_TICKERS.has(ticker.ticker.toUpperCase())) return false;

        // Must have valid entry/exit levels
        if (!ticker.price || !ticker.sl || !ticker.tp) return false;

        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const alignedLong = state === "HTF_BULL_LTF_BULL";
        const alignedShort = state === "HTF_BEAR_LTF_BEAR";
        const aligned = alignedLong || alignedShort;
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        const side = ent.side; // LONG or SHORT

        // Corridor must match alignment
        const corridorAlignedOK =
          (side === "LONG" && alignedLong) ||
          (side === "SHORT" && alignedShort);

        if (!inCorridor || !corridorAlignedOK) return false;

        // Check for trigger conditions (matches worker logic)
        const enteredAligned = prevData && prevData.state !== state && aligned;
        const trigReason = String(ticker.trigger_reason || "");
        const trigOk = trigReason === "EMA_CROSS" || trigReason === "SQUEEZE_RELEASE";
        const sqRelease = !!flags.sq30_release;
        const hasTrigger = !!ticker.trigger_price && !!ticker.trigger_ts;

        // Must be: in corridor + corridor aligns + (entered aligned OR trigger OR squeeze release)
        const shouldConsiderAlert =
          inCorridor &&
          corridorAlignedOK &&
          (enteredAligned || trigOk || sqRelease || hasTrigger);

        // Check Momentum Elite status
        const momentumElite = !!flags.momentum_elite;
        
        // Threshold gates (with Momentum Elite adjustments - matching worker logic)
        const baseMinRR = 1.5;
        const baseMaxComp = 0.4;
        const baseMaxPhase = 0.6;
        const baseMinRank = 70;
        
        // Adjust thresholds for Momentum Elite (more lenient for quality stocks)
        const minRR = momentumElite ? Math.max(1.2, baseMinRR * 0.9) : baseMinRR; // Lower RR requirement
        const maxComp = momentumElite ? Math.min(0.5, baseMaxComp * 1.25) : baseMaxComp; // Allow higher completion
        const maxPhase = momentumElite ? Math.min(0.7, baseMaxPhase * 1.17) : baseMaxPhase; // Allow higher phase
        const minRank = momentumElite ? Math.max(60, baseMinRank - 10) : baseMinRank; // Lower rank requirement

        const rr = Number(ticker.rr) || 0;
        const comp = Number(ticker.completion) || 0;
        const phase = Number(ticker.phase_pct) || 0;
        const rank = Number(ticker.rank) || 0;

        const rrOk = rr >= minRR;
        const compOk = comp <= maxComp;
        const phaseOk = phase <= maxPhase;
        const rankOk = rank >= minRank;

        // Also consider Momentum Elite as a trigger condition (quality signal)
        const momentumEliteTrigger = momentumElite && inCorridor && corridorAlignedOK;
        
        // Enhanced trigger: original conditions OR Momentum Elite in good setup
        const enhancedTrigger = shouldConsiderAlert || momentumEliteTrigger;

        return enhancedTrigger && rrOk && compOk && phaseOk && rankOk;
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
        const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        return null;
      }

      function calculateTrade(ticker, entryPrice, existingTrade = null) {
        const direction = getDirection(ticker);
        if (!direction) return null;

        const sl = Number(ticker.sl);
        const tp = Number(ticker.tp);
        const currentPrice = Number(ticker.price);

        if (!Number.isFinite(sl) || !Number.isFinite(tp) || !Number.isFinite(currentPrice)) {
          return null;
        }

        // Calculate shares (assuming $1000 position size)
        const shares = Math.floor(TRADE_SIZE / entryPrice);

        // Calculate P&L based on current price
        let pnl = 0;
        let pnlPct = 0;
        let status = "OPEN";

        // Check for partial trim (if position was already trimmed)
        const trimmedPct = existingTrade ? (existingTrade.trimmedPct || 0) : 0;
        const remainingShares = shares * (1 - trimmedPct);
        
        if (direction === "LONG") {
          // Check if hit TP or SL first
          const hitTP = currentPrice >= tp;
          const hitSL = currentPrice <= sl;
          
          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const trimPnl = (tp - entryPrice) * shares * 0.5;
              const trimPnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              pnl = (tp - entryPrice) * shares;
              pnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            pnl = (sl - entryPrice) * shares;
            pnlPct = ((sl - entryPrice) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            pnl = (currentPrice - entryPrice) * shares;
            pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        } else {
          // SHORT
          // Check if hit TP or SL first
          const hitTP = currentPrice <= tp;
          const hitSL = currentPrice >= sl;
          
          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const trimPnl = (entryPrice - tp) * shares * 0.5;
              const trimPnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              pnl = (entryPrice - tp) * shares;
              pnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            pnl = (entryPrice - sl) * shares;
            pnlPct = ((entryPrice - sl) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            pnl = (entryPrice - currentPrice) * shares;
            pnlPct = ((entryPrice - currentPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        }

        return {
          shares,
          pnl,
          pnlPct,
          status,
          currentPrice,
        };
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Trade Tracking
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Trade simulation is now handled by Worker - UI just fetches and displays
      // No need for useTradeSimulation hook anymore - Worker handles everything

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Analytics & Learning
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function useTradeAnalytics(trades) {
        return useMemo(() => {
          const closed = trades.filter((t) => t.status === "WIN" || t.status === "LOSS");
          const open = trades.filter((t) => t.status === "OPEN" || !t.status);

          const totalTrades = closed.length;
          const wins = closed.filter((t) => t.status === "WIN").length;
          const losses = closed.filter((t) => t.status === "LOSS").length;
          const winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;

          const totalPnl = closed.reduce((sum, t) => sum + (t.pnl || 0), 0);
          const openPnl = open.reduce((sum, t) => sum + (t.pnl || 0), 0);

          // Calculate average win/loss
          const winningTrades = closed.filter((t) => t.status === "WIN");
          const losingTrades = closed.filter((t) => t.status === "LOSS");
          const avgWin = winningTrades.length > 0
            ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / winningTrades.length
            : 0;
          const avgLoss = losingTrades.length > 0
            ? losingTrades.reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0) / losingTrades.length
            : 0;
          const profitFactor = avgLoss > 0 ? avgWin / avgLoss : avgWin > 0 ? Infinity : 0;

          // Analyze by signal combinations
          const signalAnalysis = {};
          closed.forEach((trade) => {
            const signals = [];
            if (trade.flags?.sq30_release) signals.push("SqueezeRelease");
            if (trade.flags?.sq30_on) signals.push("SqueezeOn");
            if (trade.flags?.phase_zone_change) signals.push("PhaseZoneChange");
            if (trade.inCorridor) signals.push("InCorridor");
            const key = signals.sort().join("+") || "None";
            
            if (!signalAnalysis[key]) {
              signalAnalysis[key] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") signalAnalysis[key].wins++;
            if (trade.status === "LOSS") signalAnalysis[key].losses++;
            signalAnalysis[key].totalPnl += trade.pnl || 0;
          });

          // Analyze by RR ranges
          const rrAnalysis = {};
          closed.forEach((trade) => {
            const rr = trade.rr || 0;
            let range = "Unknown";
            if (rr >= 2.0) range = "RR ‚â• 2.0";
            else if (rr >= 1.5) range = "RR 1.5-2.0";
            else if (rr >= 1.0) range = "RR 1.0-1.5";
            else if (rr > 0) range = "RR < 1.0";
            
            if (!rrAnalysis[range]) {
              rrAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rrAnalysis[range].wins++;
            if (trade.status === "LOSS") rrAnalysis[range].losses++;
            rrAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Analyze by rank ranges
          const rankAnalysis = {};
          closed.forEach((trade) => {
            const rank = trade.rank || 0;
            let range = "Unknown";
            if (rank >= 80) range = "Rank ‚â• 80";
            else if (rank >= 70) range = "Rank 70-80";
            else if (rank >= 60) range = "Rank 60-70";
            else if (rank > 0) range = "Rank < 60";
            
            if (!rankAnalysis[range]) {
              rankAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rankAnalysis[range].wins++;
            if (trade.status === "LOSS") rankAnalysis[range].losses++;
            rankAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Generate recommendations
          const recommendations = [];
          
          // Find best performing signal combinations
          const bestSignals = Object.entries(signalAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 3) // At least 3 trades
            .sort((a, b) => {
              const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
              const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
              return bRate - aRate;
            })
            .slice(0, 3);
          
          if (bestSignals.length > 0 && bestSignals[0][1].wins / (bestSignals[0][1].wins + bestSignals[0][1].losses) >= 0.6) {
            recommendations.push({
              type: "signal",
              priority: "high",
              message: `Focus on setups with: ${bestSignals[0][0]}. Win rate: ${((bestSignals[0][1].wins / (bestSignals[0][1].wins + bestSignals[0][1].losses)) * 100).toFixed(1)}%`,
            });
          }

          // Find best RR range
          const bestRR = Object.entries(rrAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 3)
            .sort((a, b) => {
              const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
              const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
              return bRate - aRate;
            })[0];
          
          if (bestRR && bestRR[1].wins / (bestRR[1].wins + bestRR[1].losses) >= 0.55) {
            recommendations.push({
              type: "rr",
              priority: "medium",
              message: `Best performing RR range: ${bestRR[0]} (${((bestRR[1].wins / (bestRR[1].wins + bestRR[1].losses)) * 100).toFixed(1)}% win rate)`,
            });
          }

          // Find best rank range
          const bestRank = Object.entries(rankAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 3)
            .sort((a, b) => {
              const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
              const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
              return bRate - aRate;
            })[0];
          
          if (bestRank && bestRank[1].wins / (bestRank[1].wins + bestRank[1].losses) >= 0.55) {
            recommendations.push({
              type: "rank",
              priority: "medium",
              message: `Best performing rank range: ${bestRank[0]} (${((bestRank[1].wins / (bestRank[1].wins + bestRank[1].losses)) * 100).toFixed(1)}% win rate)`,
            });
          }

          // Profit factor recommendations
          if (profitFactor < 1.0 && totalTrades >= 10) {
            recommendations.push({
              type: "risk",
              priority: "high",
              message: `Profit factor is ${profitFactor.toFixed(2)}. Consider tightening stops or improving entry selection.`,
            });
          }

          // Win rate recommendations
          if (winRate < 40 && totalTrades >= 10) {
            recommendations.push({
              type: "filter",
              priority: "high",
              message: `Win rate is ${winRate.toFixed(1)}%. Consider raising minimum rank threshold or requiring squeeze release.`,
            });
          }

          return {
            totalTrades,
            wins,
            losses,
            winRate,
            totalPnl,
            openPnl,
            avgWin,
            avgLoss,
            profitFactor,
            signalAnalysis,
            rrAnalysis,
            rankAnalysis,
            recommendations,
          };
        }, [trades]);
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Components
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Format RR display (e.g., "2.10:1" or "1:2.10")
      function formatRR(rr) {
        if (!rr || !Number.isFinite(rr)) return "N/A";
        if (rr >= 1) {
          return `${rr.toFixed(2)}:1`;
        } else {
          return `1:${(1 / rr).toFixed(2)}`;
        }
      }

      function TradeRow({ trade, onTickerClick }) {
        const pnlColor = trade.pnl >= 0 ? "text-green-400" : "text-red-400";
        const statusColor =
          trade.status === "WIN"
            ? "text-green-400"
            : trade.status === "LOSS"
            ? "text-red-400"
            : trade.status === "TP_HIT_TRIM"
            ? "text-blue-400"
            : "text-yellow-400";

        // Calculate position values
        const shares = trade.shares || Math.floor(TRADE_SIZE / (trade.entryPrice || 1)); // Default TRADE_SIZE / entryPrice
        const currentPrice = trade.currentPrice || trade.entryPrice;
        const marketValue = shares * currentPrice;
        const entryValue = shares * trade.entryPrice;
        const trimmedPct = trade.trimmedPct || 0;
        const trimmedShares = Math.floor(shares * trimmedPct);
        const remainingShares = shares - trimmedShares;
        const trimmedValue = trimmedShares > 0 ? trimmedShares * (trade.tp || currentPrice) : 0; // Use TP price when trimmed
        const currentMarketValue = remainingShares * currentPrice;

        const entryDate = new Date(trade.entryTime);
        const formattedDate = entryDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const formattedTime = entryDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });

        return (
          <tr 
            className="border-b border-[#26325f] hover:bg-[#1a2550] cursor-pointer transition-colors"
            onClick={() => onTickerClick && onTickerClick(trade.ticker)}
          >
            <td className="p-2 text-sm">{trade.ticker}</td>
            <td className="p-2 text-sm">
              <span
                className={`px-2 py-1 rounded text-xs ${
                  trade.direction === "LONG"
                    ? "bg-green-500/20 text-green-400"
                    : "bg-red-500/20 text-red-400"
                }`}
              >
                {trade.direction}
              </span>
            </td>
            <td className="p-2 text-sm">${trade.entryPrice.toFixed(2)}</td>
            <td className="p-2 text-sm">${currentPrice.toFixed(2)}</td>
            <td className="p-2 text-xs text-[#93a4d6]">
              <div className="font-semibold text-white">{formattedDate}</div>
              <div className="text-[#6b7a9f]">{formattedTime}</div>
            </td>
            <td className="p-2 text-sm font-mono">
              <div className="text-xs text-[#93a4d6]">Total: {shares}</div>
              {trimmedShares > 0 && (
                <div className="text-xs text-blue-400">Remaining: {remainingShares}</div>
              )}
            </td>
            <td className="p-2 text-sm">
              <div className="text-xs text-[#93a4d6]">Entry: ${entryValue.toFixed(2)}</div>
              <div className={`font-semibold ${trade.status === "OPEN" || trade.status === "TP_HIT_TRIM" ? "text-yellow-400" : ""}`}>
                Current: ${currentMarketValue.toFixed(2)}
              </div>
            </td>
            <td className="p-2 text-sm">
              {trimmedShares > 0 ? (
                <div className="text-xs text-blue-400">
                  <div>${trimmedValue.toFixed(2)}</div>
                  <div className="text-[#93a4d6]">({(trimmedPct * 100).toFixed(0)}%)</div>
                </div>
              ) : (
                <span className="text-xs text-[#6b7a9f]">-</span>
              )}
            </td>
            <td className="p-2 text-sm">${trade.sl.toFixed(2)}</td>
            <td className="p-2 text-sm">${trade.tp.toFixed(2)}</td>
            <td className="p-2 text-sm">{formatRR(trade.rr)}</td>
            <td className="p-2 text-sm">{trade.rank}</td>
            <td className={`p-2 text-sm font-semibold ${pnlColor}`}>
              ${trade.pnl.toFixed(2)}
            </td>
            <td className={`p-2 text-sm font-semibold ${pnlColor}`}>
              {trade.pnlPct.toFixed(2)}%
            </td>
            <td className={`p-2 text-sm font-semibold ${statusColor}`}>
              {trade.status === "TP_HIT_TRIM" 
                ? `TRIMMED (${((trade.trimmedPct || 0) * 100).toFixed(0)}%)`
                : trade.status || "OPEN"}
            </td>
            <td className="p-2 text-xs text-[#93a4d6] font-mono">
              {trade.scriptVersion || "unknown"}
            </td>
          </tr>
        );
      }

      function AnalyticsPanel({ analytics }) {
        return (
          <div className="space-y-4">
            {/* Overall Stats */}
            <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Overall Performance</h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                <div>
                  <div className="text-xs text-[#93a4d6]">Total Trades</div>
                  <div className="text-2xl font-bold">{analytics.totalTrades}</div>
                </div>
                <div>
                  <div className="text-xs text-[#93a4d6]">Win Rate</div>
                  <div className="text-2xl font-bold text-green-400">
                    {analytics.winRate.toFixed(1)}%
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[#93a4d6]">Closed P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.totalPnl >= 0 ? "text-green-400" : "text-red-400"
                    }`}
                  >
                    ${analytics.totalPnl.toFixed(2)}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[#93a4d6]">Open P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.openPnl >= 0 ? "text-green-400" : "text-yellow-400"
                    }`}
                  >
                    ${analytics.openPnl.toFixed(2)}
                  </div>
                </div>
              </div>
              {analytics.totalTrades > 0 && (
                <div className="grid grid-cols-2 md:grid-cols-3 gap-4 pt-4 border-t border-[#26325f]">
                  <div>
                    <div className="text-xs text-[#93a4d6]">Avg Win</div>
                    <div className="text-lg font-bold text-green-400">
                      ${analytics.avgWin.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[#93a4d6]">Avg Loss</div>
                    <div className="text-lg font-bold text-red-400">
                      ${analytics.avgLoss.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[#93a4d6]">Profit Factor</div>
                    <div
                      className={`text-lg font-bold ${
                        analytics.profitFactor >= 1.5
                          ? "text-green-400"
                          : analytics.profitFactor >= 1.0
                          ? "text-yellow-400"
                          : "text-red-400"
                      }`}
                    >
                      {analytics.profitFactor.toFixed(2)}
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Self-Learning Recommendations */}
            {analytics.recommendations && analytics.recommendations.length > 0 && (
              <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                <h3 className="text-lg font-bold mb-4">üéì Self-Learning Recommendations</h3>
                <div className="space-y-2">
                  {analytics.recommendations.map((rec, idx) => (
                    <div
                      key={idx}
                      className={`p-3 rounded-lg border ${
                        rec.priority === "high"
                          ? "bg-yellow-500/10 border-yellow-500/30"
                          : "bg-blue-500/10 border-blue-500/30"
                      }`}
                    >
                      <div className="flex items-start gap-2">
                        <span className="text-lg">
                          {rec.priority === "high" ? "‚ö†Ô∏è" : "üí°"}
                        </span>
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{rec.message}</div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Signal Analysis */}
            <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Signal Performance</h3>
              <div className="space-y-2 max-h-[300px] overflow-y-auto">
                {Object.entries(analytics.signalAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([signals, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={signals}
                        className="flex items-center justify-between p-2 bg-[#0f1630] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">
                            {signals || "No Signals"}
                          </div>
                          <div className="text-xs text-[#93a4d6]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* RR Analysis */}
            <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Risk/Reward Performance</h3>
              <div className="space-y-2">
                {Object.entries(analytics.rrAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[#0f1630] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[#93a4d6]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* Rank Analysis */}
            <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Rank Performance</h3>
              <div className="space-y-2">
                {Object.entries(analytics.rankAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[#0f1630] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[#93a4d6]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Helper Functions for TickerDetails
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(204 + (174 - 204) * t)}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(174 + (156 - 174) * t)}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(156 + (126 - 156) * t)}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(126 + (76 - 126) * t)}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(76 + (57 - 76) * t)}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }

      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        return rank >= 75 && rr >= 1.5 && comp < 0.4 && phase < 0.6 && (aligned || sqRel || phaseZoneChange);
      }

      function completionForSize(ticker) {
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      function computeDynamicRank(ticker) {
        const baseRank = Number(ticker.rank) || 50;
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        let dynamicScore = baseRank;
        if (inCorridor) {
          dynamicScore += 12;
          if (aligned) dynamicScore += 8;
        }
        if (sqRel && inCorridor) dynamicScore += 10;
        if (sqOn && inCorridor && !sqRel) dynamicScore += 5;
        if (rr >= 2.0) dynamicScore += 8;
        else if (rr >= 1.5) dynamicScore += 5;
        else if (rr >= 1.0) dynamicScore += 2;
        if (phase < 0.3) dynamicScore += 6;
        else if (phase < 0.5) dynamicScore += 3;
        else if (phase > 0.7) dynamicScore -= 5;
        if (comp < 0.3) dynamicScore += 5;
        else if (comp > 0.8) dynamicScore -= 8;
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;
        if (phaseZoneChange) dynamicScore += 4;
        return Math.max(0, Math.min(100, Math.round(dynamicScore)));
      }

      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const isAligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback = state === "HTF_BULL_LTF_PULLBACK" || state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        if (comp > 0.8) {
          return { action: "Prepare for Exit / Trim Position", description: `Position has reached ${(comp * 100).toFixed(0)}% completion. Consider taking profits or trimming 50-75% of position.`, color: "text-yellow-400", bg: "bg-yellow-500/20" };
        }
        if (phase > 0.7) {
          return { action: "Wait / Trim Existing Position", description: `Phase oscillator at ${(phase * 100).toFixed(0)}% indicates late-cycle conditions. Wait for pullback or trim existing positions.`, color: "text-orange-400", bg: "bg-orange-500/20" };
        }
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return { action: "Initiate Position - High Conviction", description: `Momentum Elite stock showing Prime setup with exceptional alignment. High-probability setup with strong fundamentals.`, color: "text-green-400", bg: "bg-green-500/20" };
        }
        if (sqRelease && inCorridor && isAligned) {
          return { action: "Initiate Position - Squeeze Release", description: `Squeeze release detected with timeframe alignment in entry corridor. Enter on pullback or break.`, color: "text-green-400", bg: "bg-green-500/20" };
        }
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return { action: "Consider Entry - Favorable Setup", description: `Setup is in entry corridor with both timeframes aligned. Early phase and low completion suggest room to run.`, color: "text-blue-400", bg: "bg-blue-500/20" };
        }
        return { action: "Wait - Setup Not Optimal", description: `Setup not yet optimal for entry. Wait for better conditions or confirmation signals.`, color: "text-[#93a4d6]", bg: "bg-[#26325f]" };
      }

      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL")) return { text: "LONG", color: "text-green-400", bg: "bg-green-500/20" };
        if (state.includes("BEAR")) return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: "‚Äî", color: "text-[#93a4d6]", bg: "bg-[#26325f]" };
      }

      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK") return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL") return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR") return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK") return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map(p => p.state).filter(Boolean);
        for (let i = 1; i < states.length; i++) {
          if (states[i-1] === "HTF_BULL_LTF_PULLBACK" && states[i] === "HTF_BULL_LTF_BULL") {
            patterns.push({ type: "IDEAL_ENTRY", description: "Clean Q1‚ÜíQ2 transition (Bull Entry)", quadrant: "Q1‚ÜíQ2", confidence: "HIGH" });
          }
          if (states[i-1] === "HTF_BEAR_LTF_PULLBACK" && states[i] === "HTF_BEAR_LTF_BEAR") {
            patterns.push({ type: "IDEAL_ENTRY", description: "Clean Q4‚ÜíQ3 transition (Bear Entry)", quadrant: "Q4‚ÜíQ3", confidence: "HIGH" });
          }
        }
        return patterns;
      }

      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = useState([]);
        const [loading, setLoading] = useState(false);
        const [hasLoaded, setHasLoaded] = useState(false);
        useEffect(() => {
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const res = await fetch(`${API_BASE}/timed/trail?ticker=${encodeURIComponent(ticker.ticker)}`);
                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && Array.isArray(data.trail)) {
                    setTrail(data.trail);
                  }
                }
              } catch (e) {
                console.error("Failed to load trail:", e);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300);
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);
        const patterns = detectPatterns(trail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = trail.map(p => getQuadrantFromState(p.state)).filter(Boolean);
        return (
          <div className="mb-4 p-4 bg-[#0f1630] rounded-lg border border-[#26325f]">
            <div className="text-sm font-bold mb-3 text-[#93a4d6]">Quadrant Progression</div>
            <div className="grid grid-cols-2 gap-2 mb-4">
              {[1, 2, 4, 3].map(q => {
                const quad = q === 1 ? { q: 1, name: "Q1", label: "Bull Setup", color: "blue" } :
                             q === 2 ? { q: 2, name: "Q2", label: "Bull Momentum", color: "green" } :
                             q === 4 ? { q: 4, name: "Q4", label: "Bear Setup", color: "orange" } :
                             { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
                const isActive = currentQuad?.q === quad.q;
                const hasHistory = quadHistory.some(qh => qh && qh.q === quad.q);
                return (
                  <div key={q} className={`p-3 rounded-lg border-2 ${
                    isActive ? `border-${quad.color}-400 bg-${quad.color}-500/20` :
                    hasHistory ? `border-${quad.color}-500/50 bg-${quad.color}-500/10` :
                    "border-[#26325f] bg-[#0a0f1f]"
                  }`}>
                    <div className={`text-xs font-bold text-${quad.color}-400`}>{quad.name}: {quad.label}</div>
                  </div>
                );
              })}
            </div>
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs font-bold text-yellow-400 mb-2">üéØ Detected Patterns</div>
                {patterns.map((pattern, idx) => (
                  <div key={idx} className="p-2 rounded border bg-yellow-500/20 border-yellow-400/50 mb-2">
                    <div className="text-xs font-bold text-white">{pattern.description}</div>
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      }

      function TickerDetails({ ticker, onClose, allLoadedData = null }) {
        if (!ticker) return null;
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === 'object') {
            if (Array.isArray(allLoadedData)) return allLoadedData;
            return Object.values(allLoadedData).filter(t => t && typeof t === 'object' && t.ticker);
          }
          return [];
        })();
        const baseScore = Number(ticker.rank) || 0;
        const dynamicRank = computeDynamicRank(ticker);
        const allTickersWithRank = allLoadedTickersArray.map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }));
        const sortedByDynamic = [...allTickersWithRank].sort((a, b) => b.dynamicRank - a.dynamicRank);
        const rankPosition = sortedByDynamic.findIndex(t => String(t.ticker || "").toUpperCase() === String(ticker.ticker || "").toUpperCase()) + 1;
        const totalTickers = allLoadedTickersArray.length;
        return (
          <div className="w-full h-full flex flex-col">
            <div className="bg-[#121a33] border-2 border-[#26325f] rounded-xl w-full h-full flex flex-col slide-in-right shadow-2xl">
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button onClick={onClose} className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]">‚úï</button>
                </div>
                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg">
                    <div className="text-center font-bold text-purple-300 mb-2">üöÄ MOMENTUM ELITE üöÄ</div>
                  </div>
                )}
                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500">‚≠ê PRIME SETUP ‚≠ê</div>
                )}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                      <div className="text-sm text-[#93a4d6] mb-2">Bias / Direction</div>
                      <div className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color}`}>{dir.text === "LONG" ? "üìà LONG" : dir.text === "SHORT" ? "üìâ SHORT" : dir.text}</div>
                    </div>
                  );
                })()}
                <div className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}>
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>{actionInfo.action}</div>
                  <div className="text-sm text-[#93a4d6]">{actionInfo.description}</div>
                </div>
                <QuadrantProgression ticker={ticker} flags={flags} />
                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[#93a4d6]">Phase</span>
                    <span className="text-sm font-semibold" style={{ color: phaseColor }}>{Math.round(phase * 100)}%</span>
                  </div>
                  <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                    <div className="h-full rounded-full transition-all duration-500" style={{ width: `${phase * 100}%`, backgroundColor: phaseColor }} />
                  </div>
                </div>
                <div className="space-y-2.5 text-sm">
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Base Score</span>
                    <span className="font-semibold text-blue-400">{baseScore}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Rank</span>
                    <span className="font-semibold">{rankPosition > 0 ? `#${rankPosition} of ${totalTickers}` : "‚Äî"}</span>
                  </div>
                  {dynamicRank !== baseScore && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Dynamic Score</span>
                      <span className="font-semibold text-green-400">{dynamicRank}</span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">RR</span>
                    <span className="font-semibold">{ticker.rr ? Number(ticker.rr).toFixed(2) : "‚Äî"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">State</span>
                    <span className="font-semibold">{ticker.state || "‚Äî"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Completion</span>
                    <span className="font-semibold">{Math.round(completionForSize(ticker) * 100)}%</span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">{ent.side}</span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Current Price</span>
                    <span className="font-semibold text-lg">{ticker.price ? `$${Number(ticker.price).toFixed(2)}` : "‚Äî"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">TP (Primary)</span>
                    <span className="font-semibold">{ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "‚Äî"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">SL</span>
                    <span className="font-semibold">{ticker.sl ? Number(ticker.sl).toFixed(2) : "‚Äî"}</span>
                  </div>
                </div>
                {(flags.sq30_on || flags.sq30_release || flags.phase_dot || flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[#93a4d6] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">üß® Squeeze ON</span>}
                      {flags.sq30_release && <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">‚ö° Squeeze Release</span>}
                      {flags.phase_dot && <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">Phase Dot</span>}
                      {flags.phase_zone_change && <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">Zone Change</span>}
                    </div>
                  </div>
                )}
              </div>
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[#26325f] bg-[#121a33]">
                <a href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(ticker.ticker)}`} target="_blank" rel="noopener noreferrer" className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold">üìä Open in TradingView</a>
              </div>
            </div>
          </div>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // TickerDetailsLoader - for showing ticker details
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const TickerDetailsLoader = ({ tickerSymbol, onClose, allLoadedData = null }) => {
        const [tickerData, setTickerData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        
        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              const res = await fetch(`${API_BASE}/timed/latest?ticker=${encodeURIComponent(tickerSymbol)}`);
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok || !json.data) {
                throw new Error(json.error || 'Ticker not found');
              }
              setTickerData(json.data || json.latestData);
            } catch (err) {
              console.error('Failed to fetch ticker:', err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };
          fetchTicker();
        }, [tickerSymbol]);
        
        if (loading) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[#0f1630]">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[#93a4d6]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }
        
        if (error || !tickerData) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[#0f1630]">
              <div className="text-center">
                <div className="text-red-400 mb-2">Failed to load {tickerSymbol}</div>
                <div className="text-[#93a4d6] text-sm mb-4">{error || 'No data available'}</div>
                <button onClick={onClose} className="px-4 py-2 bg-[#26325f] hover:bg-[#3a4aa0] rounded-lg text-white">Close</button>
              </div>
            </div>
          );
        }
        
        return <TickerDetails ticker={tickerData} onClose={onClose} allLoadedData={allLoadedData} />;
      };

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Main App
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function App() {
        const { data, loading, error, lastUpdate, refetch } = useTickerData();
        const { trades, loading: tradesLoading, error: tradesError, addTrade, updateTrade, clearTrades, refetch: refetchTrades } = useSimulatedTrades();
        
        // Version filter state
        const [selectedVersion, setSelectedVersion] = useState("all");
        
        // Daily summary state
        const [dailySummary, setDailySummary] = useState(null);
        const [summaryLoading, setSummaryLoading] = useState(false);
        const [showSummary, setShowSummary] = useState(false);
        
        // Selected ticker for detail view
        const [selectedTicker, setSelectedTicker] = useState(null);
        
        // Get unique versions from trades (for dropdown)
        const availableVersions = useMemo(() => {
          const versionSet = new Set(trades.map(t => t.scriptVersion || "unknown").filter(Boolean));
          return Array.from(versionSet).sort().reverse(); // Most recent first
        }, [trades]);
        
        // Filter trades by version (client-side)
        const filteredTrades = useMemo(() => {
          if (selectedVersion === "all") return trades;
          return trades.filter(t => (t.scriptVersion || "unknown") === selectedVersion);
        }, [trades, selectedVersion]);
        
        const analytics = useTradeAnalytics(filteredTrades);

        // Trade simulation is handled by Worker - just refresh trades periodically
        useEffect(() => {
          // Initial fetch on mount
          refetchTrades();
          
          // Refresh trades every 30 seconds to get latest updates from Worker
          const refreshInterval = setInterval(() => {
            refetchTrades();
          }, 30000);
          
          return () => clearInterval(refreshInterval);
        }, [refetchTrades]);

        // Fetch daily summary
        const fetchDailySummary = useCallback(async () => {
          setSummaryLoading(true);
          try {
            const res = await fetch(`${API_BASE}/timed/ai/daily-summary`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) {
              setDailySummary(json);
              setShowSummary(true);
            } else {
              throw new Error(json.error || "Failed to fetch summary");
            }
          } catch (err) {
            console.error("Daily summary error:", err);
            alert(`Failed to fetch daily summary: ${err.message}`);
          } finally {
            setSummaryLoading(false);
          }
        }, []);

        const openTrades = filteredTrades.filter((t) => t.status === "OPEN" || !t.status || t.status === "TP_HIT_TRIM");
        const closedTrades = filteredTrades.filter(
          (t) => t.status === "WIN" || t.status === "LOSS"
        );

        return (
          <div className="min-h-screen p-4">
            <div className="w-full mx-auto px-2">
              {/* Navigation */}
              <nav className="mb-4 p-3 bg-[#121a33] border border-[#26325f] rounded-lg">
                <div className="flex items-center gap-3 flex-wrap">
                  <span className="text-sm text-[#93a4d6]">Navigate:</span>
                  <a
                    href="index-react.html"
                    className="px-3 py-1.5 rounded bg-[#0f1630] border border-[#26325f] text-sm hover:bg-[#1a2550] transition-colors"
                  >
                    Dashboard
                  </a>
                  <a
                    href="simulation-dashboard.html"
                    className="px-3 py-1.5 rounded bg-blue-500/20 border border-blue-500 text-sm text-blue-400 font-semibold"
                  >
                    Trade Tracker
                  </a>
                </div>
              </nav>

              {/* Version Filter */}
              <div className="mb-4 p-3 bg-[#121a33] border border-[#26325f] rounded-lg">
                <div className="flex items-center gap-3 flex-wrap">
                  <span className="text-sm text-[#93a4d6]">Model Version:</span>
                  <select
                    value={selectedVersion}
                    onChange={(e) => setSelectedVersion(e.target.value)}
                    className="px-3 py-1.5 rounded bg-[#0f1630] border border-[#26325f] text-sm text-white hover:bg-[#1a2550] transition-colors"
                  >
                    <option value="all">All Versions ({trades.length} trades)</option>
                    {availableVersions.map((v) => {
                      const count = trades.filter(t => (t.scriptVersion || "unknown") === v).length;
                      return (
                        <option key={v} value={v}>
                          {v} ({count} trades)
                        </option>
                      );
                    })}
                  </select>
                  {selectedVersion !== "all" && (
                    <span className="text-xs text-[#93a4d6]">
                      Showing {filteredTrades.length} of {trades.length} trades
                    </span>
                  )}
                </div>
              </div>

              {/* Header */}
              <header className="mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h1 className="text-3xl font-bold">
                    Timed Trading ‚Äî Trade Tracker
                  </h1>
                  <div className="flex items-center gap-4">
                    {(loading || tradesLoading) && <div className="loading-spinner"></div>}
                    <button
                      onClick={() => { refetch(); refetchTrades(); }}
                      className="px-4 py-2 bg-[#1a2550] border border-[#26325f] rounded-lg hover:bg-[#26325f] transition-colors"
                    >
                      Refresh
                    </button>
                    <button
                      onClick={fetchDailySummary}
                      disabled={summaryLoading}
                      className="px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-colors text-blue-400 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {summaryLoading ? "Loading..." : "üìä Daily Summary"}
                    </button>
                    <button
                      onClick={clearTrades}
                      className="px-4 py-2 bg-red-500/20 border border-red-500 rounded-lg hover:bg-red-500/30 transition-colors text-red-400"
                    >
                      Clear Trades
                    </button>
                    {lastUpdate && (
                      <span className="text-sm text-[#93a4d6]">
                        Updated {lastUpdate.toLocaleTimeString()}
                      </span>
                    )}
                  </div>
                </div>
              </header>

              {/* Daily Summary Modal */}
              {showSummary && dailySummary && (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                  <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-6 max-w-3xl w-full max-h-[90vh] overflow-y-auto">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-2xl font-bold">üìä Daily Summary - {new Date(dailySummary.stats.date).toLocaleDateString()}</h2>
                      <button
                        onClick={() => setShowSummary(false)}
                        className="text-[#93a4d6] hover:text-white text-xl"
                      >
                        ‚úï
                      </button>
                    </div>
                    
                    {/* Stats Grid */}
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                      <div className="bg-[#0f1630] p-3 rounded-lg border border-[#26325f]">
                        <div className="text-xs text-[#93a4d6]">New Trades</div>
                        <div className="text-xl font-bold text-white">{dailySummary.stats.newTrades}</div>
                      </div>
                      <div className="bg-[#0f1630] p-3 rounded-lg border border-[#26325f]">
                        <div className="text-xs text-[#93a4d6]">Closed Trades</div>
                        <div className="text-xl font-bold text-white">{dailySummary.stats.closedTrades}</div>
                      </div>
                      <div className="bg-[#0f1630] p-3 rounded-lg border border-[#26325f]">
                        <div className="text-xs text-[#93a4d6]">Trimmed Trades</div>
                        <div className="text-xl font-bold text-white">{dailySummary.stats.trimmedTrades}</div>
                      </div>
                      <div className="bg-[#0f1630] p-3 rounded-lg border border-[#26325f]">
                        <div className="text-xs text-[#93a4d6]">Win Rate</div>
                        <div className={`text-xl font-bold ${dailySummary.stats.winRate >= 50 ? "text-green-400" : "text-red-400"}`}>
                          {dailySummary.stats.winRate}%
                        </div>
                      </div>
                      <div className="bg-[#0f1630] p-3 rounded-lg border border-[#26325f]">
                        <div className="text-xs text-[#93a4d6]">Closed P&L</div>
                        <div className={`text-xl font-bold ${dailySummary.stats.closedPnl >= 0 ? "text-green-400" : "text-red-400"}`}>
                          ${dailySummary.stats.closedPnl}
                        </div>
                      </div>
                      <div className="bg-[#0f1630] p-3 rounded-lg border border-[#26325f]">
                        <div className="text-xs text-[#93a4d6]">Open P&L</div>
                        <div className={`text-xl font-bold ${dailySummary.stats.openPnl >= 0 ? "text-green-400" : "text-yellow-400"}`}>
                          ${dailySummary.stats.openPnl}
                        </div>
                      </div>
                      <div className="bg-[#0f1630] p-3 rounded-lg border border-[#26325f]">
                        <div className="text-xs text-[#93a4d6]">Total P&L</div>
                        <div className={`text-xl font-bold ${dailySummary.stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}>
                          ${dailySummary.stats.totalPnl}
                        </div>
                      </div>
                    </div>

                    {/* AI Summary */}
                    <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4 mb-4">
                      <h3 className="text-lg font-bold mb-3">ü§ñ AI Analysis & Recommendations</h3>
                      <div className="text-sm text-[#e7ecff] whitespace-pre-wrap leading-relaxed space-y-3">
                        {dailySummary.summary.split('\n\n').map((paragraph, pIdx) => {
                          // Skip empty paragraphs
                          if (!paragraph.trim()) return null;
                          
                          // Check if this is a header (starts with ### or ##)
                          const isHeader = paragraph.trim().match(/^###?\s+(.+)$/);
                          if (isHeader) {
                            const level = paragraph.trim().startsWith('###') ? 3 : 2;
                            return React.createElement(
                              level === 2 ? 'h2' : 'h3',
                              {
                                key: pIdx,
                                className: level === 2 
                                  ? 'text-lg font-bold mt-4 mb-2 text-white border-b border-[#26325f] pb-2'
                                  : 'text-base font-semibold mt-3 mb-2 text-white'
                              },
                              isHeader[1]
                            );
                          }
                          
                          // Regular paragraph
                          return React.createElement('div', {
                            key: pIdx,
                            className: 'mb-3'
                          }, paragraph.split('\n').map((line, lIdx) => {
                            if (!line.trim()) return React.createElement('br', { key: lIdx });
                            
                            // Format markdown-like content
                            let formatted = line;
                            formatted = formatted.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold text-white">$1</strong>');
                            formatted = formatted.replace(/`(.+?)`/g, '<code class="bg-[#26325f] px-1.5 py-0.5 rounded text-xs font-mono text-blue-300">$1</code>');
                            formatted = formatted.replace(/\|/g, '<span class="text-[#6b7a9f] mx-1">|</span>');
                            
                            // Check if it's a list item
                            if (line.trim().startsWith('- ')) {
                              return React.createElement('div', {
                                key: lIdx,
                                className: 'ml-4 mb-1',
                                dangerouslySetInnerHTML: { __html: formatted }
                              });
                            }
                            
                            return React.createElement('p', {
                              key: lIdx,
                              className: 'mb-1',
                              dangerouslySetInnerHTML: { __html: formatted || '&nbsp;' }
                            });
                          }));
                        })}
                      </div>
                    </div>

                    {/* Performance Breakdown */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                        <h4 className="text-sm font-semibold mb-2">Performance by Rank</h4>
                        <div className="space-y-1 text-xs">
                          {Object.entries(dailySummary.stats.rankAnalysis || {}).map(([range, stats]) => (
                            <div key={range} className="flex justify-between">
                              <span className="text-[#93a4d6]">{range}:</span>
                              <span className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}>
                                {stats.wins}W/{stats.losses}L (${stats.totalPnl.toFixed(2)})
                              </span>
                            </div>
                          ))}
                        </div>
                      </div>
                      <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                        <h4 className="text-sm font-semibold mb-2">Performance by RR</h4>
                        <div className="space-y-1 text-xs">
                          {Object.entries(dailySummary.stats.rrAnalysis || {}).map(([range, stats]) => (
                            <div key={range} className="flex justify-between">
                              <span className="text-[#93a4d6]">{range}:</span>
                              <span className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}>
                                {stats.wins}W/{stats.losses}L (${stats.totalPnl.toFixed(2)})
                              </span>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Analytics */}
              <div className="mb-6">
                <AnalyticsPanel analytics={analytics} />
              </div>

              {/* Trades Table with Right Rail Detail View */}
              <div className="flex gap-4 items-start relative">
                {/* Table Container - Left Side */}
                <div className={`flex-1 bg-[#121a33] border border-[#26325f] rounded-xl p-4 transition-all ${selectedTicker ? 'mr-[470px]' : ''}`}>
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-lg font-bold">Simulated Trades</h2>
                    <div className="flex gap-2 text-sm">
                      <span className="px-3 py-1 rounded bg-[#0f1630]">
                        Open: {openTrades.length}
                      </span>
                      <span className="px-3 py-1 rounded bg-[#0f1630]">
                        Closed: {closedTrades.length}
                      </span>
                    </div>
                  </div>
                  <div className="overflow-x-auto -mx-4 px-4">
                    <table className="w-full min-w-full">
                      <thead>
                        <tr className="border-b border-[#26325f] text-left">
                          <th className="p-2 text-xs text-[#93a4d6]">Ticker</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Direction</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Entry</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Current</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Entry Time</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Qty</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Market Value</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Trimmed</th>
                          <th className="p-2 text-xs text-[#93a4d6]">SL</th>
                          <th className="p-2 text-xs text-[#93a4d6]">TP</th>
                          <th className="p-2 text-xs text-[#93a4d6]">RR</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Rank</th>
                          <th className="p-2 text-xs text-[#93a4d6]">P&L</th>
                          <th className="p-2 text-xs text-[#93a4d6]">P&L %</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Status</th>
                          <th className="p-2 text-xs text-[#93a4d6]">Version</th>
                        </tr>
                      </thead>
                      <tbody>
                        {filteredTrades.length === 0 ? (
                          <tr>
                            <td colSpan="16" className="p-8 text-center text-[#93a4d6]">
                              {selectedVersion === "all" 
                                ? "No trades yet. Trades will be automatically created when alerts trigger."
                                : `No trades found for version ${selectedVersion}.`}
                            </td>
                          </tr>
                        ) : (
                          filteredTrades.map((trade) => (
                            <TradeRow key={trade.id} trade={trade} onTickerClick={setSelectedTicker} />
                          ))
                        )}
                      </tbody>
                    </table>
                  </div>
                </div>

                {/* Right Rail - Detail View (slides in from right) */}
                {selectedTicker && (
                  <div className="absolute right-0 top-0 w-[450px] h-screen bg-[#0f1630] border-l border-[#26325f] z-40 slide-in-right shadow-2xl">
                    <TickerDetailsLoader 
                      tickerSymbol={selectedTicker} 
                      onClose={() => setSelectedTicker(null)}
                      allLoadedData={data}
                    />
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Render
      try {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          throw new Error("React or ReactDOM not loaded");
        }

        const rootElement = document.getElementById("root");
        if (!rootElement) {
          throw new Error("Root element not found");
        }

        if (ReactDOM.createRoot) {
          const root = ReactDOM.createRoot(rootElement);
          root.render(<App />);
        } else {
          ReactDOM.render(<App />, rootElement);
        }
      } catch (error) {
        console.error("Error rendering app:", error);
        document.getElementById("root").innerHTML = `
          <div style="padding: 40px; text-align: center; color: #e7ecff;">
            <h2 style="color: #e74c3c;">Error Loading Dashboard</h2>
            <p>${error.message}</p>
            <p style="margin-top: 20px; color: #93a4d6;">
              Please check the browser console (F12) for details.
            </p>
          </div>
        `;
      }
    </script>
  </body>
</html>

