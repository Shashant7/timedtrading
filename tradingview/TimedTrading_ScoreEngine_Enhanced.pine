//@version=6
indicator("TimedTrading", overlay=false, max_labels_count=50)

// Script version for data model versioning
SCRIPT_VERSION = "2.5.0"

//─────────────────────────────────────────────────────────────────────────────
// Inputs
//─────────────────────────────────────────────────────────────────────────────
groupAxes = "Axes & Timeframes"
tfW   = input.string("W",   "HTF #1 (Weekly)", group=groupAxes)
tfD   = input.string("D",   "HTF #2 (Daily)",  group=groupAxes)
tf4H  = input.string("240", "HTF #3 (4H)",     group=groupAxes)
tf1H  = input.string("60",  "HTF #4 (1H Bridge)", group=groupAxes)

tf30  = input.string("30", "LTF #1 (30m)", group=groupAxes)
tf10  = input.string("10", "LTF #2 (10m)", group=groupAxes)
tf3   = input.string("3",  "LTF #3 (3m)",  group=groupAxes)

// Base weights (will be adjusted by volatility)
wW  = input.float(0.50, "HTF Weekly base weight", group=groupAxes, minval=0, maxval=1)
wD  = input.float(0.35, "HTF Daily base weight",  group=groupAxes, minval=0, maxval=1)
w4H = input.float(0.10, "HTF 4H base weight",     group=groupAxes, minval=0, maxval=1)
w1H = input.float(0.05, "HTF 1H base weight",     group=groupAxes, minval=0, maxval=1)

w30 = input.float(0.60, "LTF 30m base weight", group=groupAxes, minval=0, maxval=1)
w10 = input.float(0.30, "LTF 10m base weight", group=groupAxes, minval=0, maxval=1)
w3  = input.float(0.10, "LTF 3m base weight",  group=groupAxes, minval=0, maxval=1)

// Adaptive features
useVolatilityAdjust = input.bool(true, "Volatility-adjusted weights", group=groupAxes)
useSessionAware = input.bool(true, "Session-aware LTF weights (RTH)", group=groupAxes)
useAssetAdaptive = input.bool(true, "Asset-class adaptive timeframes", group=groupAxes)

groupST = "SuperTrend (Phoenix default)"
stLen   = input.int(10, "ST ATR Length", group=groupST, minval=1)
stFac   = input.float(3.0, "ST Factor",  group=groupST, minval=0.1, step=0.1)

groupEMA = "EMAs (Phoenix default)"
emaFastLen = input.int(5,  "Fast EMA", group=groupEMA, minval=1)
emaSlowLen = input.int(48, "Slow EMA", group=groupEMA, minval=1)

groupSqueeze = "TTM Squeeze"
sqLen   = input.int(20,   "Squeeze length", group=groupSqueeze, minval=5)
bbMult  = input.float(2.0,"BB stdev mult",  group=groupSqueeze, step=0.1)
kcMult  = input.float(1.5,"KC ATR mult",    group=groupSqueeze, step=0.1)
momLen  = input.int(20,   "Momentum len (linreg)", group=groupSqueeze, minval=5)

groupGG = "Golden Gate (Distance-based)"
useGoldenGate = input.bool(true, "Include Golden Gate in LTF score", group=groupGG)
ggATRmult      = input.float(0.382, "GG ATR mult (PC ± mult*ATRd)", group=groupGG, step=0.001)
ggDistanceMode = input.bool(true, "Distance-based GG (vs binary cross)", group=groupGG)

groupPhase = "Phase (Multi-factor)"
phaseExitAbs = input.float(61.8, "Phase band (|osc|) reference", group=groupPhase, step=0.1)
phaseMaxAbs  = input.float(100.0,"Phase max for % (cap)", group=groupPhase, step=0.1)
useMultiFactorPhase = input.bool(true, "Multi-factor phase (price+momentum+volume)", group=groupPhase)
usePhaseZones = input.bool(true, "Graduated phase zones", group=groupPhase)

groupTP = "TP/SL (Dynamic)"
expMoveATRx = input.float(2.0, "Expected move = ATRw × (swing)", group=groupTP, step=0.1, minval=0.1)
useDynamicTP = input.bool(true, "Dynamic TP based on swing size", group=groupTP)
useEnhancedTP = input.bool(true, "Enhanced TP: ATR ladder levels", group=groupTP)
minTPDistanceATR = input.float(1.0, "Min TP distance from trigger (ATR multiple)", group=groupTP, step=0.1, minval=0.5)
useVolatilitySL = input.bool(true, "Volatility-adjusted SL", group=groupTP)
usePivotSR = input.bool(true, "Pivot-based S/R integration", group=groupTP)
pivotLookback = input.int(5, "Pivot lookback", group=groupTP, minval=3, maxval=10)

// Intelligent TP Features
groupIntelligentTP = "TP: Intelligent Features"
useChartPatterns = input.bool(true, "Chart Patterns & Measured Moves", group=groupIntelligentTP)
useHTFStructure = input.bool(true, "HTF Structure (Highs/Lows)", group=groupIntelligentTP)
useLiquidityZones = input.bool(true, "Buyside/Sellside Liquidity", group=groupIntelligentTP)
useFVG = input.bool(true, "Fair Value Gap (FVG) Analysis", group=groupIntelligentTP)
useGapAnalysis = input.bool(true, "Open Gap Analysis", group=groupIntelligentTP)

liquidityTolerance = input.float(0.5, "Liquidity zone tolerance (% of ATR)", group=groupIntelligentTP, step=0.1, minval=0.1)
fvgMinSize = input.float(0.3, "FVG min size (ATR multiple)", group=groupIntelligentTP, step=0.1, minval=0.1)
gapMinSize = input.float(0.5, "Gap min size (ATR multiple)", group=groupIntelligentTP, step=0.1, minval=0.1)

groupAlerts = "Alerts (Baseline + Meaningful change)"
scoreDelta = input.float(3.0, "Min |Δscore| to resend (0=always send)", group=groupAlerts, minval=0, step=0.5)
minMinutesBetweenSends = input.int(5, "Min minutes between sends (0=no throttle)", group=groupAlerts, minval=0)
forceBaseline = input.bool(false, "FORCE: Send baseline every bar (temporary)", group=groupAlerts)

// Note: TradingView Watchlist Alerts have a platform limitation - equity alerts may not fire during extended hours
// (pre-market 4am-9am ET, after-hours 4pm-8pm ET) even if bars are forming. This is a TradingView limitation, not a script issue.
// 24-hour markets (futures ES/NQ, crypto BTC/ETH) will continue to fire during extended hours.
// The session check below is kept for individual chart alerts, but watchlist alerts are restricted by TradingView.
bypassSessionCheck = input.bool(false, "Bypass Session Check (for individual chart alerts)", group=groupAlerts, tooltip="Bypass session restrictions. Note: Watchlist alerts are still limited by TradingView during extended hours.")
periodicUpdateMinutes = input.int(5, "Periodic update interval (minutes, 0=disabled)", group=groupAlerts, minval=0, tooltip="Send update even if no change, to maintain current data. Set to 5 to ensure all watchlist tickers are always current.")
debugHeartbeat = input.bool(false, "DEBUG: Heartbeat alert every bar close", group=groupAlerts)

//─────────────────────────────────────────────────────────────────────────────
// Utils
//─────────────────────────────────────────────────────────────────────────────
clamp(x, lo, hi) => math.max(lo, math.min(hi, x))
prevBoolSeries(b) => bar_index > 0 ? b[1] : false

f_fmt(x, dec) =>
    dec <= 0 ? str.tostring(math.round(x)) :
     str.tostring(math.round(x * math.pow(10, dec)) / math.pow(10, dec))

// Asset class detection
f_is_crypto() =>
    ticker = syminfo.ticker
    str.contains(ticker, "USD") or str.contains(ticker, "USDT") or str.contains(ticker, "BTC") or str.contains(ticker, "ETH")

f_is_futures() =>
    str.contains(syminfo.ticker, "1!")

f_is_forex() =>
    str.contains(syminfo.ticker, "DXY") or str.contains(syminfo.ticker, "EUR") or str.contains(syminfo.ticker, "GBP")

// Session detection (for equities)
// Note: TradingView Watchlist Alerts are restricted during extended hours for equities (platform limitation)
// This session check is mainly for individual chart alerts. Watchlist alerts will be limited by TradingView regardless.
f_is_rth() =>
    hour(time, "America/New_York") >= 9 and hour(time, "America/New_York") < 16

// Check if current session allows alerts
f_is_allowed_session() =>
    // Bypass option for individual chart alerts (doesn't affect TradingView's watchlist alert restrictions)
    if bypassSessionCheck
        true
    // Crypto, futures, forex: always allow (24/7 trading)
    else if f_is_crypto() or f_is_futures() or f_is_forex()
        true
    else
        // Equities: Allow during Regular Trading Hours (9am-4pm ET)
        // Extended hours (4am-9am, 4pm-8pm) may work for individual chart alerts but not watchlist alerts
        // This is a TradingView platform limitation, not a script limitation
        f_is_rth()

//─────────────────────────────────────────────────────────────────────────────
// DAILY anchors (Golden Gate) - Combined to reduce request.security calls
//─────────────────────────────────────────────────────────────────────────────
f_daily_anchors() =>
    [close[1], ta.atr(14)]
[dailyClose, dailyATR] = request.security(syminfo.tickerid, "D", f_daily_anchors(), barmerge.gaps_off, barmerge.lookahead_off)
PCd  = dailyClose
ATRd = dailyATR
GGup = PCd + ggATRmult * ATRd
GGdn = PCd - ggATRmult * ATRd

//─────────────────────────────────────────────────────────────────────────────
// WEEKLY anchors (Swing mode: 1–4 weeks) - Combined to reduce request.security calls
//─────────────────────────────────────────────────────────────────────────────
f_weekly_anchors() =>
    [close[1], ta.atr(14), ta.highest(high, 20), ta.lowest(low, 20)]
[weeklyClose, weeklyATR, weeklyHigh, weeklyLow] = request.security(syminfo.tickerid, "W", f_weekly_anchors(), barmerge.gaps_off, barmerge.lookahead_off)
PCw  = weeklyClose
ATRw = weeklyATR
recentSwingHighW = weeklyHigh
recentSwingLowW  = weeklyLow
recentSwingW = recentSwingHighW - recentSwingLowW

// 4H anchors (for Position/Swing ATR levels) - Combined to reduce request.security calls
f_4h_anchors() =>
    [close[1], ta.atr(14)]
[fourHClose, fourHATR] = request.security(syminfo.tickerid, "240", f_4h_anchors(), barmerge.gaps_off, barmerge.lookahead_off)
PC4H  = fourHClose
ATR4H = fourHATR

//─────────────────────────────────────────────────────────────────────────────
// EMA Cloud Calculations (for holding winners logic)
//─────────────────────────────────────────────────────────────────────────────
// Daily: 5-8 EMA Cloud
f_daily_ema_cloud() =>
    ema5 = ta.ema(close, 5)
    ema8 = ta.ema(close, 8)
    upperEMA = math.max(ema5, ema8)
    lowerEMA = math.min(ema5, ema8)
    currentPrice = close
    // Determine position: "above", "below", or "within"
    position = currentPrice > upperEMA ? "above" : currentPrice < lowerEMA ? "below" : "within"
    [upperEMA, lowerEMA, currentPrice, position]

[dailyEMAUpper, dailyEMALower, dailyPrice, dailyEMAPosition] = request.security(syminfo.tickerid, "D", f_daily_ema_cloud(), barmerge.gaps_off, barmerge.lookahead_off)

// 4H: 8-13 EMA Cloud
f_4h_ema_cloud() =>
    ema8 = ta.ema(close, 8)
    ema13 = ta.ema(close, 13)
    upperEMA = math.max(ema8, ema13)
    lowerEMA = math.min(ema8, ema13)
    currentPrice = close
    // Determine position: "above", "below", or "within"
    position = currentPrice > upperEMA ? "above" : currentPrice < lowerEMA ? "below" : "within"
    [upperEMA, lowerEMA, currentPrice, position]

[fourHEMAUpper, fourHEMALower, fourHPrice, fourHEMAPosition] = request.security(syminfo.tickerid, "240", f_4h_ema_cloud(), barmerge.gaps_off, barmerge.lookahead_off)

// 1H: 13-21 EMA Cloud
f_1h_ema_cloud() =>
    ema13 = ta.ema(close, 13)
    ema21 = ta.ema(close, 21)
    upperEMA = math.max(ema13, ema21)
    lowerEMA = math.min(ema13, ema21)
    currentPrice = close
    // Determine position: "above", "below", or "within"
    position = currentPrice > upperEMA ? "above" : currentPrice < lowerEMA ? "below" : "within"
    [upperEMA, lowerEMA, currentPrice, position]

[oneHEMAUpper, oneHEMALower, oneHPrice, oneHEMAPosition] = request.security(syminfo.tickerid, "60", f_1h_ema_cloud(), barmerge.gaps_off, barmerge.lookahead_off)

//─────────────────────────────────────────────────────────────────────────────
// Enhanced bundle: includes volume and RSI
//─────────────────────────────────────────────────────────────────────────────
f_tf_bundle() =>
    e5   = ta.ema(close, 5)
    e8   = ta.ema(close, 8)
    e13  = ta.ema(close, 13)
    e21  = ta.ema(close, 21)
    e48  = ta.ema(close, 48)
    e200 = ta.ema(close, 200)

    eFast = ta.ema(close, emaFastLen)
    eSlow = ta.ema(close, emaSlowLen)

    [stLine, stDir] = ta.supertrend(stFac, stLen)

    basis = ta.sma(close, sqLen)
    dev   = bbMult * ta.stdev(close, sqLen)
    bbU   = basis + dev
    bbL   = basis - dev
    atrKC = ta.atr(sqLen)
    kcU   = basis + kcMult * atrKC
    kcL   = basis - kcMult * atrKC
    sqOn  = (bbU < kcU) and (bbL > kcL)

    mom = ta.linreg(close - ta.sma(close, momLen), momLen, 0)
    momStd = ta.stdev(mom, 20)

    // Volume
    vol = volume
    volSma = ta.sma(vol, 20)
    volRatio = volSma > 0 ? vol / volSma : 1.0

    // RSI for mean reversion
    rsi = ta.rsi(close, 14)

    // Multi-factor phase
    piv = ta.ema(close, 21)
    a14 = ta.atr(14)
    pricePhase = a14 == 0 ? 0.0 : ((close - piv) / (3.0 * a14)) * 100.0
    momentumPhase = momStd > 0 ? (mom / momStd) * 20.0 : 0.0
    volumePhase = (volRatio - 1.0) * 30.0
    
    rawPhase = useMultiFactorPhase ? (pricePhase * 0.6) + (momentumPhase * 0.3) + (volumePhase * 0.1) : pricePhase
    phaseOsc = ta.ema(rawPhase, 3)

    // Phase velocity
    phaseVelocity = phaseOsc - phaseOsc[1]
    phaseAccel = phaseVelocity - phaseVelocity[1]

    // Phase zones
    phaseAbs = math.abs(phaseOsc)
    phaseZone = usePhaseZones ? (phaseAbs > 100 ? "EXTREME" : phaseAbs > 61.8 ? "HIGH" : phaseAbs > 38.2 ? "MEDIUM" : "LOW") : (phaseAbs > phaseExitAbs ? "HIGH" : "LOW")

    bbo = 2.0 * ta.stdev(close, 21)
    bup = piv + bbo
    bdn = piv - bbo
    ctU = piv + (2.0 * a14)
    ctD = piv - (2.0 * a14)
    exU = piv + (1.854 * a14)
    exD = piv - (1.854 * a14)
    above = close >= piv
    comp  = above ? (bup - ctU) : (ctD - bdn)
    inExp = above ? (bup - exU) : (exD - bdn)
    expanding = bar_index > 0 ? (comp[1] <= comp) : false
    compressed = (not (expanding and inExp > 0)) and (comp <= 0)

    // ATR for volatility
    atr14 = ta.atr(14)
    atrSma = ta.sma(atr14, 20)
    atrRatio = atrSma > 0 ? atr14 / atrSma : 1.0

    ggUpCross = ta.crossover(close, GGup)
    ggDnCross = ta.crossunder(close, GGdn)

    // Distance to Golden Gate
    ggDist = math.max(0, math.min(1, close >= PCd ? ((close - GGdn) / (GGup - GGdn)) : ((GGup - close) / (GGup - GGdn))))

    [close, e5, e8, e13, e21, e48, e200, eFast, eSlow, stLine, stDir, sqOn, mom, momStd, phaseOsc, phaseVelocity, phaseAccel, phaseZone, compressed, ggUpCross, ggDnCross, ggDist, volRatio, rsi, atrRatio]

f_get_bundle(tf) =>
    request.security(syminfo.tickerid, tf, f_tf_bundle(), barmerge.gaps_off, barmerge.lookahead_off)

// Pull bundles
[cW, e5W, e8W, e13W, e21W, e48W, e200W, eFastW, eSlowW, stLW, stDW, sqW, momW, momStdW, phW, phVelW, phAccW, phZoneW, compW, ggUpW, ggDnW, ggDistW, volRW, rsiW, atrRW] = f_get_bundle(tfW)
[cD, e5D, e8D, e13D, e21D, e48D, e200D, eFastD, eSlowD, stLD, stDD, sqD, momD, momStdD, phD, phVelD, phAccD, phZoneD, compD, ggUpD, ggDnD, ggDistD, volRD, rsiD, atrRD] = f_get_bundle(tfD)
[c4, e5H, e8H, e13H, e21H, e48H, e200H, eFast4, eSlow4, stL4, stD4, sq4, mom4, momStd4, ph4, phVel4, phAcc4, phZone4, comp4, ggUp4, ggDn4, ggDist4, volR4, rsi4, atrR4] = f_get_bundle(tf4H)
[c1, e5_1, e8_1, e13_1, e21_1, e48_1, e200_1, eFast1, eSlow1, stL1, stD1, sq1, mom1, momStd1, ph1, phVel1, phAcc1, phZone1, comp1, ggUp1, ggDn1, ggDist1, volR1, rsi1, atrR1] = f_get_bundle(tf1H)

[c30, e5_30, e8_30, e13_30, e21_30, e48_30, e200_30, eFast30, eSlow30, stL30, stD30, sq30, mom30, momStd30, ph30, phVel30, phAcc30, phZone30, comp30, ggUp30, ggDn30, ggDist30, volR30, rsi30, atrR30] = f_get_bundle(tf30)
[c10, e5_10, e8_10, e13_10, e21_10, e48_10, e200_10, eFast10, eSlow10, stL10, stD10, sq10, mom10, momStd10, ph10, phVel10, phAcc10, phZone10, comp10, ggUp10, ggDn10, ggDist10, volR10, rsi10, atrR10] = f_get_bundle(tf10)
[c3,  e5_3,  e8_3,  e13_3,  e21_3,  e48_3,  e200_3,  eFast3,  eSlow3,  stL3,  stD3,  sq3,  mom3,  momStd3,  ph3,  phVel3,  phAcc3,  phZone3,  comp3,  ggUp3,  ggDn3,  ggDist3,  volR3,  rsi3,  atrR3 ] = f_get_bundle(tf3)

//─────────────────────────────────────────────────────────────────────────────
// Enhanced HTF Scoring
//─────────────────────────────────────────────────────────────────────────────
f_htf_from_bundle(px, ema200, stDir, e5, e8, e13, e21, e48, comp, osc, eFast, eSlow, volRatio, atrRatio) =>
    // Trend bias (unchanged)
    trendBias = (px >= ema200 ? 10.0 : -10.0) + (stDir < 0 ? 10.0 : -10.0)

    // GRADUATED STRUCTURE SCORING (not binary)
    stackScore = 0.0
    if e5 > e8
        stackScore += 2.0
    if e8 > e13
        stackScore += 2.5
    if e13 > e21
        stackScore += 2.5
    if e21 > e48
        stackScore += 3.0
    // Partial stacks get partial credit
    slope48Up = e48 > e48[1]
    structure = (stackScore > 0 ? stackScore : (stackScore < 0 ? stackScore : 0.0)) + (slope48Up ? 5.0 : -5.0)

    // MULTI-FACTOR REGIME DETECTION
    bias = (trendBias >= 0) ? 1 : -1
    regimeScore = 0.0
    
    // Compression factor
    if comp
        regimeScore += (bias == 1 ? 5.0 : -5.0)
    
    // Phase exhaustion
    phaseExtreme = math.abs(osc) > phaseExitAbs
    if phaseExtreme
        regimeScore -= 3.0
    
    // ATR expansion/contraction
    atrExpansion = atrRatio > 1.1
    if atrExpansion and not comp
        regimeScore += 2.0
    
    // Volume regime
    if volRatio > 1.3
        regimeScore += 1.0
    if volRatio < 0.7
        regimeScore -= 0.5

    // Momentum component
    momC = (eFast >= eSlow) ? 5.0 : -5.0
    
    // VOLUME-WEIGHTED MOMENTUM BOOST
    volBoost = volRatio > 1.2 ? 3.0 : (volRatio < 0.8 ? -2.0 : 0.0)
    momC += volBoost

    clamp(trendBias + structure + regimeScore + momC, -50, 50)

//─────────────────────────────────────────────────────────────────────────────
// Enhanced LTF Scoring
//─────────────────────────────────────────────────────────────────────────────
f_ltf_from_bundle(px, sqOn, mom, momStd, ggUpCross, ggDnCross, ggDist, e21, e48, e5, e13, stLine, stDir, comp, volRatio, rsi, atrRatio) =>
    sqPrev = prevBoolSeries(sqOn)
    release = sqPrev and not sqOn
    
    // MOMENTUM-NORMALIZED SQUEEZE RELEASE
    relDir = release ? (mom >= 0 ? 1 : -1) : 0
    momStrength = (momStd > 0) ? math.min(1.5, math.abs(mom) / momStd) : 1.0
    trig = release ? (relDir == 1 ? 8.0 : -8.0) * momStrength : 0.0

    // DISTANCE-BASED GOLDEN GATE (vs binary cross)
    gg = 0.0
    if useGoldenGate
        if ggDistanceMode
            // Distance-based scoring
            if ggDist > 0.8
                gg += 6.0
            if ggDist < 0.2
                gg -= 4.0
            // Proximity bonus
            if math.abs(px - GGup) < ATRd * 0.1
                gg += 2.0
            if math.abs(px - GGdn) < ATRd * 0.1
                gg -= 2.0
        else
            // Binary cross (original)
            gg += ggUpCross ? 8.0 : 0.0
            gg += ggDnCross ? -8.0 : 0.0
    trigger = trig + gg

    // Alignment
    align = (px >= e21 ? 6.0 : -6.0) + (px >= e48 ? 6.0 : -6.0)
    bullStack = (e5 > e13) and (e13 > e21) and (e21 > e48)
    bearStack = (e5 < e13) and (e13 < e21) and (e21 < e48)
    align += (bullStack ? 3.0 : bearStack ? -3.0 : 0.0)

    // GRADUATED SUPERTREND SUPPORT (distance-based)
    stSlopeUp = stLine > stLine[1]
    stSlopeDn = stLine < stLine[1]
    stDist = atrRatio > 0 ? math.abs(px - stLine) / (atrRatio * ATRd) : 999
    stSupport = 0.0
    if stDir < 0 and stSlopeUp and px > stLine
        stSupport := 10.0 * math.max(0, 1.0 - stDist / 2.0)  // Fade with distance
    if stDir > 0 and stSlopeDn and px < stLine
        stSupport := -10.0 * math.max(0, 1.0 - stDist / 2.0)

    // RSI MEAN REVERSION COMPONENT
    meanRev = rsi > 70 ? -4.0 : (rsi < 30 ? 4.0 : 0.0)

    guard = (sqOn ? -3.0 : 0.0) + (comp ? -2.0 : 0.0)

    clamp(trigger + align + stSupport + meanRev + guard, -50, 50)

// HTF scores
htfWScore  = f_htf_from_bundle(cW, e200W, stDW, e5W, e8W, e13W, e21W, e48W, compW, phW, eFastW, eSlowW, volRW, atrRW)
htfDScore  = f_htf_from_bundle(cD, e200D, stDD, e5D, e8D, e13D, e21D, e48D, compD, phD, eFastD, eSlowD, volRD, atrRD)
htf4HScore = f_htf_from_bundle(c4, e200H, stD4, e5H, e8H, e13H, e21H, e48H, comp4, ph4, eFast4, eSlow4, volR4, atrR4)
htf1HScore = f_htf_from_bundle(c1, e200_1, stD1, e5_1, e8_1, e13_1, e21_1, e48_1, comp1, ph1, eFast1, eSlow1, volR1, atrR1)

// LTF scores
ltf30Score = f_ltf_from_bundle(c30, sq30, mom30, momStd30, ggUp30, ggDn30, ggDist30, e21_30, e48_30, e5_30, e13_30, stL30, stD30, comp30, volR30, rsi30, atrR30)
ltf10Score = f_ltf_from_bundle(c10, sq10, mom10, momStd10, ggUp10, ggDn10, ggDist10, e21_10, e48_10, e5_10, e13_10, stL10, stD10, comp10, volR10, rsi10, atrR10)
ltf3Score  = f_ltf_from_bundle(c3,  sq3,  mom3,  momStd3,  ggUp3,  ggDn3,  ggDist3,  e21_3,  e48_3,  e5_3,  e13_3,  stL3,  stD3,  comp3,  volR3,  rsi3,  atrR3)

//─────────────────────────────────────────────────────────────────────────────
// Volatility-adjusted weights
//─────────────────────────────────────────────────────────────────────────────
f_volatility_adjusted_weights(wW_base, wD_base, w4H_base, w1H_base, atrRW, atrRD, atrR4, atrR1) =>
    if not useVolatilityAdjust
        [wW_base, wD_base, w4H_base, w1H_base]
    else
        // High vol → favor Daily/4H/1H, Low vol → favor Weekly
        volW = atrRW
        volD = atrRD
        vol4H = atrR4
        vol1H = atrR1
        
        // Adjust based on volatility ratios
        wW_adj = volW > 1.5 ? wW_base * 0.7 : wW_base * 1.2
        wD_adj = volD > 1.3 ? wD_base * 1.2 : wD_base * 0.9
        w4H_adj = vol4H > 1.2 ? w4H_base * 1.3 : w4H_base * 0.8
        w1H_adj = vol1H > 1.1 ? w1H_base * 1.2 : w1H_base * 0.9
        
        // Normalize
        total = wW_adj + wD_adj + w4H_adj + w1H_adj
        [wW_adj / total, wD_adj / total, w4H_adj / total, w1H_adj / total]

[wW_adj, wD_adj, w4H_adj, w1H_adj] = f_volatility_adjusted_weights(wW, wD, w4H, w1H, atrRW, atrRD, atrR4, atrR1)

// Session-aware LTF weights
f_session_adjusted_ltf_weights(w30_base, w10_base, w3_base) =>
    if not useSessionAware or not f_is_rth()
        [w30_base, w10_base, w3_base]
    else
        // RTH: favor 30m, reduce 3m
        w30_adj = w30_base * 1.15
        w10_adj = w10_base * 1.0
        w3_adj = w3_base * 0.7
        total = w30_adj + w10_adj + w3_adj
        [w30_adj / total, w10_adj / total, w3_adj / total]

[w30_adj, w10_adj, w3_adj] = f_session_adjusted_ltf_weights(w30, w10, w3)

// Blend HTF
htfScore = clamp(htfWScore*wW_adj + htfDScore*wD_adj + htf4HScore*w4H_adj + htf1HScore*w1H_adj, -50, 50)

// Blend LTF
ltfScore = clamp(ltf30Score*w30_adj + ltf10Score*w10_adj + ltf3Score*w3_adj, -50, 50)

// State
htfBull = htfScore >= 0
ltfBull = ltfScore >= 0
state =
     htfBull and not ltfBull ? "HTF_BULL_LTF_PULLBACK" :
     htfBull and ltfBull     ? "HTF_BULL_LTF_BULL" :
     (not htfBull) and (not ltfBull) ? "HTF_BEAR_LTF_BEAR" :
                                       "HTF_BEAR_LTF_PULLBACK"

// Phase % (using Daily multi-factor phase)
phaseD = phD
phasePct = clamp(math.abs(phaseD) / math.max(phaseMaxAbs, 1e-9), 0, 1)
phaseDir = phaseD > 0 ? "bull" : phaseD < 0 ? "bear" : "flat"
phaseZoneD = phZoneD

// Phase dot (enhanced with zone transitions)
phasePrev = bar_index > 0 ? phaseD[1] : na
phaseZonePrev = bar_index > 0 ? phZoneD[1] : ""
phaseLeaveUp   = (not na(phasePrev)) and (phasePrev >=  phaseExitAbs) and (phaseD <  phaseExitAbs)
phaseLeaveDn   = (not na(phasePrev)) and (phasePrev <= -phaseExitAbs) and (phaseD > -phaseExitAbs)
phaseLeave100U = (not na(phasePrev)) and (phasePrev >=  100) and (phaseD < 100)
phaseLeave100D = (not na(phasePrev)) and (phasePrev <= -100) and (phaseD > -100)
phaseZoneChange = usePhaseZones and (phaseZoneD != phaseZonePrev)
phaseDot = phaseLeaveUp or phaseLeaveDn or phaseLeave100U or phaseLeave100D or phaseZoneChange

//─────────────────────────────────────────────────────────────────────────────
// Momentum Elite Detection (Simplified - Worker handles full calculation)
//─────────────────────────────────────────────────────────────────────────────
// Note: Full Momentum Elite calculation is now done in the Worker for better
// performance and access to external APIs. This is a simplified check that
// passes basic data to the Worker for final determination.
// 
// Basic price check (Worker will validate market cap, ADR, volume, momentum)
priceOver4 = close >= 4.0
// Worker will calculate full Momentum Elite status and set flags.momentum_elite
momentumElite = false  // Placeholder - Worker sets this in flags

//─────────────────────────────────────────────────────────────────────────────
// Enhanced Trigger + completion
//─────────────────────────────────────────────────────────────────────────────
sq30_prev = prevBoolSeries(sq30)
sq30_rel  = sq30_prev and not sq30
rel30Dir  = sq30_rel ? (mom30 >= 0 ? 1 : -1) : 0

crossUp30 = ta.crossover(eFast30, eSlow30)
crossDn30 = ta.crossunder(eFast30, eSlow30)

htfBiasSign = htfBull ? 1 : -1

goEvent =
     (sq30_rel and rel30Dir == htfBiasSign) or
     (crossUp30 and htfBull) or
     (crossDn30 and not htfBull)

// Trigger metadata
var string triggerReason = ""
var string triggerDirStr = ""
var float  triggerPrice  = na
var int    triggerTs     = na

if barstate.isconfirmed and goEvent
    triggerPrice := c30
    triggerTs    := time

    if (sq30_rel and rel30Dir == htfBiasSign)
        triggerReason := "SQUEEZE_RELEASE"
        triggerDirStr := rel30Dir == 1 ? "BULL" : "BEAR"
    else if (crossUp30 and htfBull)
        triggerReason := "EMA_CROSS"
        triggerDirStr := "BULL"
    else if (crossDn30 and not htfBull)
        triggerReason := "EMA_CROSS"
        triggerDirStr := "BEAR"
    else
        triggerReason := "OTHER"
        triggerDirStr := (htfBull ? "BULL" : "BEAR")

// Dynamic expected move (using recent swing calculation)
expectedMove = useDynamicTP ? expMoveATRx * math.max(ATRw, recentSwingW * 0.5) : expMoveATRx * ATRw

completion = na(triggerPrice) or expectedMove <= 0 ? 0.0 : clamp(math.abs(close - triggerPrice) / expectedMove, 0, 1)

//─────────────────────────────────────────────────────────────────────────────
// Enhanced TP/SL Calculation (Multi-Timeframe, Multiple Targets)
//─────────────────────────────────────────────────────────────────────────────
price_now = close
dir = htfBull ? 1 : -1

// DYNAMIC TP based on swing size
swingBasedATR = useDynamicTP ? math.max(ATRw, recentSwingW * 0.5) : ATRw

// Helper: Get multiplier by index (14 multipliers total)
f_get_mult(int idx) =>
    idx == 0 ? 0.382 : idx == 1 ? 0.500 : idx == 2 ? 0.618 : idx == 3 ? 0.786 : idx == 4 ? 1.000 : idx == 5 ? 1.236 : idx == 6 ? 1.382 : idx == 7 ? 1.500 : idx == 8 ? 1.618 : idx == 9 ? 1.786 : idx == 10 ? 2.000 : idx == 11 ? 2.236 : idx == 12 ? 2.618 : idx == 13 ? 3.000 : na

// Helper: Calculate ATR levels for a given anchor (PC, ATR)
f_atr_levels(float pc, float atr, bool isUp) =>
    levels = array.new<float>()
    // Key levels: 38.2%, 50%, 61.8%, 78.6%, 100%, 123.6%, 138.2%, 150%, 161.8%, 178.6%, 200%, 223.6%, 261.8%, 300%
    // Use f_get_mult() to avoid array creation issues
    if not na(pc) and not na(atr) and atr > 0
        for i = 0 to 13
            mult = f_get_mult(i)
            if not na(mult)
                level = isUp ? (pc + mult * atr) : (pc - mult * atr)
                array.push(levels, level)
    levels

// Calculate levels from multiple timeframes (only if values are valid)
levelsD = (not na(PCd) and not na(ATRd) and ATRd > 0) ? f_atr_levels(PCd, ATRd, dir == 1) : array.new<float>()
levelsW = (not na(PCw) and not na(ATRw) and ATRw > 0) ? f_atr_levels(PCw, ATRw, dir == 1) : array.new<float>()
levels4H = (not na(PC4H) and not na(ATR4H) and ATR4H > 0) ? f_atr_levels(PC4H, ATR4H, dir == 1) : array.new<float>()

// Check if 38.2% has been crossed (using Weekly as primary)
crossed382W = (not na(PCw) and not na(ATRw) and ATRw > 0) ? (dir == 1 ? (high >= (PCw + 0.382 * ATRw)) : (low <= (PCw - 0.382 * ATRw))) : false

//─────────────────────────────────────────────────────────────────────────────
// Intelligent TP Helpers
//─────────────────────────────────────────────────────────────────────────────

// TP Level JSON builder
f_tp_level_str(float price, string label, string source, string type, float multiplier, string tf, float confidence) =>
    "{\"price\":" + f_fmt(price, 2) + ",\"label\":\"" + label + "\",\"source\":\"" + source + "\",\"type\":\"" + type + "\",\"multiplier\":" + (na(multiplier) ? "null" : f_fmt(multiplier, 3)) + ",\"timeframe\":\"" + tf + "\",\"confidence\":" + (na(confidence) ? "null" : f_fmt(confidence, 2)) + "}"

// HTF Structure: Swing Highs/Lows
f_swing_high_tf(string tf, int left, int right) =>
    request.security(syminfo.tickerid, tf, ta.pivothigh(high, left, right), barmerge.gaps_off, barmerge.lookahead_off)

f_swing_low_tf(string tf, int left, int right) =>
    request.security(syminfo.tickerid, tf, ta.pivotlow(low, left, right), barmerge.gaps_off, barmerge.lookahead_off)

// FVG Detection
f_detect_fvg(bool isBullish) =>
    // Bullish FVG: low[1] > high[2] and low[1] > high[0] (gap between max(high[2], high[0]) and low[1])
    // Bearish FVG: high[1] < low[2] and high[1] < low[0] (gap between high[1] and min(low[2], low[0]))
    float fvgTop = na
    float fvgBottom = na
    if isBullish
        // Bullish FVG: gap is from max(high[2], high[0]) up to low[1]
        fvgTop := low[1]
        fvgBottom := math.max(high[2], high[0])
    else
        // Bearish FVG: gap is from high[1] down to min(low[2], low[0])
        fvgTop := math.min(low[2], low[0])
        fvgBottom := high[1]
    fvgMid = (not na(fvgTop) and not na(fvgBottom)) ? ((fvgTop + fvgBottom) / 2) : na
    fvgSize = (not na(fvgTop) and not na(fvgBottom)) ? math.abs(fvgTop - fvgBottom) : 0
    atr14 = ta.atr(14)
    isSignificant = fvgSize >= (fvgMinSize * atr14)
    [fvgMid, isSignificant]

// Gap Detection - Combined to reduce request.security calls
f_gap_data() =>
    [high[1], low[1], high, low, ta.atr(14)]

f_detect_gap_tf(string tf) =>
    [prevHigh, prevLow, currHigh, currLow, atrGap] = request.security(syminfo.tickerid, tf, f_gap_data(), barmerge.gaps_off, barmerge.lookahead_off)
    
    gapUp = (not na(prevHigh) and not na(currLow) and currLow > prevHigh)
    gapDown = (not na(prevLow) and not na(currHigh) and currHigh < prevLow)
    
    gapSize = gapUp ? (currLow - prevHigh) : (gapDown ? (prevLow - currHigh) : 0)
    gapMid = gapUp ? ((currLow + prevHigh) / 2) : (gapDown ? ((prevLow + currHigh) / 2) : na)
    
    isSignificant = gapSize >= (gapMinSize * atrGap)
    
    [gapMid, gapSize, isSignificant, gapUp, gapDown]

// Gap fill probability (simplified - would need gap age tracking for full implementation)
f_gap_fill_probability(int ageBars) =>
    ageBars <= 5 ? 0.80 : ageBars <= 20 ? 0.60 : ageBars <= 50 ? 0.40 : 0.20

// Buyside/Sellside Liquidity Detection on HTF
// Buyside liquidity = swing lows (stops below) - acts as magnet before price moves up
// Sellside liquidity = swing highs (stops above) - acts as magnet before price moves down
// These liquidity zones often need to be "swept" before price can move much higher/lower
f_detect_liquidity_tf(string tf, int lookback, float currentPrice, float atrRef) =>
    // Get swing highs and lows (most recent)
    swingHigh = f_swing_high_tf(tf, lookback, lookback)
    swingLow = f_swing_low_tf(tf, lookback, lookback)
    
    // Buyside liquidity: swing lows below current price
    // These are stops below that act as a magnet - price may need to sweep these before moving up
    // We detect the nearest swing low below price (most recent)
    float buysideLiquidity = na
    if not na(swingLow) and swingLow < currentPrice
        // Price is above the swing low - this liquidity zone could be swept
        // The swing low represents the liquidity level (stops below)
        buysideLiquidity := swingLow
    
    // Sellside liquidity: swing highs above current price
    // These are stops above that act as a magnet - price may need to sweep these before moving down
    // We detect the nearest swing high above price (most recent)
    float sellsideLiquidity = na
    if not na(swingHigh) and swingHigh > currentPrice
        // Price is below the swing high - this liquidity zone could be swept
        // The swing high represents the liquidity level (stops above)
        sellsideLiquidity := swingHigh
    
    [buysideLiquidity, sellsideLiquidity]

// Collect all valid targets from all timeframes
allTargets = array.new<float>()

// Add Weekly SuperTrend as target if not yet supportive
if dir == 1 and not na(stLW) and stLW > price_now
    array.push(allTargets, stLW)
if dir == -1 and not na(stLW) and stLW < price_now
    array.push(allTargets, stLW)

// Add Daily levels (Position trading)
sizeD = array.size(levelsD)
if sizeD > 0
    for i = 0 to sizeD - 1
        if i < sizeD
            level = array.get(levelsD, i)
            if not na(level)
                if dir == 1 and level > price_now
                    array.push(allTargets, level)
                if dir == -1 and level < price_now
                    array.push(allTargets, level)

// Add Weekly levels (Swing trading) - prioritize 61.8% and 100%
sizeW = array.size(levelsW)
if sizeW > 0
    for i = 0 to sizeW - 1
        if i < sizeW
            level = array.get(levelsW, i)
            if not na(level)
                mult = f_get_mult(i)
                if not na(mult)
                    // Prioritize 61.8% and 100% levels
                    isPriority = (mult == 0.618 or mult == 1.000)
                    // If 38.2% crossed, 61.8% becomes more likely
                    shouldInclude = isPriority or (crossed382W and mult >= 0.618) or (not crossed382W and mult >= 0.382)
                    
                    if shouldInclude
                        if dir == 1 and level > price_now
                            array.push(allTargets, level)
                        if dir == -1 and level < price_now
                            array.push(allTargets, level)

// Add 4H levels (Position/Swing)
size4H = array.size(levels4H)
if size4H > 0
    for i = 0 to size4H - 1
        if i < size4H
            level = array.get(levels4H, i)
            if not na(level)
                mult = f_get_mult(i)
                if not na(mult)
                    // Focus on key levels
                    isKeyLevel = (mult == 0.618 or mult == 1.000 or mult == 1.618)
                    if isKeyLevel
                        if dir == 1 and level > price_now
                            array.push(allTargets, level)
                        if dir == -1 and level < price_now
                            array.push(allTargets, level)

//─────────────────────────────────────────────────────────────────────────────
// Intelligent TP: HTF Structure (Swing Highs/Lows)
//─────────────────────────────────────────────────────────────────────────────
// Extract function calls for consistency (called on each calculation)
float structSwingHighW = na
float structSwingLowW = na
float structSwingHighD = na
float structSwingLowD = na
float structSwingHigh4H = na
float structSwingLow4H = na
if useHTFStructure
    structSwingHighW := f_swing_high_tf("W", 5, 5)
    structSwingLowW  := f_swing_low_tf("W", 5, 5)
    structSwingHighD := f_swing_high_tf("D", 5, 5)
    structSwingLowD  := f_swing_low_tf("D", 5, 5)
    structSwingHigh4H := f_swing_high_tf("240", 3, 3)
    structSwingLow4H  := f_swing_low_tf("240", 3, 3)

if useHTFStructure
    if dir == 1  // Long
        if not na(structSwingHighW) and structSwingHighW > price_now
            array.push(allTargets, structSwingHighW)
        if not na(structSwingHighD) and structSwingHighD > price_now
            array.push(allTargets, structSwingHighD)
        if not na(structSwingHigh4H) and structSwingHigh4H > price_now
            array.push(allTargets, structSwingHigh4H)
    else  // Short
        if not na(structSwingLowW) and structSwingLowW < price_now
            array.push(allTargets, structSwingLowW)
        if not na(structSwingLowD) and structSwingLowD < price_now
            array.push(allTargets, structSwingLowD)
        if not na(structSwingLow4H) and structSwingLow4H < price_now
            array.push(allTargets, structSwingLow4H)

//─────────────────────────────────────────────────────────────────────────────
// Intelligent TP: Fair Value Gaps (FVG)
//─────────────────────────────────────────────────────────────────────────────
// Extract FVG function calls for consistency (called on each calculation)
// Note: f_detect_fvg returns [float, bool] - [fvgMid, isSignificant]
// Always call functions for consistency, then use conditionally
[fvgMidD_temp, fvgSigD_temp] = f_detect_fvg(dir == 1)
[fvgMidW_temp, fvgSigW_temp] = request.security(syminfo.tickerid, "W", f_detect_fvg(dir == 1), barmerge.gaps_off, barmerge.lookahead_off)
fvgMidD = useFVG ? fvgMidD_temp : na
fvgSigD = useFVG ? fvgSigD_temp : false
fvgMidW = useFVG ? fvgMidW_temp : na
fvgSigW = useFVG ? fvgSigW_temp : false

if useFVG
    if not na(fvgMidD) and fvgSigD
        if dir == 1 and fvgMidD > price_now
            array.push(allTargets, fvgMidD)
        if dir == -1 and fvgMidD < price_now
            array.push(allTargets, fvgMidD)
    if not na(fvgMidW) and fvgSigW
        if dir == 1 and fvgMidW > price_now
            array.push(allTargets, fvgMidW)
        if dir == -1 and fvgMidW < price_now
            array.push(allTargets, fvgMidW)

//─────────────────────────────────────────────────────────────────────────────
// Intelligent TP: Buyside/Sellside Liquidity (HTF)
//─────────────────────────────────────────────────────────────────────────────
// Extract liquidity function calls for consistency (called on each calculation)
// Always call functions for consistency, then use conditionally
[buysideLiquidityW_temp, sellsideLiquidityW_temp] = f_detect_liquidity_tf("W", 5, price_now, ATRw)
[buysideLiquidityD_temp, sellsideLiquidityD_temp] = f_detect_liquidity_tf("D", 5, price_now, ATRd)
[buysideLiquidity4H_temp, sellsideLiquidity4H_temp] = f_detect_liquidity_tf("240", 3, price_now, ATR4H)
buysideLiquidityW = useLiquidityZones ? buysideLiquidityW_temp : na
sellsideLiquidityW = useLiquidityZones ? sellsideLiquidityW_temp : na
buysideLiquidityD = useLiquidityZones ? buysideLiquidityD_temp : na
sellsideLiquidityD = useLiquidityZones ? sellsideLiquidityD_temp : na
buysideLiquidity4H = useLiquidityZones ? buysideLiquidity4H_temp : na
sellsideLiquidity4H = useLiquidityZones ? sellsideLiquidity4H_temp : na

if useLiquidityZones
    // For LONG trades: Sellside liquidity (swing highs) above price acts as magnet/resistance
    // These are stops above that may need to be swept before price can move much higher
    if dir == 1  // Long
        if not na(sellsideLiquidityW) and sellsideLiquidityW > price_now
            array.push(allTargets, sellsideLiquidityW)
        if not na(sellsideLiquidityD) and sellsideLiquidityD > price_now
            array.push(allTargets, sellsideLiquidityD)
        if not na(sellsideLiquidity4H) and sellsideLiquidity4H > price_now
            array.push(allTargets, sellsideLiquidity4H)
    else  // Short
        // Buyside liquidity below price - may need to be swept or acts as support
        // These are stops below that may need to be swept before price can move much lower
        if not na(buysideLiquidityW) and buysideLiquidityW < price_now
            array.push(allTargets, buysideLiquidityW)
        if not na(buysideLiquidityD) and buysideLiquidityD < price_now
            array.push(allTargets, buysideLiquidityD)
        if not na(buysideLiquidity4H) and buysideLiquidity4H < price_now
            array.push(allTargets, buysideLiquidity4H)

//─────────────────────────────────────────────────────────────────────────────
// Intelligent TP: Gap Analysis
//─────────────────────────────────────────────────────────────────────────────
// Extract gap function calls for consistency (called on each calculation)
// Note: f_detect_gap_tf returns [float, float, bool, bool, bool] - [gapMid, gapSize, isSignificant, gapUp, gapDown]
// Always call functions for consistency, then use conditionally
[gapMidD_temp, gapSizeD_temp, gapSigD_temp, gapUpD_temp, gapDownD_temp] = f_detect_gap_tf("D")
[gapMidW_temp, gapSizeW_temp, gapSigW_temp, gapUpW_temp, gapDownW_temp] = f_detect_gap_tf("W")
gapMidD = useGapAnalysis ? gapMidD_temp : na
gapSizeD = useGapAnalysis ? gapSizeD_temp : na
gapSigD = useGapAnalysis ? gapSigD_temp : false
gapUpD = useGapAnalysis ? gapUpD_temp : false
gapDownD = useGapAnalysis ? gapDownD_temp : false
gapMidW = useGapAnalysis ? gapMidW_temp : na
gapSizeW = useGapAnalysis ? gapSizeW_temp : na
gapSigW = useGapAnalysis ? gapSigW_temp : false
gapUpW = useGapAnalysis ? gapUpW_temp : false
gapDownW = useGapAnalysis ? gapDownW_temp : false

if useGapAnalysis
    if gapSigD and not na(gapMidD)
        if dir == 1 and gapDownD and gapMidD < price_now
            array.push(allTargets, gapMidD)
        if dir == -1 and gapUpD and gapMidD > price_now
            array.push(allTargets, gapMidD)
    if gapSigW and not na(gapMidW)
        if dir == 1 and gapDownW and gapMidW < price_now
            array.push(allTargets, gapMidW)
        if dir == -1 and gapUpW and gapMidW > price_now
            array.push(allTargets, gapMidW)

// Sort and deduplicate targets
if array.size(allTargets) > 0
    // Sort: ascending for longs, descending for shorts
    if dir == 1
        array.sort(allTargets, order.ascending)
    else
        array.sort(allTargets, order.descending)
    
    // Deduplicate (within 0.1% tolerance)
    uniqueTargets = array.new<float>()
    sizeAll = array.size(allTargets)
    if sizeAll > 0
        for i = 0 to sizeAll - 1
            if i < sizeAll
                val = array.get(allTargets, i)
                if not na(val)
                    isUnique = true
                    sizeUnique = array.size(uniqueTargets)
                    if sizeUnique > 0
                        for j = 0 to sizeUnique - 1
                            if j < sizeUnique
                                existing = array.get(uniqueTargets, j)
                                if not na(existing) and existing > 0 and math.abs(val - existing) / existing < 0.001
                                    isUnique := false
                                    break
                    if isUnique
                        array.push(uniqueTargets, val)
    
    allTargets := uniqueTargets

// Primary TP (first target, for backward compatibility)
float tp = na
if array.size(allTargets) > 0
    tp := array.get(allTargets, 0)

// Pivot-based S/R integration - Combined to reduce request.security calls
f_pivot_data() =>
    [ta.pivothigh(high, pivotLookback, pivotLookback), ta.pivotlow(low, pivotLookback, pivotLookback)]
[pivotHigh, pivotLow] = request.security(syminfo.tickerid, "D", f_pivot_data(), barmerge.gaps_off, barmerge.lookahead_off)

// Find nearest resistance/support
float nearestResistance = na
float nearestSupport = na
for i = 0 to 20
    if not na(pivotHigh[i]) and pivotHigh[i] > price_now and na(nearestResistance)
        nearestResistance := pivotHigh[i]
        break
    if not na(pivotLow[i]) and pivotLow[i] < price_now and na(nearestSupport)
        nearestSupport := pivotLow[i]
        break

// Adjust TP to respect S/R if enabled
if not na(tp) and usePivotSR
    if dir == 1 and not na(nearestResistance) and nearestResistance < tp
        tp := nearestResistance * 0.98  // 2% below resistance
    if dir == -1 and not na(nearestSupport) and nearestSupport > tp
        tp := nearestSupport * 1.02  // 2% above support

// VOLATILITY-ADJUSTED SL with Daily 21 EMA as safe default
atrStopBase = ATRw * 0.35
atrStop = useVolatilitySL ? (atrStopBase * math.max(0.8, math.min(1.5, atrRD > 0 ? atrRD : 1.0))) : atrStopBase
if useVolatilitySL
    minSL = ATRd * 1.5
    atrStop := math.max(atrStop, minSL)

// FUSED SL: Combine multiple levels to find realistic reversal point
// Concept: "Below/above this level, we likely enter the opposite for some time"
// For longs: Use HIGHEST valid SL below price (safest = highest, represents true support)
// For shorts: Use LOWEST valid SL above price (safest = lowest, represents true resistance)
daily21EMA = e21D

// Check if Daily 21 EMA is too close to price (within 0.5% or 0.5 ATR)
// If too close, use swing low/high or previous candle low/high instead for more realistic SL
daily21EMADistance = not na(daily21EMA) ? math.abs(price_now - daily21EMA) / price_now : 999
daily21EMAATRDistance = not na(daily21EMA) and ATRd > 0 ? math.abs(price_now - daily21EMA) / ATRd : 999
daily21EMATooClose = daily21EMADistance < 0.005 or daily21EMAATRDistance < 0.5

// Get swing low/high for daily timeframe (more reliable than EMA when EMA is too close)
swingLowD = f_swing_low_tf(tfD, 5, 5)
swingHighD = f_swing_high_tf(tfD, 5, 5)

// Previous candle low/high (on daily timeframe)
prevCandleLowD = request.security(syminfo.tickerid, tfD, low[1], barmerge.gaps_off, barmerge.lookahead_off)
prevCandleHighD = request.security(syminfo.tickerid, tfD, high[1], barmerge.gaps_off, barmerge.lookahead_off)

float sl = na
if dir == 1
    // For longs: Collect ALL valid SL candidates below price, then use the HIGHEST (safest)
    slCandidates = array.new<float>()
    
    // 1. Support structure - if below price, represents a clear support level
    if usePivotSR and not na(nearestSupport) and nearestSupport < price_now
        array.push(slCandidates, nearestSupport * 0.99)  // Slightly below support for safety
    
    // 2. Daily 21 EMA - if below price and NOT too close, represents trailing support
    // If too close, skip EMA and use swing/candle levels instead
    if not na(daily21EMA) and daily21EMA < price_now and not daily21EMATooClose
        array.push(slCandidates, daily21EMA)
    
    // 2b. If Daily 21 EMA is too close, use swing low or previous candle low instead
    if daily21EMATooClose
        // Prefer swing low (structure) over previous candle low (more recent)
        if not na(swingLowD) and swingLowD < price_now
            array.push(slCandidates, swingLowD * 0.99)  // Slightly below swing low
        else if not na(prevCandleLowD) and prevCandleLowD < price_now
            array.push(slCandidates, prevCandleLowD * 0.99)  // Slightly below previous candle low
    
    // 3. Weekly SuperTrend - if below price, represents structure support
    if not na(stLW) and stLW < price_now
        array.push(slCandidates, stLW)
    
    // 4. ATR-based stop from trigger price - mechanical stop
    atrBasedSL = not na(triggerPrice) ? (triggerPrice - atrStop) : (price_now - atrStop)
    if atrBasedSL < price_now
        array.push(slCandidates, atrBasedSL)
    
    // FUSE: Use the HIGHEST (safest) of all valid candidates below price
    // This represents the most realistic reversal point (true support)
    if array.size(slCandidates) > 0
        array.sort(slCandidates, order.descending)
        sl := array.get(slCandidates, 0)  // Highest = safest stop
    else
        // Fallback: Use swing low, previous candle low, or Daily 21 EMA
        if not na(swingLowD) and swingLowD < price_now
            sl := swingLowD * 0.99
        else if not na(prevCandleLowD) and prevCandleLowD < price_now
            sl := prevCandleLowD * 0.99
        else if not na(daily21EMA)
            sl := daily21EMA
        else
            sl := price_now - atrStop  // Last resort
else
    // For shorts: Collect ALL valid SL candidates above price, then use the LOWEST (safest)
    slCandidates = array.new<float>()
    
    // 1. Resistance structure - if above price, represents a clear resistance level
    if usePivotSR and not na(nearestResistance) and nearestResistance > price_now
        array.push(slCandidates, nearestResistance * 1.01)  // Slightly above resistance for safety
    
    // 2. Daily 21 EMA - if above price and NOT too close, represents trailing resistance
    // If too close, skip EMA and use swing/candle levels instead
    if not na(daily21EMA) and daily21EMA > price_now and not daily21EMATooClose
        array.push(slCandidates, daily21EMA)
    
    // 2b. If Daily 21 EMA is too close, use swing high or previous candle high instead
    if daily21EMATooClose
        // Prefer swing high (structure) over previous candle high (more recent)
        if not na(swingHighD) and swingHighD > price_now
            array.push(slCandidates, swingHighD * 1.01)  // Slightly above swing high
        else if not na(prevCandleHighD) and prevCandleHighD > price_now
            array.push(slCandidates, prevCandleHighD * 1.01)  // Slightly above previous candle high
    
    // 3. Weekly SuperTrend - if above price, represents structure resistance
    if not na(stLW) and stLW > price_now
        array.push(slCandidates, stLW)
    
    // 4. ATR-based stop from trigger price - mechanical stop
    atrBasedSL = not na(triggerPrice) ? (triggerPrice + atrStop) : (price_now + atrStop)
    if atrBasedSL > price_now
        array.push(slCandidates, atrBasedSL)
    
    // FUSE: Use the LOWEST (safest) of all valid candidates above price
    // This represents the most realistic reversal point (true resistance)
    if array.size(slCandidates) > 0
        array.sort(slCandidates, order.ascending)
        sl := array.get(slCandidates, 0)  // Lowest = safest stop
    else
        // Fallback: Use swing high, previous candle high, or Daily 21 EMA
        if not na(swingHighD) and swingHighD > price_now
            sl := swingHighD * 1.01
        else if not na(prevCandleHighD) and prevCandleHighD > price_now
            sl := prevCandleHighD * 1.01
        else if not na(daily21EMA)
            sl := daily21EMA
        else
            sl := price_now + atrStop  // Last resort

elapsedDays = (not na(triggerTs)) ? ((time - triggerTs) / 86400000.0) : na
etaDays = (not na(elapsedDays) and completion > 0 and completion < 0.999) ? (elapsedDays * (1.0 / completion - 1.0)) : na

minRisk = math.max(price_now * 0.005, ATRw * 0.25)
risk = math.max(math.abs(price_now - sl), minRisk)
gain = na(tp) ? na : math.abs(tp - price_now)
rr = (risk > 0 and not na(gain)) ? (gain / risk) : na

//─────────────────────────────────────────────────────────────────────────────
// Alert gating
//─────────────────────────────────────────────────────────────────────────────
var bool   sentBaseline  = false
var float  lastSentHTF   = na
var float  lastSentLTF   = na
var string lastSentState = ""
var int    lastSentTime  = na

scoreMoved = (na(lastSentHTF) or na(lastSentLTF)) ? true : 
             (scoreDelta <= 0) ? true :  // If scoreDelta is 0, always consider it moved
             (math.abs(htfScore - lastSentHTF) >= scoreDelta) or (math.abs(ltfScore - lastSentLTF) >= scoreDelta)

stateChanged = (lastSentState != state)

// Check if enough time has passed for periodic update
// For tickers that haven't sent a baseline yet, we'll send on first bar (handled by not sentBaseline)
// After baseline is sent, periodic updates will trigger every periodicUpdateMinutes
periodicUpdateDue = periodicUpdateMinutes > 0 and not na(lastSentTime) and (time - lastSentTime >= periodicUpdateMinutes * 60 * 1000)

throttleOK =
     forceBaseline ? true :
     minMinutesBetweenSends <= 0 ? true :
     na(lastSentTime) ? true :
     (time - lastSentTime >= minMinutesBetweenSends * 60 * 1000)

meaningful = stateChanged or scoreMoved or sq30_rel
// Send if: force baseline, first baseline, meaningful change, OR periodic update due
// Session check: For individual chart alerts, respects session. Watchlist alerts are limited by TradingView during extended hours.
// IMPORTANT: For first baseline, we bypass session check to ensure all tickers send their initial data
// After that, periodic updates will maintain data even if nothing changes
sessionOK = f_is_allowed_session()
firstBaseline = not sentBaseline
// ALWAYS SEND: User wants alerts for every ticker regardless of delta changes
// This ensures every ticker in the watchlist sends data on every bar close
shouldSend = barstate.isconfirmed and throttleOK and (firstBaseline or sessionOK)

// Reasons
reason1 = (htfBull ? "HTF bullish bias" : "HTF bearish bias") + " (W/D/4H/1H)"
reason2 = (ltfBull ? "LTF bullish" : "LTF bearish") + " (30/10/3)"
reason3 = sq30_rel ? ("30m SQUEEZE RELEASE " + (rel30Dir==1 ? "BULL" : "BEAR")) : (sq30 ? "30m SQUEEZE ON" : "30m no squeeze")
reason4 = phaseDot ? ("D Phase " + (usePhaseZones ? phaseZoneD : "dot/leave")) : ("D Phase " + phaseDir + " pct=" + f_fmt(phasePct,2))

// Build TP array string with metadata
tpArrayStr = "["
sizeAllTp = array.size(allTargets)
tpCounter = 1

if sizeAllTp > 0
    for i = 0 to sizeAllTp - 1
        if i < sizeAllTp
            if i > 0
                tpArrayStr += ","
            
            val = array.get(allTargets, i)
            if not na(val)
                // Determine source/type for this level
                label = "TP" + str.tostring(tpCounter)
                source = "ATR Level"
                type = "ATR_FIB"
                float multiplier = na
                tf = "D"
                confidence = 0.75
                
                // Check if it matches HTF structure levels (using parent scope variables)
                if useHTFStructure
                    if (not na(structSwingHighW) and math.abs(val - structSwingHighW) < syminfo.mintick * 2) or
                       (not na(structSwingHighD) and math.abs(val - structSwingHighD) < syminfo.mintick * 2) or
                       (not na(structSwingLowW) and math.abs(val - structSwingLowW) < syminfo.mintick * 2) or
                       (not na(structSwingLowD) and math.abs(val - structSwingLowD) < syminfo.mintick * 2) or
                       (not na(structSwingHigh4H) and math.abs(val - structSwingHigh4H) < syminfo.mintick * 2) or
                       (not na(structSwingLow4H) and math.abs(val - structSwingLow4H) < syminfo.mintick * 2)
                        source := "Swing High/Low"
                        type := "STRUCTURE"
                        confidence := 0.80
                        tf := "W"
                
                // Check if it matches FVG (using parent scope variables)
                if useFVG
                    if (not na(fvgMidD) and math.abs(val - fvgMidD) < syminfo.mintick * 2) or
                       (not na(fvgMidW) and math.abs(val - fvgMidW) < syminfo.mintick * 2)
                        source := "Fair Value Gap"
                        type := "FVG"
                        confidence := 0.65
                
                // Check if it matches gap (using parent scope variables)
                if useGapAnalysis
                    if (not na(gapMidD) and math.abs(val - gapMidD) < syminfo.mintick * 2) or
                       (not na(gapMidW) and math.abs(val - gapMidW) < syminfo.mintick * 2)
                        source := "Gap Fill"
                        type := "GAP"
                        confidence := 0.60
                
                // Check if it matches liquidity zones (using parent scope variables)
                if useLiquidityZones
                    if (not na(sellsideLiquidityW) and math.abs(val - sellsideLiquidityW) < syminfo.mintick * 2) or
                       (not na(sellsideLiquidityD) and math.abs(val - sellsideLiquidityD) < syminfo.mintick * 2) or
                       (not na(sellsideLiquidity4H) and math.abs(val - sellsideLiquidity4H) < syminfo.mintick * 2) or
                       (not na(buysideLiquidityW) and math.abs(val - buysideLiquidityW) < syminfo.mintick * 2) or
                       (not na(buysideLiquidityD) and math.abs(val - buysideLiquidityD) < syminfo.mintick * 2) or
                       (not na(buysideLiquidity4H) and math.abs(val - buysideLiquidity4H) < syminfo.mintick * 2)
                        source := dir == 1 ? "Sellside Liquidity" : "Buyside Liquidity"
                        type := "LIQUIDITY"
                        confidence := 0.70
                
                // Check if it's from ATR levels (determine multiplier and timeframe)
                if type == "ATR_FIB"
                    // Try to match against known ATR levels
                    sizeD := array.size(levelsD)
                    sizeW := array.size(levelsW)
                    size4H := array.size(levels4H)
                    
                    // Check Daily levels
                    for j = 0 to sizeD - 1
                        if j < sizeD
                            levelD = array.get(levelsD, j)
                            if not na(levelD) and math.abs(val - levelD) < syminfo.mintick * 2
                                mult = f_get_mult(j)
                                multiplier := mult
                                source := f_fmt(mult * 100, 1) + "% ATR Daily"
                                tf := "D"
                                break
                    
                    // Check Weekly levels
                    for j = 0 to sizeW - 1
                        if j < sizeW
                            levelW = array.get(levelsW, j)
                            if not na(levelW) and math.abs(val - levelW) < syminfo.mintick * 2
                                mult = f_get_mult(j)
                                multiplier := mult
                                source := f_fmt(mult * 100, 1) + "% ATR Weekly"
                                tf := "W"
                                confidence := 0.85
                                break
                    
                    // Check 4H levels
                    if size4H > 0
                        for j = 0 to size4H - 1
                            if j < size4H
                                level4H = array.get(levels4H, j)
                                if not na(level4H) and math.abs(val - level4H) < syminfo.mintick * 2
                                    mult = f_get_mult(j)
                                    multiplier := mult
                                    source := f_fmt(mult * 100, 1) + "% ATR 4H"
                                    tf := "240"
                                    break
                
                // Build TP level JSON string
                tpLevelJson = f_tp_level_str(val, label, source, type, multiplier, tf, confidence)
                tpArrayStr += tpLevelJson
                tpCounter += 1

tpArrayStr += "]"

//─────────────────────────────────────────────────────────────────────────────
// Momentum % Calculations (for Momentum Elite)
//─────────────────────────────────────────────────────────────────────────────
// Get daily close prices for different periods using request.security
// Defensive: If already on daily timeframe, use close directly; otherwise use request.security
// request.security will return na if data unavailable (e.g., insufficient history, invalid symbol)
// Check if we have enough bars before attempting to access historical data
f_daily_close(int barsAgo) =>
    // If we're already on daily timeframe, use close directly (if enough bars available)
    if timeframe.isdaily
        bar_index >= barsAgo ? close[barsAgo] : na
    else
        // Use request.security for other timeframes
        // This will return na if insufficient data or symbol doesn't support daily timeframe
        [closePrice] = request.security(syminfo.tickerid, "D", [close[barsAgo]], lookahead=barmerge.lookahead_off)
        closePrice

// Get historical daily closes (will be na if data unavailable - script continues normally)
currentPrice = close
priceWeekAgo = f_daily_close(5)      // ~5 trading days ago
priceMonthAgo = f_daily_close(20)    // ~20 trading days ago
price3MonthsAgo = f_daily_close(60)   // ~60 trading days ago
price6MonthsAgo = f_daily_close(120)  // ~120 trading days ago

// Calculate percentage changes (as decimals, will convert to % in JSON)
// All checks ensure we don't divide by zero or use invalid data
pctChangeWeek = not na(priceWeekAgo) and priceWeekAgo > 0 and currentPrice > 0 ? ((currentPrice - priceWeekAgo) / priceWeekAgo) : na
pctChangeMonth = not na(priceMonthAgo) and priceMonthAgo > 0 and currentPrice > 0 ? ((currentPrice - priceMonthAgo) / priceMonthAgo) : na
pctChange3Months = not na(price3MonthsAgo) and price3MonthsAgo > 0 and currentPrice > 0 ? ((currentPrice - price3MonthsAgo) / price3MonthsAgo) : na
pctChange6Months = not na(price6MonthsAgo) and price6MonthsAgo > 0 and currentPrice > 0 ? ((currentPrice - price6MonthsAgo) / price6MonthsAgo) : na

//─────────────────────────────────────────────────────────────────────────────
// Sector & Fundamental Data (from TradingView)
//─────────────────────────────────────────────────────────────────────────────
// NOTE: request.financial() calls have been removed to avoid parse-time symbol resolution
// errors for futures/crypto/forex. Sector and industry are safe and work for all asset types.
// Fundamental data (EPS, P/E, PEG, Market Cap) can be provided by the worker if needed.

// Get sector and industry from TradingView (safe for all asset types)
sectorName = na(syminfo.sector) ? "" : syminfo.sector
industryName = na(syminfo.industry) ? "" : syminfo.industry

//─────────────────────────────────────────────────────────────────────────────
// TD Sequential (DeMark Sequential) - Reversal/Exhaustion Indicator
//─────────────────────────────────────────────────────────────────────────────
// TD Sequential helps identify potential reversal/exhaustion points
// Preparation Phase: Counts consecutive closes below/above comparison period (default 9)
// Lead-up Phase: After preparation completes, counts consecutive closes below/above low/high comparison (default 13)
// TD 9: Preparation phase reaches 9 = potential reversal signal
// TD 13: Lead-up phase reaches 13 = stronger reversal signal

// Settings (using standard DeMark defaults)
tdPrepLen = 9        // Preparation phase length
tdPrepComp = 4       // Comparison period for preparation (close[4])
tdLeadupLen = 13    // Lead-up phase length
tdLeadupComp = 2    // Comparison period for lead-up (low[2] or high[2])

// Preparation Phase (TD Count)
// Bullish: Count consecutive closes below close[comparison]
// Bearish: Count consecutive closes above close[comparison]
var int bullishPrepCount = 0
var int bearishPrepCount = 0

bullishPrepCount := close < close[tdPrepComp] ? bullishPrepCount + 1 : 0
bearishPrepCount := close > close[tdPrepComp] ? bearishPrepCount + 1 : 0

// Preparation phase completion signals
bullishPrepComplete = bullishPrepCount == tdPrepLen
bearishPrepComplete = bearishPrepCount == tdPrepLen

// Lead-up Phase (TD Sequential)
// Bullish: After bullish prep completes, count consecutive closes below low[comparison]
// Bearish: After bearish prep completes, count consecutive closes above high[comparison]
var int bullishLeadupCount = 0
var int bearishLeadupCount = 0

// Reset lead-up on opposite preparation completion (cancellation)
if bearishPrepComplete
    bullishLeadupCount := 0
if bullishPrepComplete
    bearishLeadupCount := 0

// Increment lead-up counts
if bullishPrepComplete and close < low[tdLeadupComp]
    bullishLeadupCount := bullishLeadupCount + 1
else if bullishLeadupCount > 0 and close < low[tdLeadupComp]
    bullishLeadupCount := bullishLeadupCount + 1
else if bullishLeadupCount > 0 and close >= low[tdLeadupComp]
    bullishLeadupCount := 0  // Reset if condition breaks

if bearishPrepComplete and close > high[tdLeadupComp]
    bearishLeadupCount := bearishLeadupCount + 1
else if bearishLeadupCount > 0 and close > high[tdLeadupComp]
    bearishLeadupCount := bearishLeadupCount + 1
else if bearishLeadupCount > 0 and close <= high[tdLeadupComp]
    bearishLeadupCount := 0  // Reset if condition breaks

// TD Sequential signals
// TD 9: Preparation phase complete (potential reversal)
td9Bullish = bullishPrepComplete
td9Bearish = bearishPrepComplete

// TD 13: Lead-up phase complete (stronger reversal signal)
td13Bullish = bullishLeadupCount == tdLeadupLen
td13Bearish = bearishLeadupCount == tdLeadupLen

// TD Sequential state summary
// For LONG trades: Bearish TD 9/13 = exit signal (exhaustion/reversal down)
// For SHORT trades: Bullish TD 9/13 = exit signal (exhaustion/reversal up)
tdSeqExitLong = td9Bearish or td13Bearish
tdSeqExitShort = td9Bullish or td13Bullish

// TD Sequential boost/penalty for scoring
// If TD count favors our direction, boost score
// If TD count opposes our direction, penalize score
tdSeqBoost = 0.0
if htfBull
    // For LONG bias: Bullish TD 9/13 = boost, Bearish TD 9/13 = penalty
    tdSeqBoost := td9Bullish ? 5.0 : td13Bullish ? 8.0 : td9Bearish ? -5.0 : td13Bearish ? -8.0 : 0.0
    // Also boost if bullish prep count is high (6-8) or leadup is building (6-12)
    if bullishPrepCount >= 6 and bullishPrepCount < tdPrepLen
        tdSeqBoost := tdSeqBoost + 2.0
    if bullishLeadupCount >= 6 and bullishLeadupCount < tdLeadupLen
        tdSeqBoost := tdSeqBoost + 3.0
else
    // For SHORT bias: Bearish TD 9/13 = boost, Bullish TD 9/13 = penalty
    tdSeqBoost := td9Bearish ? 5.0 : td13Bearish ? 8.0 : td9Bullish ? -5.0 : td13Bullish ? -8.0 : 0.0
    // Also boost if bearish prep count is high (6-8) or leadup is building (6-12)
    if bearishPrepCount >= 6 and bearishPrepCount < tdPrepLen
        tdSeqBoost := tdSeqBoost + 2.0
    if bearishLeadupCount >= 6 and bearishLeadupCount < tdLeadupLen
        tdSeqBoost := tdSeqBoost + 3.0

// Fundamental data variables (will be na - can be populated by worker if needed)
var float epsBasic = na
var float epsDiluted = na
var float epsReported = na
var float epsQuarterly = na
var float marketCap = na
var float epsRaw = na
var float peRatio = na
var float epsGrowthRate = na
var float pegRatio = na

// Build sector/fundamental JSON strings
sectorStr = sectorName != "" ? ("\"sector\":\"" + sectorName + "\",") : ""
industryStr = industryName != "" ? ("\"industry\":\"" + industryName + "\",") : ""
epsStr = not na(epsRaw) ? ("\"eps\":" + f_fmt(epsRaw, 2) + ",") : ""
peStr = not na(peRatio) ? ("\"pe_ratio\":" + f_fmt(peRatio, 2) + ",") : ""
epsGrowthStr = not na(epsGrowthRate) ? ("\"eps_growth_rate\":" + f_fmt(epsGrowthRate, 2) + ",") : ""
pegStr = not na(pegRatio) ? ("\"peg_ratio\":" + f_fmt(pegRatio, 2) + ",") : ""
marketCapStr = not na(marketCap) ? ("\"market_cap\":" + f_fmt(marketCap, 0) + ",") : ""

// Build EMA Cloud JSON strings
dailyEMAStr = not na(dailyEMAUpper) and not na(dailyEMALower) ? ("\"daily_ema_cloud\":{" + "\"upper\":" + f_fmt(dailyEMAUpper, 2) + "," + "\"lower\":" + f_fmt(dailyEMALower, 2) + "," + "\"price\":" + f_fmt(dailyPrice, 2) + "," + "\"position\":\"" + dailyEMAPosition + "\"" + "},") : ""
fourHEMAStr = not na(fourHEMAUpper) and not na(fourHEMALower) ? ("\"fourh_ema_cloud\":{" + "\"upper\":" + f_fmt(fourHEMAUpper, 2) + "," + "\"lower\":" + f_fmt(fourHEMALower, 2) + "," + "\"price\":" + f_fmt(fourHPrice, 2) + "," + "\"position\":\"" + fourHEMAPosition + "\"" + "},") : ""
oneHEMAStr = not na(oneHEMAUpper) and not na(oneHEMALower) ? ("\"oneh_ema_cloud\":{" + "\"upper\":" + f_fmt(oneHEMAUpper, 2) + "," + "\"lower\":" + f_fmt(oneHEMALower, 2) + "," + "\"price\":" + f_fmt(oneHPrice, 2) + "," + "\"position\":\"" + oneHEMAPosition + "\"" + "},") : ""

// Build JSON
json =    "{" +      "\"script_version\":\"" + SCRIPT_VERSION + "\"," +      "\"ts\":" + str.tostring(time) + "," +      "\"ticker\":\"" + syminfo.ticker + "\"," +      sectorStr + industryStr + epsStr + peStr + epsGrowthStr + pegStr + marketCapStr +      "\"tf_hint\":\"" + timeframe.period + "\"," +      "\"htf_score\":" + f_fmt(htfScore,2) + "," +      "\"ltf_score\":" + f_fmt(ltfScore,2) + "," +      "\"completion\":" + f_fmt(completion,2) + "," +      "\"phase_pct\":" + f_fmt(phasePct,2) + "," +      "\"phase_zone\":\"" + (usePhaseZones ? phaseZoneD : "") + "\"," +      "\"state\":\"" + state + "\"," +      "\"price\":" + f_fmt(price_now,2) + "," +      "\"trigger_ts\":" + (na(triggerTs) ? "null" : str.tostring(triggerTs)) + "," +      "\"trigger_price\":" + (na(triggerPrice) ? "null" : f_fmt(triggerPrice,2)) + "," +      "\"trigger_reason\":\"" + triggerReason + "\"," +      "\"trigger_dir\":\"" + triggerDirStr + "\"," +      "\"sl\":" + (na(sl) ? "null" : f_fmt(sl,2)) + "," +      "\"tp\":" + (na(tp) ? "null" : f_fmt(tp,2)) + "," +      "\"tp_levels\":" + tpArrayStr + "," +      "\"eta_days\":" + (na(etaDays) ? "null" : f_fmt(etaDays,2)) + "," +      "\"rr\":" + (na(rr) ? "null" : f_fmt(rr,2)) + "," +      "\"momentum_pct\":{" +        "\"week\":" + (na(pctChangeWeek) ? "null" : f_fmt(pctChangeWeek * 100, 2)) + "," +        "\"month\":" + (na(pctChangeMonth) ? "null" : f_fmt(pctChangeMonth * 100, 2)) + "," +        "\"three_months\":" + (na(pctChange3Months) ? "null" : f_fmt(pctChange3Months * 100, 2)) + "," +        "\"six_months\":" + (na(pctChange6Months) ? "null" : f_fmt(pctChange6Months * 100, 2)) +      "}," +      dailyEMAStr + fourHEMAStr + oneHEMAStr +      "\"flags\":{" +        "\"sq30_on\":" + (sq30 ? "true":"false") + "," +        "\"sq30_release\":" + (sq30_rel ? "true":"false") + "," +        "\"phase_dot\":" + (phaseDot ? "true":"false") + "," +        "\"phase_zone_change\":" + (phaseZoneChange ? "true":"false") + "," +        "\"momentum_elite\":" + (momentumElite ? "true":"false") +      "}," +      "\"td_sequential\":{" +        "\"bullish_prep_count\":" + str.tostring(bullishPrepCount) + "," +        "\"bearish_prep_count\":" + str.tostring(bearishPrepCount) + "," +        "\"bullish_leadup_count\":" + str.tostring(bullishLeadupCount) + "," +        "\"bearish_leadup_count\":" + str.tostring(bearishLeadupCount) + "," +        "\"td9_bullish\":" + (td9Bullish ? "true":"false") + "," +        "\"td9_bearish\":" + (td9Bearish ? "true":"false") + "," +        "\"td13_bullish\":" + (td13Bullish ? "true":"false") + "," +        "\"td13_bearish\":" + (td13Bearish ? "true":"false") + "," +        "\"exit_long\":" + (tdSeqExitLong ? "true":"false") + "," +        "\"exit_short\":" + (tdSeqExitShort ? "true":"false") + "," +        "\"boost\":" + f_fmt(tdSeqBoost, 2) +      "}," +      "\"reasons\":[" +        "\"" + reason1 + "\"," +        "\"" + reason2 + "\"," +        "\"" + reason3 + "\"," +        "\"" + reason4 + "\"" +      "]" +    "}"

// Send
if shouldSend
    alert(json, alert.freq_once_per_bar_close)
    sentBaseline  := true
    lastSentHTF   := htfScore
    lastSentLTF   := ltfScore
    lastSentState := state
    lastSentTime  := time

// Debug heartbeat
if debugHeartbeat and barstate.isconfirmed
    alert("{\"ts\":" + str.tostring(time) + ",\"ticker\":\"" + syminfo.ticker + "\",\"debug\":\"HEARTBEAT\"}", alert.freq_once_per_bar_close)

//─────────────────────────────────────────────────────────────────────────────
// Visual sanity
//─────────────────────────────────────────────────────────────────────────────
plot(ltfScore, "LTF Score (X)", color=color.black, linewidth=2)
plot(htfScore, "HTF Score (Y)", linewidth=2)
hline(0, "Zero", color=color.red, linestyle=hline.style_dotted, linewidth=3)

plotchar(sq30_rel, title="30m Squeeze Release", char="🚀", location=location.top)
plotchar(phaseDot, title="Daily Phase Dot/Zone Change", char="⚫️", location=location.bottom)

