//@version=6
indicator("TimedTrading Capture Heartbeat", overlay=false, max_labels_count=500)

// Focused capture-only script for watchlist alerts.
// Sends a minimal payload on every bar close.

groupCapture = "Capture Settings"
scriptVersion = input.string("capture_1.2.0", "Script Version", group=groupCapture)
includeOHLC = input.bool(false, "Include OHLC", group=groupCapture)
includeVolume = input.bool(false, "Include Volume", group=groupCapture)
volLookbackD = input.int(30, "Avg Volume Lookback (D)", minval=5, maxval=200, group=groupCapture)

// Context enrichment (optional): include a context block only every N hours to avoid noise.
groupContext = "Context (Optional)"
includeContext = input.bool(true, "Include Context (throttled)", group=groupContext)
contextEveryHours = input.int(4, "Context cadence (hours)", minval=1, maxval=24, group=groupContext)

// TradingView Technical Rating library (proxy “sentiment”)
import TradingView/TechnicalRating/3 as TR

// Daily change vs previous close (watchlist style)
// IMPORTANT: For US stocks we want "yesterday close" anchored to the regular session close (4pm ET),
// not an extended-session daily bar close which can skew the numbers after-hours.
symRth = (syminfo.type == "stock") ? ticker.new(syminfo.prefix, syminfo.ticker, session.regular) : syminfo.tickerid
prevCloseD = request.security(symRth, "D", close[1], barmerge.gaps_off, barmerge.lookahead_off)
dayChange = not na(prevCloseD) and prevCloseD > 0 ? (close - prevCloseD) : na
dayChangePct = not na(dayChange) and prevCloseD > 0 ? ((dayChange / prevCloseD) * 100.0) : na
prevCloseStr = not na(prevCloseD) ? (",\"prev_close\":" + str.tostring(prevCloseD)) : ""
chgStr = not na(dayChange) ? (",\"day_change\":" + str.tostring(dayChange) + ",\"change\":" + str.tostring(dayChange)) : ""
pctStr = not na(dayChangePct) ? (",\"day_change_pct\":" + str.tostring(dayChangePct) + ",\"change_pct\":" + str.tostring(dayChangePct)) : ""

// Session flag (exchange time). Useful so the UI can explicitly label after-hours.
isRth = not na(time(timeframe.period, "0930-1600"))
sessionStr = isRth ? "RTH" : "EXT"
sessionJson = ",\"session\":\"" + sessionStr + "\",\"is_rth\":" + str.tostring(isRth)

// Momentum Elite helpers (computed on Daily timeframe).
// These are *inputs* to Momentum Elite, not hard filters in this capture script.
avgVol30D = request.security(syminfo.tickerid, "D", ta.sma(volume, volLookbackD), barmerge.gaps_off, barmerge.lookahead_off)
adr14D = request.security(syminfo.tickerid, "D", ta.sma(high - low, 14), barmerge.gaps_off, barmerge.lookahead_off)

momW = request.security(syminfo.tickerid, "D", close[5] != 0 ? ((close / close[5] - 1) * 100.0) : na, barmerge.gaps_off, barmerge.lookahead_off)
momM = request.security(syminfo.tickerid, "D", close[21] != 0 ? ((close / close[21] - 1) * 100.0) : na, barmerge.gaps_off, barmerge.lookahead_off)
mom3M = request.security(syminfo.tickerid, "D", close[63] != 0 ? ((close / close[63] - 1) * 100.0) : na, barmerge.gaps_off, barmerge.lookahead_off)
mom6M = request.security(syminfo.tickerid, "D", close[126] != 0 ? ((close / close[126] - 1) * 100.0) : na, barmerge.gaps_off, barmerge.lookahead_off)

avgVolStr = not na(avgVol30D) ? (",\"avg_vol_" + str.tostring(volLookbackD) + "\":" + str.tostring(avgVol30D)) : ""
adrStr = not na(adr14D) ? (",\"adr_14\":" + str.tostring(adr14D)) : ""
momWJson = not na(momW) ? str.tostring(momW) : "null"
momMJson = not na(momM) ? str.tostring(momM) : "null"
mom3MJson = not na(mom3M) ? str.tostring(mom3M) : "null"
mom6MJson = not na(mom6M) ? str.tostring(mom6M) : "null"
momStr = ",\"momentum_pct\":{\"week\":" + momWJson + ",\"month\":" + momMJson + ",\"three_months\":" + mom3MJson + ",\"six_months\":" + mom6MJson + "}"

f_json_escape(s) =>
    // Basic JSON string escaping
    x = str.tostring(s)
    x := str.replace_all(x, "\\", "\\\\")
    x := str.replace_all(x, "\"", "\\\"")
    x := str.replace_all(x, "\n", "\\n")
    // Some TradingView strings appear to contain a stray carriage-return where "r" should be.
    // If we serialize it as "\r", JSON parsers will turn it back into a control char and it renders poorly.
    // Normalize it to the literal character "r".
    x := str.replace_all(x, "\r", "r")
    x

// Context throttle state (per-ticker instance)
var int lastContextSentTs = na
contextCadenceMs = contextEveryHours * 60 * 60 * 1000
shouldSendContext = includeContext and (na(lastContextSentTs) or (time - lastContextSentTs >= contextCadenceMs))

// Build optional context block (only appended to JSON when shouldSendContext)
companyName = f_json_escape(syminfo.description)
// TradingView Pine doesn't expose a rich business summary. We include this field for UI parity,
// but it will generally match `name` unless you later wire in a richer source.
companyDesc = f_json_escape(syminfo.description)
sector = f_json_escape(syminfo.sector)
industry = f_json_escape(syminfo.industry)
country = f_json_escape(syminfo.country)
exchange = f_json_escape(syminfo.prefix)
assetType = f_json_escape(syminfo.type)
currency = f_json_escape(syminfo.currency)

[ratingTotal, ratingOther, ratingMA] = TR.calcRatingAll()
ratingStatus = TR.ratingStatus(ratingTotal)
ratingTotalJson = str.tostring(ratingTotal)
ratingStatusJson = "\"" + f_json_escape(ratingStatus) + "\""

earnActual = request.earnings(syminfo.tickerid, earnings.actual)
earnEstimate = request.earnings(syminfo.tickerid, earnings.estimate)
divGross = request.dividends(syminfo.tickerid, dividends.gross)

lastEarnTs = ta.valuewhen(not na(earnActual) or not na(earnEstimate), time, 0)
lastDivTs = ta.valuewhen(not na(divGross), time, 0)

lastEarnTsJson = not na(lastEarnTs) ? str.tostring(lastEarnTs) : "null"
lastDivTsJson = not na(lastDivTs) ? str.tostring(lastDivTs) : "null"
earnActualJson = not na(earnActual) ? str.tostring(earnActual) : "null"
earnEstimateJson = not na(earnEstimate) ? str.tostring(earnEstimate) : "null"
divGrossJson = not na(divGross) ? str.tostring(divGross) : "null"

contextStr = shouldSendContext ? ",\"context\":{" + "\"name\":\"" + companyName + "\"," + "\"description\":\"" + companyDesc + "\"," + "\"sector\":\"" + sector + "\"," + "\"industry\":\"" + industry + "\"," + "\"country\":\"" + country + "\"," + "\"exchange\":\"" + exchange + "\"," + "\"type\":\"" + assetType + "\"," + "\"currency\":\"" + currency + "\"," + "\"technical_rating\":{" + "\"value\":" + ratingTotalJson + "," + "\"status\":" + ratingStatusJson + "}," + "\"events\":{" + "\"last_earnings_ts\":" + lastEarnTsJson + "," + "\"last_earnings_actual\":" + earnActualJson + "," + "\"last_earnings_estimate\":" + earnEstimateJson + "," + "\"last_dividend_ts\":" + lastDivTsJson + "," + "\"last_dividend_gross\":" + divGrossJson + "}" + "}" : ""

// Multi-TF candles (optional): fetch OHLCV per timeframe for chart rendering in the UI.
f_candle(tf) =>
    [o, h, l, c, v, tc] = request.security(syminfo.tickerid, tf, [open, high, low, close, volume, time_close], barmerge.gaps_off, barmerge.lookahead_off)
    [o, h, l, c, v, tc]

f_num(x) => na(x) ? "null" : str.tostring(x)

candlesStr = ""
if includeCandles
    [o10, h10, l10, c10, v10, t10] = f_candle("10")
    [o30, h30, l30, c30, v30, t30] = f_candle("30")
    [o60, h60, l60, c60, v60, t60] = f_candle("60")
    [o240, h240, l240, c240, v240, t240] = f_candle("240")
    [oD, hD, lD, cD, vD, tD] = f_candle("D")
    [oW, hW, lW, cW, vW, tW] = f_candle("W")
    candlesStr := ",\"tf_candles\":{\"10\":{\"ts\":" + f_num(t10) + ",\"o\":" + f_num(o10) + ",\"h\":" + f_num(h10) + ",\"l\":" + f_num(l10) + ",\"c\":" + f_num(c10) + ",\"v\":" + f_num(v10) + "},\"30\":{\"ts\":" + f_num(t30) + ",\"o\":" + f_num(o30) + ",\"h\":" + f_num(h30) + ",\"l\":" + f_num(l30) + ",\"c\":" + f_num(c30) + ",\"v\":" + f_num(v30) + "},\"60\":{\"ts\":" + f_num(t60) + ",\"o\":" + f_num(o60) + ",\"h\":" + f_num(h60) + ",\"l\":" + f_num(l60) + ",\"c\":" + f_num(c60) + ",\"v\":" + f_num(v60) + "},\"240\":{\"ts\":" + f_num(t240) + ",\"o\":" + f_num(o240) + ",\"h\":" + f_num(h240) + ",\"l\":" + f_num(l240) + ",\"c\":" + f_num(c240) + ",\"v\":" + f_num(v240) + "},\"D\":{\"ts\":" + f_num(tD) + ",\"o\":" + f_num(oD) + ",\"h\":" + f_num(hD) + ",\"l\":" + f_num(lD) + ",\"c\":" + f_num(cD) + ",\"v\":" + f_num(vD) + "},\"W\":{\"ts\":" + f_num(tW) + ",\"o\":" + f_num(oW) + ",\"h\":" + f_num(hW) + ",\"l\":" + f_num(lW) + ",\"c\":" + f_num(cW) + ",\"v\":" + f_num(vW) + "}}"

payload = "{" + "\"script_version\":\"" + scriptVersion + "\"," + "\"ts\":" + str.tostring(time) + "," + "\"time_close\":" + str.tostring(time_close) + "," + "\"bar_index\":" + str.tostring(bar_index) + "," + "\"ticker\":\"" + syminfo.ticker + "\"," + "\"tf_hint\":\"" + timeframe.period + "\"," + "\"price\":" + str.tostring(close) + sessionJson + prevCloseStr + chgStr + pctStr + avgVolStr + adrStr + momStr + (includeOHLC ? ",\"o\":" + str.tostring(open) + ",\"h\":" + str.tostring(high) + ",\"l\":" + str.tostring(low) : "") + (includeVolume ? ",\"volume\":" + str.tostring(volume) : "") + contextStr + candlesStr + ",\"ingest_kind\":\"capture\"" + "}"

if barstate.isconfirmed
    if shouldSendContext
        lastContextSentTs := time
    alert(payload, alert.freq_once_per_bar_close)
