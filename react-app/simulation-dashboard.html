<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Timed Trading - Trade Tracker</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300c853'/%3E%3Cstop offset='50%25' stop-color='%2300e676'/%3E%3Cstop offset='100%25' stop-color='%2369f0ae'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='24' height='24' rx='5.5' fill='url(%23g)'/%3E%3Cpolyline points='22 7 13.5 15.5 8.5 10.5 2 17' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpolyline points='16 7 22 7 22 13' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Trade Tracker — Robinhood-inspired dark (v3) */
      :root {
        --tt-bg-base: #0b0e11;
        --tt-bg-surface: rgba(255,255,255,0.02);
        --tt-bg-elevated: rgba(255,255,255,0.035);
        --tt-bg-hover: rgba(255,255,255,0.04);
        --tt-border: rgba(255,255,255,0.04);
        --tt-border-strong: rgba(255,255,255,0.08);
        --tt-text: #e5e7eb;
        --tt-text-muted: #6b7280;
        --tt-text-faint: #4b5563;
        --tt-accent: #00c853;
        --tt-accent-dim: rgba(0, 200, 83, 0.12);
        --tt-negative: #ff5252;
        --tt-negative-dim: rgba(255, 82, 82, 0.12);
        --tt-radius: 12px;
        --tt-radius-sm: 8px;
        --tt-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }
      body {
        background: var(--tt-bg-base);
        color: var(--tt-text);
        font-family: var(--tt-font);
        -webkit-font-smoothing: antialiased;
      }
      .tt-card {
        background: var(--tt-bg-surface);
        border: 1px solid var(--tt-border);
        border-radius: var(--tt-radius);
      }
      .tt-pill {
        padding: 6px 12px;
        border-radius: 9999px;
        font-size: 13px;
        font-weight: 500;
        transition: background 0.15s, color 0.15s;
      }
      .tt-pill-active {
        background: var(--tt-bg-elevated);
        color: var(--tt-text);
      }
      .tt-pill-inactive {
        background: transparent;
        color: var(--tt-text-muted);
      }
      .tt-pill-inactive:hover {
        color: var(--tt-text);
        background: var(--tt-bg-hover);
      }
      .tt-label {
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--tt-text-faint);
      }
      .loading-spinner {
        width: 28px; height: 28px;
        position: relative; display: inline-block;
      }
      .loading-spinner::before {
        content: ""; position: absolute; inset: 0; border-radius: 6px;
        background: linear-gradient(135deg, rgba(0,200,83,0.15), rgba(0,200,83,0.04));
        animation: tt-loader-pulse 1.6s ease-in-out infinite;
      }
      .loading-spinner::after {
        content: ""; position: absolute; left: 3px; right: 3px; top: 50%; height: 2px;
        background: linear-gradient(90deg, transparent, #00c853, #00e676, #69f0ae, transparent);
        background-size: 200% 100%; border-radius: 1px;
        animation: tt-loader-sweep 1.2s ease-in-out infinite;
      }
      @keyframes tt-loader-pulse { 0%, 100% { opacity: 0.4; transform: scale(0.92); } 50% { opacity: 1; transform: scale(1); } }
      @keyframes tt-loader-sweep { 0% { background-position: -100% 0; opacity: 0.5; } 50% { opacity: 1; } 100% { background-position: 200% 0; opacity: 0.5; } }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      @keyframes pulse-badge {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.15); }
      }
      .slide-in-right {
        animation: slideInRight 0.25s ease-out;
      }
      @keyframes slideInRight {
        from { transform: translateX(8px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      .card-pulse { animation: card-pulse 2s ease-in-out infinite; }
      @keyframes card-pulse {
        0%, 100% { box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.2); }
        50% { box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.5); }
      }
      .card-pulse-short { animation: card-pulse-short 2s ease-in-out infinite; }
      @keyframes card-pulse-short {
        0%, 100% { box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.2); }
        50% { box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.5); }
      }

      /* Admin-only nav links: hidden for non-admin users */
      body:not([data-user-role="admin"]) a[data-admin-only] {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script src="auth-gate.js?v=20260219a"></script>
    <script src="shared-price-utils.js?v=20260211a"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="shared-right-rail.compiled.js?v=20260218a" type="text/babel"></script>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, memo, useRef } = React;

      // ─────────────────────────────────────────────────────────────
      // Constants
      // ─────────────────────────────────────────────────────────────
      const API_BASE = "";  // same-origin — proxied by Pages Function
      // API_KEY removed for security - write operations disabled for public access
      // To enable trade management, implement proper authentication
      const TRADE_SIZE = 1000; // $1000 per trade
      const BASELINE_ACCOUNT = 100000; // starting account value for P&L display
      const FUTURES_TICKERS = new Set([
        "ES",
        "NQ",
        "YM",
        "RTY",
        "CL",
        "GC",
        "SI",
        "HG",
        "NG",
      ]);

      // Futures contract specifications (point value per contract) - matches worker
      const FUTURES_SPECS = {
        "ES1!": { pointValue: 50, name: "E-mini S&P 500" },
        "NQ1!": { pointValue: 20, name: "E-mini Nasdaq-100" },
        "MES1!": { pointValue: 5, name: "Micro E-mini S&P 500" },
        "MNQ1!": { pointValue: 2, name: "Micro E-mini Nasdaq-100" },
        "YM1!": { pointValue: 5, name: "E-mini Dow" },
        "RTY1!": { pointValue: 50, name: "E-mini Russell 2000" },
        ES: { pointValue: 50, name: "E-mini S&P 500" },
        NQ: { pointValue: 20, name: "E-mini Nasdaq-100" },
        YM: { pointValue: 5, name: "E-mini Dow" },
      };

      const USD_FMT = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        maximumFractionDigits: 2,
      });
      const INT_FMT = new Intl.NumberFormat("en-US");

      function fmtUsd(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return "—";
        return USD_FMT.format(n);
      }

      function fmtInt(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return "—";
        return INT_FMT.format(n);
      }

      // Normalize API ts to ms (entry_ts/exit_ts may be seconds from older data)
      function tsToMs(ts) {
        const n = Number(ts);
        if (!Number.isFinite(n)) return null;
        return n < 1e12 ? n * 1000 : n;
      }

      function humanizeExitReason(raw) {
        if (!raw) return "—";
        const s = String(raw).trim();
        const map = {
          ema_regime_reversed: "Regime Reversed",
          sl_breached: "Stop Loss Hit",
          max_loss: "Max Loss Reached",
          tp_reached: "Take Profit Hit",
          TP_FULL: "Take Profit Hit",
          replay_end_close: "Sim Period End",
          bias_flip_full_bull_vs_short: "Bias Flip (Bull vs Short)",
          bias_flip_full_bear_vs_long: "Bias Flip (Bear vs Long)",
          bias_flip_htf_bull_vs_short: "HTF Bias Flip (Bull)",
          bias_flip_htf_bear_vs_long: "HTF Bias Flip (Bear)",
          critical_downgraded_to_defend: "Critical — Defend Mode",
          hard_fuse_rsi_extreme: "RSI Fuse (Extreme)",
          soft_fuse_rsi_confirmed: "RSI Fuse (Confirmed)",
          SOFT_FUSE_RSI_CONFIRMED: "RSI Fuse (Confirmed)",
          KANBAN_EXIT: "Exit Signal",
          exit_signal: "Exit Signal",
          overextended: "Overextended",
          adverse_move_warning: "Adverse Move",
          large_adverse_move: "Large Adverse Move",
          left_entry_corridor: "Left Entry Corridor",
          daily_ema_regime_break: "Daily EMA Break",
          ichimoku_regime_break: "Ichimoku Break",
          trigger_breached_5pct: "Trigger Breached 5%",
          above_trigger: "Above Trigger",
          below_trigger: "Below Trigger",
        };
        if (map[s]) return map[s];
        const parts = s.split(",").map(p => p.trim()).filter(Boolean);
        const mapped = parts.map(p => map[p] || p.replace(/_/g, " ")).filter(Boolean);
        const unique = [...new Set(mapped)];
        if (unique.length <= 2) return unique.join(" + ");
        return unique[0];
      }

      function resolveDirection(src) {
        const direct = String(src?.direction || "").toUpperCase();
        if (direct === "LONG" || direct === "SHORT") return direct;
        const state = String(src?.state || "");
        // Prioritize HTF prefix to avoid LTF_BULL matching in HTF_BEAR_LTF_BULL
        if (state.startsWith("HTF_BULL")) return "LONG";
        if (state.startsWith("HTF_BEAR")) return "SHORT";
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        const triggerDir = String(src?.trigger_dir || "").toUpperCase();
        if (triggerDir.includes("BULL")) return "LONG";
        if (triggerDir.includes("BEAR")) return "SHORT";
        return null;
      }

      function computeEntryRef(src) {
        const entryRef = Number(src?.entry_ref);
        if (Number.isFinite(entryRef) && entryRef > 0) return entryRef;
        const trigger = Number(src?.trigger_price);
        if (Number.isFinite(trigger) && trigger > 0) return trigger;
        const entryPrice = Number(src?.entryPrice);
        if (Number.isFinite(entryPrice) && entryPrice > 0) return entryPrice;
        const price = Number(src?.price ?? src?.currentPrice);
        return Number.isFinite(price) && price > 0 ? price : null;
      }

      function computeTpTargetPrice(src) {
        const directTarget = Number(src?.tp_target_price ?? src?.tp_target);
        if (Number.isFinite(directTarget) && directTarget > 0)
          return directTarget;
        const tp = Number(src?.tp);
        if (Number.isFinite(tp) && tp > 0) return tp;
        return null;
      }

      function computeTpMaxPrice(src) {
        const directMax = Number(src?.tp_max_price ?? src?.tp_max);
        if (Number.isFinite(directMax) && directMax > 0) return directMax;
        const entry = computeEntryRef(src);
        if (!Number.isFinite(entry)) return null;
        const dir = resolveDirection(src);
        const tpLevels = Array.isArray(src?.tp_levels) ? src.tp_levels : [];
        const candidates = tpLevels
          .map((tp) => {
            const price =
              tp && typeof tp === "object" && tp.price != null
                ? Number(tp.price)
                : Number(tp);
            return Number.isFinite(price) ? price : null;
          })
          .filter((p) => Number.isFinite(p));
        if (candidates.length === 0) return null;
        if (dir === "LONG") {
          const valid = candidates.filter((p) => p > entry);
          return valid.length > 0 ? Math.max(...valid) : null;
        }
        if (dir === "SHORT") {
          const valid = candidates.filter((p) => p < entry);
          return valid.length > 0 ? Math.min(...valid) : null;
        }
        return null;
      }

      // ── Shared price utilities (from shared-price-utils.js) ──
      // Single source of truth for daily change, staleness, and market-hours logic.
      const getIngestMs = window.TimedPriceUtils.getIngestMs;
      const getNyClock = window.TimedPriceUtils.getNyClock;
      const isNyRegularMarketOpen = window.TimedPriceUtils.isNyRegularMarketOpen;
      const ageLabelFromMinutes = window.TimedPriceUtils.ageLabelFromMinutes;
      const getStaleInfo = window.TimedPriceUtils.getStaleInfo;
      const getDailyChange = window.TimedPriceUtils.getDailyChange;

      function computeReturnPct(src) {
        const direct =
          Number(src?.expected_return_pct) ||
          Number(src?.tp_target_pct) ||
          Number(src?.tp_max_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(src);
        const tpTarget = computeTpTargetPrice(src) ?? computeTpMaxPrice(src);
        if (!Number.isFinite(entry) || !Number.isFinite(tpTarget)) return null;
        return (Math.abs(tpTarget - entry) / entry) * 100;
      }

      function computeRiskPct(src) {
        const direct = Number(src?.risk_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(src);
        const sl = Number(src?.sl);
        if (!Number.isFinite(entry) || !Number.isFinite(sl)) return null;
        return (Math.abs(entry - sl) / entry) * 100;
      }

      function computeEtaDays(src) {
        const staleness = String(src?.staleness || "").toUpperCase();
        if (staleness && staleness !== "FRESH") return null;
        const baseEta = Number(src?.eta_days_v2 ?? src?.eta_days);
        if (!Number.isFinite(baseEta) || baseEta <= 0) return null;
        const dir = resolveDirection(src);
        const entry = computeEntryRef(src);
        const target = computeTpTargetPrice(src);
        const current = Number(src?.price ?? src?.currentPrice);
        if (
          !Number.isFinite(entry) ||
          !Number.isFinite(target) ||
          !Number.isFinite(current) ||
          !dir
        ) {
          return baseEta;
        }
        const totalDist = Math.abs(target - entry);
        if (!Number.isFinite(totalDist) || totalDist <= 0) return baseEta;
        const progress =
          dir === "LONG"
            ? (current - entry) / (target - entry)
            : (entry - current) / (entry - target);
        if (!Number.isFinite(progress)) return baseEta;
        const clamped = Math.max(0, Math.min(1, progress));
        const remaining = baseEta * (1 - clamped);
        return Math.max(0.1, Math.round(remaining * 100) / 100);
      }

      function computeHorizonBucket(src) {
        const bucket = String(src?.horizon_bucket || "")
          .trim()
          .toUpperCase();
        if (bucket) return bucket.replace("_", " ");
        const eta = computeEtaDays(src);
        if (!Number.isFinite(eta)) return "—";
        if (eta <= 7) return "SHORT TERM";
        if (eta <= 30) return "SWING";
        return "POSITIONAL";
      }

      function computeHorizonKey(src) {
        const bucket = String(src?.horizon_bucket || "")
          .trim()
          .toUpperCase();
        if (bucket) return bucket;
        const eta = computeEtaDays(src);
        if (!Number.isFinite(eta)) return "UNKNOWN";
        if (eta <= 7) return "SHORT_TERM";
        if (eta <= 30) return "SWING";
        return "POSITIONAL";
      }

      // ─────────────────────────────────────────────────────────────
      // Hooks
      // ─────────────────────────────────────────────────────────────
      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);
        const hasLoadedRef = React.useRef(false);

        const fetchData = useCallback(async () => {
          try {
            if (!hasLoadedRef.current) setLoading(true);
            setRefreshing(true);
            setError(null);
            const timestamp = Date.now();
            const res = await fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache, no-store, must-revalidate",
                Pragma: "no-cache",
                Expires: "0",
              },
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && json.data) {
              setData(json.data);
              setLastUpdate(new Date());
              hasLoadedRef.current = true;
            } else {
              throw new Error(json.error || "Invalid response");
            }
          } catch (err) {
            setError(err.message);
            console.error("Fetch error:", err);
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 30000); // Refresh every 30 seconds (keep prices fresh)
          return () => clearInterval(interval);
        }, [fetchData]);

        // Merge /timed/prices into data so Open Positions and metrics use actual current price + daily change
        const dataRef = React.useRef(data);
        dataRef.current = data;
        const hasData = data && Object.keys(data).length > 0;
        useEffect(() => {
          if (!hasData) return;
          const mergePrices = async () => {
            try {
              const res = await fetch(`${API_BASE}/timed/prices?_t=${Date.now()}`, { cache: "no-store" });
              if (!res.ok) return;
              const json = await res.json();
              if (!json.ok || !json.prices) return;
              const current = dataRef.current;
              if (!current || typeof current !== "object") return;
              const updated = { ...current };
              let changed = false;
              for (const [sym, priceInfo] of Object.entries(json.prices)) {
                const key = String(sym).toUpperCase();
                const existing = updated[key];
                if (!existing || !(priceInfo.p > 0)) continue;
                if (existing._live_price === priceInfo.p && existing._live_daily_change_pct === priceInfo.dp) continue;
                // Smart prev_close: reject feed's pc when it ≈ current price
                // (Alpaca returns prevDailyBar.close = current price outside RTH → 0% daily change).
                const feedPc = Number(priceInfo.pc);
                const feedP = Number(priceInfo.p);
                const feedPcUsable = Number.isFinite(feedPc) && feedPc > 0 && feedP > 0
                  && (Math.abs(feedPc - feedP) / feedP * 100) > 0.05;
                const bestPc = feedPcUsable
                  ? feedPc
                  : (existing._live_prev_close || existing.prev_close || undefined);
                // Merge dc/dp so daily change displays for SPY, sector ETFs, etc. (even when 0%)
                const feedDc = Number(priceInfo.dc);
                const feedDp = Number(priceInfo.dp);
                updated[key] = {
                  ...existing,
                  price: priceInfo.p,
                  _live_price: priceInfo.p,
                  ...(bestPc > 0 ? { _live_prev_close: bestPc } : {}),
                  ...(Number.isFinite(feedDp) ? { day_change_pct: feedDp, change_pct: feedDp } : {}),
                  ...(Number.isFinite(feedDc) ? { day_change: feedDc, change: feedDc } : {}),
                  ...(feedPcUsable && bestPc > 0 ? { prev_close: bestPc } : {}),
                  _live_daily_change: feedDc,
                  _live_daily_change_pct: feedDp,
                  _price_updated_at: json.updated_at || Date.now(),
                };
                changed = true;
              }
              if (changed) setData(updated);
            } catch (e) { console.warn("[PRICE FEED]", e); }
          };
          mergePrices();
          const interval = setInterval(mergePrices, 30000);
          return () => clearInterval(interval);
        }, [hasData]);

        return {
          data,
          loading,
          refreshing,
          error,
          lastUpdate,
          refetch: fetchData,
        };
      }

      function useSimulatedTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const hasLoadedRef = React.useRef(false);

        // Fetch trades from Worker
        const fetchTrades = useCallback(async (version = null) => {
          try {
            if (!hasLoadedRef.current) setLoading(true);
            setRefreshing(true);
            setError(null);
            const ts = Date.now();
            // Prefer D1 positions so trades include history[] (execution timeline)
            const source = "positions";
            const baseUrl = version
              ? `${API_BASE}/timed/trades?source=${source}&version=${encodeURIComponent(version)}`
              : `${API_BASE}/timed/trades?source=${source}`;
            const url = `${baseUrl}&_t=${ts}`;
            console.log(`[UI] Fetching trades from ${url}`);
            const res = await fetch(url, {
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache, no-store, must-revalidate",
                Pragma: "no-cache",
                Expires: "0",
              },
            });
            console.log(`[UI] Response status: ${res.status}, ok: ${res.ok}`);
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[UI] HTTP ${res.status} error:`, errorText);
              throw new Error(
                `HTTP ${res.status}: ${errorText.substring(0, 100)}`,
              );
            }
            const json = await res.json();
            console.log(`[UI] Response:`, {
              ok: json.ok,
              count: json.count,
              totalCount: json.totalCount,
              tradesLength: json.trades?.length,
              versions: json.versions,
            });
            if (json.ok && Array.isArray(json.trades)) {
              console.log(`[UI] ✅ Setting ${json.trades.length} trades`);
              setTrades(json.trades);
              hasLoadedRef.current = true;
            } else {
              console.error(`[UI] ❌ Invalid response:`, json);
              setTrades([]); // Set empty array instead of throwing
              throw new Error(json.error || "Invalid response format");
            }
          } catch (err) {
            setError(err.message);
            console.error("[UI] Fetch trades error:", err);
            setTrades([]); // Ensure trades is set to empty array on error
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        // Load trades on mount
        useEffect(() => {
          fetchTrades();
        }, [fetchTrades]);

        // Save trade to Worker - DISABLED for public access (security)
        const saveTrade = useCallback(async (trade) => {
          throw new Error(
            "Trade management is disabled for public access. This is a read-only dashboard.",
          );
        }, []);

        const addTrade = useCallback(
          async (trade) => {
            await saveTrade(trade);
          },
          [saveTrade],
        );

        const updateTrade = useCallback(
          async (tradeId, updates) => {
            const existingTrade = trades.find((t) => t.id === tradeId);
            if (!existingTrade) {
              console.error("Trade not found:", tradeId);
              return;
            }
            const updatedTrade = { ...existingTrade, ...updates };
            await saveTrade(updatedTrade);
          },
          [trades, saveTrade],
        );

        return {
          trades,
          loading,
          refreshing,
          error,
          addTrade,
          updateTrade,
          refetch: fetchTrades,
        };
      }

      // Paper portfolio (Kanban-driven executions)
      function usePaperPortfolio() {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);

        const fetchPortfolio = useCallback(async () => {
          try {
            setRefreshing(true);
            setError(null);
            const ts = Date.now();
            const url = `${API_BASE}/timed/portfolio?_t=${ts}`;
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "portfolio_failed");
            setData(json);
            setLastUpdate(new Date());
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        useEffect(() => {
          fetchPortfolio();
          const interval = setInterval(fetchPortfolio, 30000);
          return () => clearInterval(interval);
        }, [fetchPortfolio]);

        return {
          data,
          loading,
          refreshing,
          error,
          lastUpdate,
          refetch: fetchPortfolio,
        };
      }

      // Account Summary hook — single source of truth from account_ledger
      function useAccountSummary(mode = "trader") {
        const [summary, setSummary] = useState(null);
        const [loading, setLoading] = useState(true);

        const fetchSummary = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/account-summary?mode=${mode}&_t=${Date.now()}`, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) setSummary(json);
          } catch { /* best-effort */ }
          finally { setLoading(false); }
        }, [mode]);

        useEffect(() => {
          fetchSummary();
          const interval = setInterval(fetchSummary, 60000);
          return () => clearInterval(interval);
        }, [fetchSummary]);

        return { summary, loading, refetch: fetchSummary };
      }

      function useEquityCurve(mode = "both") {
        const [curveData, setCurveData] = useState(null);
        const [loading, setLoading] = useState(true);

        const fetchCurve = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/portfolio/equity-curve?mode=${mode}&_t=${Date.now()}`, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) setCurveData(json);
          } catch { /* best-effort */ }
          finally { setLoading(false); }
        }, [mode]);

        useEffect(() => {
          fetchCurve();
          const interval = setInterval(fetchCurve, 120000);
          return () => clearInterval(interval);
        }, [fetchCurve]);

        return { curveData, loading, refetch: fetchCurve };
      }

      // ─────────────────────────────────────────────────────────────
      // Ledger (D1) Hooks
      // ─────────────────────────────────────────────────────────────

      function useLedgerSummary({ since = null, until = null } = {}) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSummary = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const qs = new URLSearchParams();
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            const url = `${API_BASE}/timed/ledger/summary?${qs.toString()}`;
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok)
              throw new Error(json.error || "ledger_summary_failed");
            setData(json);
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
          }
        }, [since, until]);

        useEffect(() => {
          fetchSummary();
        }, [fetchSummary]);

        return { data, loading, error, refetch: fetchSummary };
      }

      function useLedgerTrades({
        ticker = "",
        status = "all",
        since = null,
        until = null,
        pageSize = 200,
      } = {}) {
        const [items, setItems] = useState([]);
        const [loading, setLoading] = useState(true);
        const [loadingMore, setLoadingMore] = useState(false);
        const [error, setError] = useState(null);
        const [hasMore, setHasMore] = useState(false);
        const [cursor, setCursor] = useState(null);

        const buildUrl = useCallback(
          (cursorVal) => {
            const qs = new URLSearchParams();
            if (ticker) qs.set("ticker", ticker);
            if (status && status !== "all") qs.set("status", status);
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            qs.set("limit", String(pageSize));
            if (cursorVal) qs.set("cursor", String(cursorVal));
            return `${API_BASE}/timed/ledger/trades?${qs.toString()}`;
          },
          [ticker, status, since, until, pageSize],
        );

        const fetchFirstPage = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(buildUrl(null), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_trades_failed");
            const trades = Array.isArray(json.trades) ? json.trades : [];
            setItems(trades);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
            setItems([]);
            setHasMore(false);
            setCursor(null);
          } finally {
            setLoading(false);
          }
        }, [buildUrl]);

        const fetchMore = useCallback(async () => {
          if (!cursor || loadingMore) return;
          try {
            setLoadingMore(true);
            const res = await fetch(buildUrl(cursor), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_trades_failed");
            const trades = Array.isArray(json.trades) ? json.trades : [];
            setItems((prev) => [...prev, ...trades]);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
          } finally {
            setLoadingMore(false);
          }
        }, [buildUrl, cursor, loadingMore]);

        useEffect(() => {
          fetchFirstPage();
        }, [fetchFirstPage]);

        return {
          items,
          loading,
          loadingMore,
          error,
          hasMore,
          fetchMore,
          refetch: fetchFirstPage,
        };
      }

      function useLedgerAlerts({
        ticker = "",
        since = null,
        until = null,
        pageSize = 200,
      } = {}) {
        const [items, setItems] = useState([]);
        const [loading, setLoading] = useState(true);
        const [loadingMore, setLoadingMore] = useState(false);
        const [error, setError] = useState(null);
        const [hasMore, setHasMore] = useState(false);
        const [cursor, setCursor] = useState(null);

        const buildUrl = useCallback(
          (cursorVal) => {
            const qs = new URLSearchParams();
            if (ticker) qs.set("ticker", ticker);
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            qs.set("limit", String(pageSize));
            if (cursorVal) qs.set("cursor", String(cursorVal));
            return `${API_BASE}/timed/ledger/alerts?${qs.toString()}`;
          },
          [ticker, since, until, pageSize],
        );

        const fetchFirstPage = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(buildUrl(null), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_alerts_failed");
            const alerts = Array.isArray(json.alerts) ? json.alerts : [];
            setItems(alerts);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
            setItems([]);
            setHasMore(false);
            setCursor(null);
          } finally {
            setLoading(false);
          }
        }, [buildUrl]);

        const fetchMore = useCallback(async () => {
          if (!cursor || loadingMore) return;
          try {
            setLoadingMore(true);
            const res = await fetch(buildUrl(cursor), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_alerts_failed");
            const alerts = Array.isArray(json.alerts) ? json.alerts : [];
            setItems((prev) => [...prev, ...alerts]);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
          } finally {
            setLoadingMore(false);
          }
        }, [buildUrl, cursor, loadingMore]);

        useEffect(() => {
          fetchFirstPage();
        }, [fetchFirstPage]);

        return {
          items,
          loading,
          loadingMore,
          error,
          hasMore,
          fetchMore,
          refetch: fetchFirstPage,
        };
      }

      function useLedgerTradeDetail(tradeId, includeEvidence = false) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);

        const fetchDetail = useCallback(async () => {
          if (!tradeId) {
            setData(null);
            setError(null);
            return;
          }
          try {
            setLoading(true);
            setError(null);
            const qs = includeEvidence ? "?includeEvidence=1" : "";
            const res = await fetch(
              `${API_BASE}/timed/ledger/trades/${encodeURIComponent(tradeId)}${qs}`,
              { cache: "no-store" },
            );
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok)
              throw new Error(json.error || "ledger_trade_detail_failed");
            setData(json);
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
          }
        }, [tradeId, includeEvidence]);

        useEffect(() => {
          fetchDetail();
        }, [fetchDetail]);

        return { data, loading, error, refetch: fetchDetail };
      }

      function useSectors() {
        const [sectors, setSectors] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSectors = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/sectors`, {
              cache: "no-store",
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.sectors)) {
              setSectors(json.sectors);
            } else {
              setSectors([]);
            }
          } catch (err) {
            setError(err.message);
            setSectors([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchSectors();
          const interval = setInterval(fetchSectors, 300000);
          return () => clearInterval(interval);
        }, [fetchSectors]);

        return { sectors, loading, error, refetch: fetchSectors };
      }

      // ─────────────────────────────────────────────────────────────
      // Trade Simulation Logic
      // ─────────────────────────────────────────────────────────────
      function shouldTriggerTrade(ticker, prevData) {
        // Skip futures
        if (FUTURES_TICKERS.has(ticker.ticker.toUpperCase())) return false;

        // Must have valid entry/exit levels
        if (!ticker.price || !ticker.sl || !ticker.tp) return false;

        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const alignedLong = state === "HTF_BULL_LTF_BULL";
        const alignedShort = state === "HTF_BEAR_LTF_BEAR";
        const aligned = alignedLong || alignedShort;
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        const side = ent.side; // LONG or SHORT

        // Corridor must match alignment
        const corridorAlignedOK =
          (side === "LONG" && alignedLong) ||
          (side === "SHORT" && alignedShort);

        if (!inCorridor || !corridorAlignedOK) return false;

        // Check for trigger conditions (matches worker logic)
        const enteredAligned = prevData && prevData.state !== state && aligned;
        const trigReason = String(ticker.trigger_reason || "");
        const trigOk =
          trigReason === "EMA_CROSS" || trigReason === "SQUEEZE_RELEASE";
        const sqRelease = !!flags.sq30_release;
        const hasTrigger = !!ticker.trigger_price && !!ticker.trigger_ts;

        // Must be: in corridor + corridor aligns + (entered aligned OR trigger OR squeeze release)
        const shouldConsiderAlert =
          inCorridor &&
          corridorAlignedOK &&
          (enteredAligned || trigOk || sqRelease || hasTrigger);

        // Check Momentum Elite status
        const momentumElite = !!flags.momentum_elite;

        // Threshold gates (with Momentum Elite adjustments - matching worker logic)
        const baseMinRR = 1.5;
        const baseMaxComp = 0.4;
        const baseMaxPhase = 0.6;
        const baseMinRank = 70;

        // Adjust thresholds for Momentum Elite (more lenient for quality stocks)
        const minRR = momentumElite
          ? Math.max(1.2, baseMinRR * 0.9)
          : baseMinRR; // Lower RR requirement
        const maxComp = momentumElite
          ? Math.min(0.5, baseMaxComp * 1.25)
          : baseMaxComp; // Allow higher completion
        const maxPhase = momentumElite
          ? Math.min(0.7, baseMaxPhase * 1.17)
          : baseMaxPhase; // Allow higher phase
        const minRank = momentumElite
          ? Math.max(60, baseMinRank - 10)
          : baseMinRank; // Lower rank requirement

        const rr = Number(ticker.rr) || 0;
        const comp = Number(ticker.completion) || 0;
        const phase = Number(ticker.phase_pct) || 0;
        const rank = Number(ticker.rank) || 0;

        const rrOk = rr >= minRR;
        const compOk = comp <= maxComp;
        const phaseOk = phase <= maxPhase;
        const rankOk = rank >= minRank;

        // Also consider Momentum Elite as a trigger condition (quality signal)
        const momentumEliteTrigger =
          momentumElite && inCorridor && corridorAlignedOK;

        // Enhanced trigger: original conditions OR Momentum Elite in good setup
        const enhancedTrigger = shouldConsiderAlert || momentumEliteTrigger;

        return enhancedTrigger && rrOk && compOk && phaseOk && rankOk;
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
        const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function getDirection(ticker) {
        const state = String(ticker.state || "");
        // Prioritize HTF prefix to avoid LTF_BULL matching in HTF_BEAR_LTF_BULL
        if (state.startsWith("HTF_BULL"))
          return {
            text: "LONG",
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        if (state.startsWith("HTF_BEAR"))
          return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        if (state.includes("BULL"))
          return {
            text: "LONG",
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        if (state.includes("BEAR"))
          return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: null, color: "text-[var(--tt-text-muted)]", bg: "bg-[var(--tt-bg-elevated)]" };
      }

      // Helpers for shared Right Rail (same API as Dashboard)
      function numFromAny(v) {
        if (v == null) return null;
        if (typeof v === "number") return Number.isFinite(v) ? v : null;
        if (typeof v === "string") {
          const s = v.trim();
          if (!s) return null;
          const m = s.replace(/,/g, "").match(/-?\d+(\.\d+)?/);
          if (!m) return null;
          const n = Number(m[0]);
          return Number.isFinite(n) ? n : null;
        }
        if (typeof v === "object" && v.price != null) return numFromAny(v.price);
        return null;
      }
      function fmtUsdAbs(n) {
        const x = numFromAny(n);
        if (!Number.isFinite(x)) return "—";
        return `$${Math.abs(x).toFixed(2)}`;
      }
      function getDirectionFromState(ticker) {
        const state = String(ticker?.state || "");
        if (state.startsWith("HTF_BULL")) return "LONG";
        if (state.startsWith("HTF_BEAR")) return "SHORT";
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        return null;
      }
      function summarizeEntryDecision(ticker) {
        const decision = ticker?.entry_decision;
        if (!decision || typeof decision !== "object") return null;
        const blockers = Array.isArray(decision.blockers) ? decision.blockers : [];
        const warnings = Array.isArray(decision.warnings) ? decision.warnings : [];
        const label = (code) => String(code || "").replace(/_/g, " ");
        if (decision.ok) return { status: "Eligible", detail: "All entry checks passed", tone: "text-green-400", bg: "bg-green-500/20", blockers: [], warnings: warnings.map(label) };
        if (blockers.length === 0) return { status: "Waiting", detail: "Setup not confirmed yet", tone: "text-[#6b7280]", bg: "bg-white/[0.04]", blockers: [], warnings: warnings.map(label) };
        const shown = blockers.slice(0, 3).map(label);
        return { status: "Blocked", detail: shown.join(", "), tone: "text-yellow-400", bg: "bg-yellow-500/20", blockers: blockers.map(label), warnings: warnings.map(label) };
      }
      const GROUP_ORDER = [];
      const GROUP_LABELS = {};
      function groupsForTicker(t) { return ["Other"]; }
      function getRankPosition(sortedTickers, tickerSymbol) {
        const sym = String(tickerSymbol || "").trim().toUpperCase();
        if (!sym) return null;
        const index = (sortedTickers || []).findIndex((t) => String(t.ticker || "").trim().toUpperCase() === sym);
        return index >= 0 ? index + 1 : null;
      }
      // Sector lookup for shared right rail (minimal map; extend as needed)
      function getTickerSector(ticker) {
        const T = String(ticker || "").trim().toUpperCase();
        if (!T) return "";
        const SECTOR_MAP = {
          XLK: "Information Technology", XLF: "Financials", XLY: "Consumer Discretionary",
          XLP: "Consumer Staples", XLE: "Energy", XLV: "Healthcare", XLI: "Industrials",
          XLB: "Basic Materials", XLRE: "Real Estate", XLU: "Utilities", XLC: "Communication Services",
          AAPL: "Information Technology", MSFT: "Information Technology", AMZN: "Consumer Discretionary",
          GOOGL: "Communication Services", META: "Communication Services", NVDA: "Information Technology",
        };
        return SECTOR_MAP[T] || "";
      }

      // Normalize sector names to match worker sector ratings (same as main dashboard).
      function normalizeSectorKey(sectorName) {
        const raw = String(sectorName || "").trim().toLowerCase().replace(/[-_/]+/g, " ").replace(/&/g, "and").replace(/\s+/g, " ");
        if (!raw) return "";
        const ALIASES = {
          "health care": "healthcare", healthcare: "healthcare", materials: "basic materials", "basic materials": "basic materials",
          "non energy minerals": "basic materials", "consumer durables": "consumer discretionary", "consumer non durables": "consumer staples",
          "consumer cyclical": "consumer discretionary", "consumer discretionary": "consumer discretionary", "consumer defensive": "consumer staples",
          "consumer staples": "consumer staples", "financial services": "financials", finance: "financials", financials: "financials",
          technology: "information technology", "technology services": "information technology", "electronic technology": "information technology",
          "information technology": "information technology", communications: "communication services", "communication services": "communication services",
          "energy minerals": "energy", energy: "energy", industrials: "industrials", utilities: "utilities", "real estate": "real estate",
        };
        return ALIASES[raw] || raw;
      }

      function sectorKeyToCanonicalName(key) {
        const K = String(key || "").trim().toLowerCase();
        const CANON = {
          "consumer discretionary": "Consumer Discretionary", industrials: "Industrials", "information technology": "Information Technology",
          "communication services": "Communication Services", "basic materials": "Basic Materials", energy: "Energy", financials: "Financials",
          "real estate": "Real Estate", "consumer staples": "Consumer Staples", healthcare: "Healthcare", utilities: "Utilities",
        };
        return CANON[K] || key;
      }

      function calculateTrade(ticker, entryPrice, existingTrade = null) {
        const directionObj = getDirection(ticker);
        const direction = directionObj.text;
        if (!direction) return null;

        const sl = Number(ticker.sl);
        const tp = Number(ticker.tp);
        const currentPrice = Number(ticker.price);

        if (
          !Number.isFinite(sl) ||
          !Number.isFinite(tp) ||
          !Number.isFinite(currentPrice)
        ) {
          return null;
        }

        // Determine if this is a futures contract
        const tickerSymbol = String(ticker.ticker || "").toUpperCase();
        const isFutures =
          FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");

        // For futures: trade 1 contract, calculate P&L based on point value
        // For stocks: calculate shares based on dollar amount
        let shares;
        let pointValue = 1; // Default for stocks (price per share)

        if (isFutures && FUTURES_SPECS[tickerSymbol]) {
          // Futures: always trade 1 contract
          shares = 1;
          pointValue = FUTURES_SPECS[tickerSymbol].pointValue;
        } else {
          // Stocks: calculate shares from dollar amount
          shares = TRADE_SIZE / entryPrice;
        }

        // Calculate P&L based on current price
        let pnl = 0;
        let pnlPct = 0;
        let status = "OPEN";

        // Check for partial trim (if position was already trimmed)
        const trimmedPct = existingTrade ? existingTrade.trimmedPct || 0 : 0;
        const remainingShares = shares * (1 - trimmedPct);

        // Calculate price differences (in points for futures, dollars for stocks)
        const priceDiff = currentPrice - entryPrice;
        const tpDiff = tp - entryPrice;
        const slDiff = sl - entryPrice;

        if (direction === "LONG") {
          // Check if hit TP or SL first
          const hitTP = currentPrice >= tp;
          const hitSL = currentPrice <= sl;

          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const trimPnl = tpDiff * shares * pointValue * 0.5;
              const trimPnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              pnl = tpDiff * shares * pointValue;
              pnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            pnl = slDiff * shares * pointValue;
            pnlPct = ((sl - entryPrice) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            pnl = priceDiff * shares * pointValue;
            pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        } else {
          // SHORT
          // Check if hit TP or SL first
          const hitTP = currentPrice <= tp;
          const hitSL = currentPrice >= sl;

          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const shortTpDiff = entryPrice - tp;
              const trimPnl = shortTpDiff * shares * pointValue * 0.5;
              const trimPnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              const shortTpDiff = entryPrice - tp;
              pnl = shortTpDiff * shares * pointValue;
              pnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            const shortSlDiff = entryPrice - sl;
            pnl = shortSlDiff * shares * pointValue;
            pnlPct = ((entryPrice - sl) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            const shortPriceDiff = entryPrice - currentPrice;
            pnl = shortPriceDiff * shares * pointValue;
            pnlPct = ((entryPrice - currentPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        }

        return {
          shares,
          pnl,
          pnlPct,
          status,
          currentPrice,
        };
      }

      // ─────────────────────────────────────────────────────────────
      // Trade Tracking
      // ─────────────────────────────────────────────────────────────
      // Trade simulation is now handled by Worker - UI just fetches and displays
      // No need for useTradeSimulation hook anymore - Worker handles everything

      // ─────────────────────────────────────────────────────────────
      // Analytics & Learning
      // ─────────────────────────────────────────────────────────────
      function useTradeAnalytics(trades) {
        return useMemo(() => {
          const EPS = 1e-6;

          const clamp01 = (x) => Math.max(0, Math.min(1, x));
          const smoothWinRate = (wins, losses) => {
            // Laplace smoothing (prevents noisy 1/1 = 100% claims)
            const w = Number(wins || 0);
            const l = Number(losses || 0);
            const n = w + l;
            return n > 0 ? (w + 1) / (n + 2) : 0;
          };
          const confidenceLabel = (n) => {
            if (n >= 30) return "high";
            if (n >= 10) return "medium";
            if (n >= 5) return "low";
            return "very low";
          };
          const getExitReason = (trade) => {
            if (!trade) return null;
            if (trade.exitReason) return String(trade.exitReason);
            const hist = trade.history;
            if (Array.isArray(hist)) {
              for (let i = hist.length - 1; i >= 0; i--) {
                const e = hist[i];
                if (e && e.type === "EXIT") {
                  if (e.reason) return String(e.reason);
                  const note = String(e.note || "");
                  const m = note.match(/\(([^)]+)\)\s*$/);
                  if (m && m[1]) return String(m[1]);
                }
              }
            }
            return null;
          };
          const hasTrimEvent = (trade) => {
            if (!trade) return false;
            if ((Number(trade.trimmedPct) || 0) > EPS) return true;
            const hist = trade.history;
            return (
              Array.isArray(hist) && hist.some((e) => e && e.type === "TRIM")
            );
          };

          const horizonKeyForTrade = (trade) => {
            if (!trade) return "UNKNOWN";
            return computeHorizonKey(trade);
          };

          const computeExcursions = (trade) => {
            if (!trade) return null;
            const entry = Number(trade.entryPrice);
            if (!Number.isFinite(entry) || entry <= 0) return null;
            const prices = [entry];
            if (Array.isArray(trade.history)) {
              trade.history.forEach((e) => {
                if (e && Number.isFinite(Number(e.price))) {
                  prices.push(Number(e.price));
                }
              });
            }
            const exit = Number(trade.exitPrice ?? trade.exit_price);
            if (Number.isFinite(exit)) prices.push(exit);
            const current = Number(trade.currentPrice);
            if (Number.isFinite(current)) prices.push(current);
            const maxP = Math.max(...prices);
            const minP = Math.min(...prices);
            const isLong =
              String(trade.direction || "").toUpperCase() !== "SHORT";
            const mfe = isLong ? maxP - entry : entry - minP;
            const mae = isLong ? entry - minP : maxP - entry;
            const mfePct = (mfe / entry) * 100;
            const maePct = (mae / entry) * 100;
            return {
              mfe: Number.isFinite(mfe) ? mfe : null,
              mae: Number.isFinite(mae) ? mae : null,
              mfePct: Number.isFinite(mfePct) ? mfePct : null,
              maePct: Number.isFinite(maePct) ? maePct : null,
            };
          };

          // Helper to check if trade has remaining shares/contracts (not fully closed)
          const hasRemainingShares = (t) => {
            const tickerSym = String(t.ticker || "").toUpperCase();
            const isFut = FUTURES_SPECS[tickerSym] || tickerSym.endsWith("1!");
            const shares =
              t.shares ||
              (isFut && FUTURES_SPECS[tickerSym]
                ? 1
                : TRADE_SIZE / (t.entryPrice || 1));
            const trimmedPct = t.trimmedPct || 0;
            const remainingShares = shares - shares * trimmedPct;
            return remainingShares > 0;
          };

          // Closed: WIN/LOSS or 100% trimmed (safety net)
          const isClosedStatus = (s) => s === "WIN" || s === "LOSS" || s === "FLAT";
          const closed = trades.filter((t) => {
            const trimmedPct = Number(t.trimmedPct ?? t.trimmed_pct ?? 0);
            return (
              isClosedStatus(t.status) ||
              trimmedPct >= 0.9999
            );
          });

          // Trimmed: partially trimmed, still has remaining shares
          const trimmed = trades.filter((t) => {
            const trimmedPct = Number(t.trimmedPct ?? t.trimmed_pct ?? 0);
            const isTrimmed = trimmedPct > 0 || t.status === "TP_HIT_TRIM";
            return isTrimmed && hasRemainingShares(t) && trimmedPct < 0.9999;
          });

          // Open: no trim, not closed
          const open = trades.filter((t) => {
            const trimmedPct = Number(t.trimmedPct ?? t.trimmed_pct ?? 0);
            const isTrimmed = trimmedPct > 0 || t.status === "TP_HIT_TRIM";
            const isClosed =
              isClosedStatus(t.status) ||
              trimmedPct >= 0.9999;
            return (
              (t.status === "OPEN" || !t.status) && !isTrimmed && !isClosed
            );
          });

          const openTrades = open.length;
          const trimmedTrades = trimmed.length;
          const closedTrades = closed.length;
          const totalTrades = openTrades + trimmedTrades + closedTrades; // Sum of all categories

          const wins = closed.filter((t) => t.status === "WIN").length;
          const losses = closed.filter((t) => t.status === "LOSS").length;
          const flats = closed.filter((t) => t.status === "FLAT").length;
          const decisiveTrades = wins + losses; // Exclude flats from win rate calculation
          const winRate = decisiveTrades > 0 ? (wins / decisiveTrades) * 100 : 0;

          // Calculate Closed P&L: includes fully closed trades + realized P&L from trimmed positions
          const closedPnl = closed.reduce((sum, t) => sum + (t.pnl || 0), 0);

          // Calculate realized P&L from trimmed positions
          const trimmedRealizedPnl = trimmed.reduce((sum, t) => {
            const tickerSym = String(t.ticker || "").toUpperCase();
            const isFut = FUTURES_SPECS[tickerSym] || tickerSym.endsWith("1!");
            const pointVal =
              isFut && FUTURES_SPECS[tickerSym]
                ? FUTURES_SPECS[tickerSym].pointValue
                : 1;
            const shares =
              t.shares ||
              (isFut && FUTURES_SPECS[tickerSym]
                ? 1
                : TRADE_SIZE / (t.entryPrice || 1));
            const trimmedPct = t.trimmedPct || 0;
            const trimmedShares = shares * trimmedPct;
            const entryPrice = t.entryPrice || 0;
            const tp = t.tp || entryPrice; // Use TP price where trimmed occurred

            if (trimmedShares > 0 && entryPrice > 0) {
              const direction = t.direction || "LONG";
              if (direction === "LONG") {
                // LONG: profit = (TP - Entry) * trimmed shares * point value
                const priceDiff = tp - entryPrice;
                return sum + priceDiff * trimmedShares * pointVal;
              } else {
                // SHORT: profit = (Entry - TP) * trimmed shares * point value
                const priceDiff = entryPrice - tp;
                return sum + priceDiff * trimmedShares * pointVal;
              }
            }
            return sum;
          }, 0);

          // Total Closed P&L = fully closed + trimmed realized
          const totalPnl = closedPnl + trimmedRealizedPnl;

          // Open P&L: prefer D1 pre-computed pnl (accurate from replay) over client-side calculation
          const openPnl = [...open, ...trimmed].reduce((sum, t) => {
            // Use stored P&L if available (from replay/trade engine)
            const storedPnl = Number(t.pnl ?? t.pnl_amount);
            if (Number.isFinite(storedPnl)) return sum + storedPnl;

            // Fallback: compute from currentPrice
            const shares = t.shares || TRADE_SIZE / (t.entryPrice || 1);
            const trimmedPct = t.trimmedPct || 0;
            const remainingShares = shares - shares * trimmedPct;
            const entryPrice = t.entryPrice || 0;
            const currentPrice = t.currentPrice || entryPrice;

            if (remainingShares > 0 && entryPrice > 0) {
              const direction = t.direction || "LONG";
              if (direction === "LONG") {
                return sum + (currentPrice - entryPrice) * remainingShares;
              } else {
                return sum + (entryPrice - currentPrice) * remainingShares;
              }
            }
            return sum;
          }, 0);

          // Calculate average win/loss
          const winningTrades = closed.filter((t) => t.status === "WIN");
          const losingTrades = closed.filter((t) => t.status === "LOSS");
          const avgWin =
            winningTrades.length > 0
              ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) /
                winningTrades.length
              : 0;
          const avgLoss =
            losingTrades.length > 0
              ? losingTrades.reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0) /
                losingTrades.length
              : 0;
          const profitFactor =
            avgLoss > 0 ? avgWin / avgLoss : avgWin > 0 ? Infinity : 0;

          const excursionStats = closed
            .map((t) => computeExcursions(t))
            .filter(Boolean);
          const avgMfePct =
            excursionStats.length > 0
              ? excursionStats.reduce((s, x) => s + (x.mfePct || 0), 0) /
                excursionStats.length
              : 0;
          const avgMaePct =
            excursionStats.length > 0
              ? excursionStats.reduce((s, x) => s + (x.maePct || 0), 0) /
                excursionStats.length
              : 0;

          const capturedStats = closed
            .map((t) => {
              const entry = Number(t.entryPrice);
              const exit = Number(t.exitPrice ?? t.exit_price);
              const target = Number(t.tp_target_price ?? t.tp);
              if (
                !Number.isFinite(entry) ||
                !Number.isFinite(exit) ||
                !Number.isFinite(target)
              )
                return null;
              const isLong =
                String(t.direction || "").toUpperCase() !== "SHORT";
              const denom = isLong ? target - entry : entry - target;
              const num = isLong ? exit - entry : entry - exit;
              if (!Number.isFinite(denom) || Math.abs(denom) < EPS) return null;
              const pct = (num / denom) * 100;
              return Number.isFinite(pct) ? pct : null;
            })
            .filter((v) => Number.isFinite(v));
          const avgCapturedPct =
            capturedStats.length > 0
              ? capturedStats.reduce((s, v) => s + v, 0) / capturedStats.length
              : 0;

          const horizonStats = {};
          for (const t of closed) {
            const key = horizonKeyForTrade(t);
            if (!horizonStats[key]) {
              horizonStats[key] = {
                n: 0,
                wins: 0,
                losses: 0,
                totalPnl: 0,
                mfePct: 0,
                maePct: 0,
                capturedPct: 0,
                capturedN: 0,
              };
            }
            const bucket = horizonStats[key];
            bucket.n += 1;
            if (t.status === "WIN") bucket.wins += 1;
            if (t.status === "LOSS") bucket.losses += 1;
            bucket.totalPnl += Number(t.pnl || 0);
            const ex = computeExcursions(t);
            if (ex && Number.isFinite(ex.mfePct)) bucket.mfePct += ex.mfePct;
            if (ex && Number.isFinite(ex.maePct)) bucket.maePct += ex.maePct;
            const entry = Number(t.entryPrice);
            const exit = Number(t.exitPrice ?? t.exit_price);
            const target = Number(t.tp_target_price ?? t.tp);
            const isLong = String(t.direction || "").toUpperCase() !== "SHORT";
            if (
              Number.isFinite(entry) &&
              Number.isFinite(exit) &&
              Number.isFinite(target)
            ) {
              const denom = isLong ? target - entry : entry - target;
              const num = isLong ? exit - entry : entry - exit;
              if (Number.isFinite(denom) && Math.abs(denom) > EPS) {
                bucket.capturedPct += (num / denom) * 100;
                bucket.capturedN += 1;
              }
            }
          }

          Object.keys(horizonStats).forEach((key) => {
            const s = horizonStats[key];
            const n = Math.max(1, s.n);
            const winRateH = s.n > 0 ? (s.wins / s.n) * 100 : 0;
            const avgWinH =
              s.wins > 0
                ? closed
                    .filter(
                      (t) =>
                        horizonKeyForTrade(t) === key && t.status === "WIN",
                    )
                    .reduce((sum, t) => sum + (t.pnl || 0), 0) / s.wins
                : 0;
            const avgLossH =
              s.losses > 0
                ? closed
                    .filter(
                      (t) =>
                        horizonKeyForTrade(t) === key && t.status === "LOSS",
                    )
                    .reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0) /
                  s.losses
                : 0;
            s.winRate = winRateH;
            s.expectancy =
              (winRateH / 100) * avgWinH - (1 - winRateH / 100) * avgLossH;
            s.avgMfePct = s.mfePct / n;
            s.avgMaePct = s.maePct / n;
            s.avgCapturedPct =
              s.capturedN > 0 ? s.capturedPct / s.capturedN : 0;
          });

          // Analyze by signal combinations
          const signalAnalysis = {};
          closed.forEach((trade) => {
            const signals = [];
            if (trade.flags?.sq30_release) signals.push("SqueezeRelease");
            if (trade.flags?.sq30_on) signals.push("SqueezeOn");
            if (trade.flags?.phase_zone_change) signals.push("PhaseZoneChange");
            if (trade.inCorridor) signals.push("InCorridor");
            const key = signals.sort().join("+") || "None";

            if (!signalAnalysis[key]) {
              signalAnalysis[key] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") signalAnalysis[key].wins++;
            if (trade.status === "LOSS") signalAnalysis[key].losses++;
            signalAnalysis[key].totalPnl += trade.pnl || 0;
          });

          // Analyze by RR ranges
          const rrAnalysis = {};
          closed.forEach((trade) => {
            const rr = trade.rr || 0;
            let range = "Unknown";
            if (rr >= 2.0) range = "RR ≥ 2.0";
            else if (rr >= 1.5) range = "RR 1.5-2.0";
            else if (rr >= 1.0) range = "RR 1.0-1.5";
            else if (rr > 0) range = "RR < 1.0";

            if (!rrAnalysis[range]) {
              rrAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rrAnalysis[range].wins++;
            if (trade.status === "LOSS") rrAnalysis[range].losses++;
            rrAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Analyze by rank ranges
          const rankAnalysis = {};
          closed.forEach((trade) => {
            const rank = trade.rank || 0;
            let range = "Unknown";
            if (rank >= 80) range = "Rank ≥ 80";
            else if (rank >= 70) range = "Rank 70-80";
            else if (rank >= 60) range = "Rank 60-70";
            else if (rank > 0) range = "Rank < 60";

            if (!rankAnalysis[range]) {
              rankAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rankAnalysis[range].wins++;
            if (trade.status === "LOSS") rankAnalysis[range].losses++;
            rankAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Generate recommendations
          const recommendations = { filters: [], management: [] };

          const pushRec = (bucket, rec) => {
            if (!bucket || !recommendations[bucket]) return;
            recommendations[bucket].push(rec);
          };

          // Find best performing signal combinations
          const bestSignals = Object.entries(signalAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5) // Reduce noise
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              // Prefer higher winrate, then larger sample, then higher pnl
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })
            .slice(0, 3);

          if (bestSignals.length > 0) {
            const [sigKey, stats] = bestSignals[0];
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (wr >= 0.55 && n >= 5) {
              pushRec("filters", {
                type: "signal",
                priority: n >= 15 ? "high" : "medium",
                message: `Filters: Favor ${sigKey} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)} per trade, n=${n}, confidence ${confidenceLabel(n)})`,
              });
            }
          }

          // Find best RR range
          const bestRR = Object.entries(rrAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5)
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })[0];

          if (bestRR) {
            const [range, stats] = bestRR;
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (n >= 5 && (wr >= 0.52 || avgPnl > 0)) {
              pushRec("filters", {
                type: "rr",
                priority: n >= 15 ? "medium" : "low",
                message: `Filters: RR sweet spot looks like ${range} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)}, n=${n})`,
              });
            }
          }

          // Find best rank range
          const bestRank = Object.entries(rankAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5)
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })[0];

          if (bestRank) {
            const [range, stats] = bestRank;
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (n >= 5 && (wr >= 0.52 || avgPnl > 0)) {
              pushRec("filters", {
                type: "rank",
                priority: n >= 15 ? "medium" : "low",
                message: `Filters: Best rank bucket so far is ${range} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)}, n=${n})`,
              });
            }
          }

          // Profit factor recommendations - only show if we have enough closed trades to analyze
          if (profitFactor < 1.0 && closedTrades >= 10) {
            pushRec("filters", {
              type: "risk",
              priority: "high",
              message: `Profit factor is ${profitFactor.toFixed(2)}. Consider tightening stops or improving entry selection.`,
            });
          }

          // Win rate recommendations - only show if we have enough closed trades to analyze
          if (winRate < 40 && closedTrades >= 10) {
            pushRec("filters", {
              type: "filter",
              priority: "high",
              message: `Win rate is ${winRate.toFixed(1)}%. Consider raising minimum rank threshold or requiring squeeze release.`,
            });
          }

          // Management learning (post-entry): trims + exit reasons
          if (closedTrades >= 5) {
            const closedWithTrim = closed.filter((t) => hasTrimEvent(t));
            const closedNoTrim = closed.filter((t) => !hasTrimEvent(t));

            const summarize = (arr) => {
              const n = arr.length;
              const w = arr.filter((t) => t.status === "WIN").length;
              const l = arr.filter((t) => t.status === "LOSS").length;
              const wr = smoothWinRate(w, l);
              const totalP = arr.reduce((s, t) => s + (t.pnl || 0), 0);
              const avgP = n > 0 ? totalP / n : 0;
              return { n, w, l, wr, avgP };
            };

            const trimStats = summarize(closedWithTrim);
            const noTrimStats = summarize(closedNoTrim);
            if (trimStats.n >= 5 || noTrimStats.n >= 5) {
              const better =
                trimStats.n >= 5 && noTrimStats.n >= 5
                  ? trimStats.avgP - noTrimStats.avgP
                  : 0;
              if (
                trimStats.n >= 5 &&
                noTrimStats.n >= 5 &&
                Math.abs(better) > 1e-9
              ) {
                pushRec("management", {
                  type: "trim_vs_no_trim",
                  priority: "medium",
                  message: `Management: Trades with trims avg $${trimStats.avgP.toFixed(2)} (n=${trimStats.n}) vs no-trim avg $${noTrimStats.avgP.toFixed(2)} (n=${noTrimStats.n}). ${better > 0 ? "Trimming is helping." : "Trimming may be hurting."}`,
                });
              } else if (trimStats.n >= 5 && noTrimStats.n < 5) {
                pushRec("management", {
                  type: "trim_data",
                  priority: "low",
                  message: `Management: Most closed trades include trims (n=${trimStats.n}). Keep logging trims + exits to learn hold/trim improvements.`,
                });
              }
            }

            const exitReasonStats = {};
            closed.forEach((t) => {
              const r = getExitReason(t) || "UNKNOWN";
              if (!exitReasonStats[r])
                exitReasonStats[r] = { n: 0, wins: 0, losses: 0, pnl: 0 };
              exitReasonStats[r].n += 1;
              if (t.status === "WIN") exitReasonStats[r].wins += 1;
              if (t.status === "LOSS") exitReasonStats[r].losses += 1;
              exitReasonStats[r].pnl += t.pnl || 0;
            });

            const topExit = Object.entries(exitReasonStats)
              .filter(([_, s]) => s.n >= 3)
              .sort((a, b) => (b[1].pnl || 0) - (a[1].pnl || 0))[0];

            if (topExit) {
              const [reason, s] = topExit;
              const wr = smoothWinRate(s.wins, s.losses);
              const avgP = s.n > 0 ? (s.pnl || 0) / s.n : 0;
              pushRec("management", {
                type: "exit_reason",
                priority: reason === "SL" ? "high" : "low",
                message: `Management: Exit reason ${reason} avg $${avgP.toFixed(2)} (smoothed win rate ${(wr * 100).toFixed(1)}%, n=${s.n}).`,
              });
            }
          } else {
            pushRec("management", {
              type: "needs_data",
              priority: "low",
              message: `Management: Need more closed trades (currently n=${closedTrades}) to learn trim/exit improvements reliably.`,
            });
          }

          return {
            totalTrades,
            openTrades,
            trimmedTrades,
            closedTrades,
            wins,
            losses,
            winRate,
            totalPnl,
            openPnl,
            avgWin,
            avgLoss,
            profitFactor,
            avgMfePct,
            avgMaePct,
            avgCapturedPct,
            horizonStats,
            signalAnalysis,
            rrAnalysis,
            rankAnalysis,
            recommendations,
          };
        }, [trades]);
      }

      // ─────────────────────────────────────────────────────────────
      // Components
      // ─────────────────────────────────────────────────────────────
      // Format RR display (e.g., "2.10:1" or "1:2.10")
      function formatRR(rr) {
        if (!rr || !Number.isFinite(rr)) return "N/A";
        if (rr >= 1) {
          return `${rr.toFixed(2)}:1`;
        } else {
          return `1:${(1 / rr).toFixed(2)}`;
        }
      }

      // Trade History Component (entry, add entry, trim, exit with full details)
      function TradeHistory({ history = [], fmtUsd: fmt }) {
        const fmtUsd = fmt || (v => (Number.isFinite(Number(v)) ? new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(Number(v)) : "—"));
        if (!history || history.length === 0) {
          return (
            <div className="text-xs text-[var(--tt-text-faint)] italic p-2">
              No history available
            </div>
          );
        }

        const getEventIcon = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "📥";
          if (t === "SCALE_IN" || t === "ADD_ENTRY") return "➕";
          if (t === "TRIM") return "✂️";
          if (t === "EXIT") return "📤";
          return "•";
        };

        const getEventColor = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "text-[var(--tt-accent)]";
          if (t === "SCALE_IN" || t === "ADD_ENTRY") return "text-[var(--tt-text)]";
          if (t === "TRIM") return "text-[var(--tt-text-muted)]";
          if (t === "EXIT") return "text-[var(--tt-negative)]";
          return "text-[var(--tt-text-muted)]";
        };

        return (
          <div className="space-y-2 max-h-[400px] overflow-y-auto">
            {history.map((event, idx) => {
              const eventDate = new Date(event.timestamp);
              const formattedDate = eventDate.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
              });
              const formattedTime = eventDate.toLocaleTimeString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                hour12: true,
              });

              return (
                <div
                  key={idx}
                  className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-3"
                >
                  <div className="flex items-start gap-3">
                    <div className={`text-xl ${getEventColor(event.type)}`}>
                      {getEventIcon(event.type)}
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center justify-between mb-1">
                        <span
                          className={`text-sm font-semibold ${getEventColor(event.type)}`}
                        >
                          {event.type.replace("_", " ")}
                        </span>
                        <span className="text-xs text-[var(--tt-text-faint)]">
                          {formattedDate} {formattedTime}
                        </span>
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mb-2">
                        {event.note}
                      </div>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 text-xs">
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Price:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            ${Number(event.price).toFixed(2)}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Shares:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            {event.shares}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Value:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            ${Number(event.value).toFixed(2)}
                          </span>
                        </div>
                        {event.pnl_realized != null && Number.isFinite(Number(event.pnl_realized)) && (
                          <div className="sm:col-span-2">
                            <span className="text-[var(--tt-text-faint)]">Net P&L:</span>
                            <span className={`ml-1 font-semibold ${Number(event.pnl_realized) >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                              {fmtUsd(Number(event.pnl_realized))}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      // Ledger trade history (date asc): execution timeline — mirrors Trade Journey image (cards with type · date time, then details)
      function LedgerTradeHistory({ events = [], trade = null, fmtUsd }) {
        if (!events || events.length === 0) {
          return (
            <div className="text-xs text-[var(--tt-text-faint)] italic p-3">
              No actions yet for this position.
            </div>
          );
        }
        const sorted = [...events].sort((a, b) => (a.ts || 0) - (b.ts || 0));
        const actionLabel = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "Entry";
          if (t === "ADD_ENTRY" || t === "SCALE_IN") return "Add entry";
          if (t === "TRIM") return "Trim";
          if (t === "EXIT") return "Exit";
          return t || "—";
        };
        return (
          <div className="space-y-3 max-h-[400px] overflow-y-auto">
            {sorted.map((ev, idx) => {
              const d = ev.ts != null ? new Date(Number(ev.ts)) : null;
              const dateStr = d ? d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "—";
              const timeStr = d ? d.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true }) : "—";
              const t = ev.trade || trade || {};
              const qty = ev.shares ?? ev.qty ?? (t.shares != null ? t.shares : (t.entry_price > 0 ? Math.round(TRADE_SIZE / t.entry_price) : null));
              const price = ev.price != null ? Number(ev.price) : (ev.type === "ENTRY" || ev.type === "ADD_ENTRY" || ev.type === "SCALE_IN" ? Number(t.entry_price ?? t.entryPrice) : ev.type === "EXIT" ? Number(t.exit_price ?? t.exitPrice) : null);
              const value = ev.value != null ? Number(ev.value) : (Number.isFinite(price) && Number.isFinite(qty) ? price * qty : null);
              const pnl = ev.pnl_realized != null ? Number(ev.pnl_realized) : null;
              const trimmedPct = ev.trimmed_pct != null ? Number(ev.trimmed_pct) : (t.trimmed_pct != null ? Number(t.trimmed_pct) : (t.trimmedPct != null ? Number(t.trimmedPct) : null));
              const label = actionLabel(ev.type);
              const typeUpper = String(ev.type || "").toUpperCase();
              return (
                <div
                  key={idx}
                  className="rounded-lg p-3 border border-[var(--tt-border)] bg-[var(--tt-bg-surface)]"
                >
                  <div className="font-medium text-white text-sm">
                    {label} · {dateStr} {timeStr}
                  </div>
                  <div className="mt-1.5 space-y-0.5 text-xs text-[var(--tt-text-muted)]">
                    {Number.isFinite(price) && <div>Price: {fmtUsd(price)}</div>}
                    {Number.isFinite(value) && <div>Value: {fmtUsd(value)}</div>}
                    {Number.isFinite(qty) && <div>Qty: {Number(qty).toFixed(FUTURES_SPECS[t?.ticker] ? 0 : 4)}</div>}
                    {typeUpper === "TRIM" && (() => {
                      const pct = trimmedPct ?? t.trimmed_pct ?? t.trimmedPct;
                      if (pct == null || !Number.isFinite(Number(pct))) return null;
                      return <div>Trimmed {Math.round(Number(pct) * 100)}%</div>;
                    })()}
                    {Number.isFinite(pnl) && (
                      <div className={pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>
                        Net P&L: {fmtUsd(pnl)}
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      // Universal Right Rail (shared component from shared-right-rail.js)
      const _fmtUsd = typeof fmtUsd === "function" ? fmtUsd : (v) => (Number.isFinite(Number(v)) ? new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(Number(v)) : "—");
      const _fmtUsdAbs = typeof fmtUsdAbs === "function" ? fmtUsdAbs : (n) => (Number.isFinite(Number(n)) ? `$${Math.abs(Number(n)).toFixed(2)}` : "—");
      const TickerDetailRightRail = window.TickerDetailRightRailFactory({
        React,
        API_BASE,
        fmtUsd: _fmtUsd,
        fmtUsdAbs: _fmtUsdAbs,
        getDailyChange,
        isPrimeBubble,
        entryType,
        getActionDescription,
        rankScoreForTicker,
        getRankedTickers,
        getRankPosition,
        getRankPositionFromMap,
        detectPatterns,
        normalizeTrailPoints,
        phaseToColor,
        completionForSize,
        computeHorizonBucket,
        computeEtaDays,
        computeReturnPct,
        computeRiskPct,
        computeTpTargetPrice,
        computeTpMaxPrice,
        summarizeEntryDecision,
        getDirectionFromState,
        getDirection,
        numFromAny,
        groupsForTicker,
        GROUP_ORDER,
        GROUP_LABELS,
        TRADE_SIZE,
        FUTURES_SPECS,
        getStaleInfo,
        isNyRegularMarketOpen,
        downsampleByInterval,
        getTickerSector,
        normalizeSectorKey,
        sectorKeyToCanonicalName,
      });

      function TradeRow({ trade, tickerData, onTickerClick, onTradeClick }) {
        const pnlColor = trade.pnl >= 0 ? "text-green-400" : "text-red-400";
        const statusColor =
          trade.status === "WIN"
            ? "text-green-400"
            : trade.status === "LOSS"
              ? "text-red-400"
              : trade.status === "TP_HIT_TRIM"
                ? "text-blue-400"
                : "text-yellow-400";

        // Determine if this is a futures contract
        const tickerSymbol = String(trade.ticker || "").toUpperCase();
        const isFutures =
          FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");
        const pointValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? FUTURES_SPECS[tickerSymbol].pointValue
            : 1;

        // Metrics derived from latest ticker data (preferred) or trade data
        const metricsSource = tickerData || trade;
        const horizon = computeHorizonBucket(metricsSource);
        const eta = computeEtaDays(metricsSource);
        const retPct = computeReturnPct(metricsSource);
        const riskPct = computeRiskPct(metricsSource);
        const tpTarget = computeTpTargetPrice(metricsSource);
        const avgCorr = Number(metricsSource?.avg_corr);
        const diversity = Number(metricsSource?.diversity_score);
        const exitPrice = Number(trade.exitPrice ?? trade.exit_price);
        const trimPrice = Number(trade.trimPrice ?? trade.trim_price);

        // Calculate position values
        // For futures: shares = contracts (always 1), for stocks: calculate from TRADE_SIZE
        const shares =
          trade.shares ||
          (isFutures && FUTURES_SPECS[tickerSymbol]
            ? 1
            : TRADE_SIZE / (trade.entryPrice || 1));
        const currentPrice = trade.currentPrice || trade.entryPrice;

        // For futures: value calculation is different (contracts * point value * price)
        // For stocks: shares * price
        const marketValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? shares * currentPrice * pointValue
            : shares * currentPrice;
        const entryValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? shares * trade.entryPrice * pointValue
            : shares * trade.entryPrice;
        const trimmedPct = trade.trimmedPct || 0;
        const trimmedShares = shares * trimmedPct;
        const remainingShares = shares - trimmedShares;
        const trimmedValue =
          trimmedShares > 0
            ? isFutures && FUTURES_SPECS[tickerSymbol]
              ? trimmedShares * (trade.tp || currentPrice) * pointValue
              : trimmedShares * (trade.tp || currentPrice)
            : 0;
        const currentMarketValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? remainingShares * currentPrice * pointValue
            : remainingShares * currentPrice;

        // Recalculate P&L using correct futures logic (override stored value)
        // Note: trimmedPct is already declared above (line 1336)
        let recalculatedPnl = 0;
        let recalculatedPnlPct = 0;
        const priceDiff = currentPrice - trade.entryPrice;

        if (trade.direction === "LONG") {
          const hitTP = currentPrice >= trade.tp;
          const hitSL = currentPrice <= trade.sl;

          if (hitTP) {
            if (trimmedPct === 0) {
              // First TP hit - trim 50%
              const tpDiff = trade.tp - trade.entryPrice;
              recalculatedPnl = tpDiff * shares * pointValue * 0.5;
              recalculatedPnlPct =
                ((trade.tp - trade.entryPrice) / trade.entryPrice) * 100;
            } else {
              // Already trimmed - full exit at TP
              const tpDiff = trade.tp - trade.entryPrice;
              recalculatedPnl = tpDiff * shares * pointValue;
              recalculatedPnlPct =
                ((trade.tp - trade.entryPrice) / trade.entryPrice) * 100;
            }
          } else if (hitSL) {
            const slDiff = trade.sl - trade.entryPrice;
            recalculatedPnl = slDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.sl - trade.entryPrice) / trade.entryPrice) * 100;
          } else {
            // Still open - calculate current P&L
            recalculatedPnl = priceDiff * shares * pointValue;
            recalculatedPnlPct =
              ((currentPrice - trade.entryPrice) / trade.entryPrice) * 100;
          }
        } else {
          // SHORT
          const hitTP = currentPrice <= trade.tp;
          const hitSL = currentPrice >= trade.sl;

          if (hitTP) {
            if (trimmedPct === 0) {
              // First TP hit - trim 50%
              const tpDiff = trade.entryPrice - trade.tp;
              recalculatedPnl = tpDiff * shares * pointValue * 0.5;
              recalculatedPnlPct =
                ((trade.entryPrice - trade.tp) / trade.entryPrice) * 100;
            } else {
              // Already trimmed - full exit at TP
              const tpDiff = trade.entryPrice - trade.tp;
              recalculatedPnl = tpDiff * shares * pointValue;
              recalculatedPnlPct =
                ((trade.entryPrice - trade.tp) / trade.entryPrice) * 100;
            }
          } else if (hitSL) {
            const slDiff = trade.entryPrice - trade.sl;
            recalculatedPnl = slDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.entryPrice - trade.sl) / trade.entryPrice) * 100;
          } else {
            // Still open - calculate current P&L
            const shortPriceDiff = trade.entryPrice - currentPrice;
            recalculatedPnl = shortPriceDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.entryPrice - currentPrice) / trade.entryPrice) * 100;
          }
        }

        // Parse entryTime - now uses current time when trade was created (not trigger_ts)
        const entryDate = new Date(trade.entryTime);
        const formattedDate = entryDate.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric",
          year: "numeric",
        });
        const formattedTime = entryDate.toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });

        return (
          <tr
            className="border-b border-[var(--tt-border)] hover:bg-[var(--tt-bg-elevated)] cursor-pointer transition-colors"
            onClick={() => {
              if (onTradeClick) onTradeClick(trade);
              else if (onTickerClick) onTickerClick(trade.ticker);
            }}
          >
            <td className="p-2 text-sm">{trade.ticker}</td>
            <td className="p-2 text-sm">
              <span
                className={`px-2 py-1 rounded text-xs ${
                  trade.direction === "LONG"
                    ? "bg-green-500/20 text-green-400"
                    : "bg-red-500/20 text-red-400"
                }`}
              >
                {trade.direction}
              </span>
            </td>
            <td className="p-2 text-sm">${trade.entryPrice.toFixed(2)}</td>
            <td className="p-2 text-sm">${currentPrice.toFixed(2)}</td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)]">
              <div className="font-semibold text-white">{formattedDate}</div>
              <div className="text-[var(--tt-text-faint)]">{formattedTime}</div>
            </td>
            <td className="p-2 text-sm font-mono">
              {isFutures && FUTURES_SPECS[tickerSymbol] ? (
                <>
                  <div className="text-xs text-[var(--tt-text-muted)]">
                    Total: {shares.toFixed(0)} contract{shares !== 1 ? "s" : ""}
                  </div>
                  {trimmedShares > 0 && (
                    <div className="text-xs text-blue-400">
                      Remaining: {remainingShares.toFixed(2)} contract
                      {remainingShares !== 1 ? "s" : ""}
                    </div>
                  )}
                </>
              ) : (
                <>
                  <div className="text-xs text-[var(--tt-text-muted)]">
                    Total: {shares.toFixed(4)}
                  </div>
                  {trimmedShares > 0 && (
                    <div className="text-xs text-blue-400">
                      Remaining: {remainingShares.toFixed(4)}
                    </div>
                  )}
                </>
              )}
            </td>
            <td className="p-2 text-sm">
              <div className="text-xs text-[var(--tt-text-muted)]">
                Entry: ${entryValue.toFixed(2)}
              </div>
              <div
                className={`font-semibold ${trade.status === "OPEN" || trade.status === "TP_HIT_TRIM" ? "text-yellow-400" : ""}`}
              >
                Current: ${currentMarketValue.toFixed(2)}
              </div>
            </td>
            <td className="p-2 text-sm">
              {trimmedShares > 0 ? (
                <div className="text-xs text-blue-400">
                  <div>${trimmedValue.toFixed(2)}</div>
                  <div className="text-[var(--tt-text-muted)]">
                    ({(trimmedPct * 100).toFixed(0)}%)
                  </div>
                </div>
              ) : (
                <span className="text-xs text-[var(--tt-text-faint)]">-</span>
              )}
            </td>
            <td className="p-2 text-sm">${trade.sl.toFixed(2)}</td>
            <td
              className="p-2 text-sm"
              title={tpList ? `TP Levels: ${tpList}` : ""}
            >
              $
              {Number.isFinite(tpTarget)
                ? tpTarget.toFixed(2)
                : trade.tp.toFixed(2)}
            </td>
            <td className="p-2 text-sm text-green-400">
              {Number.isFinite(retPct) ? `${retPct.toFixed(1)}%` : "—"}
            </td>
            <td className="p-2 text-sm text-red-400">
              {Number.isFinite(riskPct) ? `${riskPct.toFixed(1)}%` : "—"}
            </td>
            <td className="p-2 text-sm">
              {Number.isFinite(eta) ? `${eta.toFixed(1)}d` : "—"}
            </td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)]">{horizon}</td>
            <td className="p-2 text-sm text-[var(--tt-text-muted)]">
              {Number.isFinite(diversity) ? Math.round(diversity) : "—"}
            </td>
            <td className="p-2 text-sm text-[var(--tt-text-muted)]">
              {Number.isFinite(avgCorr) ? avgCorr.toFixed(2) : "—"}
            </td>
            <td className="p-2 text-sm">{formatRR(trade.rr)}</td>
            <td className="p-2 text-sm">{trade.rank}</td>
            <td
              className={`p-2 text-sm font-semibold ${recalculatedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
            >
              ${recalculatedPnl.toFixed(2)}
            </td>
            <td
              className={`p-2 text-sm font-semibold ${recalculatedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
            >
              {recalculatedPnlPct.toFixed(2)}%
            </td>
            <td className={`p-2 text-sm font-semibold ${statusColor}`}>
              <div>
                {trade.status === "TP_HIT_TRIM"
                  ? `TRIMMED (${((trade.trimmedPct || 0) * 100).toFixed(0)}%)`
                  : trade.status || "OPEN"}
              </div>
              {trade.status === "TP_HIT_TRIM" && Number.isFinite(trimPrice) && (
                <div className="text-[10px] text-yellow-300">
                  Trim @ ${trimPrice.toFixed(2)}
                </div>
              )}
              {(trade.status === "WIN" || trade.status === "LOSS") &&
                Number.isFinite(exitPrice) && (
                  <div className="text-[10px] text-purple-300">
                    Exit @ ${exitPrice.toFixed(2)}
                  </div>
                )}
            </td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)] font-mono">
              {trade.scriptVersion || "unknown"}
            </td>
          </tr>
        );
      }

      function AnalyticsPanel({ analytics }) {
        return (
          <div className="space-y-4">
            {/* Overall Stats */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Overall Performance</h3>
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-4">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Total Trades</div>
                  <div className="text-2xl font-bold">
                    {analytics.totalTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Open Trades</div>
                  <div className="text-2xl font-bold text-yellow-400">
                    {analytics.openTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Trimmed Trades</div>
                  <div className="text-2xl font-bold text-blue-400">
                    {analytics.trimmedTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Closed Trades</div>
                  <div className="text-2xl font-bold text-white">
                    {analytics.closedTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Win Rate</div>
                  <div className="text-2xl font-bold text-green-400">
                    {analytics.winRate.toFixed(1)}%
                  </div>
                </div>
              </div>
              <div className="grid grid-cols-2 md:grid-cols-2 gap-4 pt-4 border-t border-[var(--tt-border)]">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Closed P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.totalPnl >= 0
                        ? "text-green-400"
                        : "text-red-400"
                    }`}
                  >
                    ${analytics.totalPnl.toFixed(2)}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Open P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.openPnl >= 0
                        ? "text-green-400"
                        : "text-yellow-400"
                    }`}
                  >
                    ${analytics.openPnl.toFixed(2)}
                  </div>
                </div>
              </div>
              {analytics.totalTrades > 0 && (
                <div className="grid grid-cols-2 md:grid-cols-3 gap-4 pt-4 border-t border-[var(--tt-border)]">
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Avg Win</div>
                    <div className="text-lg font-bold text-green-400">
                      ${analytics.avgWin.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Avg Loss</div>
                    <div className="text-lg font-bold text-red-400">
                      ${analytics.avgLoss.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Profit Factor</div>
                    <div
                      className={`text-lg font-bold ${
                        analytics.profitFactor >= 1.5
                          ? "text-green-400"
                          : analytics.profitFactor >= 1.0
                            ? "text-yellow-400"
                            : "text-red-400"
                      }`}
                    >
                      {analytics.profitFactor.toFixed(2)}
                    </div>
                  </div>
                </div>
              )}
            </div>

            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Excursion & Capture</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg MFE %</div>
                  <div className="text-lg font-bold text-green-400">
                    {analytics.avgMfePct.toFixed(1)}%
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg MAE %</div>
                  <div className="text-lg font-bold text-red-400">
                    {analytics.avgMaePct.toFixed(1)}%
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg Captured %</div>
                  <div className="text-lg font-bold text-blue-400">
                    {analytics.avgCapturedPct.toFixed(1)}%
                  </div>
                </div>
              </div>
            </div>

            {analytics.horizonStats && (
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
                <h3 className="text-lg font-bold mb-4">Horizon Performance</h3>
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead>
                      <tr className="border-b border-[var(--tt-border)] text-left text-xs text-[var(--tt-text-muted)]">
                        <th className="p-2">Horizon</th>
                        <th className="p-2">Trades</th>
                        <th className="p-2">Win %</th>
                        <th className="p-2">Expectancy</th>
                        <th className="p-2">MFE %</th>
                        <th className="p-2">MAE %</th>
                        <th className="p-2">Captured %</th>
                      </tr>
                    </thead>
                    <tbody>
                      {Object.entries(analytics.horizonStats).map(
                        ([key, s]) => (
                          <tr
                            key={key}
                            className="border-b border-[var(--tt-border)]/50"
                          >
                            <td className="p-2 text-xs text-[var(--tt-text-muted)]">
                              {String(key).replace("_", " ")}
                            </td>
                            <td className="p-2">{s.n}</td>
                            <td className="p-2">{s.winRate.toFixed(1)}%</td>
                            <td className="p-2">
                              {Number.isFinite(s.expectancy)
                                ? `$${s.expectancy.toFixed(2)}`
                                : "—"}
                            </td>
                            <td className="p-2">{s.avgMfePct.toFixed(1)}%</td>
                            <td className="p-2">{s.avgMaePct.toFixed(1)}%</td>
                            <td className="p-2">
                              {s.avgCapturedPct.toFixed(1)}%
                            </td>
                          </tr>
                        ),
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            )}

            {/* Self-Learning Recommendations */}
            {(() => {
              const recs = analytics.recommendations || {};
              const filterRecs = Array.isArray(recs.filters)
                ? recs.filters
                : [];
              const mgmtRecs = Array.isArray(recs.management)
                ? recs.management
                : [];
              const hasAny = filterRecs.length + mgmtRecs.length > 0;
              if (!hasAny) return null;

              const renderRec = (rec, idx) => (
                <div
                  key={idx}
                  className={`p-3 rounded-lg border ${
                    rec.priority === "high"
                      ? "bg-yellow-500/10 border-yellow-500/30"
                      : "bg-blue-500/10 border-blue-500/30"
                  }`}
                >
                  <div className="flex items-start gap-2">
                    <span className="text-lg">
                      {rec.priority === "high" ? "⚠️" : "💡"}
                    </span>
                    <div className="flex-1">
                      <div className="text-sm font-semibold">{rec.message}</div>
                    </div>
                  </div>
                </div>
              );

              return (
                <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
                  <h3 className="text-lg font-bold mb-4">
                    🎓 Self-Learning Recommendations
                  </h3>

                  {filterRecs.length > 0 && (
                    <div className="mb-4">
                      <div className="text-xs text-[var(--tt-text-muted)] font-semibold mb-2">
                        Filters (before entry)
                      </div>
                      <div className="space-y-2">
                        {filterRecs.map(renderRec)}
                      </div>
                    </div>
                  )}

                  {mgmtRecs.length > 0 && (
                    <div>
                      <div className="text-xs text-[var(--tt-text-muted)] font-semibold mb-2">
                        Management (after entry)
                      </div>
                      <div className="space-y-2">{mgmtRecs.map(renderRec)}</div>
                    </div>
                  )}
                </div>
              );
            })()}

            {/* Signal Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Signal Performance</h3>
              <div className="space-y-2 max-h-[300px] overflow-y-auto">
                {Object.entries(analytics.signalAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([signals, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={signals}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">
                            {signals || "No Signals"}
                          </div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* RR Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">
                Risk/Reward Performance
              </h3>
              <div className="space-y-2">
                {Object.entries(analytics.rrAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* Rank Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Rank Performance</h3>
              <div className="space-y-2">
                {Object.entries(analytics.rankAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>
          </div>
        );
      }

      function KpiCard({ label, value, sub = null, tone = "neutral" }) {
        const toneBar =
          tone === "green"
            ? "from-green-400 to-[#00c853]"
            : tone === "red"
              ? "from-red-400 to-rose-500"
              : tone === "yellow"
                ? "from-yellow-300 to-amber-500"
                : tone === "blue"
                  ? "from-blue-400 to-cyan-400"
                  : "from-[var(--tt-text-faint)] to-[var(--tt-border)]";

        return (
          <div className="relative bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-xl p-3 overflow-hidden">
            <div
              className={`absolute left-0 top-0 bottom-0 w-1 bg-gradient-to-b ${toneBar}`}
            />
            <div className="pl-2">
              <div className="text-[11px] uppercase tracking-wide text-[var(--tt-text-muted)]">
                {label}
              </div>
              <div className="mt-1 text-lg font-bold text-white leading-tight">
                {value}
              </div>
              {sub ? (
                <div className="mt-1 text-[11px] text-[var(--tt-text-faint)]">{sub}</div>
              ) : null}
            </div>
          </div>
        );
      }

      function PerformanceDashboard({ mode, ledgerSummary, analytics }) {
        const isLedger = mode === "ledger";

        const loading = isLedger ? !!ledgerSummary?.loading : false;
        const err = isLedger ? ledgerSummary?.error : null;
        const t = isLedger ? ledgerSummary?.data?.totals : null;

        const totalTrades = isLedger
          ? Number(t?.totalTrades || 0)
          : Number(analytics?.totalTrades || 0);
        const openTrades = isLedger
          ? Number(t?.openTrades || 0)
          : Number(analytics?.openTrades || 0);
        const trimmedTrades = isLedger
          ? 0
          : Number(analytics?.trimmedTrades || 0);
        const closedTrades = isLedger
          ? Number(t?.closedTrades || 0)
          : Number(analytics?.closedTrades || 0);
        const wins = isLedger
          ? Number(t?.wins || 0)
          : Number(analytics?.wins || 0);
        const losses = isLedger
          ? Number(t?.losses || 0)
          : Number(analytics?.losses || 0);
        const winRate = isLedger
          ? Number(t?.winRate || 0)
          : Number(analytics?.winRate || 0);

        const closedPnl = isLedger
          ? Number(t?.closedPnl || 0)
          : Number(analytics?.totalPnl || 0);
        const openPnl = !isLedger ? Number(analytics?.openPnl || 0) : null;

        const avgWin = isLedger
          ? Number(t?.avgWin || 0)
          : Number(analytics?.avgWin || 0);
        const avgLoss = isLedger
          ? Number(t?.avgLoss || 0)
          : Number(analytics?.avgLoss || 0);
        const profitFactor = isLedger
          ? Number(t?.profitFactor || 0)
          : Number(analytics?.profitFactor || 0);
        const expectancy = isLedger
          ? Number(t?.expectancy || 0)
          : closedTrades > 0
            ? closedPnl / closedTrades
            : 0;

        const openCapitalTrades = isLedger
          ? openTrades
          : openTrades + trimmedTrades;
        const openCapital = openCapitalTrades * TRADE_SIZE;
        const totalCapital = totalTrades * TRADE_SIZE;

        const pfLabel =
          Number.isFinite(profitFactor) && profitFactor !== Infinity
            ? profitFactor.toFixed(2)
            : "∞";

        const cards = [
          { label: "Total Trades", value: fmtInt(totalTrades) },
          {
            label: "Open Trades",
            value: fmtInt(openTrades),
            sub: isLedger ? "status ≠ WIN/LOSS" : "no trims yet",
            tone: "yellow",
          },
          ...(!isLedger
            ? [
                {
                  label: "Trimmed Trades",
                  value: fmtInt(trimmedTrades),
                  sub: "partial position left",
                  tone: "blue",
                },
              ]
            : []),
          { label: "Wins", value: fmtInt(wins), tone: "green" },
          { label: "Losses", value: fmtInt(losses), tone: "red" },
          {
            label: "Win Rate",
            value: `${Number.isFinite(winRate) ? winRate.toFixed(1) : "0.0"}%`,
            tone: winRate >= 55 ? "green" : winRate >= 45 ? "yellow" : "red",
          },
          {
            label: "Closed P&L",
            value: fmtUsd(closedPnl),
            sub: `${fmtInt(closedTrades)} closed`,
            tone: closedPnl >= 0 ? "green" : "red",
          },
          ...(!isLedger
            ? [
                {
                  label: "Open P&L",
                  value: fmtUsd(openPnl),
                  sub: "unrealized",
                  tone: (openPnl || 0) >= 0 ? "green" : "yellow",
                },
              ]
            : []),
          { label: "Avg Win", value: fmtUsd(avgWin), tone: "green" },
          { label: "Avg Loss", value: fmtUsd(avgLoss), tone: "red" },
          {
            label: "Profit Factor",
            value: pfLabel,
            sub: "gross wins / gross losses",
            tone:
              profitFactor >= 1.5
                ? "green"
                : profitFactor >= 1.0
                  ? "yellow"
                  : "red",
          },
          {
            label: "Expectancy",
            value: fmtUsd(expectancy),
            sub: "avg per closed trade",
            tone: expectancy >= 0 ? "green" : "red",
          },
          {
            label: "Open Capital",
            value: fmtUsd(openCapital),
            sub: `${fmtUsd(TRADE_SIZE)} model / trade`,
            tone: "blue",
          },
        ];

        return (
          <div className="mb-6 bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
            <div className="flex items-center justify-between gap-3 flex-wrap mb-3">
              <div>
                <div className="text-xs text-[var(--tt-text-muted)]">Dashboard</div>
                <div className="text-lg font-bold">
                  {isLedger ? "Ledger KPIs" : "Legacy KPIs"}
                </div>
              </div>
              <div className="text-xs text-[var(--tt-text-faint)]">
                {isLedger ? "Source: D1 ledger" : "Source: KV + live prices"}
              </div>
            </div>

            {loading ? (
              <div className="text-sm text-[var(--tt-text-muted)]">
                Loading dashboard metrics…
              </div>
            ) : err ? (
              <div className="text-sm text-[var(--tt-negative)]">
                Dashboard unavailable: {err}
              </div>
            ) : (
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">
                {cards.map((c, idx) => (
                  <KpiCard
                    key={`${c.label}-${idx}`}
                    label={c.label}
                    value={c.value}
                    sub={c.sub || null}
                    tone={c.tone || "neutral"}
                  />
                ))}
              </div>
            )}
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Helper Functions for TickerDetails
      // ─────────────────────────────────────────────────────────────

      // Calculate score breakdown (mirrors computeDynamicScore / backend-style scoring)
      function calculateScoreBreakdown(ticker) {
        const htf = Number(ticker?.htf_score) || 0;
        const ltf = Number(ticker?.ltf_score) || 0;
        const phase = Number(ticker?.phase_pct) || 0;
        const rr = Number(ticker?.rr) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker?.flags || {};
        const state = String(ticker?.state || "");
        const ent = entryType(ticker || {});
        const inCorridor = !!ent?.corridor;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;

        const breakdown = {
          base: Number(ticker?.rank) || 50,
          corridor: inCorridor ? 12 : 0,
          corridorAligned: inCorridor && aligned ? 8 : 0,
          squeezeRelease: sqRel && inCorridor ? 10 : 0,
          squeezeOn: sqOn && inCorridor && !sqRel ? 5 : 0,
          rr: rr >= 2.0 ? 8 : rr >= 1.5 ? 5 : rr >= 1.0 ? 2 : 0,
          phase: phase < 0.3 ? 6 : phase < 0.5 ? 3 : phase > 0.7 ? -5 : 0,
          completion: comp < 0.3 ? 5 : comp > 0.8 ? -8 : 0,
          htfStrength: Math.min(8, Math.abs(htf) * 0.15),
          ltfStrength: Math.min(6, Math.abs(ltf) * 0.12),
          phaseZoneChange: phaseZoneChange ? 4 : 0,
        };

        breakdown.total = Math.max(
          0,
          breakdown.base +
            breakdown.corridor +
            breakdown.corridorAligned +
            breakdown.squeezeRelease +
            breakdown.squeezeOn +
            breakdown.rr +
            breakdown.phase +
            breakdown.completion +
            breakdown.htfStrength +
            breakdown.ltfStrength +
            breakdown.phaseZoneChange,
        );

        return breakdown;
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(204 + (174 - 204) * t)}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(174 + (156 - 174) * t)}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(156 + (126 - 156) * t)}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(126 + (76 - 126) * t)}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(76 + (57 - 76) * t)}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }

      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      function completionForSize(ticker) {
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      function computeDynamicRank(ticker) {
        const baseRank = Number(ticker.rank) || 50;
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        let dynamicScore = baseRank;
        if (inCorridor) {
          dynamicScore += 12;
          if (aligned) dynamicScore += 8;
        }
        if (sqRel && inCorridor) dynamicScore += 10;
        if (sqOn && inCorridor && !sqRel) dynamicScore += 5;
        if (rr >= 2.0) dynamicScore += 8;
        else if (rr >= 1.5) dynamicScore += 5;
        else if (rr >= 1.0) dynamicScore += 2;
        if (phase < 0.3) dynamicScore += 6;
        else if (phase < 0.5) dynamicScore += 3;
        else if (phase > 0.7) dynamicScore -= 5;
        if (comp < 0.3) dynamicScore += 5;
        else if (comp > 0.8) dynamicScore -= 8;
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;
        if (phaseZoneChange) dynamicScore += 4;
        return Math.max(0, Math.min(100, Math.round(dynamicScore)));
      }

      function toTickerArray(source) {
        if (!source) return [];
        if (Array.isArray(source)) {
          return source.filter((t) => t && typeof t === "object" && t.ticker);
        }
        if (typeof source === "object") {
          return Object.values(source).filter(
            (t) => t && typeof t === "object" && t.ticker,
          );
        }
        return [];
      }

      function rankScoreForTicker(ticker) {
        const rankScore = Number(ticker?.rank_score);
        if (Number.isFinite(rankScore)) return rankScore;
        const dynamicRank = Number(ticker?.dynamicRank);
        if (Number.isFinite(dynamicRank)) return dynamicRank;
        const dynamicScore = Number(ticker?.dynamicScore);
        if (Number.isFinite(dynamicScore)) return dynamicScore;
        return Number(computeDynamicRank(ticker)) || 0;
      }

      function getRankedTickers(source) {
        const list = toTickerArray(source);
        const withScores = list.map((t) => ({
          ...t,
          __rankPos: Number(t?.rank_position),
          __rankScore: rankScoreForTicker(t),
        }));
        withScores.sort((a, b) => {
          const rankA = Number(a.__rankPos);
          const rankB = Number(b.__rankPos);
          const hasRankA = Number.isFinite(rankA) && rankA > 0;
          const hasRankB = Number.isFinite(rankB) && rankB > 0;
          if (hasRankA && hasRankB) return rankA - rankB;
          if (hasRankA) return -1;
          if (hasRankB) return 1;
          const scoreA = Number(a.__rankScore) || 0;
          const scoreB = Number(b.__rankScore) || 0;
          return scoreB - scoreA;
        });
        return withScores;
      }

      function getRankPositionFromMap(rankPositions, tickerSymbol) {
        if (!rankPositions) return null;
        const sym = String(tickerSymbol || "")
          .trim()
          .toUpperCase();
        if (!sym) return null;
        const pos = Number(rankPositions[sym]);
        return Number.isFinite(pos) && pos > 0 ? pos : null;
      }

      // ─────────────────────────────────────────────────────────────
      // Opportunities Panel (unified: Prime / Eligible / Watch)
      // ─────────────────────────────────────────────────────────────
      function OpportunitiesPanel({
        tickers = [],
        rankPositions = null,
        onSelectTicker,
        defaultView = "prime",
      }) {
        const [view, setView] = React.useState(defaultView); // prime | eligible | watch | all
        const [dir, setDir] = React.useState("ALL"); // ALL | LONG | SHORT
        const [horizon, setHorizon] = React.useState("ALL"); // ALL | SHORT_TERM | SWING | POSITIONAL
        const [query, setQuery] = React.useState("");

        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const formatAge = (t) => {
          const raw = t?.ingest_ts ?? t?.ingest_time ?? t?.ts ?? t?.timestamp;
          if (!raw) return "—";
          let ms = null;
          if (typeof raw === "number" && Number.isFinite(raw)) ms = raw;
          else if (typeof raw === "string") {
            const parsed = new Date(raw).getTime();
            ms = Number.isFinite(parsed) ? parsed : null;
          } else {
            const n = Number(raw);
            ms = Number.isFinite(n) ? n : null;
          }
          if (!ms) return "—";
          const ageMs = Date.now() - ms;
          const ageMin = Math.floor(ageMs / 60000);
          if (ageMin < 60) return `${Math.max(0, ageMin)}m ago`;
          const ageHr = Math.floor(ageMin / 60);
          if (ageHr < 24) return `${ageHr}h ago`;
          const ageDay = Math.floor(ageHr / 24);
          return `${ageDay}d ago`;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isEligible = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);
          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct)
            return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct)
            return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf)
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr)
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const toBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const classify = (t) => {
          const prime = isPrimeBubble(t);
          const eligible = isEligible(t);
          return {
            prime,
            eligible,
            bucket: toBucket(t),
            dir: getDirection(t)?.text || "NEUTRAL",
          };
        };

        const counts = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          let prime = 0;
          let eligible = 0;
          for (const t of list) {
            const c = classify(t);
            if (c.prime) prime++;
            if (c.eligible) eligible++;
          }
          return { prime, eligible, all: list.length };
        }, [tickers]);

        const filtered = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const q = String(query || "")
            .trim()
            .toUpperCase();
          return list
            .map((t) => {
              const c = classify(t);
              const status = c.prime
                ? "prime"
                : c.eligible
                  ? "eligible"
                  : "watch";
              const score = Number(rankScoreForTicker(t) || 0);
              const rp =
                getRankPositionFromMap(
                  rankPositions,
                  String(t?.ticker || "").toUpperCase(),
                ) ?? Number(t?.rank_position);
              return {
                t,
                c,
                status,
                score,
                rp: Number.isFinite(rp) ? rp : null,
              };
            })
            .filter(({ t, c, status }) => {
              if (!t?.ticker) return false;
              if (view !== "all" && status !== view) return false;
              if (dir !== "ALL" && c.dir !== dir) return false;
              if (horizon !== "ALL" && c.bucket !== horizon) return false;
              if (q && !String(t.ticker).toUpperCase().includes(q))
                return false;
              return true;
            })
            .sort((a, b) => {
              const pri = (x) =>
                x.status === "prime" ? 0 : x.status === "eligible" ? 1 : 2;
              const dp = pri(a) - pri(b);
              if (dp !== 0) return dp;
              const ds = (b.score || 0) - (a.score || 0);
              if (ds !== 0) return ds;
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              return String(a.t.ticker).localeCompare(String(b.t.ticker));
            });
        }, [tickers, view, dir, horizon, query, rankPositions]);

        const pill = (label, isActive, onClick) => (
          <button
            onClick={onClick}
            className={`px-2.5 py-1 rounded-lg border text-xs font-semibold transition-all ${
              isActive
                ? "border-blue-400 bg-blue-500/20 text-blue-200"
                : "border-[var(--tt-border)] bg-[var(--tt-bg-surface)] text-[var(--tt-text-muted)] hover:text-white"
            }`}
          >
            {label}
          </button>
        );

        return (
          <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-xl p-3">
            <div className="flex items-start justify-between gap-3 flex-wrap">
              <div>
                <div className="text-sm font-bold text-white">
                  ✨ Opportunities
                </div>
                <div className="text-[10px] text-[var(--tt-text-muted)] mt-0.5">
                  Prime {counts.prime} • Eligible {counts.eligible} • Total{" "}
                  {counts.all}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <input
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  placeholder="Ticker…"
                  className="px-2 py-1 text-xs bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded text-white w-[110px]"
                />
              </div>
            </div>

            <div className="mt-2 flex items-center gap-2 flex-wrap">
              {pill("Prime", view === "prime", () => setView("prime"))}
              {pill("Eligible", view === "eligible", () => setView("eligible"))}
              {pill("Watch", view === "watch", () => setView("watch"))}
              {pill("All", view === "all", () => setView("all"))}
              <div className="w-px h-6 bg-[var(--tt-bg-elevated)] mx-1" />
              {pill("All", dir === "ALL", () => setDir("ALL"))}
              {pill("Long", dir === "LONG", () => setDir("LONG"))}
              {pill("Short", dir === "SHORT", () => setDir("SHORT"))}
              <div className="w-px h-6 bg-[var(--tt-bg-elevated)] mx-1" />
              {pill("Any horizon", horizon === "ALL", () => setHorizon("ALL"))}
              {pill("≤7d", horizon === "SHORT_TERM", () =>
                setHorizon("SHORT_TERM"),
              )}
              {pill("8–30d", horizon === "SWING", () => setHorizon("SWING"))}
              {pill("31d+", horizon === "POSITIONAL", () =>
                setHorizon("POSITIONAL"),
              )}
            </div>

            <div className="mt-3 max-h-[420px] overflow-y-auto space-y-2 pr-1">
              {filtered.length === 0 ? (
                <div className="text-xs text-[var(--tt-text-faint)] p-3">No matches.</div>
              ) : (
                filtered.slice(0, 75).map((item) => {
                  const t = item.t;
                  const c = item.c;
                  const actionInfo = getActionDescription(t);
                  const price = Number(t?.price);
                  const rr = Number(t?.rr);
                  const eta = computeEtaDays(t);
                  const age = formatAge(t);
                  const statusPill =
                    item.status === "prime"
                      ? "bg-yellow-500/15 text-yellow-300 border-yellow-500/40"
                      : item.status === "eligible"
                        ? "bg-green-500/15 text-green-400 border-green-500/40"
                        : "bg-[var(--tt-bg-elevated)] text-[var(--tt-text-muted)] border-[var(--tt-border)]";
                  const dirPill =
                    c.dir === "LONG"
                      ? "bg-green-500/10 text-green-400 border-green-500/30"
                      : c.dir === "SHORT"
                        ? "bg-red-500/10 text-red-400 border-red-500/30"
                        : "bg-[var(--tt-bg-elevated)] text-[var(--tt-text-muted)] border-[var(--tt-border)]";
                  return (
                    <button
                      key={t.ticker}
                      onClick={() => onSelectTicker && onSelectTicker(t.ticker)}
                      className="w-full text-left px-3 py-2 rounded-lg border border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-elevated)] hover:border-[var(--tt-border-strong)] transition-all"
                      title="Open in right rail"
                    >
                      <div className="flex items-start justify-between gap-2">
                        <div className="min-w-0">
                          <div className="flex items-center gap-2 flex-wrap">
                            <div className="font-bold text-white">
                              {t.ticker}
                            </div>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${statusPill}`}
                            >
                              {item.status === "prime"
                                ? "Prime"
                                : item.status === "eligible"
                                  ? "Eligible"
                                  : "Watch"}
                            </span>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${dirPill}`}
                            >
                              {c.dir}
                            </span>
                            {c.bucket && c.bucket !== "UNKNOWN" && (
                              <span className="px-2 py-0.5 rounded border border-[var(--tt-border)] bg-[var(--tt-bg-surface)] text-[10px] text-[var(--tt-text-muted)]">
                                {c.bucket === "SHORT_TERM"
                                  ? "≤7d"
                                  : c.bucket === "SWING"
                                    ? "8–30d"
                                    : "31d+"}
                              </span>
                            )}
                          </div>
                          <div className="mt-0.5 text-[11px] text-[var(--tt-text-muted)] whitespace-nowrap overflow-hidden text-ellipsis">
                            <span className="text-[var(--tt-text-faint)]">
                              {actionInfo.action}
                            </span>
                          </div>
                        </div>

                        <div className="flex-shrink-0 text-right text-[11px]">
                          <div className="text-white">
                            {Number.isFinite(price)
                              ? `$${price.toFixed(2)}`
                              : "—"}
                          </div>
                          <div className="text-[var(--tt-text-faint)]">{age}</div>
                        </div>
                      </div>

                      <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[var(--tt-text-muted)]">
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Score</span>{" "}
                          <span className="text-white font-semibold">
                            {(() => {
                              const s = rankScoreForTicker(t);
                              return Number.isFinite(s) ? s.toFixed(1) : "—";
                            })()}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Rank</span>{" "}
                          <span className="text-white font-semibold">
                            {item.rp != null ? `#${item.rp}` : "—"}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">RR/ETA</span>{" "}
                          <span className="text-white font-semibold">
                            {Number.isFinite(rr) ? rr.toFixed(2) : "—"} /{" "}
                            {eta != null ? `${eta.toFixed(1)}d` : "—"}
                          </span>
                        </div>
                      </div>

                      {(() => {
                        const phaseP = Math.max(
                          0,
                          Math.min(1, Number(t?.phase_pct) || 0),
                        );
                        const compP = completionForSize(t);
                        const phaseColor = phaseToColor(phaseP);
                        const compColor = phaseToColor(compP);
                        const Bar = ({ label, p, color }) => (
                          <div className="flex items-center gap-2">
                            <div className="w-20 text-[10px] text-[var(--tt-text-faint)]">
                              {label}
                            </div>
                            <div className="flex-1 h-1.5 rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] overflow-hidden">
                              <div
                                className="h-full"
                                style={{
                                  width: `${Math.round(p * 100)}%`,
                                  background: color,
                                }}
                              />
                            </div>
                            <div className="w-10 text-right text-[10px] text-[var(--tt-text-muted)]">
                              {Math.round(p * 100)}%
                            </div>
                          </div>
                        );
                        return (
                          <div className="mt-2 space-y-1">
                            <Bar label="Phase" p={phaseP} color={phaseColor} />
                            <Bar
                              label="Completion"
                              p={compP}
                              color={compColor}
                            />
                          </div>
                        );
                      })()}
                    </button>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      function normalizeTrailPoints(trail) {
        if (!Array.isArray(trail)) return [];
        return trail
          .map((p) => {
            if (!p || typeof p !== "object") return null;
            const ltf = p.ltf_score ?? p.ltfScore ?? p.ltf ?? p.x ?? p.ltf_value ?? p.ltfValue ?? p.ltf_score_value;
            const htf = p.htf_score ?? p.htfScore ?? p.htf ?? p.y ?? p.htf_value ?? p.htfValue ?? p.htf_score_value;
            const phase = p.phase_pct ?? p.phasePct ?? p.phase ?? p.phase_completion ?? p.phaseCompletion;
            const completion = p.completion ?? p.comp ?? p.completion_pct ?? p.completionPct;
            return {
              ...p,
              ltf_score: Number.isFinite(Number(ltf)) ? Number(ltf) : 0,
              htf_score: Number.isFinite(Number(htf)) ? Number(htf) : 0,
              phase_pct: Number.isFinite(Number(phase)) ? Math.max(0, Math.min(1, Number(phase))) : Number.isFinite(Number(p.phase_pct)) ? Number(p.phase_pct) : 0,
              completion: Number.isFinite(Number(completion)) ? Math.max(0, Math.min(1, Number(completion))) : Number.isFinite(Number(p.completion)) ? Number(p.completion) : 0,
            };
          })
          .filter(Boolean);
      }

      function downsampleByInterval(points, intervalMs) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const buckets = new Map();
        points.forEach((p) => {
          const tsRaw = p.__ts_ms ?? p.ts ?? p.ingest_ts ?? p.ingest_time;
          const ts =
            typeof tsRaw === "string"
              ? new Date(tsRaw).getTime()
              : Number(tsRaw);
          if (!Number.isFinite(ts)) return;
          const bucket = Math.floor(ts / intervalMs) * intervalMs;
          const prev = buckets.get(bucket);
          if (!prev || ts > prev.__ts_ms) {
            buckets.set(bucket, { ...p, __ts_ms: ts, __bucket: bucket });
          }
        });
        return Array.from(buckets.values()).sort(
          (a, b) => a.__ts_ms - b.__ts_ms,
        );
      }

      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const isAligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(0)}% completion. Consider taking profits or trimming 50-75% of position.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(0)}% indicates late-cycle conditions. Wait for pullback or trim existing positions.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20",
          };
        }
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock showing Prime setup with exceptional alignment. High-probability setup with strong fundamentals.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. Enter on pullback or break.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase and low completion suggest room to run.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }
        if (isPrime) {
          return {
            action: "Wait for Entry - Prime Setup",
            description: `This is a Prime (high-quality) setup, but entry conditions are not yet aligned. Wait for corridor alignment or confirmation before entering.`,
            color: "text-[var(--tt-text-muted)]",
            bg: "bg-[var(--tt-bg-elevated)]",
          };
        }
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. Wait for better conditions or confirmation signals.`,
          color: "text-[var(--tt-text-muted)]",
          bg: "bg-[var(--tt-bg-elevated)]",
        };
      }

      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK")
          return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL")
          return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR")
          return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK")
          return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map((p) => p.state).filter(Boolean);
        for (let i = 1; i < states.length; i++) {
          if (
            states[i - 1] === "HTF_BULL_LTF_PULLBACK" &&
            states[i] === "HTF_BULL_LTF_BULL"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1→Q2 transition (Bull Entry)",
              quadrant: "Q1→Q2",
              confidence: "HIGH",
            });
          }
          if (
            states[i - 1] === "HTF_BEAR_LTF_PULLBACK" &&
            states[i] === "HTF_BEAR_LTF_BEAR"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4→Q3 transition (Bear Entry)",
              quadrant: "Q4→Q3",
              confidence: "HIGH",
            });
          }
        }
        return patterns;
      }

      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = useState([]);
        const [loading, setLoading] = useState(false);
        const [hasLoaded, setHasLoaded] = useState(false);
        useEffect(() => {
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const res = await fetch(
                  `${API_BASE}/timed/trail?ticker=${encodeURIComponent(ticker.ticker)}`,
                );
                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && Array.isArray(data.trail)) {
                    setTrail(data.trail);
                  }
                }
              } catch (e) {
                console.error("Failed to load trail:", e);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300);
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);
        const sampledTrail = useMemo(
          () => downsampleByInterval(trail, 15 * 60 * 1000),
          [trail],
        );
        const patterns = detectPatterns(sampledTrail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = sampledTrail
          .map((p) => getQuadrantFromState(p.state))
          .filter(Boolean);
        return (
          <div className="mb-4 p-4 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
            <div className="text-sm font-bold mb-3 text-[var(--tt-text-muted)]">
              Quadrant Progression (15m increments)
            </div>
            <div className="grid grid-cols-2 gap-2 mb-4">
              {[1, 2, 4, 3].map((q) => {
                const quad =
                  q === 1
                    ? { q: 1, name: "Q1", label: "Bull Setup", color: "blue" }
                    : q === 2
                      ? {
                          q: 2,
                          name: "Q2",
                          label: "Bull Momentum",
                          color: "green",
                        }
                      : q === 4
                        ? {
                            q: 4,
                            name: "Q4",
                            label: "Bear Setup",
                            color: "orange",
                          }
                        : {
                            q: 3,
                            name: "Q3",
                            label: "Bear Momentum",
                            color: "red",
                          };
                const isActive = currentQuad?.q === quad.q;
                const hasHistory = quadHistory.some(
                  (qh) => qh && qh.q === quad.q,
                );
                return (
                  <div
                    key={q}
                    className={`p-3 rounded-lg border-2 ${
                      isActive
                        ? `border-${quad.color}-400 bg-${quad.color}-500/20`
                        : hasHistory
                          ? `border-${quad.color}-500/50 bg-${quad.color}-500/10`
                          : "border-[var(--tt-border)] bg-[var(--tt-bg-surface)]"
                    }`}
                  >
                    <div className={`text-xs font-bold text-${quad.color}-400`}>
                      {quad.name}: {quad.label}
                    </div>
                  </div>
                );
              })}
            </div>
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[var(--tt-border)]">
                <div className="text-xs font-bold text-yellow-400 mb-2">
                  🎯 Detected Patterns
                </div>
                {patterns.map((pattern, idx) => (
                  <div
                    key={idx}
                    className="p-2 rounded border bg-yellow-500/20 border-yellow-400/50 mb-2"
                  >
                    <div className="text-xs font-bold text-white">
                      {pattern.description}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      }

      function TickerDetails({ ticker, onClose, allLoadedData = null }) {
        if (!ticker) return null;
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) return allLoadedData;
            return Object.values(allLoadedData).filter(
              (t) => t && typeof t === "object" && t.ticker,
            );
          }
          return [];
        })();
        const baseScore = Number(ticker.rank) || 0;
        const displayScore = rankScoreForTicker(ticker);
        const dynamicRank = computeDynamicRank(ticker);
        const allTickersWithRank = allLoadedTickersArray.map((t) => ({
          ...t,
          dynamicRank: computeDynamicRank(t),
        }));
        const sortedByDynamic = [...allTickersWithRank].sort(
          (a, b) => b.dynamicRank - a.dynamicRank,
        );
        const rankPosition =
          sortedByDynamic.findIndex(
            (t) =>
              String(t.ticker || "").toUpperCase() ===
              String(ticker.ticker || "").toUpperCase(),
          ) + 1;
        const totalTickers = allLoadedTickersArray.length;
        return (
          <div className="w-full h-full flex flex-col">
            <div className="w-full h-full flex flex-col slide-in-right shadow-2xl rounded-xl border-2" style={{ background: "#0c0f14", borderColor: "var(--tt-border)" }}>
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button
                    onClick={onClose}
                    className="text-[var(--tt-text-muted)] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)]"
                  >
                    ✕
                  </button>
                </div>
                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      🚀 MOMENTUM ELITE 🚀
                    </div>
                  </div>
                )}
                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500">
                    ⭐ PRIME SETUP ⭐
                  </div>
                )}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                      <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color}`}
                      >
                        {dir.text === "LONG"
                          ? "📈 L"
                          : dir.text === "SHORT"
                            ? "📉 S"
                            : dir.text}
                      </div>
                    </div>
                  );
                })()}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[var(--tt-text-muted)]">
                    {actionInfo.description}
                  </div>
                </div>
                <QuadrantProgression ticker={ticker} flags={flags} />
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[var(--tt-text-muted)]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                    </span>
                  </div>
                  <div className="h-3 bg-[var(--tt-bg-elevated)] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                      }}
                    />
                  </div>
                </div>
                <div className="space-y-2.5 text-sm">
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Score</span>
                    <span className="font-semibold text-blue-400 text-lg">
                      {Number.isFinite(displayScore)
                        ? displayScore.toFixed(1)
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Rank</span>
                    <span className="font-semibold">
                      {rankPosition > 0
                        ? `#${rankPosition} of ${totalTickers}`
                        : "—"}
                    </span>
                  </div>
                  {dynamicRank !== baseScore && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Dynamic Score</span>
                      <span className="font-semibold text-green-400">
                        {dynamicRank}
                      </span>
                    </div>
                  )}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const components = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(1)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(1)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return (
                      <div className="mt-4 pt-4 border-t border-[var(--tt-border)]">
                        <div className="text-xs text-[var(--tt-text-muted)] mb-3 font-semibold">
                          Score Breakdown
                        </div>
                        <div className="space-y-1.5">
                          {components.map((comp, idx) => (
                            <div
                              key={idx}
                              className="flex justify-between items-center text-xs"
                            >
                              <span className="text-[var(--tt-text-muted)]">
                                {comp.label}
                              </span>
                              <span className={`font-semibold ${comp.color}`}>
                                {comp.value}
                              </span>
                            </div>
                          ))}
                          <div className="flex justify-between items-center pt-2 mt-2 border-t border-[var(--tt-border)]/50">
                            <span className="text-[var(--tt-text-muted)] font-semibold">
                              Total Score
                            </span>
                            <span className="font-bold text-lg text-blue-400">
                              {Math.round(breakdown.total)}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">State</span>
                    <span className="font-semibold">{ticker.state || "—"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Completion</span>
                    <span className="font-semibold">
                      {Math.round(completionForSize(ticker) * 100)}%
                    </span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                        {ent.side}
                      </span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Current Price</span>
                    <span className="font-semibold text-lg">
                      {ticker.price
                        ? `$${Number(ticker.price).toFixed(2)}`
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">TP (Primary)</span>
                    <span className="font-semibold">
                      {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]" title="Trailing Stop Loss">TSL</span>
                    <span className="font-semibold">
                      {ticker.sl ? Number(ticker.sl).toFixed(2) : "—"}
                    </span>
                  </div>
                </div>
                {(flags.sq30_on ||
                  flags.sq30_release ||
                  flags.phase_dot ||
                  flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[var(--tt-text-muted)] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && (
                        <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                          🧨 Squeeze ON
                        </span>
                      )}
                      {flags.sq30_release && (
                        <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                          ⚡ Squeeze Release
                        </span>
                      )}
                      {flags.phase_dot && (
                        <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                          Phase Dot
                        </span>
                      )}
                      {flags.phase_zone_change && (
                        <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                          Zone Change
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </div>
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[var(--tt-border)] bg-[var(--tt-bg-elevated)]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(ticker.ticker)}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  📊 Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // TickerDetailsLoader - Loads ticker data and passes to unified component
      // ─────────────────────────────────────────────────────────────
      const TickerDetailsLoader = ({
        tickerSymbol,
        trade = null,
        onClose,
        allLoadedData = null,
        sectors = [],
        rankedTickers = null,
        rankedTickerPositions = null,
        positionEvents = null,
      }) => {
        const [tickerData, setTickerData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              const res = await fetch(
                `${API_BASE}/timed/latest?ticker=${encodeURIComponent(tickerSymbol)}`,
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok || !json.data) {
                throw new Error(json.error || "Ticker not found");
              }
              setTickerData(json.data || json.latestData);
            } catch (err) {
              console.error("Failed to fetch ticker:", err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };
          fetchTicker();
        }, [tickerSymbol]);

        if (loading) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[var(--tt-bg-surface)]">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[var(--tt-text-muted)]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }

        if (error || !tickerData) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[var(--tt-bg-surface)]">
              <div className="text-center">
                <div className="text-red-400 mb-2">
                  Failed to load {tickerSymbol}
                </div>
                <div className="text-[var(--tt-text-muted)] text-sm mb-4">
                  {error || "No data available"}
                </div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-elevated)] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }

        return (
          <TickerDetailRightRail
            ticker={tickerData}
            trade={trade}
            onClose={onClose}
            allLoadedData={allLoadedData}
            sectors={sectors}
            rankedTickers={rankedTickers}
            rankedTickerPositions={rankedTickerPositions}
            initialRailTab={trade ? "TRADE_HISTORY" : null}
          />
        );
      };

      // ─────────────────────────────────────────────────────────────
      // Welcome Modal Component - Dashboard Guide (Trading Concepts)
      // ─────────────────────────────────────────────────────────────
      function DashboardWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Timed Trading! 🎯",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  This dashboard helps you find high-quality trading setups by
                  combining multiple timeframes and technical indicators.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎓 How to Use This Guide
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    Click "Next" to learn about each concept, or use the
                    navigation dots to jump to any section. You can always
                    reopen this guide from the navigation bar.
                  </p>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ✨ Quick Start
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">green zones</strong> (Q1 &
                      Q2) for LONG setups
                    </li>
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">red zones</strong> (Q3 &
                      Q4) for SHORT setups
                    </li>
                    <li>Click on any bubble to see detailed information</li>
                    <li>Use filters to narrow down the best opportunities</li>
                  </ol>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding the Quadrants 📊",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The chart is divided into <strong>4 quadrants</strong> based
                  on two scores:
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                    <h3 className="text-green-400 font-semibold mb-2">
                      HTF Score (Y-axis)
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      <strong className="text-white">Higher Timeframe</strong> -
                      Shows the overall trend direction.
                      <br />• Positive = Bullish trend
                      <br />• Negative = Bearish trend
                    </p>
                  </div>
                  <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                    <h3 className="text-blue-400 font-semibold mb-2">
                      LTF Score (X-axis)
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      <strong className="text-white">Lower Timeframe</strong> -
                      Shows entry timing.
                      <br />• Positive = Momentum/Continuation
                      <br />• Negative = Pullback/Setup
                    </p>
                  </div>
                </div>
                <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-3">
                    The 4 Quadrants:
                  </h3>
                  <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q1: Long Setup 📈
                      </div>
                      <div className="text-[var(--tt-text-muted)]">
                        HTF Bull + LTF Pullback
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Best entry zone for LONG trades
                      </div>
                    </div>
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q2: Long Momentum 🚀
                      </div>
                      <div className="text-[var(--tt-text-muted)]">HTF Bull + LTF Bull</div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q3: Short Momentum 📉
                      </div>
                      <div className="text-[var(--tt-text-muted)]">HTF Bear + LTF Bear</div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q4: Short Setup 🔻
                      </div>
                      <div className="text-[var(--tt-text-muted)]">
                        HTF Bear + LTF Pullback
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Best entry zone for SHORT trades
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Prime Setups ⭐",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  <strong className="text-yellow-400">Prime Setups</strong> are
                  the highest-quality opportunities. They have a ⭐ icon and
                  appear with a green glow.
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    Prime Setup Criteria:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Rank ≥ 75</strong> - High
                      overall quality score
                    </li>
                    <li>
                      <strong className="text-white">Risk/Reward ≥ 1.5</strong>{" "}
                      - Good profit potential vs risk
                    </li>
                    <li>
                      <strong className="text-white">Completion ≤ 40%</strong> -
                      Still early in the move
                    </li>
                    <li>
                      <strong className="text-white">In Corridor</strong> -
                      Valid entry zone
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    💡 How to Find Prime Setups:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"Prime Only"</strong>{" "}
                      filter button
                    </li>
                    <li>Look for bubbles with ⭐ icons and green borders</li>
                    <li>Click on a bubble to see detailed entry/exit levels</li>
                    <li>Check the Risk/Reward ratio - higher is better!</li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Tip:</strong> Prime
                    setups are rare but offer the best risk/reward. Focus on Q1
                    (Long Setup) and Q4 (Short Setup) quadrants for the best
                    entries.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "In Corridor 🎯",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The <strong className="text-cyan-400">Corridor</strong> is a
                  specific zone where entries are considered valid and safe.
                </p>
                <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                  <h3 className="text-cyan-400 font-semibold mb-2">
                    What is a Corridor?
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                    A corridor is a narrow band on the chart where price action
                    is optimal for entry. Think of it as a "sweet spot" where
                    the setup is most likely to succeed.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Long Corridor 📈
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        HTF Score &gt; 0<br />
                        LTF Score: -8 to +12
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Short Corridor 📉
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        HTF Score &lt; 0<br />
                        LTF Score: -12 to +8
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How to Use Corridor Filter:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"In Corridor"</strong>{" "}
                      filter button
                    </li>
                    <li>This shows only tickers in valid entry zones</li>
                    <li>These are the safest setups to trade</li>
                    <li>
                      Combine with "Prime Only" for the best opportunities
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">
                      Why Corridors Matter:
                    </strong>{" "}
                    Tickers outside corridors may be too early, too late, or in
                    unfavorable conditions. Corridor entries have the highest
                    probability of success.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "TD Sequential (TD9) 🔢",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  <strong className="text-purple-400">TD Sequential</strong> is
                  a powerful indicator that identifies potential reversal
                  points.
                </p>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    What is TD9?
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                    TD Sequential counts consecutive bars in one direction. When
                    it reaches <strong className="text-white">9</strong>, it
                    signals potential exhaustion and reversal.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        TD9 Bullish 📈
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        Signals potential <strong>bottom</strong> and upward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for LONG entries
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        TD9 Bearish 📉
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        Signals potential <strong>top</strong> and downward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for SHORT entries or exit
                        LONGs
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🔢 How to Use TD9 Filter:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"TD9 Setup"</strong> filter
                      button
                    </li>
                    <li>This shows only tickers with active TD9 signals</li>
                    <li>
                      TD9 signals are strongest when combined with other
                      factors:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>
                          In the correct quadrant (Q1 for bullish, Q4 for
                          bearish)
                        </li>
                        <li>In corridor</li>
                        <li>With good Risk/Reward</li>
                      </ul>
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Pro Tip:</strong> TD9
                    signals are most powerful at extremes. If you see a TD9
                    signal in Q1 (Long Setup) or Q4 (Short Setup), it's a strong
                    confirmation of a reversal setup.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Squeeze Indicators 🧨⚡",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The <strong className="text-yellow-400">Squeeze</strong>{" "}
                  indicator shows when volatility is building up, like a spring
                  being compressed before release.
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                    <h3 className="text-yellow-400 font-semibold mb-2 flex items-center gap-2">
                      🧨 In Squeeze
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                      Volatility is{" "}
                      <strong className="text-white">compressed</strong> - price
                      is consolidating.
                    </p>
                    <div className="text-xs text-[var(--tt-text-muted)] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        Energy is building up
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Watch
                        closely - a big move is coming
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Wait for squeeze release
                      </div>
                    </div>
                  </div>
                  <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                    <h3 className="text-cyan-400 font-semibold mb-2 flex items-center gap-2">
                      ⚡ Squeeze Release
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                      Volatility has{" "}
                      <strong className="text-white">exploded</strong> - price
                      is breaking out.
                    </p>
                    <div className="text-xs text-[var(--tt-text-muted)] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        The spring has released!
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Strong
                        momentum signal
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Enter on pullback or breakout
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How to Use Squeeze Filters:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">
                        "In Squeeze" Filter:
                      </strong>{" "}
                      Shows tickers where volatility is building. These are good
                      to watch but wait for release before entering.
                    </div>
                    <div>
                      <strong className="text-white">
                        "Squeeze Release" Filter:
                      </strong>{" "}
                      Shows tickers where the squeeze has fired. These often
                      have strong momentum - combine with Prime filter for best
                      results.
                    </div>
                  </div>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    💡 Best Practices:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">
                        Squeeze Release + Prime Setup
                      </strong>{" "}
                      = Very strong signal
                    </li>
                    <li>
                      <strong className="text-white">
                        Squeeze Release + In Corridor
                      </strong>{" "}
                      = High probability entry
                    </li>
                    <li>
                      <strong className="text-white">In Squeeze</strong> =
                      Prepare but don't enter yet
                    </li>
                    <li>
                      Look for squeeze release in the direction of the HTF trend
                    </li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together 🎓",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  Now that you understand the concepts, here's a{" "}
                  <strong className="text-yellow-400">
                    step-by-step workflow
                  </strong>{" "}
                  to find great setups:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    📋 Your Trading Workflow:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Step 1: Choose Your Direction
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • For LONG trades: Focus on Q1 (Long Setup) quadrant
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • For SHORT trades: Focus on Q4 (Short Setup) quadrant
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 2: Apply Quality Filters
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Click "Prime Only" to see only high-quality setups
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Click "In Corridor" to ensure valid entry zones
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 3: Look for Confirmation Signals
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • TD9 Setup: Strong reversal signal
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Squeeze Release ⚡: Strong momentum
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Momentum Elite 🚀: Best fundamentals
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 4: Analyze the Setup
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Click on a bubble to see details
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Check Risk/Reward ratio (aim for ≥ 1.5)
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Verify entry price, stop loss, and take profit levels
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 5: Execute Your Trade
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Enter at the suggested entry price
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Set stop loss at the SL level
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Target the TP levels (consider trimming at first TP)
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ⭐ The Perfect Setup Checklist:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>
                      ✅ In the correct quadrant (Q1 for LONG, Q4 for SHORT)
                    </div>
                    <div>✅ Prime Setup (⭐ icon)</div>
                    <div>✅ In Corridor</div>
                    <div>✅ Risk/Reward ≥ 1.5</div>
                    <div>✅ Completion ≤ 40% (still early)</div>
                    <div>
                      ✅ TD9 signal OR Squeeze Release (bonus confirmation)
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Remember:</strong> Not
                    every setup will have all these factors. Use your judgment
                    and risk management. Start with paper trading if you're new!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[var(--tt-bg-base)] border-2 border-[var(--tt-border)] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[var(--tt-border)] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[var(--tt-bg-elevated)]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[var(--tt-text-muted)] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[var(--tt-border)] p-4 flex items-center justify-between bg-[var(--tt-bg-surface)]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[var(--tt-border)] text-[var(--tt-text-muted)] opacity-50 cursor-not-allowed"
                      : "border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-hover)] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[var(--tt-text-muted)]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Trading! 🚀
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Welcome Modal Component - Simulated Trades Guide
      // ─────────────────────────────────────────────────────────────
      function TrackerWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Trade Tracker! 📊",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  The Trade Tracker automatically simulates trades based on
                  alerts from the main dashboard, helping you learn which setups
                  work best.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How It Works:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      When an alert fires from TradingView, a simulated trade is
                      automatically created
                    </li>
                    <li>
                      Each trade uses a{" "}
                      <strong className="text-white">
                        $1,000 position size
                      </strong>
                    </li>
                    <li>
                      Trades are tracked in real-time with live P&L updates
                    </li>
                    <li>
                      When price hits Stop Loss or Take Profit, the trade closes
                      automatically
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ✨ What You'll Learn:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>Which setups have the best win rate</li>
                    <li>How different Risk/Reward ratios perform</li>
                    <li>Which model versions work best</li>
                    <li>Performance by rank, sector, and other factors</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Note:</strong> These are
                    simulated trades for learning purposes only. Always do your
                    own research before making real trades!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding Trade Statuses 🏷️",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  Each trade has a <strong>status</strong> that tells you its
                  current state:
                </p>
                <div className="grid grid-cols-1 gap-3">
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>🟢 OPEN</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade is active and being tracked. P&L updates in
                      real-time as price moves. The trade will close when it
                      hits Stop Loss or Take Profit.
                    </p>
                  </div>
                  <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                    <div className="font-bold text-blue-400 mb-2 flex items-center gap-2">
                      <span>🔵 TP_HIT_TRIM</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      First Take Profit level was hit! The system automatically
                      trimmed (sold) part of the position to lock in profits.
                      The remaining position stays open to target higher TP
                      levels.
                    </p>
                  </div>
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>✅ WIN</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade closed profitably! Either hit a Take Profit level or
                      was manually closed in profit. Check the trade history to
                      see the exit details.
                    </p>
                  </div>
                  <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                    <div className="font-bold text-red-400 mb-2 flex items-center gap-2">
                      <span>❌ LOSS</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade hit Stop Loss and closed at a loss. This is normal -
                      not every trade wins! Review what went wrong to improve
                      future setups.
                    </p>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Tip:</strong> Click on
                    any trade row to see detailed information including entry
                    price, stop loss, take profit levels, and full trade
                    history.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Reading the Trade Table 📋",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The trade table shows all your simulated trades. Here's what
                  each column means:
                </p>
                <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                  <div className="space-y-3 text-sm">
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Ticker
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        The stock or futures contract symbol
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Direction
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        LONG (buy) or SHORT (sell)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Entry Price
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Price when the trade was opened
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Current Price
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Live market price (updates every 30 seconds)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Profit or Loss in dollars.{" "}
                        <span className="text-green-400">Green = profit</span>,
                        <span className="text-red-400"> red = loss</span>
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L %
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Profit or Loss as a percentage
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Shares/Contracts
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        For stocks: number of shares (based on $1,000 position).
                        For futures: number of contracts (usually 1)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Status
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Current trade status (OPEN, WIN, LOSS, etc.)
                      </span>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    💡 Pro Tips:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      Click any trade row to see detailed information and trade
                      history
                    </li>
                    <li>
                      Use the version filter to compare different model versions
                    </li>
                    <li>
                      Open trades show live P&L that updates automatically
                    </li>
                    <li>Closed trades show final P&L and exit reason</li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "How P&L is Calculated 💰",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  Understanding how profit and loss is calculated helps you
                  interpret the results:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    📈 For Stocks:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">Position Size:</strong>{" "}
                      $1,000 per trade
                    </div>
                    <div>
                      <strong className="text-white">Shares:</strong> $1,000 ÷
                      Entry Price
                    </div>
                    <div>
                      <strong className="text-white">P&L (LONG):</strong>{" "}
                      (Current Price - Entry Price) × Shares
                    </div>
                    <div>
                      <strong className="text-white">P&L (SHORT):</strong>{" "}
                      (Entry Price - Current Price) × Shares
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    📊 For Futures:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">Contracts:</strong> Usually
                      1 contract per trade
                    </div>
                    <div>
                      <strong className="text-white">Point Value:</strong> Each
                      futures contract has a point value:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>NQ1! (Nasdaq): $20 per point</li>
                        <li>ES1! (S&P 500): $50 per point</li>
                        <li>Other futures vary</li>
                      </ul>
                    </div>
                    <div>
                      <strong className="text-white">P&L:</strong> (Price
                      Change) × Contracts × Point Value
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2">
                    🎯 Example:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>
                      <strong className="text-white">Stock Trade:</strong> AAPL
                      at $150 entry, $155 current
                    </div>
                    <div className="ml-4">
                      Shares: $1,000 ÷ $150 = 6.67 shares
                    </div>
                    <div className="ml-4">
                      P&L: ($155 - $150) × 6.67 ={" "}
                      <span className="text-green-400">+$33.35</span>
                    </div>
                    <div className="mt-2">
                      <strong className="text-white">Futures Trade:</strong>{" "}
                      NQ1! at 15,000 entry, 15,100 current
                    </div>
                    <div className="ml-4">
                      Price Change: 15,100 - 15,000 = 100 points
                    </div>
                    <div className="ml-4">
                      P&L: 100 × 1 × $20 ={" "}
                      <span className="text-green-400">+$2,000</span>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Tracking & Analytics 📊",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The Trade Tracker provides powerful analytics to help you
                  learn:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    📈 Performance Metrics:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Win Rate:</strong>{" "}
                      Percentage of winning trades
                    </li>
                    <li>
                      <strong className="text-white">Total P&L:</strong> Sum of
                      all profits and losses
                    </li>
                    <li>
                      <strong className="text-white">Average Win/Loss:</strong>{" "}
                      Average profit per win vs loss
                    </li>
                    <li>
                      <strong className="text-white">Best/Worst Trade:</strong>{" "}
                      Your biggest winners and losers
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🔍 Filter by Version:
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-2">
                    Use the "Model Version" dropdown to compare performance
                    across different versions of the trading model. This helps
                    you see which improvements work best.
                  </p>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-white">Tip:</strong> Newer versions
                    often include improvements, but older versions may have
                    proven track records.
                  </p>
                </div>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    📊 Daily Summary:
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    Click "View Daily Summary" to see performance breakdowns by:
                  </p>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1 mt-2">
                    <li>Rank ranges (which ranked setups perform best)</li>
                    <li>Risk/Reward ratios (which RR ratios win more)</li>
                    <li>Quadrants (which chart zones are most profitable)</li>
                    <li>Overall statistics and insights</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Remember:</strong> The
                    goal is to learn which setups work best. Review your wins
                    and losses regularly to improve your trading strategy!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together 🎓",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  Here's your{" "}
                  <strong className="text-yellow-400">workflow</strong> for
                  using the Trade Tracker:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    📋 Daily Workflow:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Monitor Open Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check the "Open Trades" section regularly
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Watch P&L update in real-time
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Click trades to see detailed information
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Review Closed Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check "Closed Trades" to see final results
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Review trade history to understand what happened
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Learn from both wins and losses
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Analyze Performance
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Use the version filter to compare models
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Check daily summary for insights
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Look for patterns in winning vs losing trades
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Improve Your Strategy
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Focus on setups with high win rates
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Avoid setups that consistently lose
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Adjust filters on the main dashboard based on results
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ⭐ Key Takeaways:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>✅ Trades are created automatically from alerts</div>
                    <div>✅ Each trade uses $1,000 position size</div>
                    <div>✅ P&L updates in real-time for open trades</div>
                    <div>✅ Trades close automatically at SL or TP</div>
                    <div>✅ Use analytics to learn which setups work best</div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">
                      Ready to start tracking?
                    </strong>{" "}
                    The Trade Tracker refreshes every 30 seconds to show the
                    latest trades and updates. Click "Start Tracking!" to begin!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[var(--tt-bg-base)] border-2 border-[var(--tt-border)] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[var(--tt-border)] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[var(--tt-bg-elevated)]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[var(--tt-text-muted)] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[var(--tt-border)] p-4 flex items-center justify-between bg-[var(--tt-bg-surface)]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[var(--tt-border)] text-[var(--tt-text-muted)] opacity-50 cursor-not-allowed"
                      : "border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-hover)] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[var(--tt-text-muted)]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Tracking! 🚀
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Paper portfolio proof section (extracted from IIFE to fix Babel parse error)
      function PaperPortfolioProofSection({
        paperPortfolio,
        ledgerRangeDays,
        ledgerClosedTrades,
        setLedgerTab,
        setSelectedTicker,
        setSelectedTrade,
      }) {
        const pp = paperPortfolio ?? {};
        const p = pp.data?.portfolio || {};
        const ex = pp.data?.executions || {};
        const byDay =
          ex.byDay && typeof ex.byDay === "object" ? ex.byDay : {};
        const proof = pp.data?.proof;
        const proofByDay =
          proof && typeof proof.byDay === "object" ? proof.byDay : null;
        const openPos = Array.isArray(p.openPositions) ? p.openPositions : [];
        const dayKeyUtc = (ts) => {
          const d = new Date(Number(ts));
          if (!Number.isFinite(d.getTime())) return null;
          return d.toISOString().slice(0, 10);
        };
        const daysBackKeys = (n) => {
          const keys = [];
          for (let i = 0; i < n; i++) {
            const d = new Date();
            d.setUTCDate(d.getUTCDate() - i);
            keys.push(d.toISOString().slice(0, 10));
          }
          return keys;
        };
        const windowDays = Math.max(1, Number(ledgerRangeDays) || 7);
        const windowKeys = daysBackKeys(Math.min(60, windowDays));
        const entryByTradeId = new Map();
        const allEvents = [];
        for (const k of Object.keys(byDay)) {
          const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
          for (const e of arr) allEvents.push(e);
        }
        for (const e of allEvents) {
          const type = String(e?.type || "").toUpperCase();
          const tradeId = String(e?.trade_id || "");
          if (!tradeId || type !== "ENTRY") continue;
          const entryPrice = Number(e?.price);
          const direction = String(e?.direction || "").toUpperCase();
          if (
            Number.isFinite(entryPrice) &&
            (direction === "LONG" || direction === "SHORT")
          ) {
            entryByTradeId.set(tradeId, {
              entryPrice,
              direction,
              entryShares: Number.isFinite(Number(e?.shares)) ? Number(e?.shares) : null,
              entryTs: Number.isFinite(Number(e?.ts)) ? Number(e.ts) : null,
            });
          }
        }
        const pnlForEvent = (e) => {
          const type = String(e?.type || "").toUpperCase();
          if (type !== "TRIM" && type !== "EXIT") return null;
          const meta = entryByTradeId.get(String(e?.trade_id || ""));
          if (!meta) return null;
          const price = Number(e?.price);
          const shares = Number(e?.shares);
          if (!Number.isFinite(price) || !Number.isFinite(shares)) return null;
          const sign = meta.direction === "SHORT" ? -1 : 1;
          return (price - meta.entryPrice) * shares * sign;
        };
        const summarizeKeys = (keys) => {
          const out = { entries: 0, trims: 0, exits: 0, realizedPnl: 0, wins: 0, losses: 0 };
          const closedByTradeId = new Map();
          for (const k of keys) {
            const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
            for (const e of arr) {
              const type = String(e?.type || "").toUpperCase();
              if (type === "ENTRY") out.entries += 1;
              if (type === "TRIM") out.trims += 1;
              if (type === "EXIT") out.exits += 1;
              const pnl = pnlForEvent(e);
              if (Number.isFinite(pnl)) {
                out.realizedPnl += pnl;
                if (type === "EXIT" && e?.trade_id)
                  closedByTradeId.set(String(e.trade_id), pnl);
              }
            }
          }
          for (const pnl of closedByTradeId.values()) {
            if (Number.isFinite(pnl) && pnl !== 0) pnl > 0 ? (out.wins += 1) : (out.losses += 1);
          }
          const denom = out.wins + out.losses;
          out.winRate = denom > 0 ? (out.wins / denom) * 100 : null;
          out.closedTrades = denom;
          return out;
        };
        const summarizeOpen = () => {
          let unreal = 0;
          const rows = [];
          for (const pos of openPos) {
            const direction = String(pos?.direction || "").toUpperCase();
            const sign = direction === "SHORT" ? -1 : 1;
            const avgEntry = Number(pos?.avgEntry);
            const mark = Number(pos?.mark);
            const shares = Number(pos?.shares);
            if (!Number.isFinite(avgEntry) || !Number.isFinite(mark) || !Number.isFinite(shares)) continue;
            unreal += (mark - avgEntry) * shares * sign;
            rows.push({ ...pos, __unreal: (mark - avgEntry) * shares * sign });
          }
          rows.sort((a, b) => Number(b.__unreal) - Number(a.__unreal));
          return { unrealizedPnl: unreal, rows };
        };
        const today = summarizeKeys([new Date().toISOString().slice(0, 10)]);
        const week = summarizeKeys(daysBackKeys(7));
        const windowSum = summarizeKeys(windowKeys);
        const open = summarizeOpen();
        return (
          <div className="space-y-4">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 text-sm">
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Today</div>
                <div className="font-bold">{fmtInt(today.entries)} entries / {fmtInt(today.exits)} exits</div>
                <div className={today.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(today.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Week</div>
                <div className="font-bold">{fmtInt(week.closedTrades)} closed</div>
                <div className={week.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(week.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Window ({windowDays}d)</div>
                <div className="font-bold">{fmtInt(windowSum.closedTrades)} closed</div>
                <div className={windowSum.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(windowSum.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Open</div>
                <div className="font-bold">{fmtInt(openPos.length)} positions</div>
                <div className={open.unrealizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(open.unrealizedPnl)}</div>
              </div>
            </div>
            <div className="text-xs text-[var(--tt-text-muted)]">
              <button type="button" onClick={() => setLedgerTab && setLedgerTab("trades")} className="text-[var(--tt-accent)] hover:underline">
                Open Trades tab for full detail →
              </button>
            </div>
          </div>
        );
      }

      // Date range slider: start and end date thumbs, default full range
      function DateRangeSlider({ range, onRangeChange, sliderDays = 90 }) {
        const trackRef = useRef(null);
        const [dragging, setDragging] = useState(null); // 'start' | 'end'

        const minDate = (() => {
          const d = new Date();
          d.setDate(d.getDate() - sliderDays);
          d.setHours(0, 0, 0, 0);
          return d.getTime();
        })();
        const maxDate = (() => {
          const d = new Date();
          d.setHours(23, 59, 59, 999);
          return d.getTime();
        })();

        const rangeMs = maxDate - minDate;
        const startPct = Math.max(0, Math.min(100, ((range.start.getTime() - minDate) / rangeMs) * 100));
        const endPct = Math.max(0, Math.min(100, ((range.end.getTime() - minDate) / rangeMs) * 100));

        const moveToX = useCallback(
          (clientX, which) => {
            const el = trackRef.current;
            if (!el) return;
            const rect = el.getBoundingClientRect();
            const pct = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            const t = minDate + (pct / 100) * rangeMs;
            const d = new Date(t);
            if (which === "start") {
              const endTs = range.end.getTime();
              d.setTime(Math.min(d.getTime(), endTs));
              onRangeChange({ start: d, end: range.end });
            } else {
              const startTs = range.start.getTime();
              d.setTime(Math.max(d.getTime(), startTs));
              onRangeChange({ start: range.start, end: d });
            }
          },
          [minDate, rangeMs, range, onRangeChange],
        );

        useEffect(() => {
          if (!dragging) return;
          const onMove = (e) => moveToX(e.clientX, dragging);
          const onUp = () => setDragging(null);
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onUp);
          return () => {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onUp);
          };
        }, [dragging, moveToX]);

        const fmt = (d) => d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
        return (
          <div className="flex items-center gap-3">
            <div className="flex flex-col gap-1">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Start</div>
              <div className="text-xs font-medium text-[var(--tt-text)]">{fmt(range.start)}</div>
            </div>
            <div className="relative flex-1 min-w-[200px] max-w-[340px] h-6 flex items-center" ref={trackRef}>
              <div className="absolute inset-0 rounded-full bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)]" />
              <div
                className="absolute h-full rounded-full bg-[var(--tt-accent)]/30"
                style={{ left: `${startPct}%`, width: `${endPct - startPct}%` }}
              />
              <div
                role="slider"
                aria-label="Start date"
                tabIndex={0}
                className="absolute w-4 h-4 rounded-full border-2 border-[var(--tt-accent)] bg-[var(--tt-bg-surface)] cursor-ew-resize touch-none"
                style={{ left: `calc(${startPct}% - 8px)`, top: "50%", transform: "translateY(-50%)" }}
                onMouseDown={() => setDragging("start")}
              />
              <div
                role="slider"
                aria-label="End date"
                tabIndex={0}
                className="absolute w-4 h-4 rounded-full border-2 border-[var(--tt-accent)] bg-[var(--tt-bg-surface)] cursor-ew-resize touch-none"
                style={{ left: `calc(${endPct}% - 8px)`, top: "50%", transform: "translateY(-50%)" }}
                onMouseDown={() => setDragging("end")}
              />
            </div>
            <div className="flex flex-col gap-1">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">End</div>
              <div className="text-xs font-medium text-[var(--tt-text)]">{fmt(range.end)}</div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Investor Portfolio Panel — shown when "Investor" tab is active
      // ─────────────────────────────────────────────────────────────
      // Map raw investor reason codes to human-readable descriptions
      function investorReasonLabel(reason, action) {
        if (!reason) return "—";
        const map = {
          auto_entry_accumulate: "Auto-buy: Accumulate stage (5-7% allocation)",
          auto_entry_watch: "Auto-buy: Watch stage (2% starter position)",
          auto_entry_core_hold: "Auto-buy: Core Hold (adding to position)",
          auto_reduce: "Auto-trim: Reduce stage (25% reduction)",
          auto_exit: "Auto-exit: Score dropped below threshold",
          manual_buy: "Manual buy",
          manual_sell: "Manual sell",
          initial_entry: "Initial position entry",
          dca_buy: "Dollar-cost average buy",
          test_cleanup: "Test / cleanup",
          rebalance_add: "Rebalance: adding to reach target allocation",
          rebalance_trim: "Rebalance: trimming to reduce overweight",
          score_drop: "Score dropped — reducing exposure",
          trend_reversal: "Weekly trend reversed — reducing exposure",
          rs_weak: "Relative strength weakened — reducing exposure",
        };
        return map[reason] || reason.replace(/_/g, " ");
      }

      function EquityCurveChart({ curveData, mode }) {
        const chartRef = useRef(null);
        const containerRef = useRef(null);

        useEffect(() => {
          if (!containerRef.current || !curveData) return;
          const modeData = curveData[mode];
          if (!modeData || !modeData.points || modeData.points.length < 2) return;

          if (chartRef.current) {
            chartRef.current.remove();
            chartRef.current = null;
          }

          const chart = LightweightCharts.createChart(containerRef.current, {
            width: containerRef.current.clientWidth,
            height: 220,
            layout: { background: { type: "solid", color: "transparent" }, textColor: "#9ca3af", fontSize: 11 },
            grid: { vertLines: { color: "rgba(255,255,255,0.03)" }, horzLines: { color: "rgba(255,255,255,0.03)" } },
            rightPriceScale: { borderColor: "rgba(255,255,255,0.06)" },
            timeScale: { borderColor: "rgba(255,255,255,0.06)", timeVisible: false },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
          });

          const lineSeries = chart.addAreaSeries({
            lineColor: mode === "investor" ? "#8b5cf6" : "#10b981",
            topColor: mode === "investor" ? "rgba(139,92,246,0.25)" : "rgba(16,185,129,0.25)",
            bottomColor: mode === "investor" ? "rgba(139,92,246,0)" : "rgba(16,185,129,0)",
            lineWidth: 2,
          });

          const lineData = modeData.points.map(p => ({ time: p.date, value: p.equity }));
          lineSeries.setData(lineData);
          chart.timeScale().fitContent();
          chartRef.current = chart;

          const ro = new ResizeObserver(() => {
            if (containerRef.current && chartRef.current) {
              chartRef.current.applyOptions({ width: containerRef.current.clientWidth });
            }
          });
          ro.observe(containerRef.current);

          return () => { ro.disconnect(); if (chartRef.current) { chartRef.current.remove(); chartRef.current = null; } };
        }, [curveData, mode]);

        if (!curveData || !curveData[mode] || (curveData[mode].points || []).length < 2) {
          return html`<div className="tt-card p-6">
            <p className="tt-label mb-1">Equity Curve</p>
            <p className="text-sm text-[var(--tt-text-faint)]">No snapshot data yet. Run a backtest to generate the equity curve.</p>
          </div>`;
        }

        const s = curveData[mode].summary;
        return html`<div className="tt-card overflow-hidden p-6">
          <div className="flex items-center justify-between mb-3">
            <div>
              <p className="tt-label mb-0.5">Equity Curve</p>
              <p className="text-lg font-semibold text-[var(--tt-text)]">
                ${fmtUsd(s.endEquity)}
                <span className="text-sm ml-2 ${s.totalReturnPct >= 0 ? 'text-[var(--tt-accent)]' : 'text-[var(--tt-negative)]'}">
                  ${s.totalReturnPct >= 0 ? '+' : ''}${s.totalReturnPct}%
                </span>
              </p>
            </div>
            <div className="flex gap-4 text-xs text-[var(--tt-text-muted)]">
              <span title="Maximum drawdown">Max DD: ${s.maxDrawdownPct}%</span>
              <span title="Annualized Sharpe ratio">Sharpe: ${s.sharpe}</span>
              <span>${s.totalDays} days</span>
            </div>
          </div>
          <div ref=${containerRef} className="w-full" style=${{ height: "220px" }} />
          <div className="flex gap-4 text-[10px] text-[var(--tt-text-faint)] mt-2">
            <span>Start: ${fmtUsd(s.startCash)}</span>
            <span>Realized: ${fmtUsd(s.cumRealized)}</span>
          </div>
        </div>`;
      }

      // ─────────────────────────────────────────────────────────────
      // PortfolioColumn — unified column for Active Trader OR Investor
      // Renders: Equity Curve -> Metrics -> Open Positions -> Trade History
      // ─────────────────────────────────────────────────────────────
      function PortfolioColumn({ mode, summary, curveData, trades, positions, tickerData, loading, onSelectTrade }) {
        const isTrader = mode === "trader";
        const label = isTrader ? "Active Trader" : "Investor";
        const accentColor = isTrader ? "var(--tt-accent)" : "#8b5cf6";
        const startCash = summary?.startCash || 100000;
        const acctVal = summary?.accountValue ?? startCash;
        const totalRealized = summary?.totalRealized ?? 0;
        const unrealized = summary?.unrealized ?? 0;
        const totalPnl = acctVal - startCash;

        const openTrades = useMemo(() => {
          return (trades || []).filter(t => {
            const s = String(t.status || "").toUpperCase();
            return s === "OPEN" || s === "TP_HIT_TRIM";
          });
        }, [trades]);

        const closedTrades = useMemo(() => {
          return (trades || []).filter(t => {
            const s = String(t.status || "").toUpperCase();
            return s === "WIN" || s === "LOSS" || s === "FLAT" || Number(t.trimmed_pct ?? t.trimmedPct ?? 0) >= 0.9999;
          });
        }, [trades]);

        const wins = closedTrades.filter(t => (Number(t.pnl) || 0) > 0).length;
        const losses = closedTrades.filter(t => (Number(t.pnl) || 0) <= 0).length;
        const realizedPnl = closedTrades.reduce((s, t) => s + (Number(t.pnl) || 0), 0);

        // Open positions with live P&L
        const openPositionCards = useMemo(() => {
          const items = isTrader ? openTrades : (positions || []).filter(p => String(p.status || "").toUpperCase() === "OPEN");
          return items.map(item => {
            const ticker = String(item.ticker || "").toUpperCase();
            const td = tickerData && (tickerData[ticker] || tickerData[item.ticker]);
            const curPrice = Number(td?.price) || Number(item.currentPrice) || Number(item.mark) || 0;
            const entryPrice = Number(item.entry_price || item.avg_entry || item.avgEntry) || 0;
            const qty = Number(item.qty || item.total_qty || item.total_shares || item.shares) || 0;
            const costBasis = Number(item.cost_basis || item.costBasis) || (entryPrice * qty);
            const dir = String(item.direction || "LONG").toUpperCase();
            const sign = dir === "SHORT" ? -1 : 1;
            const pnl = qty > 0 && entryPrice > 0 ? sign * (curPrice - entryPrice) * qty : 0;
            const pnlPct = costBasis > 0 ? (pnl / costBasis) * 100 : 0;
            return { ticker, entryPrice, curPrice, qty, pnl, pnlPct, direction: dir, item };
          }).sort((a, b) => a.ticker.localeCompare(b.ticker));
        }, [isTrader, openTrades, positions, tickerData]);

        // Trade history sorted by date descending
        const [expanded, setExpanded] = useState(false);
        const tradeHistory = useMemo(() => {
          const all = (trades || []).map(t => {
            const s = String(t.status || "").toUpperCase();
            const isClosed = s === "WIN" || s === "LOSS" || s === "FLAT";
            return {
              ticker: String(t.ticker || "").toUpperCase(),
              date: t.exit_ts ? new Date(Number(t.exit_ts)).toLocaleDateString("en-CA") : (t.entry_ts ? new Date(Number(t.entry_ts)).toLocaleDateString("en-CA") : "—"),
              action: isClosed ? "EXIT" : (Number(t.trimmed_pct) > 0 ? "TRIM" : "ENTRY"),
              price: isClosed ? Number(t.exit_price) : Number(t.entry_price),
              pnl: isClosed ? Number(t.pnl) || 0 : null,
              reason: isClosed ? humanizeExitReason(t.exit_reason || t.exitReason) : "",
              status: s,
              raw: t,
            };
          });
          all.sort((a, b) => (b.date || "").localeCompare(a.date || ""));
          return all;
        }, [trades]);

        // By-day grouping for expanded view
        const byDay = useMemo(() => {
          const map = {};
          for (const t of trades || []) {
            const day = t.entry_ts ? new Date(Number(t.entry_ts)).toLocaleDateString("en-CA") : "unknown";
            if (!map[day]) map[day] = { day, entries: 0, exits: 0, pnl: 0, actions: [] };
            const s = String(t.status || "").toUpperCase();
            const isClosed = s === "WIN" || s === "LOSS" || s === "FLAT";
            if (isClosed) { map[day].exits++; map[day].pnl += (Number(t.pnl) || 0); }
            else map[day].entries++;
            map[day].actions.push(t);
          }
          return Object.values(map).sort((a, b) => b.day.localeCompare(a.day));
        }, [trades]);

        // By-ticker grouping for expanded view
        const byTicker = useMemo(() => {
          const map = {};
          for (const t of trades || []) {
            const tk = String(t.ticker || "").toUpperCase();
            if (!map[tk]) map[tk] = { ticker: tk, trades: [], totalPnl: 0, wins: 0, losses: 0 };
            map[tk].trades.push(t);
            const s = String(t.status || "").toUpperCase();
            if (s === "WIN" || s === "LOSS" || s === "FLAT") {
              map[tk].totalPnl += Number(t.pnl) || 0;
              if ((Number(t.pnl) || 0) > 0) map[tk].wins++;
              else map[tk].losses++;
            }
          }
          return Object.values(map).sort((a, b) => Math.abs(b.totalPnl) - Math.abs(a.totalPnl));
        }, [trades]);

        if (loading) {
          return html`<div className="space-y-4">
            <div className="tt-card p-6 text-center text-[var(--tt-text-faint)]">Loading ${label}...</div>
          </div>`;
        }

        return html`<div className="space-y-4">
          <h2 className="text-base font-semibold text-[var(--tt-text)] flex items-center gap-2">
            <span className="w-2 h-2 rounded-full" style=${{ background: accentColor }} />
            ${label}
          </h2>

          ${/* ── 1. Equity Curve ── */}
          html`<${EquityCurveChart} curveData=${curveData} mode=${mode} />`

          ${/* ── 2. Metrics ── */}
          <div className="grid grid-cols-2 lg:grid-cols-5 gap-2">
            <div className="tt-card p-3">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Account</div>
              <div className="text-base font-bold text-[var(--tt-text)]">${fmtUsd(acctVal)}</div>
            </div>
            <div className="tt-card p-3">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Total P&L</div>
              <div className=${"text-base font-bold " + (totalPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]")}>${fmtUsd(totalPnl)}</div>
            </div>
            <div className="tt-card p-3">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Open P&L</div>
              <div className=${"text-base font-bold " + (unrealized >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]")}>${fmtUsd(unrealized)}</div>
            </div>
            <div className="tt-card p-3">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Closed</div>
              <div className="text-base font-bold text-[var(--tt-text)]">${closedTrades.length}</div>
              <div className="text-[10px] text-[var(--tt-text-faint)]">${wins}W ${losses}L</div>
            </div>
            <div className="tt-card p-3">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Realized</div>
              <div className=${"text-base font-bold " + (realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]")}>${fmtUsd(realizedPnl)}</div>
            </div>
          </div>

          ${/* ── 3. Open Positions ── */}
          <div className="tt-card p-4">
            <h3 className="text-xs font-medium text-[var(--tt-text-faint)] uppercase tracking-wider mb-3">
              Open Positions (${openPositionCards.length})
            </h3>
            ${openPositionCards.length === 0
              ? html`<div className="text-[13px] text-[var(--tt-text-faint)] py-2">No open positions</div>`
              : html`<div className="space-y-1.5 max-h-[300px] overflow-y-auto">
                  ${openPositionCards.map(p => {
                    const isGain = p.pnl >= 0;
                    return html`<div
                      key=${p.ticker}
                      className="flex items-center justify-between py-2 px-3 rounded bg-[var(--tt-bg)] border border-[var(--tt-border)] hover:bg-[var(--tt-bg-hover)] cursor-pointer transition-colors"
                      onClick=${() => onSelectTrade && onSelectTrade(p.item)}
                    >
                      <div className="flex items-center gap-2 min-w-0">
                        <span className="text-[13px] font-semibold text-[var(--tt-text)]">${p.ticker}</span>
                        <span className="text-[11px] text-[var(--tt-text-faint)]">${p.qty.toFixed(1)} sh @ $${p.entryPrice.toFixed(2)}</span>
                      </div>
                      <div className="flex items-center gap-3 text-[13px]">
                        <span className="text-[var(--tt-text-muted)]">$${p.curPrice.toFixed(2)}</span>
                        <span className=${"font-semibold " + (isGain ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]")}>
                          ${isGain ? "+" : ""}${fmtUsd(p.pnl)} (${p.pnlPct >= 0 ? "+" : ""}${p.pnlPct.toFixed(1)}%)
                        </span>
                      </div>
                    </div>`;
                  })}
                </div>`
            }
          </div>

          ${/* ── 4. Trade History ── */}
          <div className="tt-card p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-xs font-medium text-[var(--tt-text-faint)] uppercase tracking-wider">
                Trade History (${tradeHistory.length})
              </h3>
              ${tradeHistory.length > 0 && html`<button
                onClick=${() => setExpanded(!expanded)}
                className="text-[11px] px-2 py-1 rounded border border-[var(--tt-border)] text-[var(--tt-text-muted)] hover:text-[var(--tt-text)] hover:bg-[var(--tt-bg-hover)] transition-colors"
              >
                ${expanded ? "Collapse" : "Expand"}
              </button>`}
            </div>

            ${!expanded ? html`
              ${tradeHistory.length === 0
                ? html`<div className="text-[13px] text-[var(--tt-text-faint)] py-2">No trades yet</div>`
                : html`<div className="max-h-[260px] overflow-y-auto">
                    <table className="w-full text-[12px]">
                      <thead>
                        <tr className="text-[var(--tt-text-faint)] text-left border-b border-[var(--tt-border)]">
                          <th className="py-1.5 pr-2 font-medium">Date</th>
                          <th className="py-1.5 pr-2 font-medium">Ticker</th>
                          <th className="py-1.5 pr-2 font-medium">Action</th>
                          <th className="py-1.5 pr-2 font-medium text-right">Price</th>
                          <th className="py-1.5 pr-2 font-medium text-right">P&L</th>
                          <th className="py-1.5 font-medium">Reason</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${tradeHistory.slice(0, 50).map((h, i) => {
                          const actionColor = h.action === "ENTRY" ? "text-cyan-400" : h.action === "EXIT" ? (h.pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]") : "text-yellow-400";
                          return html`<tr
                            key=${i}
                            className="border-b border-[var(--tt-border)]/30 hover:bg-[var(--tt-bg-hover)] cursor-pointer transition-colors"
                            onClick=${() => onSelectTrade && onSelectTrade(h.raw)}
                          >
                            <td className="py-1.5 pr-2 text-[var(--tt-text-muted)]">${h.date}</td>
                            <td className="py-1.5 pr-2 font-medium text-[var(--tt-text)]">${h.ticker}</td>
                            <td className=${"py-1.5 pr-2 font-semibold " + actionColor}>${h.action}</td>
                            <td className="py-1.5 pr-2 text-right text-[var(--tt-text)]">${h.price ? "$" + h.price.toFixed(2) : "—"}</td>
                            <td className=${"py-1.5 pr-2 text-right font-semibold " + (h.pnl != null ? (h.pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]") : "text-[var(--tt-text-faint)]")}>
                              ${h.pnl != null ? fmtUsd(h.pnl) : "—"}
                            </td>
                            <td className="py-1.5 text-[var(--tt-text-faint)] truncate max-w-[120px]" title=${h.reason}>${h.reason || "—"}</td>
                          </tr>`;
                        })}
                      </tbody>
                    </table>
                    ${tradeHistory.length > 50 && html`<div className="text-center text-[11px] text-[var(--tt-text-faint)] py-2">Showing 50 of ${tradeHistory.length}</div>`}
                  </div>`
              }
            ` : html`
              ${/* Expanded: By Day + By Ticker side by side */}
              <div className="grid grid-cols-1 xl:grid-cols-2 gap-4">
                <div>
                  <h4 className="text-[11px] font-medium text-[var(--tt-text-faint)] mb-2 uppercase">By Day</h4>
                  <div className="space-y-1 max-h-[400px] overflow-y-auto">
                    ${byDay.length === 0
                      ? html`<div className="text-[13px] text-[var(--tt-text-faint)]">No activity</div>`
                      : byDay.slice(0, 60).map(d => html`<div key=${d.day} className="py-2 px-3 rounded bg-[var(--tt-bg)] border border-[var(--tt-border)]">
                          <div className="flex items-center justify-between">
                            <span className="text-[12px] font-medium text-[var(--tt-text)]">${d.day}</span>
                            <div className="flex items-center gap-2 text-[11px]">
                              ${d.entries > 0 && html`<span className="text-cyan-400">+${d.entries}</span>`}
                              ${d.exits > 0 && html`<span className="text-[var(--tt-text-muted)]">-${d.exits}</span>`}
                              ${d.pnl !== 0 && html`<span className=${d.pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>${fmtUsd(d.pnl)}</span>`}
                            </div>
                          </div>
                        </div>`)
                    }
                  </div>
                </div>
                <div>
                  <h4 className="text-[11px] font-medium text-[var(--tt-text-faint)] mb-2 uppercase">P&L by Ticker</h4>
                  <div className="space-y-1 max-h-[400px] overflow-y-auto">
                    ${byTicker.length === 0
                      ? html`<div className="text-[13px] text-[var(--tt-text-faint)]">No trades</div>`
                      : (() => {
                          const maxAbs = Math.max(...byTicker.map(r => Math.abs(r.totalPnl)), 1);
                          return byTicker.slice(0, 100).map(row => {
                            const pct = Math.min(Math.abs(row.totalPnl) / maxAbs, 1) * 100;
                            const isGain = row.totalPnl >= 0;
                            return html`<div
                              key=${row.ticker}
                              className="relative flex items-center justify-between py-2 px-3 rounded bg-[var(--tt-bg)] border border-[var(--tt-border)] overflow-hidden"
                            >
                              <div className="absolute top-0 bottom-0 left-0" style=${{ width: pct + "%", background: isGain ? "rgba(0,200,83,0.10)" : "rgba(255,82,82,0.10)" }} />
                              <span className="relative text-[12px] font-medium text-[var(--tt-text)]">${row.ticker}</span>
                              <div className="relative flex items-center gap-2 text-[12px]">
                                <span className="text-[var(--tt-text-muted)]">${row.trades.length}T</span>
                                ${row.wins > 0 && html`<span className="text-[var(--tt-accent)]">${row.wins}W</span>`}
                                ${row.losses > 0 && html`<span className="text-[var(--tt-negative)]">${row.losses}L</span>`}
                                <span className=${"font-semibold " + (isGain ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]")}>${isGain ? "+" : ""}${fmtUsd(row.totalPnl)}</span>
                              </div>
                            </div>`;
                          });
                        })()
                    }
                  </div>
                </div>
              </div>
            `}
          </div>
        </div>`;
      }


      // ─────────────────────────────────────────────────────────────
      // Main App
      // ─────────────────────────────────────────────────────────────
      function App() {
        const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
        const { data, loading, refreshing, error, lastUpdate, refetch } =
          useTickerData();
        const {
          trades,
          loading: tradesLoading,
          refreshing: tradesRefreshing,
          error: tradesError,
          addTrade,
          updateTrade,
          refetch: refetchTrades,
        } = useSimulatedTrades();
        const { sectors } = useSectors();
        const { summary: acctSummary } = useAccountSummary("trader");

        // ── Investor portfolio data ──
        const { summary: investorSummary } = useAccountSummary("investor");
        const { curveData: equityCurveData } = useEquityCurve("both");
        const [investorTrades, setInvestorTrades] = useState(null);
        const [investorTradesLoading, setInvestorTradesLoading] = useState(false);
        const [investorPositions, setInvestorPositions] = useState(null);
        const [investorPosLoading, setInvestorPosLoading] = useState(false);
        const [portfolioTab, setPortfolioTab] = useState("trader"); // "trader" | "investor"

        // Fetch investor trades + open positions eagerly on mount (both columns visible on desktop)
        const fetchInvestorData = useCallback(() => {
          setInvestorTradesLoading(true);
          setInvestorPosLoading(true);
          Promise.all([
            fetch(`${API_BASE}/timed/ledger/trades?mode=investor&limit=500`).then(r => r.json()),
            fetch(`${API_BASE}/timed/investor/positions?status=OPEN&compact=true`).then(r => r.json()),
          ]).then(([tradesJson, posJson]) => {
            if (tradesJson.ok) setInvestorTrades(tradesJson.trades || []);
            if (posJson.ok) setInvestorPositions(posJson.positions || []);
          }).catch(() => {}).finally(() => {
            setInvestorTradesLoading(false);
            setInvestorPosLoading(false);
          });
        }, []);
        useEffect(() => {
          fetchInvestorData();
          const interval = setInterval(fetchInvestorData, 120000);
          return () => clearInterval(interval);
        }, [fetchInvestorData]);

        // Welcome Guide state
        const [showWelcomeDashboard, setShowWelcomeDashboard] = useState(false);
        const [showWelcomeTracker, setShowWelcomeTracker] = useState(() => {
          const hasSeenWelcome = localStorage.getItem(
            "timedTrading_welcomeSeen",
          );
          return !hasSeenWelcome;
        });

        const handleWelcomeDashboardClose = () => {
          setShowWelcomeDashboard(false);
        };

        const handleWelcomeTrackerClose = () => {
          setShowWelcomeTracker(false);
          localStorage.setItem("timedTrading_welcomeSeen", "true");
        };

        // Version filter state
        const [selectedVersion, setSelectedVersion] = useState("all");
        const [horizonFilter, setHorizonFilter] = useState("ALL");

        // Unified experience: D1-backed Trade Journey (single mode)
        const trackerMode = "ledger";
        const [expandedPositionTicker, setExpandedPositionTicker] = useState(null);
        const initialLedgerTicker = (() => {
          try {
            const t =
              new URLSearchParams(window.location.search).get("ticker") || "";
            return String(t).trim().toUpperCase();
          } catch {
            return "";
          }
        })();
        const [ledgerTickerFilter, setLedgerTickerFilter] =
          useState(initialLedgerTicker);
        const [ledgerStatusFilter, setLedgerStatusFilter] = useState("all");
        const SLIDER_RANGE_DAYS = 365;
        const [ledgerDateRange, setLedgerDateRange] = useState(() => {
          const end = new Date();
          end.setHours(23, 59, 59, 999);
          const start = new Date(end.getTime() - SLIDER_RANGE_DAYS * 24 * 60 * 60 * 1000);
          start.setHours(0, 0, 0, 0);
          return { start, end };
        });
        const [ledgerIncludeEvidence, setLedgerIncludeEvidence] =
          useState(true);

        const ledgerRangeDays = useMemo(() => {
          const a = ledgerDateRange.start.getTime();
          const b = ledgerDateRange.end.getTime();
          return Math.max(1, Math.round((b - a) / (24 * 60 * 60 * 1000)));
        }, [ledgerDateRange]);

        const windowLabel = useMemo(() => {
          const days = ledgerRangeDays;
          return days === 1 ? "Today" : `Last ${days}d`;
        }, [ledgerRangeDays]);

        // P&L by ticker: computed at component level so Engine calibration / P&L section (outside paperPortfolio IIFE) can use it.
        const pnlByTickerWindow = useMemo(() => {
          const pp = paperPortfolio ?? {};
          const openPos = Array.isArray(pp.data?.portfolio?.openPositions)
            ? pp.data.portfolio.openPositions
            : [];
          const byDay = pp.data?.executions?.byDay && typeof pp.data.executions.byDay === "object"
            ? pp.data.executions.byDay
            : {};
          const windowDays = Math.max(1, Number(ledgerRangeDays) || 7);
          const daysBackKeys = (n) => {
            const keys = [];
            for (let i = 0; i < n; i++) {
              const d = new Date();
              d.setUTCDate(d.getUTCDate() - i);
              keys.push(d.toISOString().slice(0, 10));
            }
            return keys;
          };
          const windowKeys = daysBackKeys(Math.min(60, windowDays));

          const entryByTradeId = new Map();
          for (const k of Object.keys(byDay)) {
            const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
            for (const e of arr) {
              const type = String(e?.type || "").toUpperCase();
              const tradeId = String(e?.trade_id || "");
              if (!tradeId || type !== "ENTRY") continue;
              const entryPrice = Number(e?.price);
              const entryShares = Number(e?.shares);
              const entryTs = Number(e?.ts);
              const direction = String(e?.direction || "").toUpperCase();
              if (Number.isFinite(entryPrice) && (direction === "LONG" || direction === "SHORT")) {
                entryByTradeId.set(tradeId, { entryPrice, direction, entryShares: Number.isFinite(entryShares) ? entryShares : null, entryTs: Number.isFinite(entryTs) ? entryTs : null });
              }
            }
          }
          const pnlForEvent = (e) => {
            const type = String(e?.type || "").toUpperCase();
            if (type !== "TRIM" && type !== "EXIT") return null;
            const tradeId = String(e?.trade_id || "");
            const meta = tradeId ? entryByTradeId.get(tradeId) : null;
            if (!meta) return null;
            const price = Number(e?.price);
            const shares = Number(e?.shares);
            if (!Number.isFinite(price) || !Number.isFinite(shares)) return null;
            const sign = meta.direction === "SHORT" ? -1 : 1;
            return (price - meta.entryPrice) * shares * sign;
          };

          const fromTape = () => {
            const realized = new Map();
            for (const k of windowKeys) {
              const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
              for (const e of arr) {
                const pnl = pnlForEvent(e);
                if (!Number.isFinite(pnl) || pnl === 0) continue;
                const tkr = String(e?.ticker || "").toUpperCase();
                if (!tkr) continue;
                realized.set(tkr, (realized.get(tkr) || 0) + pnl);
              }
            }
            const unreal = new Map();
            for (const pos of openPos) {
              const tkr = String(pos?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const direction = String(pos?.direction || "").toUpperCase();
              const sign = direction === "SHORT" ? -1 : 1;
              const avgEntry = Number(pos?.avgEntry);
              const mark = Number(pos?.mark);
              const shares = Number(pos?.shares);
              if (!Number.isFinite(avgEntry) || !Number.isFinite(mark) || !Number.isFinite(shares)) continue;
              const pnl = (mark - avgEntry) * shares * sign;
              if (!Number.isFinite(pnl) || pnl === 0) continue;
              unreal.set(tkr, (unreal.get(tkr) || 0) + pnl);
            }
            const tickers = new Set([...realized.keys(), ...unreal.keys()]);
            const rows = Array.from(tickers)
              .map((ticker) => ({
                ticker,
                realized: Number(realized.get(ticker) || 0),
                unrealized: Number(unreal.get(ticker) || 0),
                total: Number(realized.get(ticker) || 0) + Number(unreal.get(ticker) || 0),
              }))
              .filter((r) => Number.isFinite(r.total) && r.total !== 0);
            rows.sort((a, b) => Math.abs(b.total) - Math.abs(a.total));
            const maxAbs = rows.reduce((m, r) => Math.max(m, Math.abs(r.total)), 0);
            return { rows, maxAbs };
          };

          let out = fromTape();
          if (out.rows.length === 0 && ((Array.isArray(ledgerClosedTrades) && ledgerClosedTrades.length > 0) || openPos.length > 0)) {
            const realized = new Map();
            for (const t of ledgerClosedTrades || []) {
              const tkr = String(t?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const pnl = Number(t?.pnl);
              if (!Number.isFinite(pnl)) continue;
              realized.set(tkr, (realized.get(tkr) || 0) + pnl);
            }
            const unreal = new Map();
            for (const pos of openPos) {
              const tkr = String(pos?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const dir = String(pos?.direction || "").toUpperCase();
              const sign = dir === "SHORT" ? -1 : 1;
              const avg = Number(pos?.avgEntry);
              const mark = Number(pos?.mark);
              const sh = Number(pos?.shares);
              if (!Number.isFinite(avg) || !Number.isFinite(mark) || !Number.isFinite(sh)) continue;
              unreal.set(tkr, (unreal.get(tkr) || 0) + (mark - avg) * sh * sign);
            }
            const tickers = new Set([...realized.keys(), ...unreal.keys()]);
            const rows = Array.from(tickers)
              .map((ticker) => {
                const r = Number(realized.get(ticker) || 0);
                const u = Number(unreal.get(ticker) || 0);
                return { ticker, realized: r, unrealized: u, total: r + u };
              })
              .filter((r) => Number.isFinite(r.total) && r.total !== 0);
            rows.sort((a, b) => Math.abs(b.total) - Math.abs(a.total));
            const maxAbs = rows.reduce((m, r) => Math.max(m, Math.abs(r.total)), 0);
            out = { rows, maxAbs };
          }
          return out;
        }, [paperPortfolio?.data, ledgerClosedTrades, ledgerRangeDays]);

        const startOfDay = (d) => {
          const x = new Date(d);
          x.setHours(0, 0, 0, 0);
          return x;
        };
        const endOfDay = (d) => {
          const x = new Date(d);
          x.setHours(23, 59, 59, 999);
          return x;
        };
        const ledgerSince = useMemo(
          () => startOfDay(ledgerDateRange.start).getTime(),
          [ledgerDateRange.start],
        );
        const ledgerUntil = useMemo(
          () => endOfDay(ledgerDateRange.end).getTime(),
          [ledgerDateRange.end],
        );

        const ledgerTrades = useLedgerTrades({
          ticker: ledgerTickerFilter.trim(),
          status: ledgerStatusFilter,
          since: ledgerSince,
          until: ledgerUntil,
          pageSize: 500,
        });
        const ledgerAlerts = useLedgerAlerts({
          ticker: ledgerTickerFilter.trim(),
          since: ledgerSince,
          until: ledgerUntil,
          pageSize: 500,
        });
        const ledgerSummary = useLedgerSummary({
          since: ledgerSince,
          until: ledgerUntil,
        });
        const paperPortfolio = usePaperPortfolio();
        // Legacy "Trade Detail" right rail removed; use unified ticker right rail instead.

        const rankedTickers = useMemo(() => {
          return getRankedTickers(data);
        }, [data]);

        const rankedTickerPositions = useMemo(() => {
          const map = {};
          rankedTickers.forEach((t, idx) => {
            const sym = String(t.ticker || "")
              .trim()
              .toUpperCase();
            const pos = Number(t?.rank_position);
            const rankPos = Number.isFinite(pos) && pos > 0 ? pos : idx + 1;
            if (sym && map[sym] == null) {
              map[sym] = rankPos;
            }
          });
          return map;
        }, [rankedTickers]);

        // All trades (unfiltered) — used for account value so it's always consistent
        const allLedgerItems = useMemo(() => {
          const lt = ledgerTrades ?? {};
          return Array.isArray(lt.items) ? lt.items : [];
        }, [ledgerTrades?.items]);

        const ledgerFilteredTrades = useMemo(() => {
          if (horizonFilter === "ALL") return allLedgerItems;
          return allLedgerItems.filter((t) => {
            const sym = String(t.ticker || "").toUpperCase();
            const live = data && (data[sym] || data[t.ticker]);
            const key = computeHorizonKey(live || t);
            return key === horizonFilter;
          });
        }, [allLedgerItems, horizonFilter, data]);

        // Open: not WIN/LOSS, no exit_ts, trimmed_pct < 100% (safety net)
        const ledgerOpenTrades = useMemo(
          () =>
            ledgerFilteredTrades.filter((t) => {
              const trimmedPct = Number(t.trimmed_pct ?? t.trimmedPct ?? 0);
              return (
                t.status !== "WIN" &&
                t.status !== "LOSS" &&
                !t.exit_ts &&
                trimmedPct < 0.9999
              );
            }),
          [ledgerFilteredTrades],
        );

        // Closed: WIN/LOSS/FLAT or 100% trimmed
        const ledgerClosedTrades = useMemo(
          () =>
            ledgerFilteredTrades.filter(
              (t) =>
                t.status === "WIN" ||
                t.status === "LOSS" ||
                t.status === "FLAT" ||
                Number(t.trimmed_pct ?? t.trimmedPct ?? 0) >= 0.9999,
            ),
          [ledgerFilteredTrades],
        );

        const ledgerActivityDays = useMemo(() => {
          const MIN_SANE_TS = 946684800000; // Jan 1, 2000 — skip bogus epoch/pre-2000 so they don't show as "Dec 31, 1969"
          const sane = (ts) => ts != null && Number.isFinite(ts) && ts > 0 && ts >= MIN_SANE_TS;
          const events = [];
          const dayKeyFor = (ts) => {
            const d = new Date(Number(ts));
            if (!Number.isFinite(d.getTime())) return "unknown";
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, "0");
            const dd = String(d.getDate()).padStart(2, "0");
            return `${yyyy}-${mm}-${dd}`;
          };

          for (const t of ledgerFilteredTrades) {
            const entryTs = tsToMs(t.entry_ts);
            if (sane(entryTs)) {
              events.push({
                ts: entryTs,
                type: "ENTRY",
                trade: t,
                price: Number(t.entry_price),
              });
            }
            const trimTsRaw = t.trim_ts ?? t.updated_at ?? t.exit_ts ?? t.entry_ts;
            if (
              (t.status === "TP_HIT_TRIM" || Number(t.trimmed_pct) > 0) &&
              trimTsRaw != null &&
              Number.isFinite(Number(trimTsRaw))
            ) {
              const trimTs = tsToMs(trimTsRaw) ?? Number(trimTsRaw);
              if (sane(trimTs)) {
                events.push({
                  ts: trimTs,
                  type: "TRIM",
                  trade: t,
                  price: null,
                });
              }
            }
            const exitTs = tsToMs(t.exit_ts);
            const trimmedPct = Number(t.trimmed_pct ?? t.trimmedPct ?? 0);
            const isClosed = t.status === "WIN" || t.status === "LOSS" || t.status === "FLAT" || trimmedPct >= 0.9999;
            if (isClosed && sane(exitTs)) {
              events.push({
                ts: exitTs,
                type: "EXIT",
                trade: t,
                price: Number(t.exit_price),
              });
            }
          }

          const groups = new Map();
          for (const ev of events) {
            const key = dayKeyFor(ev.ts);
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(ev);
          }

          const keys = Array.from(groups.keys()).sort((a, b) =>
            a < b ? 1 : -1,
          );
          return keys.map((key) => {
            const items = groups.get(key) || [];
            items.sort((a, b) => b.ts - a.ts);
            const stats = items.reduce(
              (acc, ev) => {
                if (ev.type === "ENTRY") acc.entries += 1;
                if (ev.type === "TRIM") acc.trims += 1;
                if (ev.type === "EXIT") acc.exits += 1;
                if (ev.type === "EXIT")
                  acc.closedPnl += Number(ev.trade.pnl || 0);
                return acc;
              },
              { entries: 0, trims: 0, exits: 0, closedPnl: 0 },
            );
            const label =
              key === "unknown"
                ? "Unknown date"
                : new Date(`${key}T00:00:00`).toLocaleDateString(undefined, {
                    weekday: "short",
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                  });
            return { key, label, events: items, stats };
          });
        }, [ledgerFilteredTrades]);

        const ledgerClosedByTicker = useMemo(() => {
          const groups = new Map();
          for (const t of ledgerClosedTrades) {
            const key = String(t.ticker || "").toUpperCase();
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(t);
          }
          const tickers = Array.from(groups.keys()).sort((a, b) =>
            a.localeCompare(b),
          );
          return tickers.map((ticker) => {
            const trades = groups.get(ticker) || [];
            trades.sort(
              (a, b) => Number(b.exit_ts || 0) - Number(a.exit_ts || 0),
            );
            const totalPnl = trades.reduce(
              (sum, t) => sum + Number(t.pnl || 0),
              0,
            );
            return { ticker, trades, totalPnl };
          });
        }, [ledgerClosedTrades]);

        const todayActions = useMemo(() => {
          const todayKey = (() => {
            const d = new Date();
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, "0");
            const dd = String(d.getDate()).padStart(2, "0");
            return `${yyyy}-${mm}-${dd}`;
          })();
          const todayStartMs = new Date(todayKey + "T00:00:00").getTime();
          const todayEndMs = todayStartMs + 24 * 60 * 60 * 1000;
          const actions = [];
          const seenActionKeys = new Set();
          for (const t of (ledgerFilteredTrades || [])) {
            const entryTs = tsToMs(t.entry_ts);
            if (entryTs >= todayStartMs && entryTs < todayEndMs) {
              const key = `entry-${t.ticker}-${entryTs}`;
              if (!seenActionKeys.has(key)) {
                seenActionKeys.add(key);
                actions.push({ ts: entryTs, type: "ENTRY", ticker: t.ticker, direction: t.direction || "LONG", price: Number(t.entry_price), pnl: null, trade: t });
              }
            }
            const trimTsRaw = t.trim_ts ?? t.updated_at;
            const trimTs = trimTsRaw ? tsToMs(trimTsRaw) : null;
            if (trimTs >= todayStartMs && trimTs < todayEndMs && Number(t.trimmed_pct) > 0) {
              const key = `trim-${t.ticker}-${trimTs}`;
              if (!seenActionKeys.has(key)) {
                seenActionKeys.add(key);
                actions.push({ ts: trimTs, type: "TRIM", ticker: t.ticker, direction: t.direction || "LONG", price: Number(t.trim_price) || null, trimmedPct: Number(t.trimmed_pct) || 0, pnl: null, trade: t });
              }
            }
            const exitTs = tsToMs(t.exit_ts);
            if (exitTs >= todayStartMs && exitTs < todayEndMs && (t.status === "WIN" || t.status === "LOSS")) {
              const key = `exit-${t.ticker}-${exitTs}`;
              if (!seenActionKeys.has(key)) {
                seenActionKeys.add(key);
                actions.push({ ts: exitTs, type: "EXIT", ticker: t.ticker, direction: t.direction || "LONG", price: Number(t.exit_price), pnl: Number(t.pnl || 0), status: t.status, trade: t });
              }
            }
          }
          actions.sort((a, b) => b.ts - a.ts);
          return actions;
        }, [ledgerFilteredTrades]);

        const portfolioSummary = useMemo(() => {
          let netPnl = 0;
          let totalGain = 0;
          let totalLoss = 0;
          for (const t of ledgerFilteredTrades) {
            const pnl = Number(t.pnl);
            if (!Number.isFinite(pnl)) continue;
            netPnl += pnl;
            if (pnl >= 0) totalGain += pnl;
            else totalLoss += pnl;
          }
          return {
            netPnl,
            totalGain,
            totalLoss,
            totalTrades: ledgerFilteredTrades.length,
          };
        }, [ledgerFilteredTrades]);

        const getPositionMetrics = (trade, live) => {
          const sym = String(trade.ticker || "").toUpperCase();
          const isFutures = FUTURES_SPECS[sym] || sym.endsWith("1!");
          const pointValue =
            isFutures && FUTURES_SPECS[sym] ? FUTURES_SPECS[sym].pointValue : 1;
          const entryPrice = Number(trade.entry_price ?? trade.entryPrice ?? 0);
          const shares =
            trade.shares ?? trade.quantity ??
            (isFutures ? 1 : entryPrice > 0 ? TRADE_SIZE / entryPrice : 0);
          // Prefer live price feed (_live_price) so Open Positions matches Right Rail and actual current price
          const livePriceRaw = Number(live?._live_price ?? live?.price);
          const livePrice = Number.isFinite(livePriceRaw) && livePriceRaw > 0 ? livePriceRaw : null;
          const direction = String(trade.direction || "").toUpperCase();
          const signed = direction === "SHORT" ? -1 : 1;

          // Prefer D1 pre-computed P&L (accurate from replay) over live price calculation when no live feed.
          // When we have live price from /timed/prices, use it so UI matches Right Rail.
          const tradePnl = Number(trade.pnl ?? trade.pnl_amount);
          const tradePnlPct = Number(trade.pnlPct ?? trade.pnl_pct);
          const hasStoredPnl = Number.isFinite(tradePnl);
          const hasStoredPnlPct = Number.isFinite(tradePnlPct);

          // Determine current price: live feed (_live_price) > stored P&L back-compute > live?.price
          let current = null;
          let pnlOpen = null;
          let retOpenPct = null;

          if (Number.isFinite(livePrice) && entryPrice > 0) {
            current = livePrice;
            pnlOpen = (current - entryPrice) * shares * pointValue * signed;
            retOpenPct = ((current - entryPrice) / entryPrice) * 100 * signed;
          } else if (hasStoredPnl) {
            pnlOpen = tradePnl;
            retOpenPct = hasStoredPnlPct ? tradePnlPct : (entryPrice > 0 ? (tradePnl / (entryPrice * shares * pointValue)) * 100 : null);
            current = entryPrice > 0 ? entryPrice + (tradePnl / (shares * pointValue)) * signed : null;
          }

          return {
            isFutures,
            pointValue,
            entryPrice,
            shares,
            current,
            pnlOpen,
            retOpenPct,
          };
        };

        // Aggregate metrics when same ticker has multiple open entries (e.g. two ENTRY events)
        const getAggregatedPositionMetrics = (trades, live) => {
          if (!trades || trades.length === 0) return null;
          if (trades.length === 1) return getPositionMetrics(trades[0], live);
          const sym = String(trades[0].ticker || "").toUpperCase();
          const isFutures = FUTURES_SPECS[sym] || sym.endsWith("1!");
          const pointValue = isFutures && FUTURES_SPECS[sym] ? FUTURES_SPECS[sym].pointValue : 1;
          const livePriceRaw = Number(live?._live_price ?? live?.price);
          const livePrice = Number.isFinite(livePriceRaw) && livePriceRaw > 0 ? livePriceRaw : null;
          let totalShares = 0;
          let costBasis = 0;
          let pnlOpen = 0;
          let hasAllStoredPnl = true;
          for (const t of trades) {
            const entryPrice = Number(t.entry_price ?? t.entryPrice ?? 0);
            const shares = t.shares ?? t.quantity ?? (isFutures ? 1 : entryPrice > 0 ? TRADE_SIZE / entryPrice : 0);
            const direction = String(t.direction || "").toUpperCase();
            const signed = direction === "SHORT" ? -1 : 1;
            totalShares += shares;
            costBasis += entryPrice * shares;
            // Prefer stored P&L from D1 (accurate from replay)
            const tradePnl = Number(t.pnl ?? t.pnl_amount);
            if (Number.isFinite(tradePnl)) {
              pnlOpen += tradePnl;
            } else if (Number.isFinite(livePrice) && entryPrice > 0) {
              pnlOpen += (livePrice - entryPrice) * shares * pointValue * signed;
              hasAllStoredPnl = false;
            } else {
              hasAllStoredPnl = false;
            }
          }
          const entryPrice = totalShares > 0 ? costBasis / totalShares : 0;
          const direction = String(trades[0].direction || "").toUpperCase();
          const signed = direction === "SHORT" ? -1 : 1;
          // Back-compute current price from aggregate P&L for display
          const current = Number.isFinite(livePrice)
            ? livePrice
            : (hasAllStoredPnl && totalShares > 0 && entryPrice > 0
              ? entryPrice + (pnlOpen / (totalShares * pointValue)) * signed
              : null);
          const retOpenPct = entryPrice > 0 && current != null
            ? ((current - entryPrice) / entryPrice) * 100 * signed
            : null;
          return {
            isFutures,
            pointValue,
            entryPrice,
            shares: totalShares,
            current,
            pnlOpen: Number.isFinite(pnlOpen) ? pnlOpen : null,
            retOpenPct,
          };
        };

        // All positions grouped by ticker — unified view (open + closed combined)
        const ledgerAllByTicker = useMemo(() => {
          const groups = new Map();
          for (const t of ledgerFilteredTrades) {
            const key = String(t.ticker || "").toUpperCase();
            if (!groups.has(key)) groups.set(key, { open: [], closed: [] });
            const isClosed = t.status === "WIN" || t.status === "LOSS" || Number(t.trimmed_pct ?? t.trimmedPct ?? 0) >= 0.9999;
            if (isClosed) groups.get(key).closed.push(t);
            else groups.get(key).open.push(t);
          }
          return Array.from(groups.keys()).sort((a, b) => a.localeCompare(b)).map((ticker) => {
            const { open, closed } = groups.get(ticker);
            const allTrades = [...open, ...closed].sort((a, b) => Number(b.entry_ts || 0) - Number(a.entry_ts || 0));
            const live = data && (data[ticker] || data[allTrades[0]?.ticker]);
            const unrealizedPnl = open.reduce((sum, t) => {
              const m = getPositionMetrics(t, live);
              return sum + (Number(m.pnlOpen) || 0);
            }, 0);
            const closedPnl = closed.reduce((sum, t) => sum + Number(t.pnl || 0), 0);
            const totalPnl = unrealizedPnl + closedPnl;
            const wins = closed.filter(t => Number(t.pnl || 0) > 0).length;
            const losses = closed.filter(t => Number(t.pnl || 0) < 0).length;
            const direction = allTrades[0]?.direction || "LONG";
            return { ticker, trades: allTrades, open, closed, unrealizedPnl, closedPnl, totalPnl, wins, losses, direction, hasOpen: open.length > 0 };
          });
        }, [ledgerFilteredTrades, data]);

        // Open positions grouped by ticker (for By Ticker column)
        const ledgerOpenByTicker = useMemo(() => {
          const groups = new Map();
          for (const t of ledgerOpenTrades) {
            const key = String(t.ticker || "").toUpperCase();
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(t);
          }
          return Array.from(groups.keys()).sort((a, b) => a.localeCompare(b)).map((ticker) => {
            const trades = groups.get(ticker) || [];
            const live = data && (data[ticker] || data[trades[0]?.ticker]);
            const unrealizedPnl = trades.reduce((sum, t) => {
              const m = getPositionMetrics(t, live);
              return sum + (Number(m.pnlOpen) || 0);
            }, 0);
            const totalQty = trades.reduce((sum, t) => sum + (Number(t.qty ?? t.total_qty) || 0), 0);
            const direction = trades[0]?.direction || "LONG";
            return { ticker, trades, unrealizedPnl, totalQty, direction, isOpen: true };
          });
        }, [ledgerOpenTrades, data]);

        // Range in ms for account chart (1D, 5D, 10D, 30D, 1Y)
        const accountChartRangeMs = useMemo(() => {
          const day = 24 * 60 * 60 * 1000;
          const map = { "1D": 1 * day, "5D": 5 * day, "10D": 10 * day, "30D": 30 * day, "1Y": 365 * day };
          return map[accountChartRange] ?? 1 * day;
        }, [accountChartRange]);

        // Overall account value over time — ALWAYS uses ALL trades (unfiltered) to stay
        // in lockstep with the Dashboard's Account Value calculation.
        const allOpenTrades = useMemo(
          () => allLedgerItems.filter((t) => {
            const trimmedPct = Number(t.trimmed_pct ?? t.trimmedPct ?? 0);
            return t.status !== "WIN" && t.status !== "LOSS" && !t.exit_ts && trimmedPct < 0.9999;
          }),
          [allLedgerItems],
        );
        const portfolioChartPoints = useMemo(() => {
          const points = [{ ts: 0, value: 0 }];
          const closed = allLedgerItems.filter(
            (t) =>
              t.status === "WIN" ||
              t.status === "LOSS" ||
              Number(t.trimmed_pct ?? t.trimmedPct ?? 0) >= 0.9999,
          );
          const sorted = [...closed].sort(
            (a, b) => (tsToMs(a.exit_ts) ?? 0) - (tsToMs(b.exit_ts) ?? 0),
          );
          let running = 0;
          for (const t of sorted) {
            const exitTs = tsToMs(t.exit_ts);
            if (exitTs == null) continue;
            running += Number(t.pnl) || 0;
            points.push({ ts: exitTs, value: running });
          }
          const openPnl = allOpenTrades.reduce((sum, t) => {
            const m = getPositionMetrics(
              t,
              data && (data[t.ticker] || data[String(t.ticker).toUpperCase()]),
            );
            return sum + (Number(m.pnlOpen) || 0);
          }, 0);
          points.push({
            ts: Date.now(),
            value: running + openPnl,
          });
          return points;
        }, [
          allLedgerItems,
          allOpenTrades,
          data,
        ]);

        // Filter chart points to selected time frame; add start-of-range point for clean line
        const portfolioChartPointsInRange = useMemo(() => {
          const now = Date.now();
          const start = now - accountChartRangeMs;
          const sorted = [...portfolioChartPoints].sort((a, b) => a.ts - b.ts);
          const beforeStart = sorted.filter((p) => p.ts <= start);
          const startValue = beforeStart.length > 0 ? beforeStart[beforeStart.length - 1].value : 0;
          const inRange = sorted.filter((p) => p.ts >= start);
          if (inRange.length === 0) return [{ ts: start, value: startValue }, { ts: now, value: startValue }];
          const firstInRange = inRange[0];
          const withStart = firstInRange.ts > start
            ? [{ ts: start, value: startValue }, ...inRange]
            : inRange;
          return withStart;
        }, [portfolioChartPoints, accountChartRangeMs]);

        // Positions with trade history in asc time order (Robinhood-style)
        // Group open trades by ticker so multiple entries (e.g. AEHR 36 + 35) aggregate qty and P&L
        const positionsWithHistory = useMemo(() => {
          const byTicker = new Map();
          for (const t of ledgerFilteredTrades) {
            const ticker = String(t.ticker || "").toUpperCase();
            if (!ticker) continue;
            const entryTs = tsToMs(t.entry_ts);
            if (entryTs != null) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              byTicker.get(ticker).push({
                ts: entryTs,
                type: "ENTRY",
                trade: t,
                price: Number(t.entry_price),
              });
            }
            const trimTs = tsToMs(t.trim_ts ?? t.updated_at ?? t.exit_ts ?? t.entry_ts);
            if (
              (t.status === "TP_HIT_TRIM" || Number(t.trimmed_pct) > 0) &&
              trimTs != null
            ) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              const trimPrice = Number(t.trim_price ?? t.trimPrice ?? t.tp ?? t.tp_price) || null;
              byTicker.get(ticker).push({
                ts: trimTs,
                type: "TRIM",
                trade: t,
                price: Number.isFinite(trimPrice) ? trimPrice : null,
              });
            }
            const exitTs = tsToMs(t.exit_ts);
            if (
              (t.status === "WIN" || t.status === "LOSS") &&
              exitTs != null
            ) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              byTicker.get(ticker).push({
                ts: exitTs,
                type: "EXIT",
                trade: t,
                price: Number(t.exit_price),
              });
            }
          }
          const openByTicker = new Map();
          for (const t of ledgerOpenTrades) {
            const ticker = String(t.ticker || "").toUpperCase();
            if (!ticker) continue;
            if (!openByTicker.has(ticker)) openByTicker.set(ticker, []);
            openByTicker.get(ticker).push(t);
          }
          const result = [];
          for (const [ticker, trades] of openByTicker) {
            const live = data && (data[ticker] || data[trades[0].ticker]);
            const metrics = getAggregatedPositionMetrics(trades, live);
            const events = (byTicker.get(ticker) || []).sort(
              (a, b) => a.ts - b.ts,
            );
            result.push({
              ticker,
              isOpen: true,
              qty: metrics.shares,
              entryPrice: metrics.entryPrice,
              mktValue:
                Number.isFinite(metrics.current) && Number.isFinite(metrics.shares)
                  ? metrics.current * metrics.shares
                  : null,
              current: metrics.current,
              pnlOpen: metrics.pnlOpen,
              retOpenPct: metrics.retOpenPct,
              trade: trades[0],
              events,
            });
          }
          for (const [ticker, events] of byTicker) {
            if (openByTicker.has(ticker)) continue;
            const sorted = events.sort((a, b) => a.ts - b.ts);
            const lastTrade = sorted.length
              ? sorted[sorted.length - 1].trade
              : null;
            result.push({
              ticker,
              isOpen: false,
              qty: null,
              entryPrice: lastTrade
                ? Number(lastTrade.entry_price ?? lastTrade.entryPrice)
                : null,
              mktValue: null,
              current: null,
              pnlOpen: null,
              trade: lastTrade,
              events: sorted,
            });
          }
          result.sort((a, b) => a.ticker.localeCompare(b.ticker));
          return result;
        }, [ledgerFilteredTrades, ledgerOpenTrades, data]);

        const openPositionCards = useMemo(
          () => positionsWithHistory.filter((p) => p.isOpen),
          [positionsWithHistory],
        );

        // Daily summary state
        const [dailySummary, setDailySummary] = useState(null);
        const [summaryLoading, setSummaryLoading] = useState(false);
        const [showSummary, setShowSummary] = useState(false);

        // Selected ticker for detail view
        const [selectedTicker, setSelectedTicker] = useState(null);

        // Expanded day key for By-day events (ticker, action, time, price)
        const [expandedByDayKey, setExpandedByDayKey] = useState(null);

        // Selected trade for right rail; positionEvents for Trade Tracker history
        const [selectedTrade, setSelectedTrade] = useState(null);
        const [selectedPositionEvents, setSelectedPositionEvents] = useState(null);

        // Trade date range is derived from the main ledgerDateRange slider

        // Get unique versions from trades (for dropdown)
        const availableVersions = useMemo(() => {
          const versionSet = new Set(
            trades.map((t) => t.scriptVersion || "unknown").filter(Boolean),
          );
          return Array.from(versionSet).sort().reverse(); // Most recent first
        }, [trades]);

        // Filter trades by version (client-side), de-dupe only exact duplicates, and sort alphabetically
        const filteredTrades = useMemo(() => {
          let filtered =
            selectedVersion === "all"
              ? trades
              : trades.filter(
                  (t) => (t.scriptVersion || "unknown") === selectedVersion,
                );

          // Remove duplicates: keep the most recent trade for each exact trade key
          // (Ticker + Direction + EntryTime/Id). This prevents accidental collapsing of real historical trades.
          const tradeMap = new Map();
          filtered.forEach((trade) => {
            const entryKey =
              trade.entryTime ||
              trade.entryTs ||
              trade.trigger_ts ||
              trade.id ||
              "";
            const key = `${trade.ticker}_${trade.direction}_${entryKey}`;
            const existing = tradeMap.get(key);
            if (!existing) {
              tradeMap.set(key, trade);
            } else {
              // Keep the most recent one (by entryTime)
              const existingTime = new Date(existing.entryTime || 0).getTime();
              const currentTime = new Date(trade.entryTime || 0).getTime();
              if (currentTime > existingTime) {
                tradeMap.set(key, trade);
              }
            }
          });

          // Convert back to array
          filtered = Array.from(tradeMap.values());

          // Apply ledger date range: include trades that overlap the selected range
          // (entered before range end AND either still open or exited after range start)
          if (ledgerDateRange?.start && ledgerDateRange?.end) {
            const rangeStart = startOfDay(ledgerDateRange.start).getTime();
            const rangeEnd = endOfDay(ledgerDateRange.end).getTime();
            filtered = filtered.filter((t) => {
              const entryMs = new Date(t.entryTime || t.entryTs || t.trigger_ts || 0).getTime();
              const exitMs = t.exitTime || t.exitTs || t.exit_ts
                ? new Date(t.exitTime || t.exitTs || t.exit_ts).getTime()
                : null;
              const isClosed = t.status === "WIN" || t.status === "LOSS" || t.status === "FLAT";
              const enteredBeforeEnd = entryMs <= rangeEnd;
              const activeInRange = !isClosed || (exitMs && exitMs >= rangeStart);
              return enteredBeforeEnd && activeInRange;
            });
          }

          // Sort alphabetically by ticker
          filtered.sort((a, b) => {
            const tickerA = String(a.ticker || "").toUpperCase();
            const tickerB = String(b.ticker || "").toUpperCase();
            return tickerA.localeCompare(tickerB);
          });

          return filtered;
        }, [trades, selectedVersion, ledgerDateRange]);

        // Keep Current Price fresh by overriding open/trimmed trades with latest ticker prices.
        // Trades returned by the Worker can lag between runs; this makes the UI reflect latest ingested prices.
        // GUARD: Only override P&L if live price is reasonably fresh (< 60 min old).
        // Stale KV prices (e.g. from old TradingView captures) cause wildly wrong P&L display.
        const filteredTradesWithLivePrices = useMemo(() => {
          if (!Array.isArray(filteredTrades)) return [];
          return filteredTrades.map((t) => {
            const symRaw = t?.ticker;
            if (!symRaw) return t;
            const sym = String(symRaw).toUpperCase();
            const live = (data && (data[sym] || data[symRaw])) || null;
            const livePrice =
              live && live.price != null ? Number(live.price) : NaN;
            const isOpenLike =
              t.status === "OPEN" || !t.status || t.status === "TP_HIT_TRIM";
            if (!isOpenLike || !Number.isFinite(livePrice)) return t;

            // Staleness check: don't override D1 P&L with stale price data
            const livePriceTs = Number(live.data_source_ts || live.ts || live.ingest_ts || 0);
            const tradeUpdatedAt = Number(t.updated_at || t.entry_ts || 0);
            const priceAgeMs = Date.now() - livePriceTs;
            const isStale = priceAgeMs > 60 * 60 * 1000; // > 1 hour old
            const tradeHasStoredPnl = Number.isFinite(Number(t.pnl));

            // If live price is stale but trade has D1 pnl, keep the stored values
            if (isStale && tradeHasStoredPnl) return t;

            const next = {
              ...t,
              currentPrice: livePrice,
              _uiPriceTs: livePriceTs || null,
            };

            // Recompute P&L using latest price so the UI always reflects the latest move.
            // This does not change status; the Worker remains the source of truth for state transitions.
            const tickerSymbol = String(next.ticker || "").toUpperCase();
            const isFutures =
              FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");
            const pointValue =
              isFutures && FUTURES_SPECS[tickerSymbol]
                ? FUTURES_SPECS[tickerSymbol].pointValue
                : 1;
            const entryPrice = Number(next.entryPrice);
            const tp = Number(next.tp);
            const sl = Number(next.sl);
            const currentPrice = Number(next.currentPrice);
            const trimmedPct = Number(next.trimmedPct) || 0;
            const shares =
              next.shares ||
              (isFutures && FUTURES_SPECS[tickerSymbol]
                ? 1
                : TRADE_SIZE / (entryPrice || 1));

            if (
              Number.isFinite(entryPrice) &&
              Number.isFinite(tp) &&
              Number.isFinite(sl) &&
              Number.isFinite(currentPrice) &&
              Number.isFinite(shares)
            ) {
              let pnl = 0;
              let pnlPct = 0;

              if (next.direction === "LONG") {
                const hitTP = currentPrice >= tp;
                const hitSL = currentPrice <= sl;
                if (hitTP) {
                  const tpDiff = tp - entryPrice;
                  pnl =
                    tpDiff * shares * pointValue * (trimmedPct === 0 ? 0.5 : 1);
                  pnlPct = ((tp - entryPrice) / entryPrice) * 100;
                } else if (hitSL) {
                  const slDiff = sl - entryPrice;
                  pnl = slDiff * shares * pointValue;
                  pnlPct = ((sl - entryPrice) / entryPrice) * 100;
                } else {
                  const priceDiff = currentPrice - entryPrice;
                  pnl = priceDiff * shares * pointValue;
                  pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;
                }
              } else if (next.direction === "SHORT") {
                const hitTP = currentPrice <= tp;
                const hitSL = currentPrice >= sl;
                if (hitTP) {
                  const tpDiff = entryPrice - tp;
                  pnl =
                    tpDiff * shares * pointValue * (trimmedPct === 0 ? 0.5 : 1);
                  pnlPct = ((entryPrice - tp) / entryPrice) * 100;
                } else if (hitSL) {
                  const slDiff = entryPrice - sl;
                  pnl = slDiff * shares * pointValue;
                  pnlPct = ((entryPrice - sl) / entryPrice) * 100;
                } else {
                  const priceDiff = entryPrice - currentPrice;
                  pnl = priceDiff * shares * pointValue;
                  pnlPct = ((entryPrice - currentPrice) / entryPrice) * 100;
                }
              }

              next.pnl = pnl;
              next.pnlPct = pnlPct;
            }

            return next;
          });
        }, [filteredTrades, data]);

        const tradesForDisplay = useMemo(() => {
          if (!Array.isArray(filteredTradesWithLivePrices)) return [];
          if (horizonFilter === "ALL") return filteredTradesWithLivePrices;
          return filteredTradesWithLivePrices.filter((t) => {
            const sym = String(t.ticker || "").toUpperCase();
            const live = data && (data[sym] || data[t.ticker]);
            const key = computeHorizonKey(live || t);
            return key === horizonFilter;
          });
        }, [filteredTradesWithLivePrices, data, horizonFilter]);

        const analytics = useTradeAnalytics(filteredTradesWithLivePrices);

        // Trade simulation is handled by Worker - just refresh trades periodically
        useEffect(() => {
          // Initial fetch on mount
          refetchTrades();

          // Refresh trades every 30 seconds to get latest updates from Worker
          const refreshInterval = setInterval(() => {
            refetchTrades();
          }, 30000);

          return () => clearInterval(refreshInterval);
        }, [refetchTrades]);

        // Fetch daily summary
        const fetchDailySummary = useCallback(async () => {
          setSummaryLoading(true);
          try {
            const res = await fetch(`${API_BASE}/timed/ai/daily-summary`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) {
              setDailySummary(json);
              setShowSummary(true);
            } else {
              throw new Error(json.error || "Failed to fetch summary");
            }
          } catch (err) {
            console.error("Daily summary error:", err);
            alert(`Failed to fetch daily summary: ${err.message}`);
          } finally {
            setSummaryLoading(false);
          }
        }, []);

        const openTrades = tradesForDisplay.filter(
          (t) => t.status === "OPEN" || !t.status || t.status === "TP_HIT_TRIM",
        );
        const closedTrades = tradesForDisplay.filter(
          (t) => t.status === "WIN" || t.status === "LOSS",
        );

        return (
          <div className="tt-root">
            <div className="min-h-screen p-0" style={{ background: "var(--tt-bg-base)" }}>
              {/* ═══ Unified Nav Bar ═══ */}
              <nav className="sticky top-0 z-50 border-b border-white/[0.06]" style={{background:"rgba(10,10,15,0.95)",backdropFilter:"blur(12px)"}}>
                <div className="flex items-center justify-between px-4 py-2.5">
                  <div className="flex items-center gap-3 md:gap-5 min-w-0">
                    <a href="index-react.html" className="flex items-center gap-2 no-underline shrink-0">
                      <div className="w-[28px] h-[28px] md:w-[32px] md:h-[32px] rounded-[8px] flex items-center justify-center" style={{background:"linear-gradient(135deg, #00c853, #00e676, #69f0ae)"}}>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                          <polyline points="22 7 13.5 15.5 8.5 10.5 2 17" />
                          <polyline points="16 7 22 7 22 13" />
                        </svg>
                      </div>
                      <span className="text-[14px] md:text-[15px] font-bold text-white hidden sm:inline" style={{letterSpacing:"-0.03em"}}>Timed Trading</span>
                    </a>
                    <div className="hidden lg:flex items-center gap-0.5">
                      <a href="index-react.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Active Trader</a>
                      <a href="investor-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Investor</a>
                      <a href="simulation-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-white bg-white/[0.07] font-medium">Trades</a>
                      <a href="system-intelligence.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">System Intelligence</a>
                      <a href="screener.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Screener</a>
                      <a href="ticker-management.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Tickers</a>
                      <a href="daily-brief.html" id="nav-daily-brief" className="relative px-3 py-1 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium">
                        Daily Brief
                        <span id="brief-badge" className="hidden absolute -top-0.5 -right-0.5 w-2 h-2 rounded-full bg-[#f59e0b]" style={{animation: "pulse-badge 2s ease-in-out infinite"}} />
                      </a>
                    </div>
                  </div>
                  <div className="flex items-center gap-1.5 md:gap-2 shrink-0">
                    <a href="/faq.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</a>
                    <a href="index-react.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all" title="Restart tour">Tour</a>
                    <a href="/faq.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">FAQ</a>
                    <a href="index-react.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#60a5fa] hover:text-[#93bbfc] hover:bg-[#60a5fa]/[0.06] transition-all font-medium">Ask AI</a>
                    {(window.TimedAuthHelpers?.getStoredSession()?.role === 'admin' || window.TimedAuthHelpers?.getStoredSession()?.tier === 'admin') && (
                      <a href="admin-clients.html" data-admin-only="true" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#a78bfa]/80 hover:text-[#a78bfa] font-medium">Admin</a>
                    )}
                    <span className="hidden sm:inline text-[11px] text-[#4b5563]">Paper · $1k/trade</span>
                    {window.TimedNotificationCenter && <window.TimedNotificationCenter apiBase={API_BASE} />}
                    {window.TimedUserBadge && <window.TimedUserBadge user={window.TimedAuthHelpers?.getStoredSession()} compact />}
                    <button onClick={() => setMobileMenuOpen(v => !v)} className="lg:hidden p-1.5 rounded-md text-[#6b7280] hover:text-white hover:bg-white/[0.06] transition-all" aria-label="Toggle menu">
                      {mobileMenuOpen ? (
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                      ) : (
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                      )}
                    </button>
                  </div>
                </div>
                {mobileMenuOpen && (
                  <div className="lg:hidden border-t border-white/[0.06] px-4 py-2 flex flex-col gap-0.5" style={{background:"rgba(10,10,15,0.98)"}}>
                    <a href="index-react.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Active Trader</a>
                    <a href="investor-dashboard.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Investor</a>
                    <a href="simulation-dashboard.html" className="px-3 py-2 rounded-md text-[13px] text-white bg-white/[0.07] font-medium" onClick={() => setMobileMenuOpen(false)}>Trades</a>
                    <a href="system-intelligence.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>System Intelligence</a>
                    <a href="screener.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Screener</a>
                    <a href="ticker-management.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Tickers</a>
                    <a href="daily-brief.html" className="px-3 py-2 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium" onClick={() => setMobileMenuOpen(false)}>Daily Brief</a>
                    <div className="border-t border-white/[0.06] mt-1 pt-1 flex items-center gap-2">
                      <a href="/faq.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</a>
                      <a href="index-react.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all" title="Restart tour">Tour</a>
                      <a href="/faq.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">FAQ</a>
                      <a href="index-react.html" className="px-3 py-2 rounded-md text-[12px] text-[#60a5fa] hover:text-white hover:bg-white/[0.04] transition-all">Ask AI</a>
                      <a href="mailto:support@timed-trading.com" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Contact</a>
                    </div>
                  </div>
                )}
              </nav>

              <div className="w-full mx-auto px-4 pt-2">
                {/* ═══ Shared Header: controls + status ═══ */}
                <header className="flex items-center justify-between gap-4 flex-wrap mb-6">
                  <div className="flex items-center gap-4">
                    <h1 className="text-lg font-semibold tracking-tight text-[var(--tt-text)]">
                      Portfolio Overview
                    </h1>
                  </div>
                  <div className="flex items-center gap-4 flex-wrap">
                    <div className="flex flex-col gap-1">
                      <span className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Date Range</span>
                      <DateRangeSlider
                        range={ledgerDateRange}
                        onRangeChange={(r) => { setLedgerDateRange(r); setHorizonFilter("ALL"); }}
                        sliderDays={SLIDER_RANGE_DAYS}
                      />
                    </div>
                    {(loading || tradesLoading) && (
                      <div className="loading-spinner" />
                    )}
                    {lastUpdate && (
                      <span className="text-xs text-[var(--tt-text-faint)]">
                        Updated {lastUpdate.toLocaleTimeString()}
                        {(refreshing || tradesRefreshing) && " · refreshing…"}
                      </span>
                    )}
                    <button
                      onClick={() => { refetch(); refetchTrades(); }}
                      className="tt-pill tt-pill-active text-[13px]"
                    >
                      Refresh
                    </button>
                    <button
                      type="button"
                      onClick={async () => {
                        try {
                          const res = await fetch(`${API_BASE}/timed/trades?source=positions`, { cache: "no-store" });
                          const json = await res.json();
                          if (!res.ok || !json.ok) throw new Error(json.error || res.statusText);
                          const blob = new Blob([JSON.stringify({ exported: new Date().toISOString(), trades: json.trades || [], count: json.count }, null, 2)], { type: "application/json" });
                          const a = document.createElement("a");
                          a.href = URL.createObjectURL(blob);
                          a.download = `timed-positions-${new Date().toISOString().slice(0, 10)}.json`;
                          a.click();
                          URL.revokeObjectURL(a.href);
                        } catch (e) {
                          console.error("Export failed:", e);
                        }
                      }}
                      className="tt-pill tt-pill-inactive text-[13px]"
                      title="Export positions (reconciliation)"
                    >
                      Export
                    </button>
                  </div>
                </header>

                {/* ═══ Dual-Column Layout: Active Trader | Investor ═══ */}
                <div className={`${selectedTicker || selectedTrade ? "mr-[470px]" : ""}`}>

                  {/* Mobile: Tab toggle (hidden on lg+) */}
                  <div className="flex items-center gap-1 mb-4 border-b border-[var(--tt-border)] lg:hidden">
                    <button
                      onClick={() => setPortfolioTab("trader")}
                      className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${
                        portfolioTab === "trader"
                          ? "border-[var(--tt-accent)] text-[var(--tt-accent)]"
                          : "border-transparent text-[var(--tt-text-muted)] hover:text-[var(--tt-text)]"
                      }`}
                    >
                      Active Trader
                    </button>
                    <button
                      onClick={() => setPortfolioTab("investor")}
                      className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${
                        portfolioTab === "investor"
                          ? "border-[#8b5cf6] text-[#8b5cf6]"
                          : "border-transparent text-[var(--tt-text-muted)] hover:text-[var(--tt-text)]"
                      }`}
                    >
                      Investor
                    </button>
                  </div>

                  {/* 2-column grid on desktop, single column on mobile controlled by tabs */}
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    {/* Left column: Active Trader (always visible on lg+, tab-controlled on mobile) */}
                    <div className={`${portfolioTab !== "trader" ? "hidden lg:block" : ""}`}>
                      <PortfolioColumn
                        mode="trader"
                        summary={acctSummary}
                        curveData={equityCurveData}
                        trades={ledgerFilteredTrades}
                        positions={null}
                        tickerData={data}
                        loading={(ledgerTrades ?? {}).loading}
                        onSelectTrade={(t) => {
                          setSelectedTrade(t);
                          setSelectedTicker(t?.ticker || null);
                          setSelectedPositionEvents(t?.history || []);
                        }}
                      />
                    </div>
                    {/* Right column: Investor (always visible on lg+, tab-controlled on mobile) */}
                    <div className={`${portfolioTab !== "investor" ? "hidden lg:block" : ""}`}>
                      <PortfolioColumn
                        mode="investor"
                        summary={investorSummary}
                        curveData={equityCurveData}
                        trades={investorTrades}
                        positions={investorPositions}
                        tickerData={data}
                        loading={investorTradesLoading}
                        onSelectTrade={(t) => {
                          setSelectedTrade(t);
                          setSelectedTicker(t?.ticker || null);
                          setSelectedPositionEvents(t?.history || []);
                        }}
                      />
                    </div>
                  </div>
                </div>

                  {/* Right rail — same component and look as Dashboard */}
                  {(selectedTicker || selectedTrade) && (
                    <div className="fixed right-0 top-[49px] w-[450px] bottom-0 z-40 slide-in-right shadow-2xl overflow-y-auto bg-[#0b0e11] border-l border-white/[0.04]">
                      <TickerDetailsLoader
                        tickerSymbol={selectedTrade ? selectedTrade.ticker : selectedTicker}
                        trade={selectedTrade}
                        positionEvents={selectedPositionEvents}
                        onClose={() => {
                          setSelectedTrade(null);
                          setSelectedTicker(null);
                          setSelectedPositionEvents(null);
                        }}
                        allLoadedData={data}
                        sectors={sectors}
                        rankedTickers={rankedTickers}
                        rankedTickerPositions={rankedTickerPositions}
                      />
                    </div>
                  )}
              </div>
            </div>

                {/* Daily Summary Modal */}
                {showSummary && dailySummary && (
                  <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-6 max-w-3xl w-full max-h-[90vh] overflow-y-auto">
                      <div className="flex items-center justify-between mb-4">
                        <h2 className="text-2xl font-bold">
                          📊 Daily Summary -{" "}
                          {new Date(
                            dailySummary.stats.date,
                          ).toLocaleDateString()}
                        </h2>
                        <button
                          onClick={() => setShowSummary(false)}
                          className="text-[var(--tt-text-muted)] hover:text-white text-xl"
                        >
                          ✕
                        </button>
                      </div>

                      {/* Stats Grid */}
                      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            New Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.newTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Closed Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.closedTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Trimmed Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.trimmedTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">Win Rate</div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.winRate >= 50 ? "text-green-400" : "text-red-400"}`}
                          >
                            {dailySummary.stats.winRate}%
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Closed P&L
                          </div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.closedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                          >
                            ${dailySummary.stats.closedPnl}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">Open P&L</div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.openPnl >= 0 ? "text-green-400" : "text-yellow-400"}`}
                          >
                            ${dailySummary.stats.openPnl}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Total P&L
                          </div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                          >
                            ${dailySummary.stats.totalPnl}
                          </div>
                        </div>
                      </div>

                      {/* AI Summary */}
                      <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-6 mb-4">
                        <h3 className="text-xl font-bold mb-4 flex items-center gap-2">
                          <span className="text-2xl">🤖</span>
                          <span>AI Analysis & Recommendations</span>
                        </h3>
                        <div className="text-sm text-[var(--tt-text)] leading-relaxed">
                          {(() => {
                            // Enhanced markdown renderer
                            const renderMarkdown = (text) => {
                              const parts = [];
                              let currentIndex = 0;

                              // Split by double newlines for paragraphs
                              const paragraphs = text.split(/\n\n+/);

                              return paragraphs.map((paragraph, pIdx) => {
                                if (!paragraph.trim()) return null;

                                // Headers (## or ###)
                                const headerMatch = paragraph
                                  .trim()
                                  .match(/^(#{2,3})\s+(.+)$/m);
                                if (headerMatch) {
                                  const level = headerMatch[1].length;
                                  const content = headerMatch[2];
                                  return React.createElement(
                                    level === 2 ? "h2" : "h3",
                                    {
                                      key: pIdx,
                                      className:
                                        level === 2
                                          ? "text-lg font-bold mt-6 mb-3 text-white border-b border-[var(--tt-border)] pb-2 first:mt-0"
                                          : "text-base font-semibold mt-4 mb-2 text-white",
                                    },
                                    content,
                                  );
                                }

                                // Lists (bulleted or numbered)
                                if (
                                  paragraph.trim().match(/^[-*•]\s+/m) ||
                                  paragraph.trim().match(/^\d+\.\s+/m)
                                ) {
                                  const listItems = paragraph
                                    .split("\n")
                                    .filter((l) => l.trim());
                                  const isOrdered = listItems[0]
                                    ?.trim()
                                    .match(/^\d+\./);

                                  return React.createElement(
                                    isOrdered ? "ol" : "ul",
                                    {
                                      key: pIdx,
                                      className:
                                        "list-none space-y-2 my-3 ml-4",
                                    },
                                    listItems.map((item, iIdx) => {
                                      const cleanItem = item
                                        .replace(/^[-*•]\s+/, "")
                                        .replace(/^\d+\.\s+/, "");
                                      return React.createElement(
                                        "li",
                                        {
                                          key: iIdx,
                                          className: "flex items-start gap-2",
                                        },
                                        [
                                          React.createElement(
                                            "span",
                                            {
                                              key: "bullet",
                                              className:
                                                "text-blue-400 mt-1.5 flex-shrink-0",
                                            },
                                            isOrdered ? `${iIdx + 1}.` : "•",
                                          ),
                                          React.createElement("span", {
                                            key: "content",
                                            className: "flex-1",
                                            dangerouslySetInnerHTML: {
                                              __html:
                                                formatInlineMarkdown(cleanItem),
                                            },
                                          }),
                                        ],
                                      );
                                    }),
                                  );
                                }

                                // Regular paragraph
                                return React.createElement(
                                  "div",
                                  {
                                    key: pIdx,
                                    className: "mb-4 last:mb-0",
                                  },
                                  paragraph.split("\n").map((line, lIdx) => {
                                    if (!line.trim()) {
                                      return React.createElement("br", {
                                        key: lIdx,
                                      });
                                    }

                                    // Check for special formatting patterns
                                    const isBoldLine =
                                      line.match(/^\*\*(.+)\*\*$/);
                                    if (isBoldLine) {
                                      return React.createElement(
                                        "p",
                                        {
                                          key: lIdx,
                                          className:
                                            "font-semibold text-white mb-2",
                                        },
                                        isBoldLine[1],
                                      );
                                    }

                                    // Check for emoji-prefixed lines (opportunities, warnings, etc.)
                                    const emojiMatch = line.match(
                                      /^([🎯⚠️📊💡🚀]+)\s+(.+)$/,
                                    );
                                    if (emojiMatch) {
                                      const emoji = emojiMatch[1];
                                      const content = emojiMatch[2];
                                      const bgColor = emoji.includes("🎯")
                                        ? "bg-blue-500/10 border-blue-500/30"
                                        : emoji.includes("⚠️")
                                          ? "bg-yellow-500/10 border-yellow-500/30"
                                          : emoji.includes("📊")
                                            ? "bg-purple-500/10 border-purple-500/30"
                                            : emoji.includes("💡")
                                              ? "bg-green-500/10 border-green-500/30"
                                              : "bg-[var(--tt-bg-elevated)]/50 border-[var(--tt-border)]";

                                      return React.createElement(
                                        "div",
                                        {
                                          key: lIdx,
                                          className: `flex items-start gap-3 p-3 rounded-lg border ${bgColor} mb-2`,
                                        },
                                        [
                                          React.createElement(
                                            "span",
                                            {
                                              key: "emoji",
                                              className:
                                                "text-xl flex-shrink-0",
                                            },
                                            emoji,
                                          ),
                                          React.createElement("div", {
                                            key: "content",
                                            className: "flex-1",
                                            dangerouslySetInnerHTML: {
                                              __html:
                                                formatInlineMarkdown(content),
                                            },
                                          }),
                                        ],
                                      );
                                    }

                                    return React.createElement("p", {
                                      key: lIdx,
                                      className: "mb-2 leading-relaxed",
                                      dangerouslySetInnerHTML: {
                                        __html:
                                          formatInlineMarkdown(line) ||
                                          "&nbsp;",
                                      },
                                    });
                                  }),
                                );
                              });
                            };

                            // Format inline markdown (bold, code, links, etc.)
                            const formatInlineMarkdown = (text) => {
                              // Sanitize: strip dangerous HTML tags and event handlers
                              let formatted = text
                                .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")
                                .replace(/<iframe\b[^>]*>.*?<\/iframe>/gi, "")
                                .replace(/<object\b[^>]*>.*?<\/object>/gi, "")
                                .replace(/<embed\b[^>]*>/gi, "")
                                .replace(/\bon\w+\s*=\s*["'][^"']*["']/gi, "")
                                .replace(/\bon\w+\s*=\s*[^\s>]*/gi, "")
                                .replace(/javascript\s*:/gi, "")
                                .replace(/data\s*:\s*text\/html/gi, "");

                              // Bold (**text**)
                              formatted = formatted.replace(
                                /\*\*(.+?)\*\*/g,
                                '<strong class="font-semibold text-white">$1</strong>',
                              );

                              // Inline code (`code`)
                              formatted = formatted.replace(
                                /`([^`]+)`/g,
                                '<code class="bg-[var(--tt-bg-elevated)] px-1.5 py-0.5 rounded text-xs font-mono text-blue-300">$1</code>',
                              );

                              // Links [text](url) - not common in AI responses but good to have
                              formatted = formatted.replace(
                                /\[([^\]]+)\]\(([^)]+)\)/g,
                                '<a href="$2" class="text-blue-400 hover:text-blue-300 underline" target="_blank" rel="noopener noreferrer">$1</a>',
                              );

                              // Ticker symbols (uppercase 2-5 letter codes)
                              formatted = formatted.replace(
                                /\b([A-Z]{2,5})\b/g,
                                '<span class="font-semibold text-blue-300">$1</span>',
                              );

                              // Numbers with $ (prices)
                              formatted = formatted.replace(
                                /\$(\d+\.?\d*)/g,
                                '<span class="text-green-400 font-medium">$$1</span>',
                              );

                              // Percentages
                              formatted = formatted.replace(
                                /(\d+\.?\d*)%/g,
                                '<span class="text-yellow-400 font-medium">$1%</span>',
                              );

                              // RR ratios (X:1 or 1:X)
                              formatted = formatted.replace(
                                /(\d+\.?\d*):1/g,
                                '<span class="text-purple-400 font-medium">$1:1</span>',
                              );

                              // Table separators (|)
                              formatted = formatted.replace(
                                /\|/g,
                                '<span class="text-[var(--tt-text-faint)] mx-1">|</span>',
                              );

                              return formatted;
                            };

                            return renderMarkdown(dailySummary.summary);
                          })()}
                        </div>
                      </div>

                      {/* Performance Breakdown */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                          <h4 className="text-sm font-semibold mb-2">
                            Performance by Rank
                          </h4>
                          <div className="space-y-1 text-xs">
                            {Object.entries(
                              dailySummary.stats.rankAnalysis || {},
                            ).map(([range, stats]) => (
                              <div key={range} className="flex justify-between">
                                <span className="text-[var(--tt-text-muted)]">{range}:</span>
                                <span
                                  className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                                >
                                  {stats.wins}W/{stats.losses}L ($
                                  {stats.totalPnl.toFixed(2)})
                                </span>
                              </div>
                            ))}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                          <h4 className="text-sm font-semibold mb-2">
                            Performance by RR
                          </h4>
                          <div className="space-y-1 text-xs">
                            {Object.entries(
                              dailySummary.stats.rrAnalysis || {},
                            ).map(([range, stats]) => (
                              <div key={range} className="flex justify-between">
                                <span className="text-[var(--tt-text-muted)]">{range}:</span>
                                <span
                                  className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                                >
                                  {stats.wins}W/{stats.losses}L ($
                                  {stats.totalPnl.toFixed(2)})
                                </span>
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
          </div>
        );
      }

      // Error boundary so render errors show in UI instead of blank screen
      class TrackerErrorBoundary extends React.Component {
        state = { error: null };
        static getDerivedStateFromError(err) {
          return { error: err };
        }
        componentDidCatch(err, info) {
          console.error("Tracker render error:", err, info);
        }
        render() {
          if (this.state.error) {
            return (
              <div className="p-10 text-center font-sans" style={{ color: "var(--tt-text)" }}>
                <h2 className="text-[var(--tt-negative)]">Trade Tracker failed to load</h2>
                <p style={{ marginTop: 16 }}>{this.state.error.message}</p>
                <pre style={{ textAlign: "left", marginTop: 16, padding: 16, background: "var(--tt-bg-surface)", overflow: "auto", fontSize: 12 }}>
                  {this.state.error.stack}
                </pre>
              </div>
            );
          }
          return this.props.children;
        }
      }

      try {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          throw new Error("React or ReactDOM not loaded");
        }
        const rootElement = document.getElementById("root");
        if (!rootElement) {
          throw new Error("Root element not found");
        }
        const AuthGate = window.TimedAuthGate;
        const root = ReactDOM.createRoot ? ReactDOM.createRoot(rootElement) : null;
        const app = (
          <AuthGate apiBase={API_BASE} requiredTier="pro">
            {(user) => (
              <TrackerErrorBoundary>
                <App user={user} />
              </TrackerErrorBoundary>
            )}
          </AuthGate>
        );
        if (root) {
          root.render(app);
        } else {
          ReactDOM.render(app, rootElement);
        }
      } catch (error) {
        console.error("Error rendering app:", error);
        const root = document.getElementById("root");
        if (root) {
          root.innerHTML = `
          <div className="p-10 text-center" style={{ color: "var(--tt-text)" }}>
            <h2 className="text-[var(--tt-negative)]">Error Loading Trade Tracker</h2>
            <p>${error.message}</p>
            <p style="margin-top: 20px; color: var(--tt-text-muted);">Check the browser console (F12) for details.</p>
          </div>`;
        }
      }
    </script>
    <script>
      (function() {
        fetch("/timed/daily-brief/badge", { cache: "no-store" })
          .then(r => r.json())
          .then(d => {
            if (d?.badge?.ts) {
              const seen = Number(localStorage.getItem("tt_brief_seen") || 0);
              if (d.badge.ts > seen) {
                const el = document.getElementById("brief-badge");
                if (el) el.classList.remove("hidden");
              }
            }
          })
          .catch(() => {});
      })();
    </script>
    <footer id="legal-footer" style="position:fixed;bottom:0;left:0;right:0;z-index:9999;background:rgba(10,10,15,0.92);backdrop-filter:blur(6px);border-top:1px solid rgba(255,255,255,0.06);padding:6px 16px;text-align:center;font-size:10px;color:#6b7280;line-height:1.4;">
      For informational and educational purposes only. Not investment advice. Past performance does not guarantee future results. All trading involves risk of loss. <a href="/terms.html" style="color:#6b7280;text-decoration:underline;">Full Terms</a>
    </footer>
  </body>
</html>
