<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <title>Trade Autopsy — Timed Trading</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300c853'/%3E%3Cstop offset='50%25' stop-color='%2300e676'/%3E%3Cstop offset='100%25' stop-color='%2369f0ae'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='24' height='24' rx='5.5' fill='url(%23g)'/%3E%3Cpolyline points='22 7 13.5 15.5 8.5 10.5 2 17' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpolyline points='16 7 22 7 22 13' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="auth-gate.js?v=20260219a"></script>
    <style>
      :root {
        --tt-bg-base: #0b0e11;
        --tt-bg-surface: rgba(255,255,255,0.02);
        --tt-bg-elevated: rgba(255,255,255,0.035);
        --tt-bg-hover: rgba(255,255,255,0.04);
        --tt-border: rgba(255,255,255,0.04);
        --tt-border-strong: rgba(255,255,255,0.08);
        --tt-text: #e5e7eb;
        --tt-text-muted: #6b7280;
        --tt-text-faint: #4b5563;
        --tt-accent: #14b8a6;
        --tt-negative: #e11d48;
        --tt-amber: #f59e0b;
        --tt-radius: 12px;
        --tt-radius-sm: 8px;
        --tt-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }
      body { background: var(--tt-bg-base); color: var(--tt-text); font-family: var(--tt-font); -webkit-font-smoothing: antialiased; margin: 0; }
      .tt-card { background: var(--tt-bg-surface); border: 1px solid var(--tt-border); border-radius: var(--tt-radius); }
      .loading-spinner { width: 28px; height: 28px; position: relative; display: inline-block; }
      .loading-spinner::before { content: ""; position: absolute; inset: 0; border-radius: 6px; background: linear-gradient(135deg, rgba(0,200,83,0.15), rgba(0,200,83,0.04)); animation: tt-loader-pulse 1.6s ease-in-out infinite; }
      .loading-spinner::after { content: ""; position: absolute; left: 3px; right: 3px; top: 50%; height: 2px; background: linear-gradient(90deg, transparent, #00c853, #00e676, #69f0ae, transparent); background-size: 200% 100%; border-radius: 1px; animation: tt-loader-sweep 1.2s ease-in-out infinite; }
      @keyframes tt-loader-pulse { 0%, 100% { opacity: 0.4; transform: scale(0.92); } 50% { opacity: 1; transform: scale(1); } }
      @keyframes tt-loader-sweep { 0% { background-position: -100% 0; opacity: 0.5; } 50% { opacity: 1; } 100% { background-position: 200% 0; opacity: 0.5; } }
      body:not([data-user-role="admin"]) a[data-admin-only] { display: none !important; }
      ::-webkit-scrollbar { width: 6px; height: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
      .trade-row:hover { background: rgba(255,255,255,0.03); cursor: pointer; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef } = React;

      const API_BASE = "";

      const CLASSIFICATION_OPTIONS = [
        { value: "", label: "— Select classification —" },
        { value: "bad_trade", label: "Bad Trade" },
        { value: "valid_loss", label: "Valid Trade - Loss" },
        { value: "valid_win", label: "Valid Trade - Win" },
        { value: "improvement_opportunity", label: "Improvement Opportunity" },
        { value: "data_error", label: "Data Error" },
        { value: "edge_case", label: "Edge Case" },
        { value: "execution_issue", label: "Execution Issue" },
        { value: "good_trade", label: "Good Trade (confirmation)" },
      ];

      const fetchOpts = { cache: "no-store", credentials: "include" };

      const TF_ORDER = ["10m", "30m", "1H", "4H", "D"];
      const SIGNAL_LABELS = {
        ema_cross: "EMA cross",
        supertrend: "SuperTrend",
        ema_structure: "EMA structure",
        ema_depth: "EMA depth",
        rsi: "RSI",
        ema5_48: "EMA 5/48",
        s1_slope: "Slope",
      };
      function formatPath(path) {
        if (!path || typeof path !== "string") return null;
        return path.replace(/_/g, " ").replace(/\b\w/g, c => c.toUpperCase());
      }
      function parseSnapshot(snap) {
        if (!snap) return null;
        try {
          const parsed = typeof snap === "string" ? JSON.parse(snap) : snap;
          if (!parsed?.tf || typeof parsed.tf !== "object") return null;
          return TF_ORDER.filter(tf => parsed.tf[tf]).map(tf => ({
            tf,
            signals: parsed.tf[tf]?.signals || {},
          }));
        } catch { return null; }
      }
      function parseTfStack(tfStackJson) {
        if (!tfStackJson) return null;
        try {
          const parsed = typeof tfStackJson === "string" ? JSON.parse(tfStackJson) : tfStackJson;
          if (!Array.isArray(parsed)) return null;
          return parsed.filter(e => e?.tf);
        } catch { return null; }
      }
      function signalValueLabel(key, value) {
        if (value == null || !Number.isFinite(value)) return null;
        if (key === "ema_cross" || key === "supertrend") return value === 1 ? "Bullish" : "Bearish";
        if (key === "rsi") return String(value);
        return String(value);
      }
      function signalValueColor(key, value) {
        if (key === "ema_cross" || key === "supertrend") return value === 1 ? "text-[#22c55e]" : "text-[#ef4444]";
        if (key === "rsi") {
          if (value >= 70) return "text-[#ef4444]";
          if (value <= 30) return "text-[#22c55e]";
          return "text-[#d1d5db]";
        }
        return "text-[#d1d5db]";
      }

      function formatDate(ms) {
        if (!Number.isFinite(ms)) return "—";
        const d = new Date(ms);
        return d.toLocaleString("en-US", { timeZone: "America/New_York", month: "short", day: "numeric", hour: "numeric", minute: "2-digit", hour12: true });
      }

      function fmtUsd(n) {
        if (!Number.isFinite(n)) return "—";
        return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(n);
      }

      // ── Indicator helpers (computed from OHLC) ───────────────────────────────
      function computeEMA(data, period) {
        const k = 2 / (period + 1);
        const out = [];
        let ema = null;
        for (let i = 0; i < data.length; i++) {
          const c = data[i].close;
          if (ema == null) {
            let sum = 0;
            for (let j = 0; j < Math.min(period, i + 1); j++) sum += data[j].close;
            ema = sum / Math.min(period, i + 1);
          } else {
            ema = c * k + ema * (1 - k);
          }
          out.push({ time: data[i].time, value: ema });
        }
        return out;
      }
      function computeRSI(data, period = 14) {
        const out = [];
        for (let i = 0; i < data.length; i++) {
          if (i < period) {
            out.push({ time: data[i].time, value: 50 });
            continue;
          }
          let gains = 0, losses = 0;
          for (let j = i - period + 1; j <= i; j++) {
            const chg = data[j].close - (j > 0 ? data[j - 1].close : data[j].close);
            if (chg > 0) gains += chg; else losses -= chg;
          }
          const avgGain = gains / period, avgLoss = losses / period;
          const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
          const rsi = 100 - (100 / (1 + rs));
          out.push({ time: data[i].time, value: Math.max(0, Math.min(100, rsi)) });
        }
        return out;
      }

      function computeSuperTrend(data, period = 10, multiplier = 3) {
        const out = [];
        const k = 2 / (period + 1);
        let atr = null;
        let prevClose = data[0]?.close ?? 0;
        let prevUpper = null, prevLower = null, st = null;
        for (let i = 0; i < data.length; i++) {
          const h = data[i].high, l = data[i].low, c = data[i].close;
          const tr = Math.max(h - l, Math.abs(h - prevClose), Math.abs(l - prevClose));
          prevClose = c;
          if (i < period) {
            atr = atr == null ? tr : tr * k + atr * (1 - k);
            out.push({ time: data[i].time, value: (h + l) / 2 });
            continue;
          }
          atr = tr * k + atr * (1 - k);
          const hl2 = (h + l) / 2;
          const basicUpper = hl2 + multiplier * atr;
          const basicLower = hl2 - multiplier * atr;
          const finalUpper = (prevUpper == null || basicUpper < prevUpper || data[i - 1].close > prevUpper) ? basicUpper : prevUpper;
          const finalLower = (prevLower == null || basicLower > prevLower || data[i - 1].close < prevLower) ? basicLower : prevLower;
          const prevSt = st;
          st = (st == null) ? finalLower : (st === prevUpper ? (c > prevUpper ? finalLower : finalUpper) : (c < prevLower ? finalUpper : finalLower));
          prevUpper = finalUpper;
          prevLower = finalLower;
          out.push({ time: data[i].time, value: st });
        }
        return out;
      }

      // SuperTrend as two separate line segments (upper band / lower band) for a clean break at flips
      function computeSuperTrendSegments(data, period = 10, multiplier = 3) {
        const upper = [];
        const lower = [];
        const k = 2 / (period + 1);
        let atr = null;
        let prevClose = data[0]?.close ?? 0;
        let prevUpper = null, prevLower = null, st = null;
        let trend = 0; // 1 = uptrend (st = lower), -1 = downtrend (st = upper)
        for (let i = 0; i < data.length; i++) {
          const h = data[i].high, l = data[i].low, c = data[i].close;
          const tr = Math.max(h - l, Math.abs(h - prevClose), Math.abs(l - prevClose));
          prevClose = c;
          if (i < period) {
            atr = atr == null ? tr : tr * k + atr * (1 - k);
            const hl2 = (h + l) / 2;
            lower.push({ time: data[i].time, value: hl2 });
            continue;
          }
          atr = tr * k + atr * (1 - k);
          const hl2 = (h + l) / 2;
          const basicUpper = hl2 + multiplier * atr;
          const basicLower = hl2 - multiplier * atr;
          const finalUpper = (prevUpper == null || basicUpper < prevUpper || data[i - 1].close > prevUpper) ? basicUpper : prevUpper;
          const finalLower = (prevLower == null || basicLower > prevLower || data[i - 1].close < prevLower) ? basicLower : prevLower;
          const prevSt = st;
          if (st == null) {
            st = finalLower;
            trend = 1;
          } else if (st === prevUpper) {
            if (c > prevUpper) { st = finalLower; trend = 1; } else { st = finalUpper; trend = -1; }
          } else {
            if (c < prevLower) { st = finalUpper; trend = -1; } else { st = finalLower; trend = 1; }
          }
          prevUpper = finalUpper;
          prevLower = finalLower;
          if (trend === 1) lower.push({ time: data[i].time, value: st });
          else upper.push({ time: data[i].time, value: st });
        }
        return { upper, lower };
      }

      // Find bar that was current at timestamp (bar at or before this moment)
      // Candles: Unix seconds (intraday) or "YYYY-MM-DD" string (daily)
      function findBarTime(mapped, tsMs) {
        if (!mapped?.length || !Number.isFinite(tsMs)) return null;
        const tsSec = tsMs > 1e12 ? Math.floor(tsMs / 1000) : tsMs;
        const isDaily = typeof mapped[0].time === "string";
        if (isDaily) {
          const dayStr = new Date(tsSec * 1000).toLocaleDateString("en-CA", { timeZone: "America/New_York" });
          let best = null;
          for (const b of mapped) {
            if (String(b.time) <= dayStr && (best === null || String(b.time) > String(best.time))) best = b;
          }
          if (best) return best.time;
          if (String(mapped[0].time) > dayStr) return mapped[0].time;
          return null;
        }
        let best = null;
        for (const b of mapped) {
          if (b.time <= tsSec && (best === null || b.time > best.time)) best = b;
        }
        if (best) return best.time;
        if (mapped[0].time > tsSec) return mapped[0].time;
        return null;
      }

      // ── Interactive Chart (TradingView Lightweight Charts) ───────────────────
      const INDICATOR_KEYS = ["ema9", "ema21", "ema48", "ema200", "superTrend"];
      function AutopsyChart({ ticker, entryPrice, exitPrice, entryTs, exitTs, trimTs, height = 360 }) {
        const containerRef = useRef(null);
        const chartRef = useRef(null);
        const seriesRef = useRef(null);
        const priceLinesRef = useRef([]);
        const emaSeriesRef = useRef([]);
        const indicatorDataRef = useRef(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [tf, setTf] = useState("10");
        const [showIndicators, setShowIndicators] = useState({ ema9: false, ema21: false, ema48: false, ema200: false, superTrend: false });

        const mapCandles = useCallback((candles, timeframe) => {
          const mapped = candles.map(c => {
            const rawTs = Number(c.ts);
            const ts = rawTs > 1e12 ? Math.floor(rawTs / 1000) : rawTs;
            return {
              time: ts,
              open: Number(c.o),
              high: Number(c.h),
              low: Number(c.l),
              close: Number(c.c),
            };
          }).filter(c => c.open > 0 && c.high > 0).sort((a, b) => a.time - b.time);
          const seen = new Set();
          const deduped = mapped.filter(x => {
            if (seen.has(x.time)) return false;
            seen.add(x.time);
            return true;
          });

          if (timeframe === "D") {
            const dayKey = (ts) => new Date(ts * 1000).toLocaleDateString("en-CA", { timeZone: "America/New_York" });
            const byDay = new Map();
            for (const b of deduped) {
              const key = dayKey(b.time);
              const existing = byDay.get(key);
              if (!existing || b.time >= existing.time) byDay.set(key, { ...b, time: key });
            }
            return Array.from(byDay.entries()).sort((a, b) => a[0].localeCompare(b[0])).map(([, b]) => b);
          }
          return deduped;
        }, []);

        useEffect(() => {
          if (!containerRef.current || !ticker || typeof LightweightCharts === "undefined") {
            setLoading(false);
            setError("Charts unavailable");
            return;
          }

          // Full range: 3 days before entry through 3 days after exit
          const entryMs = Number.isFinite(Number(entryTs)) && entryTs
            ? (Number(entryTs) < 1e12 ? Number(entryTs) * 1000 : Number(entryTs))
            : null;
          const exitMs = Number.isFinite(Number(exitTs)) && exitTs
            ? (Number(exitTs) < 1e12 ? Number(exitTs) * 1000 : Number(exitTs))
            : null;
          const threeDaysMs = 3 * 24 * 60 * 60 * 1000;
          const asOfMs = exitMs
            ? exitMs + threeDaysMs
            : (entryMs || Date.now());
          const limit = 3000; // Max supported by API; covers ~77 trading days of 10m bars
          const container = containerRef.current;
          const initialWidth = Math.max(container.clientWidth || 400, 200);

          const chart = LightweightCharts.createChart(container, {
            width: initialWidth,
            height: height,
            layout: {
              background: { type: "solid", color: "#0b0e11" },
              textColor: "#6b7280",
              fontSize: 10,
            },
            grid: {
              vertLines: { color: "rgba(38,50,95,0.35)" },
              horzLines: { color: "rgba(38,50,95,0.35)" },
            },
            crosshair: {
              mode: LightweightCharts.CrosshairMode.Normal,
              vertLine: { color: "rgba(255,255,255,0.15)", width: 1, style: 2, labelBackgroundColor: "#1e293b" },
              horzLine: { color: "rgba(255,255,255,0.15)", width: 1, style: 2, labelBackgroundColor: "#1e293b" },
            },
            rightPriceScale: {
              borderColor: "rgba(38,50,95,0.5)",
              scaleMargins: { top: 0.08, bottom: 0.08 },
              autoScale: true,
            },
            timeScale: {
              borderColor: "rgba(38,50,95,0.5)",
              timeVisible: true,
              secondsVisible: false,
              rightOffset: 3,
              tickMarkFormatter: (time) => {
                try {
                  if (typeof time === "string") {
                    const [y, m, d] = time.split("-").map(Number);
                    const date = new Date(y, (m || 1) - 1, d || 1);
                    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
                  }
                  const d = new Date(time * 1000);
                  const dateStr = d.toLocaleDateString("en-US", { month: "short", day: "numeric", timeZone: "America/New_York" });
                  const timeStr = d.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", timeZone: "America/New_York" });
                  return dateStr + " " + timeStr;
                } catch { return ""; }
              },
            },
            localization: {
              timeFormatter: (time) => {
                try {
                  if (typeof time === "string") {
                    const [y, m, d] = time.split("-").map(Number);
                    const date = new Date(y, (m || 1) - 1, d || 1);
                    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
                  }
                  const d = new Date(time * 1000);
                  const dateStr = d.toLocaleDateString("en-US", { month: "short", day: "numeric", timeZone: "America/New_York" });
                  const timeStr = d.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", second: "2-digit", timeZone: "America/New_York" });
                  return dateStr + " " + timeStr;
                } catch { return ""; }
              },
            },
            handleScroll: { vertTouchDrag: false },
          });
          chartRef.current = chart;

          const candleSeries = chart.addCandlestickSeries({
            upColor: "#22c55e",
            downColor: "#ef4444",
            borderUpColor: "#22c55e",
            borderDownColor: "#ef4444",
            wickUpColor: "#22c55e",
            wickDownColor: "#ef4444",
          });
          seriesRef.current = candleSeries;

          const asOfTsParam = asOfMs;
          let url = `${API_BASE}/timed/candles?ticker=${encodeURIComponent(ticker)}&tf=${tf}&limit=${limit}`;
          if (asOfTsParam) url += `&asOfTs=${asOfTsParam}`;

          const doRender = (candles) => {
            if (!candles || candles.length === 0) {
              setError("No chart data for this ticker");
              setLoading(false);
              return;
            }
            const mapped = mapCandles(candles, tf);
            if (mapped.length < 2) {
              setError("Insufficient candle data (need at least 2 bars)");
              setLoading(false);
              return;
            }
            candleSeries.setData(mapped);

            // Add EMAs and SuperTrend (broken line); store data for visibility toggles
            for (const s of emaSeriesRef.current) {
              try { chart.removeSeries(s); } catch (_) {}
            }
            emaSeriesRef.current = [];
            const ema9Data = computeEMA(mapped, 9);
            const ema21Data = computeEMA(mapped, 21);
            const ema48Data = computeEMA(mapped, 48);
            const ema200Data = computeEMA(mapped, 200);
            const superTrendSegments = computeSuperTrendSegments(mapped, 10, 3);
            indicatorDataRef.current = { ema9: ema9Data, ema21: ema21Data, ema48: ema48Data, ema200: ema200Data, superTrend: superTrendSegments };
            const noPriceLine = { lastValueVisible: false, priceLineVisible: false };
            const ema9 = chart.addLineSeries({ color: "#a78bfa", lineWidth: 2, title: "EMA 9", ...noPriceLine });
            const ema21 = chart.addLineSeries({ color: "#f472b6", lineWidth: 2, title: "EMA 21", ...noPriceLine });
            const ema48 = chart.addLineSeries({ color: "#38bdf8", lineWidth: 2, title: "EMA 48", ...noPriceLine });
            const ema200 = chart.addLineSeries({ color: "#fbbf24", lineWidth: 2, title: "EMA 200", ...noPriceLine });
            const superTrendUpper = chart.addLineSeries({ color: "#f97316", lineWidth: 2, title: "SuperTrend", ...noPriceLine });
            const superTrendLower = chart.addLineSeries({ color: "#f97316", lineWidth: 2, title: "", ...noPriceLine });
            ema9.setData(showIndicators.ema9 ? ema9Data : []);
            ema21.setData(showIndicators.ema21 ? ema21Data : []);
            ema48.setData(showIndicators.ema48 ? ema48Data : []);
            ema200.setData(showIndicators.ema200 ? ema200Data : []);
            if (showIndicators.superTrend) {
              superTrendUpper.setData(superTrendSegments.upper);
              superTrendLower.setData(superTrendSegments.lower);
            } else {
              superTrendUpper.setData([]);
              superTrendLower.setData([]);
            }
            emaSeriesRef.current = [ema9, ema21, ema48, ema200, superTrendUpper, superTrendLower];

            // Add entry/exit price lines (thicker, solid, prominent labels)
            for (const pl of priceLinesRef.current) {
              try { candleSeries.removePriceLine(pl); } catch (_) {}
            }
            priceLinesRef.current = [];
            const ep = Number(entryPrice);
            const xp = Number(exitPrice);
            if (Number.isFinite(ep) && ep > 0) {
              const pl = candleSeries.createPriceLine({
                price: ep,
                color: "#60a5fa",
                lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Solid,
                axisLabelVisible: true,
                title: "Entry",
              });
              priceLinesRef.current.push(pl);
            }
            if (Number.isFinite(xp) && xp > 0 && xp !== ep) {
              const pl = candleSeries.createPriceLine({
                price: xp,
                color: "#f59e0b",
                lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Solid,
                axisLabelVisible: true,
                title: "Exit",
              });
              priceLinesRef.current.push(pl);
            }
            const lastClose = mapped.length > 0 ? mapped[mapped.length - 1].close : null;
            if (Number.isFinite(lastClose) && lastClose > 0) {
              const pl = candleSeries.createPriceLine({
                price: lastClose,
                color: "#6b7280",
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                axisLabelVisible: true,
                title: "Price",
              });
              priceLinesRef.current.push(pl);
            }

            // Bar markers: Entry, Exit, Trim(s)
            const entryMs = Number(entryTs);
            const exitMs = Number(exitTs);
            const trimMs = Number(trimTs);
            const markers = [];
            const entryBar = findBarTime(mapped, entryMs);
            if (entryBar != null) {
              markers.push({ time: entryBar, position: "inBar", color: "#60a5fa", shape: "arrowUp", text: "Entry", size: 2 });
            }
            const exitBar = findBarTime(mapped, exitMs);
            if (exitBar != null && exitBar !== entryBar) {
              markers.push({ time: exitBar, position: "aboveBar", color: "#f59e0b", shape: "arrowDown", text: "Exit", size: 2 });
            }
            if (Number.isFinite(trimMs) && trimMs > 0) {
              const trimBar = findBarTime(mapped, trimMs);
              if (trimBar != null && trimBar !== entryBar && trimBar !== exitBar) {
                markers.push({ time: trimBar, position: "aboveBar", color: "#a78bfa", shape: "circle", text: "Trim", size: 1.5 });
              }
            }
            try { candleSeries.setMarkers(markers); } catch (_) {}

            chart.timeScale().fitContent();
            const entryBarTime = findBarTime(mapped, entryTs);
            const exitBarTime = findBarTime(mapped, exitTs);
            const hasTradeRange = entryBarTime != null && exitBarTime != null;
            const isDailyTime = typeof mapped[0].time === "string";
            let visibleFrom = mapped[0].time, visibleTo = mapped[mapped.length - 1].time;
            if (hasTradeRange) {
              if (isDailyTime) {
                const idxEntry = mapped.findIndex(b => b.time === entryBarTime);
                const idxExit = mapped.findIndex(b => b.time === exitBarTime);
                if (idxEntry >= 0 && idxExit >= 0) {
                  const padding = 5;
                  const fromIdx = Math.max(0, idxEntry - padding);
                  const toIdx = Math.min(mapped.length - 1, idxExit + padding);
                  visibleFrom = mapped[fromIdx].time;
                  visibleTo = mapped[toIdx].time;
                }
              } else {
                const oneWeekSec = 5 * 24 * 3600;
                visibleFrom = Math.max(mapped[0].time, entryBarTime - oneWeekSec);
                visibleTo = Math.min(mapped[mapped.length - 1].time, exitBarTime + oneWeekSec);
              }
              try {
                chart.timeScale().setVisibleRange({ from: visibleFrom, to: visibleTo });
              } catch (_) {}
            }
            // Constrain price scale to visible range so indicators (e.g. SuperTrend) don't stretch the axis
            const visibleCandles = mapped.filter(b => (isDailyTime ? String(b.time) >= String(visibleFrom) && String(b.time) <= String(visibleTo) : b.time >= visibleFrom && b.time <= visibleTo));
            const priceValues = [...visibleCandles.flatMap(b => [b.low, b.high])];
            if (Number.isFinite(ep)) priceValues.push(ep);
            if (Number.isFinite(xp)) priceValues.push(xp);
            if (priceValues.length > 0) {
              let priceMin = Math.min(...priceValues);
              let priceMax = Math.max(...priceValues);
              const paddingPct = 0.08;
              const range = Math.max(priceMax - priceMin, 1) * (1 + 2 * paddingPct);
              const center = (priceMin + priceMax) / 2;
              priceMin = center - range / 2;
              priceMax = center + range / 2;
              try {
                candleSeries.priceScale().setVisibleRange({ from: priceMin, to: priceMax });
              } catch (_) {}
            }
            requestAnimationFrame(() => {
              if (chartRef.current && containerRef.current) {
                if (!hasTradeRange) chartRef.current.timeScale().scrollToPosition(-3, false);
                const w = containerRef.current.clientWidth;
                const h = containerRef.current.clientHeight;
                if (w > 0 && h > 0) chartRef.current.resize(w, h);
              }
            });
            setTimeout(() => {
              if (chartRef.current && containerRef.current) {
                const w = containerRef.current.clientWidth;
                const h = containerRef.current.clientHeight;
                if (w > 0 && h > 0) chartRef.current.resize(w, h);
              }
            }, 200);
            setLoading(false);
          };

          fetch(url, { cache: "no-store" })
            .then(r => r.json())
            .then(data => {
              if (!data.ok || !data.candles) {
                setError("No chart data for this ticker");
                setLoading(false);
                return;
              }
              let candles = data.candles;
              if (candles.length < 2 && asOfTsParam) {
                const fallbackUrl = `${API_BASE}/timed/candles?ticker=${encodeURIComponent(ticker)}&tf=${tf}&limit=${limit}`;
                return fetch(fallbackUrl, { cache: "no-store" })
                  .then(r => r.json())
                  .then(d => {
                    if (d.ok && d.candles && d.candles.length >= 2) candles = d.candles;
                    if (candles.length < 2) {
                      setError("Insufficient chart data (try a different timeframe)");
                      setLoading(false);
                      return;
                    }
                    doRender(candles);
                  })
                  .catch(() => {
                    if (candles.length < 2) {
                      setError("Insufficient chart data (try a different timeframe)");
                      setLoading(false);
                    } else {
                      doRender(candles);
                    }
                  });
              }
              doRender(candles);
            })
            .catch(e => {
              setError("Failed to load chart");
              setLoading(false);
            });

          const handleResize = () => {
            if (containerRef.current && chartRef.current) {
              const w = containerRef.current.clientWidth;
              const h = containerRef.current.clientHeight;
              if (w > 0 && h > 0) chartRef.current.resize(w, h);
            }
          };
          const ro = typeof ResizeObserver !== "undefined" ? new ResizeObserver(handleResize) : null;
          if (ro) ro.observe(containerRef.current);
          window.addEventListener("resize", handleResize);

          return () => {
            if (ro) ro.disconnect();
            window.removeEventListener("resize", handleResize);
            priceLinesRef.current = [];
            emaSeriesRef.current = [];
            chart.remove();
            chartRef.current = null;
            seriesRef.current = null;
          };
        }, [ticker, tf, entryPrice, exitPrice, entryTs, exitTs, trimTs, height, mapCandles]);

        useEffect(() => {
          const series = emaSeriesRef.current;
          const data = indicatorDataRef.current;
          if (!data || !series || series.length !== 6) return;
          series[0].setData(showIndicators.ema9 ? data.ema9 : []);
          series[1].setData(showIndicators.ema21 ? data.ema21 : []);
          series[2].setData(showIndicators.ema48 ? data.ema48 : []);
          series[3].setData(showIndicators.ema200 ? data.ema200 : []);
          if (showIndicators.superTrend && data.superTrend) {
            series[4].setData(data.superTrend.upper || []);
            series[5].setData(data.superTrend.lower || []);
          } else {
            series[4].setData([]);
            series[5].setData([]);
          }
        }, [showIndicators]);

        const toggleIndicator = (key) => {
          setShowIndicators(prev => ({ ...prev, [key]: !prev[key] }));
        };

        return (
          <div className="tt-card overflow-hidden">
            <div className="px-3 py-2 flex items-center justify-between border-b border-white/[0.04]">
              <span className="text-[13px] font-semibold text-[#14b8a6]">{ticker}</span>
              <div className="flex items-center gap-1">
                {["5", "10", "60", "D"].map(t => (
                  <button
                    key={t}
                    onClick={() => setTf(t)}
                    className={`px-2 py-1 rounded text-[11px] font-medium ${tf === t ? "bg-white/10 text-white" : "text-[#6b7280] hover:text-white"}`}
                  >
                    {t === "D" ? "1D" : t + "m"}
                  </button>
                ))}
              </div>
            </div>
            <div ref={containerRef} style={{ height, minWidth: 200, width: "100%" }} className="w-full">
              {error && !loading && (
                <div className="flex items-center justify-center h-full text-[#6b7280] text-[13px]">{error}</div>
              )}
              {loading && (
                <div className="flex items-center justify-center h-full">
                  <div className="loading-spinner" style={{ width: 24, height: 24 }} />
                </div>
              )}
            </div>
            <div className="px-3 py-2 flex flex-wrap items-center gap-x-4 gap-y-1 border-t border-white/[0.04] bg-white/[0.02] text-[11px] text-[#9ca3af]">
              <span className="flex items-center gap-1.5"><span className="inline-block w-3 h-0.5 rounded bg-[#60a5fa]" /> Entry</span>
              <span className="flex items-center gap-1.5"><span className="inline-block w-3 h-0.5 rounded bg-[#f59e0b]" /> Exit</span>
              {["ema9", "ema21", "ema48", "ema200", "superTrend"].map(key => {
                const labels = { ema9: "EMA 9", ema21: "EMA 21", ema48: "EMA 48", ema200: "EMA 200", superTrend: "SuperTrend" };
                const colors = { ema9: "#a78bfa", ema21: "#f472b6", ema48: "#38bdf8", ema200: "#fbbf24", superTrend: "#f97316" };
                const on = showIndicators[key];
                return (
                  <button key={key} type="button" onClick={() => toggleIndicator(key)} className={`flex items-center gap-1.5 rounded px-1.5 py-0.5 -m-0.5 hover:bg-white/[0.06] transition-all ${on ? "opacity-100" : "opacity-45"}`} title={on ? "Hide" : "Show"}>
                    <span className="inline-block w-3 h-0.5 rounded shrink-0" style={{ background: colors[key] }} />
                    <span>{labels[key]}</span>
                  </button>
                );
              })}
            </div>
          </div>
        );
      }

      // ── Autopsy Modal ───────────────────────────────────────────────────────
      function AutopsyModal({ trade, annotations, onSave, onRefreshTrades, onClose }) {
        const [notes, setNotes] = useState(annotations?.notes ?? "");
        const [classification, setClassification] = useState(annotations?.classification ?? "");
        const [saving, setSaving] = useState(false);
        const [candleCloseAtEntry, setCandleCloseAtEntry] = useState(null);
        const [candleCloseAtExit, setCandleCloseAtExit] = useState(null);
        const appliedEntryRef = useRef(false);
        const appliedExitRef = useRef(false);

        const tradeId = trade?.trade_id || trade?.id || `${trade?.ticker}-${trade?.entry_ts}`;
        const storedEntry = Number(trade?.entry_price || trade?.entryPrice);
        const storedExit = Number(trade?.exit_price || trade?.exitPrice);

        // Fetch 10m candle at entry and exit to align stored prices with bar closes
        useEffect(() => {
          if (!trade?.ticker || !trade?.entry_ts) return;
          const asOfMs = (ts) => {
            const raw = Number(ts);
            if (!Number.isFinite(raw) || raw <= 0) return null;
            return raw < 1e12 ? raw * 1000 : raw;
          };
          const entryMs = asOfMs(trade.entry_ts);
          if (entryMs) {
            fetch(`${API_BASE}/timed/candles?ticker=${encodeURIComponent(trade.ticker)}&tf=10&limit=5&asOfTs=${entryMs}`, fetchOpts)
              .then(r => r.json())
              .then(data => {
                const candles = data?.candles;
                if (Array.isArray(candles) && candles.length > 0) {
                  const close = Number(candles[candles.length - 1]?.c);
                  if (Number.isFinite(close) && close > 0) setCandleCloseAtEntry(close);
                }
              })
              .catch(() => {});
          }
          if (trade?.exit_ts) {
            const exitMs = asOfMs(trade.exit_ts);
            if (exitMs) {
              fetch(`${API_BASE}/timed/candles?ticker=${encodeURIComponent(trade.ticker)}&tf=10&limit=5&asOfTs=${exitMs}`, fetchOpts)
                .then(r => r.json())
                .then(data => {
                  const candles = data?.candles;
                  if (Array.isArray(candles) && candles.length > 0) {
                    const close = Number(candles[candles.length - 1]?.c);
                    if (Number.isFinite(close) && close > 0) setCandleCloseAtExit(close);
                  }
                })
                .catch(() => {});
            }
          }
        }, [trade?.ticker, trade?.entry_ts, trade?.exit_ts]);

        // Auto-apply entry/exit price correction so displayed prices match 10m bar closes
        useEffect(() => {
          if (!tradeId || !onRefreshTrades) return;
          const run = async () => {
            let didCorrect = false;
            if (Number.isFinite(candleCloseAtEntry) && Number.isFinite(storedEntry) && Math.abs(candleCloseAtEntry - storedEntry) > 0.01 && !appliedEntryRef.current) {
              appliedEntryRef.current = true;
              try {
                const res = await fetch(`${API_BASE}/timed/admin/trade-autopsy/correct-entry`, {
                  ...fetchOpts,
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ trade_id: tradeId }),
                });
                const data = await res.json();
                if (data.ok && data.corrected) didCorrect = true;
              } catch (_) {}
            }
            if (Number.isFinite(candleCloseAtExit) && Number.isFinite(storedExit) && Math.abs(candleCloseAtExit - storedExit) > 0.01 && !appliedExitRef.current) {
              appliedExitRef.current = true;
              try {
                const res = await fetch(`${API_BASE}/timed/admin/trade-autopsy/correct-exit`, {
                  ...fetchOpts,
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ trade_id: tradeId }),
                });
                const data = await res.json();
                if (data.ok && data.corrected) didCorrect = true;
              } catch (_) {}
            }
            if (didCorrect) await onRefreshTrades();
          };
          run();
        }, [tradeId, candleCloseAtEntry, candleCloseAtExit, storedEntry, storedExit, onRefreshTrades]);

        const handleSave = async () => {
          setSaving(true);
          try {
            const res = await fetch(`${API_BASE}/timed/admin/trade-autopsy/annotations`, {
              ...fetchOpts,
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ trade_id: tradeId, classification, notes }),
            });
            const data = await res.json();
            if (data.ok) {
              onSave?.();
              onClose?.();
            }
          } finally {
            setSaving(false);
          }
        };

        const entrySnap = trade?.signal_snapshot_json;
        const tfStack = trade?.tf_stack_json;
        const mfe = trade?.max_favorable_excursion;
        const mae = trade?.max_adverse_excursion;
        const exitReason = trade?.exit_reason;

        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center p-4" style={{ background: "rgba(0,0,0,0.7)", backdropFilter: "blur(4px)" }} onClick={onClose}>
            <div className="tt-card w-full max-w-[95vw] max-h-[95vh] overflow-hidden flex flex-col" onClick={e => e.stopPropagation()}>
              <div className="flex items-center justify-between px-4 py-2.5 border-b border-white/[0.06] shrink-0" style={{ background: "var(--tt-bg-surface)" }}>
                <h2 className="text-[15px] font-semibold text-white">
                  {trade?.ticker} {trade?.direction || ""} — Trade Autopsy
                </h2>
                <button onClick={onClose} className="p-1.5 rounded-md text-[#6b7280] hover:text-white hover:bg-white/[0.06]">✕</button>
              </div>

              <div className="p-4 flex-1 min-h-0 flex flex-col gap-3">
                <div className="flex flex-wrap items-center gap-3 shrink-0">
                  <div className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-[#60a5fa]/15 border border-[#60a5fa]/30">
                    <span className="text-[10px] font-semibold text-[#60a5fa] uppercase tracking-wider">Entry</span>
                    <span className="text-[13px] font-semibold text-white">{formatDate(trade?.entry_ts)} @ {fmtUsd(trade?.entry_price || trade?.entryPrice)}</span>
                  </div>
                  <div className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-[#f59e0b]/15 border border-[#f59e0b]/30">
                    <span className="text-[10px] font-semibold text-[#f59e0b] uppercase tracking-wider">Exit</span>
                    <span className="text-[13px] font-semibold text-white">{formatDate(trade?.exit_ts)} @ {fmtUsd(trade?.exit_price || trade?.exitPrice)}</span>
                  </div>
                  <div className="text-[12px] text-[#9ca3af]">
                    P&L: <span className={Number(trade?.pnl) >= 0 ? "text-[#22c55e] font-semibold" : "text-[#ef4444] font-semibold"}>{fmtUsd(trade?.pnl)}</span>
                  </div>
                  {trade?.status && <div className="text-[12px] text-[#9ca3af]">Status: {trade.status}</div>}
                </div>
                <div className="text-[11px] text-[#9ca3af] px-1">
                  Entry and exit prices are aligned to the 10m bar close at that time.
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 flex-1 min-h-0">
                  <div className="lg:col-span-1 flex flex-col gap-3 min-h-0 overflow-y-auto">
                    {(entrySnap || tfStack || trade?.entry_path) && (
                      <div className="tt-card p-3 shrink-0">
                        <div className="text-[11px] font-semibold text-[#14b8a6] uppercase tracking-wider mb-2">Signal snapshot at entry</div>
                        {trade?.entry_path && (
                          <div className="mb-3 px-2.5 py-1.5 rounded-lg bg-[#14b8a6]/10 border border-[#14b8a6]/20">
                            <span className="text-[10px] text-[#9ca3af] uppercase tracking-wider">Regime</span>
                            <div className="text-[13px] font-semibold text-white mt-0.5">{formatPath(trade.entry_path)}</div>
                          </div>
                        )}
                        {parseTfStack(tfStack)?.length > 0 && (
                          <div className="mb-3">
                            <span className="text-[10px] text-[#9ca3af] uppercase tracking-wider block mb-1.5">Timeframe bias</span>
                            <div className="flex flex-wrap gap-1.5">
                              {parseTfStack(tfStack).map(({ tf, bias }) => {
                                const b = String(bias || "").toLowerCase();
                                const isBull = b === "bullish";
                                const isBear = b === "bearish";
                                const label = isBull ? "Bullish" : isBear ? "Bearish" : (bias || "—");
                                const style = isBull ? "bg-[#22c55e]/15 text-[#22c55e]" : isBear ? "bg-[#ef4444]/15 text-[#ef4444]" : "bg-white/[0.06] text-[#9ca3af]";
                                return (
                                  <span key={tf} className={`inline-flex items-center gap-1 px-2 py-0.5 rounded-md text-[11px] font-medium ${style}`}>
                                    <span className="opacity-80">{tf}</span>
                                    <span>{label}</span>
                                  </span>
                                );
                              })}
                            </div>
                          </div>
                        )}
                        {parseSnapshot(entrySnap)?.length > 0 && (
                          <div>
                            <span className="text-[10px] text-[#9ca3af] uppercase tracking-wider block mb-1.5">Indicators by timeframe</span>
                            <div className="space-y-2">
                              {parseSnapshot(entrySnap).map(({ tf, signals }) => (
                                <div key={tf} className="px-2 py-1.5 rounded-md bg-white/[0.03] border border-white/[0.06]">
                                  <div className="text-[10px] font-medium text-[#9ca3af] mb-1">{tf}</div>
                                  <div className="flex flex-wrap gap-x-3 gap-y-0.5 text-[11px]">
                                    {Object.entries(signals).filter(([, v]) => v != null && Number.isFinite(v)).map(([k, v]) => (
                                      <span key={k} className="flex items-center gap-1">
                                        <span className="text-[#6b7280]">{SIGNAL_LABELS[k] || k}:</span>
                                        <span className={signalValueColor(k, v)}>{signalValueLabel(k, v)}</span>
                                      </span>
                                    ))}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                    {(exitReason != null || Number.isFinite(mfe) || Number.isFinite(mae)) && (
                      <div className="tt-card p-3 shrink-0">
                        <div className="text-[11px] font-semibold text-[#f59e0b] uppercase tracking-wider mb-2">Exit context</div>
                        <div className="text-[12px] text-[#d1d5db] space-y-1">
                          {exitReason && <div className="break-words"><span className="text-[#9ca3af]">Reason:</span> {exitReason}</div>}
                          {Number.isFinite(mfe) && <div><span className="text-[#9ca3af]">MFE:</span> <span className="text-[#22c55e]">{mfe.toFixed(2)}%</span></div>}
                          {Number.isFinite(mae) && <div><span className="text-[#9ca3af]">MAE:</span> <span className="text-[#ef4444]">{mae.toFixed(2)}%</span></div>}
                        </div>
                      </div>
                    )}
                  </div>
                  <div className="lg:col-span-2 min-h-[500px] flex flex-col">
                    <AutopsyChart
                      ticker={trade?.ticker}
                      entryPrice={trade?.entry_price || trade?.entryPrice}
                      exitPrice={trade?.exit_price || trade?.exitPrice}
                      entryTs={trade?.entry_ts}
                      exitTs={trade?.exit_ts}
                      trimTs={trade?.trim_ts}
                      height={500}
                    />
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 shrink-0">
                  <div>
                    <label className="block text-[11px] font-medium text-[#9ca3af] mb-1">Classification</label>
                    <select
                      value={classification}
                      onChange={e => setClassification(e.target.value)}
                      className="w-full px-2.5 py-1.5 rounded-lg bg-white/[0.04] border border-white/[0.06] text-[12px] text-white focus:outline-none focus:ring-1 focus:ring-[#14b8a6]/50"
                    >
                      {CLASSIFICATION_OPTIONS.map(opt => (
                        <option key={opt.value || "empty"} value={opt.value}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                  <div>
                    <label className="block text-[11px] font-medium text-[#9ca3af] mb-1">Notes / Description</label>
                    <textarea
                      value={notes}
                      onChange={e => setNotes(e.target.value)}
                      placeholder="Add notes about this trade..."
                      rows={2}
                      className="w-full px-2.5 py-1.5 rounded-lg bg-white/[0.04] border border-white/[0.06] text-[12px] text-white placeholder-[#4b5563] focus:outline-none focus:ring-1 focus:ring-[#14b8a6]/50 resize-none"
                    />
                  </div>
                </div>

                <div className="flex justify-end gap-2 shrink-0">
                  <button onClick={onClose} className="px-3 py-1.5 rounded-lg text-[12px] text-[#9ca3af] hover:bg-white/[0.04]" disabled={saving}>Cancel</button>
                  <button onClick={handleSave} disabled={saving} className="px-3 py-1.5 rounded-lg text-[12px] font-medium bg-[#14b8a6]/20 text-[#14b8a6] hover:bg-[#14b8a6]/30 disabled:opacity-50">{saving ? "Saving…" : "Save"}</button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // ── Main App ───────────────────────────────────────────────────────────
      function App({ user }) {
        const [trades, setTrades] = useState([]);
        const [annotations, setAnnotations] = useState({});
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [selectedTrade, setSelectedTrade] = useState(null);
        const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
        const [filterTicker, setFilterTicker] = useState("");
        const [filterClassification, setFilterClassification] = useState("");
        const [filterDateFrom, setFilterDateFrom] = useState("");
        const [filterDateTo, setFilterDateTo] = useState("");

        const refreshAnnotations = useCallback(async () => {
          try {
            const r = await fetch(`${API_BASE}/timed/admin/trade-autopsy/annotations?all=1`, fetchOpts);
            const d = await r.json();
            if (d.ok && d.annotations) setAnnotations(d.annotations);
          } catch (_) {}
        }, []);

        const refreshTrades = useCallback(async () => {
          try {
            const r = await fetch(`${API_BASE}/timed/admin/trade-autopsy/trades`, fetchOpts);
            const d = await r.json();
            if (d.ok && Array.isArray(d.trades)) {
              setTrades(d.trades);
              setSelectedTrade(prev => {
                if (!prev) return prev;
                const id = prev.trade_id || prev.id || `${prev.ticker}-${prev.entry_ts}`;
                const updated = d.trades.find(t => (t.trade_id || t.id || `${t.ticker}-${t.entry_ts}`) === id);
                return updated || prev;
              });
            }
          } catch (_) {}
        }, []);

        const refreshAll = useCallback(async () => {
          setLoading(true);
          setError(null);
          try {
            const [tradesRes, annRes] = await Promise.all([
              fetch(`${API_BASE}/timed/admin/trade-autopsy/trades`, fetchOpts).then(r => r.json()),
              fetch(`${API_BASE}/timed/admin/trade-autopsy/annotations?all=1`, fetchOpts).then(r => r.json()),
            ]);
            if (tradesRes.ok && Array.isArray(tradesRes.trades)) setTrades(tradesRes.trades);
            else setError(tradesRes?.error === "unauthorized" ? "Admin access required" : "Failed to load trades");
            if (annRes.ok && annRes.annotations) setAnnotations(annRes.annotations);
          } catch (_) {
            setError("Failed to load trades");
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          Promise.all([
            fetch(`${API_BASE}/timed/admin/trade-autopsy/trades`, fetchOpts).then(r => r.json()),
            fetch(`${API_BASE}/timed/admin/trade-autopsy/annotations?all=1`, fetchOpts).then(r => r.json()),
          ]).then(([tradesData, annData]) => {
            if (tradesData.ok && Array.isArray(tradesData.trades)) setTrades(tradesData.trades);
            else setError(tradesData?.error === "unauthorized" ? "Admin access required" : "Failed to load trades");
            if (annData.ok && annData.annotations) setAnnotations(annData.annotations);
          }).catch(() => setError("Failed to load trades")).finally(() => setLoading(false));
        }, []);

        const filteredTrades = useMemo(() => {
          let out = trades;
          if (filterTicker.trim()) {
            const q = filterTicker.trim().toUpperCase();
            out = out.filter(t => String(t.ticker || "").toUpperCase().includes(q));
          }
          if (filterClassification) {
            out = out.filter(t => {
              const id = t?.trade_id || t?.id || `${t?.ticker}-${t?.entry_ts}`;
              return (annotations[id]?.classification || "") === filterClassification;
            });
          }
          if (filterDateFrom) {
            const fromMs = new Date(filterDateFrom + "T00:00:00").getTime();
            out = out.filter(t => (t.entry_ts || 0) >= fromMs);
          }
          if (filterDateTo) {
            const toMs = new Date(filterDateTo + "T23:59:59").getTime();
            out = out.filter(t => (t.entry_ts || 0) <= toMs);
          }
          return out;
        }, [trades, annotations, filterTicker, filterClassification, filterDateFrom, filterDateTo]);

        const getAnnotation = (t) => {
          const id = t?.trade_id || t?.id || `${t?.ticker}-${t?.entry_ts}`;
          return annotations[id] || {};
        };

        return (
          <div className="min-h-screen pb-16" style={{ background: "var(--tt-bg-base)" }}>
            <nav className="sticky top-0 z-50 border-b border-white/[0.06]" style={{ background: "rgba(10,10,15,0.95)", backdropFilter: "blur(12px)" }}>
              <div className="flex items-center justify-between px-4 py-2.5">
                <div className="flex items-center gap-3 md:gap-5 min-w-0">
                  <a href="index-react.html" className="flex items-center gap-2 no-underline shrink-0">
                    <div className="w-[28px] h-[28px] md:w-[32px] md:h-[32px] rounded-[8px] flex items-center justify-center" style={{ background: "linear-gradient(135deg, #00c853, #00e676, #69f0ae)" }}>
                      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                        <polyline points="22 7 13.5 15.5 8.5 10.5 2 17" />
                        <polyline points="16 7 22 7 22 13" />
                      </svg>
                    </div>
                    <span className="text-[14px] md:text-[15px] font-bold text-white hidden sm:inline" style={{ letterSpacing: "-0.03em" }}>Timed Trading</span>
                  </a>
                  <div className="hidden md:flex items-center gap-0.5">
                    <a href="index-react.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Analysis</a>
                    <a href="simulation-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Trades</a>
                    <a href="system-intelligence.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">System Intelligence</a>
                    <a href="screener.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Screener</a>
                    <a href="ticker-management.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Tickers</a>
                    <a href="trade-autopsy.html" className="px-3 py-1 rounded-md text-[13px] text-white bg-white/[0.07] font-medium">Trade Autopsy</a>
                    <a href="daily-brief.html" id="nav-daily-brief" className="relative px-3 py-1 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium">
                      Daily Brief
                      <span id="brief-badge" className="hidden absolute -top-0.5 -right-0.5 w-2 h-2 rounded-full bg-[#f59e0b]" style={{ animation: "pulse-badge 2s ease-in-out infinite" }} />
                    </a>
                  </div>
                </div>
                <div className="flex items-center gap-1.5 md:gap-2 shrink-0">
                  <a href="/faq.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</a>
                  <a href="index-react.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all" title="Restart tour">Tour</a>
                  <a href="/faq.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">FAQ</a>
                  <a href="index-react.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#60a5fa] hover:text-[#93bbfc] hover:bg-[#60a5fa]/[0.06] transition-all font-medium">Ask AI</a>
                  {window.TimedNotificationCenter && <window.TimedNotificationCenter apiBase={API_BASE} />}
                  {window.TimedUserBadge && <window.TimedUserBadge user={window.TimedAuthHelpers?.getStoredSession()} compact />}
                  <button onClick={() => setMobileMenuOpen(v => !v)} className="md:hidden p-1.5 rounded-md text-[#6b7280] hover:text-white hover:bg-white/[0.06] transition-all" aria-label="Toggle menu">
                    {mobileMenuOpen ? (
                      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    ) : (
                      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                    )}
                  </button>
                </div>
              </div>
              {mobileMenuOpen && (
                <div className="md:hidden border-t border-white/[0.06] px-4 py-2 flex flex-col gap-0.5" style={{ background: "rgba(10,10,15,0.98)" }}>
                  <a href="index-react.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Analysis</a>
                  <a href="simulation-dashboard.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Trades</a>
                  <a href="system-intelligence.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>System Intelligence</a>
                  <a href="screener.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Screener</a>
                  <a href="ticker-management.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Tickers</a>
                  <a href="trade-autopsy.html" className="px-3 py-2 rounded-md text-[13px] text-white bg-white/[0.07] font-medium" onClick={() => setMobileMenuOpen(false)}>Trade Autopsy</a>
                  <a href="daily-brief.html" className="px-3 py-2 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium" onClick={() => setMobileMenuOpen(false)}>Daily Brief</a>
                  <div className="border-t border-white/[0.06] mt-1 pt-1 flex items-center gap-2">
                    <a href="/faq.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</a>
                    <a href="index-react.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all" title="Restart tour">Tour</a>
                    <a href="/faq.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">FAQ</a>
                    <a href="index-react.html" className="px-3 py-2 rounded-md text-[12px] text-[#60a5fa] hover:text-white hover:bg-white/[0.04] transition-all">Ask AI</a>
                    <a href="mailto:support@timed-trading.com" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Contact</a>
                  </div>
                </div>
              )}
            </nav>

            <main className="max-w-[1200px] mx-auto px-4 md:px-6 py-6">
              <div className="flex flex-wrap items-start justify-between gap-3 mb-4">
                <div>
                  <h1 className="text-xl font-semibold text-white mb-1">Trade Autopsy</h1>
                  <p className="text-[13px] text-[#6b7280]">Review and annotate trades. Click a row to open the chart and add classification. This list is a snapshot — use <strong className="text-[#9ca3af]">Refresh</strong> to load new trades. Backtests run in the terminal (<code className="text-[11px] bg-white/[0.06] px-1 rounded">./scripts/full-backtest.sh</code>), not in the UI.</p>
                </div>
                <button onClick={refreshAll} className="shrink-0 px-3 py-1.5 rounded-lg bg-white/[0.06] border border-white/[0.08] text-[12px] font-medium text-[#9ca3af] hover:text-white hover:bg-white/[0.1] transition-all">Refresh</button>
              </div>

              {!loading && !error && trades.length > 0 && (
                <div className="flex flex-wrap gap-3 mb-4">
                  <input
                    type="text"
                    placeholder="Filter by ticker"
                    value={filterTicker}
                    onChange={e => setFilterTicker(e.target.value)}
                    className="px-3 py-1.5 rounded-lg bg-white/[0.04] border border-white/[0.06] text-[13px] text-white placeholder-[#4b5563] w-32"
                  />
                  <select
                    value={filterClassification}
                    onChange={e => setFilterClassification(e.target.value)}
                    className="px-3 py-1.5 rounded-lg bg-white/[0.04] border border-white/[0.06] text-[13px] text-white"
                  >
                    <option value="">All classifications</option>
                    {CLASSIFICATION_OPTIONS.filter(o => o.value).map(o => (
                      <option key={o.value} value={o.value}>{o.label}</option>
                    ))}
                  </select>
                  <input
                    type="date"
                    value={filterDateFrom}
                    onChange={e => setFilterDateFrom(e.target.value)}
                    className="px-3 py-1.5 rounded-lg bg-white/[0.04] border border-white/[0.06] text-[13px] text-white"
                  />
                  <input
                    type="date"
                    value={filterDateTo}
                    onChange={e => setFilterDateTo(e.target.value)}
                    className="px-3 py-1.5 rounded-lg bg-white/[0.04] border border-white/[0.06] text-[13px] text-white"
                  />
                  {(filterTicker || filterClassification || filterDateFrom || filterDateTo) && (
                    <button onClick={() => { setFilterTicker(""); setFilterClassification(""); setFilterDateFrom(""); setFilterDateTo(""); }} className="px-2 py-1.5 text-[12px] text-[#6b7280] hover:text-white">Clear</button>
                  )}
                  {filteredTrades.length !== trades.length && (
                    <span className="text-[12px] text-[#6b7280] self-center">Showing {filteredTrades.length} of {trades.length}</span>
                  )}
                </div>
              )}

              {loading && (
                <div className="flex items-center justify-center py-16">
                  <div className="loading-spinner" />
                </div>
              )}

              {error && (
                <div className="tt-card p-6 text-center text-[#ef4444]">{error}</div>
              )}

              {!loading && !error && trades.length === 0 && (
                <div className="tt-card p-12 text-center text-[#6b7280]">No closed trades to review.</div>
              )}

              {!loading && !error && trades.length > 0 && filteredTrades.length === 0 && (
                <div className="tt-card p-12 text-center text-[#6b7280]">No trades match the current filters.</div>
              )}

              {!loading && !error && filteredTrades.length > 0 && (
                <div className="tt-card overflow-hidden">
                  <div className="overflow-x-auto">
                    <table className="w-full text-[13px]">
                      <thead>
                        <tr className="border-b border-white/[0.06]">
                          <th className="px-4 py-3 text-left font-semibold text-[#6b7280]">Ticker</th>
                          <th className="px-4 py-3 text-left font-semibold text-[#6b7280]">Dir</th>
                          <th className="px-4 py-3 text-left font-semibold text-[#6b7280]">Entry</th>
                          <th className="px-4 py-3 text-left font-semibold text-[#6b7280]">Exit</th>
                          <th className="px-4 py-3 text-right font-semibold text-[#6b7280]">P&L</th>
                          <th className="px-4 py-3 text-left font-semibold text-[#6b7280]">Status</th>
                          <th className="px-4 py-3 text-left font-semibold text-[#6b7280]">Classification</th>
                        </tr>
                      </thead>
                      <tbody>
                        {filteredTrades.map((t, i) => {
                          const ann = getAnnotation(t);
                          const clsOpt = CLASSIFICATION_OPTIONS.find(o => o.value === ann.classification);
                          return (
                            <tr
                              key={t.trade_id || t.id || i}
                              className="trade-row border-b border-white/[0.04]"
                              onClick={() => setSelectedTrade(t)}
                            >
                              <td className="px-4 py-2.5 font-medium text-white">{t.ticker}</td>
                              <td className="px-4 py-2.5 text-[#9ca3af]">{t.direction || "—"}</td>
                              <td className="px-4 py-2.5 text-[#9ca3af]">{formatDate(t.entry_ts)}</td>
                              <td className="px-4 py-2.5 text-[#9ca3af]">{formatDate(t.exit_ts)}</td>
                              <td className={`px-4 py-2.5 text-right font-medium ${Number(t.pnl) >= 0 ? "text-[#22c55e]" : "text-[#ef4444]"}`}>{fmtUsd(t.pnl)}</td>
                              <td className="px-4 py-2.5 text-[#9ca3af]">{t.status || "—"}</td>
                              <td className="px-4 py-2.5 text-[#6b7280]">{clsOpt?.label || "—"}</td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}
            </main>

            <footer className="max-w-[1200px] mx-auto px-4 md:px-6 py-4 text-center text-[11px] text-[#4b5563]">
              For informational and educational purposes only. Not investment advice. Past performance does not guarantee future results. All trading involves risk of loss. <a href="/terms.html" className="text-[#6b7280] underline hover:text-[#9ca3af]">Full Terms</a> · Market data powered by <a href="https://twelvedata.com" target="_blank" rel="noopener" className="text-[#6b7280] underline hover:text-[#9ca3af]">Twelve Data</a>
            </footer>

            {selectedTrade && (
              <AutopsyModal
                trade={selectedTrade}
                annotations={getAnnotation(selectedTrade)}
                onSave={refreshAnnotations}
                onRefreshTrades={refreshTrades}
                onClose={() => setSelectedTrade(null)}
              />
            )}
          </div>
        );
      }

      // Bootstrap
      (function () {
        const session = window.TimedAuthHelpers?.getStoredSession?.();
        const root = document.getElementById("root");
        if (!session) {
          root.innerHTML = '<div class="flex items-center justify-center min-h-screen bg-[#0b0e11] text-[#6b7280] font-[Inter]"><p>Please <a href="index-react.html" class="text-[#00c853]">sign in</a> to view Trade Autopsy.</p></div>';
          return;
        }
        ReactDOM.createRoot(root).render(<App user={session} />);
      })();
    </script>
  </body>
</html>
