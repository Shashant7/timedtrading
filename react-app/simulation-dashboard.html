<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Timed Trading - Trade Tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Trade Tracker â€” Robinhood-inspired dark (v3) */
      :root {
        --tt-bg-base: #0b0e11;
        --tt-bg-surface: rgba(255,255,255,0.02);
        --tt-bg-elevated: rgba(255,255,255,0.035);
        --tt-bg-hover: rgba(255,255,255,0.04);
        --tt-border: rgba(255,255,255,0.04);
        --tt-border-strong: rgba(255,255,255,0.08);
        --tt-text: #e5e7eb;
        --tt-text-muted: #6b7280;
        --tt-text-faint: #4b5563;
        --tt-accent: #00c853;
        --tt-accent-dim: rgba(0, 200, 83, 0.12);
        --tt-negative: #ff5252;
        --tt-negative-dim: rgba(255, 82, 82, 0.12);
        --tt-radius: 12px;
        --tt-radius-sm: 8px;
        --tt-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }
      body {
        background: var(--tt-bg-base);
        color: var(--tt-text);
        font-family: var(--tt-font);
        -webkit-font-smoothing: antialiased;
      }
      .tt-card {
        background: var(--tt-bg-surface);
        border: 1px solid var(--tt-border);
        border-radius: var(--tt-radius);
      }
      .tt-pill {
        padding: 6px 12px;
        border-radius: 9999px;
        font-size: 13px;
        font-weight: 500;
        transition: background 0.15s, color 0.15s;
      }
      .tt-pill-active {
        background: var(--tt-bg-elevated);
        color: var(--tt-text);
      }
      .tt-pill-inactive {
        background: transparent;
        color: var(--tt-text-muted);
      }
      .tt-pill-inactive:hover {
        color: var(--tt-text);
        background: var(--tt-bg-hover);
      }
      .tt-label {
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--tt-text-faint);
      }
      .loading-spinner {
        border: 2px solid var(--tt-border);
        border-top-color: var(--tt-accent);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      @keyframes pulse-badge {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.15); }
      }
      .slide-in-right {
        animation: slideInRight 0.25s ease-out;
      }
      @keyframes slideInRight {
        from { transform: translateX(8px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      .card-pulse { animation: card-pulse 2s ease-in-out infinite; }
      @keyframes card-pulse {
        0%, 100% { box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.2); }
        50% { box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.5); }
      }
      .card-pulse-short { animation: card-pulse-short 2s ease-in-out infinite; }
      @keyframes card-pulse-short {
        0%, 100% { box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.2); }
        50% { box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.5); }
      }

      /* Admin-only nav links: greyed out with lock for non-admin users */
      body:not([data-user-role="admin"]) a[data-admin-only] {
        opacity: 0.35;
        pointer-events: none;
        position: relative;
      }
      body:not([data-user-role="admin"]) a[data-admin-only]::after {
        content: " ðŸ”’";
        font-size: 9px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script src="auth-gate.js"></script>
    <script src="shared-price-utils.js?v=20260211a"></script>
    <script src="shared-right-rail.compiled.js?v=20260211e" type="text/babel"></script>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, memo, useRef } = React;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Constants
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const API_BASE = "";  // same-origin â€” proxied by Pages Function
      // API_KEY removed for security - write operations disabled for public access
      // To enable trade management, implement proper authentication
      const TRADE_SIZE = 1000; // $1000 per trade
      const BASELINE_ACCOUNT = 100000; // starting account value for P&L display
      const FUTURES_TICKERS = new Set([
        "ES",
        "NQ",
        "YM",
        "RTY",
        "CL",
        "GC",
        "SI",
        "HG",
        "NG",
      ]);

      // Futures contract specifications (point value per contract) - matches worker
      const FUTURES_SPECS = {
        "ES1!": { pointValue: 50, name: "E-mini S&P 500" },
        "NQ1!": { pointValue: 20, name: "E-mini Nasdaq-100" },
        "MES1!": { pointValue: 5, name: "Micro E-mini S&P 500" },
        "MNQ1!": { pointValue: 2, name: "Micro E-mini Nasdaq-100" },
        "YM1!": { pointValue: 5, name: "E-mini Dow" },
        "RTY1!": { pointValue: 50, name: "E-mini Russell 2000" },
        ES: { pointValue: 50, name: "E-mini S&P 500" },
        NQ: { pointValue: 20, name: "E-mini Nasdaq-100" },
        YM: { pointValue: 5, name: "E-mini Dow" },
      };

      const USD_FMT = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        maximumFractionDigits: 2,
      });
      const INT_FMT = new Intl.NumberFormat("en-US");

      function fmtUsd(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return "â€”";
        return USD_FMT.format(n);
      }

      function fmtInt(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return "â€”";
        return INT_FMT.format(n);
      }

      // Normalize API ts to ms (entry_ts/exit_ts may be seconds from older data)
      function tsToMs(ts) {
        const n = Number(ts);
        if (!Number.isFinite(n)) return null;
        return n < 1e12 ? n * 1000 : n;
      }

      function resolveDirection(src) {
        const direct = String(src?.direction || "").toUpperCase();
        if (direct === "LONG" || direct === "SHORT") return direct;
        const state = String(src?.state || "");
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        const triggerDir = String(src?.trigger_dir || "").toUpperCase();
        if (triggerDir.includes("BULL")) return "LONG";
        if (triggerDir.includes("BEAR")) return "SHORT";
        return null;
      }

      function computeEntryRef(src) {
        const entryRef = Number(src?.entry_ref);
        if (Number.isFinite(entryRef) && entryRef > 0) return entryRef;
        const trigger = Number(src?.trigger_price);
        if (Number.isFinite(trigger) && trigger > 0) return trigger;
        const entryPrice = Number(src?.entryPrice);
        if (Number.isFinite(entryPrice) && entryPrice > 0) return entryPrice;
        const price = Number(src?.price ?? src?.currentPrice);
        return Number.isFinite(price) && price > 0 ? price : null;
      }

      function computeTpTargetPrice(src) {
        const directTarget = Number(src?.tp_target_price ?? src?.tp_target);
        if (Number.isFinite(directTarget) && directTarget > 0)
          return directTarget;
        const tp = Number(src?.tp);
        if (Number.isFinite(tp) && tp > 0) return tp;
        return null;
      }

      function computeTpMaxPrice(src) {
        const directMax = Number(src?.tp_max_price ?? src?.tp_max);
        if (Number.isFinite(directMax) && directMax > 0) return directMax;
        const entry = computeEntryRef(src);
        if (!Number.isFinite(entry)) return null;
        const dir = resolveDirection(src);
        const tpLevels = Array.isArray(src?.tp_levels) ? src.tp_levels : [];
        const candidates = tpLevels
          .map((tp) => {
            const price =
              tp && typeof tp === "object" && tp.price != null
                ? Number(tp.price)
                : Number(tp);
            return Number.isFinite(price) ? price : null;
          })
          .filter((p) => Number.isFinite(p));
        if (candidates.length === 0) return null;
        if (dir === "LONG") {
          const valid = candidates.filter((p) => p > entry);
          return valid.length > 0 ? Math.max(...valid) : null;
        }
        if (dir === "SHORT") {
          const valid = candidates.filter((p) => p < entry);
          return valid.length > 0 ? Math.min(...valid) : null;
        }
        return null;
      }

      // â”€â”€ Shared price utilities (from shared-price-utils.js) â”€â”€
      // Single source of truth for daily change, staleness, and market-hours logic.
      const getIngestMs = window.TimedPriceUtils.getIngestMs;
      const getNyClock = window.TimedPriceUtils.getNyClock;
      const isNyRegularMarketOpen = window.TimedPriceUtils.isNyRegularMarketOpen;
      const ageLabelFromMinutes = window.TimedPriceUtils.ageLabelFromMinutes;
      const getStaleInfo = window.TimedPriceUtils.getStaleInfo;
      const getDailyChange = window.TimedPriceUtils.getDailyChange;

      function computeReturnPct(src) {
        const direct =
          Number(src?.expected_return_pct) ||
          Number(src?.tp_target_pct) ||
          Number(src?.tp_max_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(src);
        const tpTarget = computeTpTargetPrice(src) ?? computeTpMaxPrice(src);
        if (!Number.isFinite(entry) || !Number.isFinite(tpTarget)) return null;
        return (Math.abs(tpTarget - entry) / entry) * 100;
      }

      function computeRiskPct(src) {
        const direct = Number(src?.risk_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(src);
        const sl = Number(src?.sl);
        if (!Number.isFinite(entry) || !Number.isFinite(sl)) return null;
        return (Math.abs(entry - sl) / entry) * 100;
      }

      function computeEtaDays(src) {
        const staleness = String(src?.staleness || "").toUpperCase();
        if (staleness && staleness !== "FRESH") return null;
        const baseEta = Number(src?.eta_days_v2 ?? src?.eta_days);
        if (!Number.isFinite(baseEta) || baseEta <= 0) return null;
        const dir = resolveDirection(src);
        const entry = computeEntryRef(src);
        const target = computeTpTargetPrice(src);
        const current = Number(src?.price ?? src?.currentPrice);
        if (
          !Number.isFinite(entry) ||
          !Number.isFinite(target) ||
          !Number.isFinite(current) ||
          !dir
        ) {
          return baseEta;
        }
        const totalDist = Math.abs(target - entry);
        if (!Number.isFinite(totalDist) || totalDist <= 0) return baseEta;
        const progress =
          dir === "LONG"
            ? (current - entry) / (target - entry)
            : (entry - current) / (entry - target);
        if (!Number.isFinite(progress)) return baseEta;
        const clamped = Math.max(0, Math.min(1, progress));
        const remaining = baseEta * (1 - clamped);
        return Math.max(0.1, Math.round(remaining * 100) / 100);
      }

      function computeHorizonBucket(src) {
        const bucket = String(src?.horizon_bucket || "")
          .trim()
          .toUpperCase();
        if (bucket) return bucket.replace("_", " ");
        const eta = computeEtaDays(src);
        if (!Number.isFinite(eta)) return "â€”";
        if (eta <= 7) return "SHORT TERM";
        if (eta <= 30) return "SWING";
        return "POSITIONAL";
      }

      function computeHorizonKey(src) {
        const bucket = String(src?.horizon_bucket || "")
          .trim()
          .toUpperCase();
        if (bucket) return bucket;
        const eta = computeEtaDays(src);
        if (!Number.isFinite(eta)) return "UNKNOWN";
        if (eta <= 7) return "SHORT_TERM";
        if (eta <= 30) return "SWING";
        return "POSITIONAL";
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Hooks
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);
        const hasLoadedRef = React.useRef(false);

        const fetchData = useCallback(async () => {
          try {
            if (!hasLoadedRef.current) setLoading(true);
            setRefreshing(true);
            setError(null);
            const timestamp = Date.now();
            const res = await fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache, no-store, must-revalidate",
                Pragma: "no-cache",
                Expires: "0",
              },
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && json.data) {
              setData(json.data);
              setLastUpdate(new Date());
              hasLoadedRef.current = true;
            } else {
              throw new Error(json.error || "Invalid response");
            }
          } catch (err) {
            setError(err.message);
            console.error("Fetch error:", err);
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 30000); // Refresh every 30 seconds (keep prices fresh)
          return () => clearInterval(interval);
        }, [fetchData]);

        // Merge /timed/prices into data so Open Positions and metrics use actual current price + daily change
        const dataRef = React.useRef(data);
        dataRef.current = data;
        const hasData = data && Object.keys(data).length > 0;
        useEffect(() => {
          if (!hasData) return;
          const mergePrices = async () => {
            try {
              const res = await fetch(`${API_BASE}/timed/prices?_t=${Date.now()}`, { cache: "no-store" });
              if (!res.ok) return;
              const json = await res.json();
              if (!json.ok || !json.prices) return;
              const current = dataRef.current;
              if (!current || typeof current !== "object") return;
              const updated = { ...current };
              let changed = false;
              for (const [sym, priceInfo] of Object.entries(json.prices)) {
                const key = String(sym).toUpperCase();
                const existing = updated[key];
                if (!existing || !(priceInfo.p > 0)) continue;
                if (existing._live_price === priceInfo.p && existing._live_daily_change_pct === priceInfo.dp) continue;
                updated[key] = {
                  ...existing,
                  price: priceInfo.p,
                  prev_close: priceInfo.pc > 0 ? priceInfo.pc : (existing.prev_close || undefined),
                  day_change: priceInfo.dc,
                  day_change_pct: priceInfo.dp,
                  _live_price: priceInfo.p,
                  _live_prev_close: priceInfo.pc,
                  _live_daily_change: priceInfo.dc,
                  _live_daily_change_pct: priceInfo.dp,
                  _price_updated_at: json.updated_at || Date.now(),
                };
                changed = true;
              }
              if (changed) setData(updated);
            } catch (e) { console.warn("[PRICE FEED]", e); }
          };
          mergePrices();
          const interval = setInterval(mergePrices, 30000);
          return () => clearInterval(interval);
        }, [hasData]);

        return {
          data,
          loading,
          refreshing,
          error,
          lastUpdate,
          refetch: fetchData,
        };
      }

      function useSimulatedTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const hasLoadedRef = React.useRef(false);

        // Fetch trades from Worker
        const fetchTrades = useCallback(async (version = null) => {
          try {
            if (!hasLoadedRef.current) setLoading(true);
            setRefreshing(true);
            setError(null);
            const ts = Date.now();
            // Prefer D1 positions so trades include history[] (execution timeline)
            const source = "positions";
            const baseUrl = version
              ? `${API_BASE}/timed/trades?source=${source}&version=${encodeURIComponent(version)}`
              : `${API_BASE}/timed/trades?source=${source}`;
            const url = `${baseUrl}&_t=${ts}`;
            console.log(`[UI] Fetching trades from ${url}`);
            const res = await fetch(url, {
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache, no-store, must-revalidate",
                Pragma: "no-cache",
                Expires: "0",
              },
            });
            console.log(`[UI] Response status: ${res.status}, ok: ${res.ok}`);
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[UI] HTTP ${res.status} error:`, errorText);
              throw new Error(
                `HTTP ${res.status}: ${errorText.substring(0, 100)}`,
              );
            }
            const json = await res.json();
            console.log(`[UI] Response:`, {
              ok: json.ok,
              count: json.count,
              totalCount: json.totalCount,
              tradesLength: json.trades?.length,
              versions: json.versions,
            });
            if (json.ok && Array.isArray(json.trades)) {
              console.log(`[UI] âœ… Setting ${json.trades.length} trades`);
              setTrades(json.trades);
              hasLoadedRef.current = true;
            } else {
              console.error(`[UI] âŒ Invalid response:`, json);
              setTrades([]); // Set empty array instead of throwing
              throw new Error(json.error || "Invalid response format");
            }
          } catch (err) {
            setError(err.message);
            console.error("[UI] Fetch trades error:", err);
            setTrades([]); // Ensure trades is set to empty array on error
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        // Load trades on mount
        useEffect(() => {
          fetchTrades();
        }, [fetchTrades]);

        // Save trade to Worker - DISABLED for public access (security)
        const saveTrade = useCallback(async (trade) => {
          throw new Error(
            "Trade management is disabled for public access. This is a read-only dashboard.",
          );
        }, []);

        const addTrade = useCallback(
          async (trade) => {
            await saveTrade(trade);
          },
          [saveTrade],
        );

        const updateTrade = useCallback(
          async (tradeId, updates) => {
            const existingTrade = trades.find((t) => t.id === tradeId);
            if (!existingTrade) {
              console.error("Trade not found:", tradeId);
              return;
            }
            const updatedTrade = { ...existingTrade, ...updates };
            await saveTrade(updatedTrade);
          },
          [trades, saveTrade],
        );

        return {
          trades,
          loading,
          refreshing,
          error,
          addTrade,
          updateTrade,
          refetch: fetchTrades,
        };
      }

      // Paper portfolio (Kanban-driven executions)
      function usePaperPortfolio() {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [refreshing, setRefreshing] = useState(false);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);

        const fetchPortfolio = useCallback(async () => {
          try {
            setRefreshing(true);
            setError(null);
            const ts = Date.now();
            const url = `${API_BASE}/timed/portfolio?_t=${ts}`;
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "portfolio_failed");
            setData(json);
            setLastUpdate(new Date());
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
            setRefreshing(false);
          }
        }, []);

        useEffect(() => {
          fetchPortfolio();
          const interval = setInterval(fetchPortfolio, 30000);
          return () => clearInterval(interval);
        }, [fetchPortfolio]);

        return {
          data,
          loading,
          refreshing,
          error,
          lastUpdate,
          refetch: fetchPortfolio,
        };
      }

      // Account Summary hook â€” single source of truth from account_ledger
      function useAccountSummary(mode = "trader") {
        const [summary, setSummary] = useState(null);
        const [loading, setLoading] = useState(true);

        const fetchSummary = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/account-summary?mode=${mode}&_t=${Date.now()}`, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) setSummary(json);
          } catch { /* best-effort */ }
          finally { setLoading(false); }
        }, [mode]);

        useEffect(() => {
          fetchSummary();
          const interval = setInterval(fetchSummary, 60000);
          return () => clearInterval(interval);
        }, [fetchSummary]);

        return { summary, loading, refetch: fetchSummary };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Ledger (D1) Hooks
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      function useLedgerSummary({ since = null, until = null } = {}) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSummary = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const qs = new URLSearchParams();
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            const url = `${API_BASE}/timed/ledger/summary?${qs.toString()}`;
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok)
              throw new Error(json.error || "ledger_summary_failed");
            setData(json);
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
          }
        }, [since, until]);

        useEffect(() => {
          fetchSummary();
        }, [fetchSummary]);

        return { data, loading, error, refetch: fetchSummary };
      }

      function useLedgerTrades({
        ticker = "",
        status = "all",
        since = null,
        until = null,
        pageSize = 200,
      } = {}) {
        const [items, setItems] = useState([]);
        const [loading, setLoading] = useState(true);
        const [loadingMore, setLoadingMore] = useState(false);
        const [error, setError] = useState(null);
        const [hasMore, setHasMore] = useState(false);
        const [cursor, setCursor] = useState(null);

        const buildUrl = useCallback(
          (cursorVal) => {
            const qs = new URLSearchParams();
            if (ticker) qs.set("ticker", ticker);
            if (status && status !== "all") qs.set("status", status);
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            qs.set("limit", String(pageSize));
            if (cursorVal) qs.set("cursor", String(cursorVal));
            return `${API_BASE}/timed/ledger/trades?${qs.toString()}`;
          },
          [ticker, status, since, until, pageSize],
        );

        const fetchFirstPage = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(buildUrl(null), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_trades_failed");
            const trades = Array.isArray(json.trades) ? json.trades : [];
            setItems(trades);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
            setItems([]);
            setHasMore(false);
            setCursor(null);
          } finally {
            setLoading(false);
          }
        }, [buildUrl]);

        const fetchMore = useCallback(async () => {
          if (!cursor || loadingMore) return;
          try {
            setLoadingMore(true);
            const res = await fetch(buildUrl(cursor), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_trades_failed");
            const trades = Array.isArray(json.trades) ? json.trades : [];
            setItems((prev) => [...prev, ...trades]);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
          } finally {
            setLoadingMore(false);
          }
        }, [buildUrl, cursor, loadingMore]);

        useEffect(() => {
          fetchFirstPage();
        }, [fetchFirstPage]);

        return {
          items,
          loading,
          loadingMore,
          error,
          hasMore,
          fetchMore,
          refetch: fetchFirstPage,
        };
      }

      function useLedgerAlerts({
        ticker = "",
        since = null,
        until = null,
        pageSize = 200,
      } = {}) {
        const [items, setItems] = useState([]);
        const [loading, setLoading] = useState(true);
        const [loadingMore, setLoadingMore] = useState(false);
        const [error, setError] = useState(null);
        const [hasMore, setHasMore] = useState(false);
        const [cursor, setCursor] = useState(null);

        const buildUrl = useCallback(
          (cursorVal) => {
            const qs = new URLSearchParams();
            if (ticker) qs.set("ticker", ticker);
            if (since != null) qs.set("since", String(since));
            if (until != null) qs.set("until", String(until));
            qs.set("limit", String(pageSize));
            if (cursorVal) qs.set("cursor", String(cursorVal));
            return `${API_BASE}/timed/ledger/alerts?${qs.toString()}`;
          },
          [ticker, since, until, pageSize],
        );

        const fetchFirstPage = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(buildUrl(null), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_alerts_failed");
            const alerts = Array.isArray(json.alerts) ? json.alerts : [];
            setItems(alerts);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
            setItems([]);
            setHasMore(false);
            setCursor(null);
          } finally {
            setLoading(false);
          }
        }, [buildUrl]);

        const fetchMore = useCallback(async () => {
          if (!cursor || loadingMore) return;
          try {
            setLoadingMore(true);
            const res = await fetch(buildUrl(cursor), { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ledger_alerts_failed");
            const alerts = Array.isArray(json.alerts) ? json.alerts : [];
            setItems((prev) => [...prev, ...alerts]);
            setHasMore(!!json.hasMore);
            setCursor(json.nextCursor || null);
          } catch (e) {
            setError(String(e.message || e));
          } finally {
            setLoadingMore(false);
          }
        }, [buildUrl, cursor, loadingMore]);

        useEffect(() => {
          fetchFirstPage();
        }, [fetchFirstPage]);

        return {
          items,
          loading,
          loadingMore,
          error,
          hasMore,
          fetchMore,
          refetch: fetchFirstPage,
        };
      }

      function useLedgerTradeDetail(tradeId, includeEvidence = false) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);

        const fetchDetail = useCallback(async () => {
          if (!tradeId) {
            setData(null);
            setError(null);
            return;
          }
          try {
            setLoading(true);
            setError(null);
            const qs = includeEvidence ? "?includeEvidence=1" : "";
            const res = await fetch(
              `${API_BASE}/timed/ledger/trades/${encodeURIComponent(tradeId)}${qs}`,
              { cache: "no-store" },
            );
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok)
              throw new Error(json.error || "ledger_trade_detail_failed");
            setData(json);
          } catch (e) {
            setError(String(e.message || e));
            setData(null);
          } finally {
            setLoading(false);
          }
        }, [tradeId, includeEvidence]);

        useEffect(() => {
          fetchDetail();
        }, [fetchDetail]);

        return { data, loading, error, refetch: fetchDetail };
      }

      function useSectors() {
        const [sectors, setSectors] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSectors = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/sectors`, {
              cache: "no-store",
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.sectors)) {
              setSectors(json.sectors);
            } else {
              setSectors([]);
            }
          } catch (err) {
            setError(err.message);
            setSectors([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchSectors();
          const interval = setInterval(fetchSectors, 300000);
          return () => clearInterval(interval);
        }, [fetchSectors]);

        return { sectors, loading, error, refetch: fetchSectors };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Trade Simulation Logic
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function shouldTriggerTrade(ticker, prevData) {
        // Skip futures
        if (FUTURES_TICKERS.has(ticker.ticker.toUpperCase())) return false;

        // Must have valid entry/exit levels
        if (!ticker.price || !ticker.sl || !ticker.tp) return false;

        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const alignedLong = state === "HTF_BULL_LTF_BULL";
        const alignedShort = state === "HTF_BEAR_LTF_BEAR";
        const aligned = alignedLong || alignedShort;
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        const side = ent.side; // LONG or SHORT

        // Corridor must match alignment
        const corridorAlignedOK =
          (side === "LONG" && alignedLong) ||
          (side === "SHORT" && alignedShort);

        if (!inCorridor || !corridorAlignedOK) return false;

        // Check for trigger conditions (matches worker logic)
        const enteredAligned = prevData && prevData.state !== state && aligned;
        const trigReason = String(ticker.trigger_reason || "");
        const trigOk =
          trigReason === "EMA_CROSS" || trigReason === "SQUEEZE_RELEASE";
        const sqRelease = !!flags.sq30_release;
        const hasTrigger = !!ticker.trigger_price && !!ticker.trigger_ts;

        // Must be: in corridor + corridor aligns + (entered aligned OR trigger OR squeeze release)
        const shouldConsiderAlert =
          inCorridor &&
          corridorAlignedOK &&
          (enteredAligned || trigOk || sqRelease || hasTrigger);

        // Check Momentum Elite status
        const momentumElite = !!flags.momentum_elite;

        // Threshold gates (with Momentum Elite adjustments - matching worker logic)
        const baseMinRR = 1.5;
        const baseMaxComp = 0.4;
        const baseMaxPhase = 0.6;
        const baseMinRank = 70;

        // Adjust thresholds for Momentum Elite (more lenient for quality stocks)
        const minRR = momentumElite
          ? Math.max(1.2, baseMinRR * 0.9)
          : baseMinRR; // Lower RR requirement
        const maxComp = momentumElite
          ? Math.min(0.5, baseMaxComp * 1.25)
          : baseMaxComp; // Allow higher completion
        const maxPhase = momentumElite
          ? Math.min(0.7, baseMaxPhase * 1.17)
          : baseMaxPhase; // Allow higher phase
        const minRank = momentumElite
          ? Math.max(60, baseMinRank - 10)
          : baseMinRank; // Lower rank requirement

        const rr = Number(ticker.rr) || 0;
        const comp = Number(ticker.completion) || 0;
        const phase = Number(ticker.phase_pct) || 0;
        const rank = Number(ticker.rank) || 0;

        const rrOk = rr >= minRR;
        const compOk = comp <= maxComp;
        const phaseOk = phase <= maxPhase;
        const rankOk = rank >= minRank;

        // Also consider Momentum Elite as a trigger condition (quality signal)
        const momentumEliteTrigger =
          momentumElite && inCorridor && corridorAlignedOK;

        // Enhanced trigger: original conditions OR Momentum Elite in good setup
        const enhancedTrigger = shouldConsiderAlert || momentumEliteTrigger;

        return enhancedTrigger && rrOk && compOk && phaseOk && rankOk;
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
        const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL"))
          return {
            text: "LONG",
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        if (state.includes("BEAR"))
          return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: null, color: "text-[var(--tt-text-muted)]", bg: "bg-[var(--tt-bg-elevated)]" };
      }

      // Helpers for shared Right Rail (same API as Dashboard)
      function numFromAny(v) {
        if (v == null) return null;
        if (typeof v === "number") return Number.isFinite(v) ? v : null;
        if (typeof v === "string") {
          const s = v.trim();
          if (!s) return null;
          const m = s.replace(/,/g, "").match(/-?\d+(\.\d+)?/);
          if (!m) return null;
          const n = Number(m[0]);
          return Number.isFinite(n) ? n : null;
        }
        if (typeof v === "object" && v.price != null) return numFromAny(v.price);
        return null;
      }
      function fmtUsdAbs(n) {
        const x = numFromAny(n);
        if (!Number.isFinite(x)) return "â€”";
        return `$${Math.abs(x).toFixed(2)}`;
      }
      function getDirectionFromState(ticker) {
        const state = String(ticker?.state || "");
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        return null;
      }
      function summarizeEntryDecision(ticker) {
        const decision = ticker?.entry_decision;
        if (!decision || typeof decision !== "object") return null;
        const blockers = Array.isArray(decision.blockers) ? decision.blockers : [];
        const warnings = Array.isArray(decision.warnings) ? decision.warnings : [];
        const label = (code) => String(code || "").replace(/_/g, " ");
        if (decision.ok) return { status: "Eligible", detail: "All entry checks passed", tone: "text-green-400", bg: "bg-green-500/20", blockers: [], warnings: warnings.map(label) };
        if (blockers.length === 0) return { status: "Waiting", detail: "Setup not confirmed yet", tone: "text-[#6b7280]", bg: "bg-white/[0.04]", blockers: [], warnings: warnings.map(label) };
        const shown = blockers.slice(0, 3).map(label);
        return { status: "Blocked", detail: shown.join(", "), tone: "text-yellow-400", bg: "bg-yellow-500/20", blockers: blockers.map(label), warnings: warnings.map(label) };
      }
      const GROUP_ORDER = [];
      const GROUP_LABELS = {};
      function groupsForTicker(t) { return ["Other"]; }
      function getRankPosition(sortedTickers, tickerSymbol) {
        const sym = String(tickerSymbol || "").trim().toUpperCase();
        if (!sym) return null;
        const index = (sortedTickers || []).findIndex((t) => String(t.ticker || "").trim().toUpperCase() === sym);
        return index >= 0 ? index + 1 : null;
      }
      // Sector lookup for shared right rail (minimal map; extend as needed)
      function getTickerSector(ticker) {
        const T = String(ticker || "").trim().toUpperCase();
        if (!T) return "";
        const SECTOR_MAP = {
          XLK: "Information Technology", XLF: "Financials", XLY: "Consumer Discretionary",
          XLP: "Consumer Staples", XLE: "Energy", XLV: "Healthcare", XLI: "Industrials",
          XLB: "Basic Materials", XLRE: "Real Estate", XLU: "Utilities", XLC: "Communication Services",
          AAPL: "Information Technology", MSFT: "Information Technology", AMZN: "Consumer Discretionary",
          GOOGL: "Communication Services", META: "Communication Services", NVDA: "Information Technology",
        };
        return SECTOR_MAP[T] || "";
      }

      // Normalize sector names to match worker sector ratings (same as main dashboard).
      function normalizeSectorKey(sectorName) {
        const raw = String(sectorName || "").trim().toLowerCase().replace(/[-_/]+/g, " ").replace(/&/g, "and").replace(/\s+/g, " ");
        if (!raw) return "";
        const ALIASES = {
          "health care": "healthcare", healthcare: "healthcare", materials: "basic materials", "basic materials": "basic materials",
          "non energy minerals": "basic materials", "consumer durables": "consumer discretionary", "consumer non durables": "consumer staples",
          "consumer cyclical": "consumer discretionary", "consumer discretionary": "consumer discretionary", "consumer defensive": "consumer staples",
          "consumer staples": "consumer staples", "financial services": "financials", finance: "financials", financials: "financials",
          technology: "information technology", "technology services": "information technology", "electronic technology": "information technology",
          "information technology": "information technology", communications: "communication services", "communication services": "communication services",
          "energy minerals": "energy", energy: "energy", industrials: "industrials", utilities: "utilities", "real estate": "real estate",
        };
        return ALIASES[raw] || raw;
      }

      function sectorKeyToCanonicalName(key) {
        const K = String(key || "").trim().toLowerCase();
        const CANON = {
          "consumer discretionary": "Consumer Discretionary", industrials: "Industrials", "information technology": "Information Technology",
          "communication services": "Communication Services", "basic materials": "Basic Materials", energy: "Energy", financials: "Financials",
          "real estate": "Real Estate", "consumer staples": "Consumer Staples", healthcare: "Healthcare", utilities: "Utilities",
        };
        return CANON[K] || key;
      }

      function calculateTrade(ticker, entryPrice, existingTrade = null) {
        const directionObj = getDirection(ticker);
        const direction = directionObj.text;
        if (!direction) return null;

        const sl = Number(ticker.sl);
        const tp = Number(ticker.tp);
        const currentPrice = Number(ticker.price);

        if (
          !Number.isFinite(sl) ||
          !Number.isFinite(tp) ||
          !Number.isFinite(currentPrice)
        ) {
          return null;
        }

        // Determine if this is a futures contract
        const tickerSymbol = String(ticker.ticker || "").toUpperCase();
        const isFutures =
          FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");

        // For futures: trade 1 contract, calculate P&L based on point value
        // For stocks: calculate shares based on dollar amount
        let shares;
        let pointValue = 1; // Default for stocks (price per share)

        if (isFutures && FUTURES_SPECS[tickerSymbol]) {
          // Futures: always trade 1 contract
          shares = 1;
          pointValue = FUTURES_SPECS[tickerSymbol].pointValue;
        } else {
          // Stocks: calculate shares from dollar amount
          shares = TRADE_SIZE / entryPrice;
        }

        // Calculate P&L based on current price
        let pnl = 0;
        let pnlPct = 0;
        let status = "OPEN";

        // Check for partial trim (if position was already trimmed)
        const trimmedPct = existingTrade ? existingTrade.trimmedPct || 0 : 0;
        const remainingShares = shares * (1 - trimmedPct);

        // Calculate price differences (in points for futures, dollars for stocks)
        const priceDiff = currentPrice - entryPrice;
        const tpDiff = tp - entryPrice;
        const slDiff = sl - entryPrice;

        if (direction === "LONG") {
          // Check if hit TP or SL first
          const hitTP = currentPrice >= tp;
          const hitSL = currentPrice <= sl;

          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const trimPnl = tpDiff * shares * pointValue * 0.5;
              const trimPnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              pnl = tpDiff * shares * pointValue;
              pnlPct = ((tp - entryPrice) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            pnl = slDiff * shares * pointValue;
            pnlPct = ((sl - entryPrice) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            pnl = priceDiff * shares * pointValue;
            pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        } else {
          // SHORT
          // Check if hit TP or SL first
          const hitTP = currentPrice <= tp;
          const hitSL = currentPrice >= sl;

          if (hitTP) {
            // If not already trimmed, trim 50% at first TP hit
            if (trimmedPct === 0) {
              const shortTpDiff = entryPrice - tp;
              const trimPnl = shortTpDiff * shares * pointValue * 0.5;
              const trimPnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Return special status for trimming
              return {
                shares,
                pnl: trimPnl,
                pnlPct: trimPnlPct,
                status: "TP_HIT_TRIM",
                currentPrice,
                trimmedPct: 0.5, // Mark as 50% trimmed
              };
            } else {
              // Already trimmed, full exit at TP
              const shortTpDiff = entryPrice - tp;
              pnl = shortTpDiff * shares * pointValue;
              pnlPct = ((entryPrice - tp) / entryPrice) * 100;
              // Status based on actual P&L, not just TP hit
              status = pnl >= 0 ? "WIN" : "LOSS";
            }
          } else if (hitSL) {
            const shortSlDiff = entryPrice - sl;
            pnl = shortSlDiff * shares * pointValue;
            pnlPct = ((entryPrice - sl) / entryPrice) * 100;
            status = "LOSS";
          } else {
            // Still open - calculate current P&L
            const shortPriceDiff = entryPrice - currentPrice;
            pnl = shortPriceDiff * shares * pointValue;
            pnlPct = ((entryPrice - currentPrice) / entryPrice) * 100;
            status = "OPEN";
          }
        }

        return {
          shares,
          pnl,
          pnlPct,
          status,
          currentPrice,
        };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Trade Tracking
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Trade simulation is now handled by Worker - UI just fetches and displays
      // No need for useTradeSimulation hook anymore - Worker handles everything

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Analytics & Learning
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function useTradeAnalytics(trades) {
        return useMemo(() => {
          const EPS = 1e-6;

          const clamp01 = (x) => Math.max(0, Math.min(1, x));
          const smoothWinRate = (wins, losses) => {
            // Laplace smoothing (prevents noisy 1/1 = 100% claims)
            const w = Number(wins || 0);
            const l = Number(losses || 0);
            const n = w + l;
            return n > 0 ? (w + 1) / (n + 2) : 0;
          };
          const confidenceLabel = (n) => {
            if (n >= 30) return "high";
            if (n >= 10) return "medium";
            if (n >= 5) return "low";
            return "very low";
          };
          const getExitReason = (trade) => {
            if (!trade) return null;
            if (trade.exitReason) return String(trade.exitReason);
            const hist = trade.history;
            if (Array.isArray(hist)) {
              for (let i = hist.length - 1; i >= 0; i--) {
                const e = hist[i];
                if (e && e.type === "EXIT") {
                  if (e.reason) return String(e.reason);
                  const note = String(e.note || "");
                  const m = note.match(/\(([^)]+)\)\s*$/);
                  if (m && m[1]) return String(m[1]);
                }
              }
            }
            return null;
          };
          const hasTrimEvent = (trade) => {
            if (!trade) return false;
            if ((Number(trade.trimmedPct) || 0) > EPS) return true;
            const hist = trade.history;
            return (
              Array.isArray(hist) && hist.some((e) => e && e.type === "TRIM")
            );
          };

          const horizonKeyForTrade = (trade) => {
            if (!trade) return "UNKNOWN";
            return computeHorizonKey(trade);
          };

          const computeExcursions = (trade) => {
            if (!trade) return null;
            const entry = Number(trade.entryPrice);
            if (!Number.isFinite(entry) || entry <= 0) return null;
            const prices = [entry];
            if (Array.isArray(trade.history)) {
              trade.history.forEach((e) => {
                if (e && Number.isFinite(Number(e.price))) {
                  prices.push(Number(e.price));
                }
              });
            }
            const exit = Number(trade.exitPrice ?? trade.exit_price);
            if (Number.isFinite(exit)) prices.push(exit);
            const current = Number(trade.currentPrice);
            if (Number.isFinite(current)) prices.push(current);
            const maxP = Math.max(...prices);
            const minP = Math.min(...prices);
            const isLong =
              String(trade.direction || "").toUpperCase() !== "SHORT";
            const mfe = isLong ? maxP - entry : entry - minP;
            const mae = isLong ? entry - minP : maxP - entry;
            const mfePct = (mfe / entry) * 100;
            const maePct = (mae / entry) * 100;
            return {
              mfe: Number.isFinite(mfe) ? mfe : null,
              mae: Number.isFinite(mae) ? mae : null,
              mfePct: Number.isFinite(mfePct) ? mfePct : null,
              maePct: Number.isFinite(maePct) ? maePct : null,
            };
          };

          // Helper to check if trade has remaining shares/contracts (not fully closed)
          const hasRemainingShares = (t) => {
            const tickerSym = String(t.ticker || "").toUpperCase();
            const isFut = FUTURES_SPECS[tickerSym] || tickerSym.endsWith("1!");
            const shares =
              t.shares ||
              (isFut && FUTURES_SPECS[tickerSym]
                ? 1
                : TRADE_SIZE / (t.entryPrice || 1));
            const trimmedPct = t.trimmedPct || 0;
            const remainingShares = shares - shares * trimmedPct;
            return remainingShares > 0;
          };

          // Closed: WIN/LOSS or 100% trimmed (safety net)
          const isClosedStatus = (s) => s === "WIN" || s === "LOSS" || s === "FLAT";
          const closed = trades.filter((t) => {
            const trimmedPct = Number(t.trimmedPct ?? t.trimmed_pct ?? 0);
            return (
              isClosedStatus(t.status) ||
              trimmedPct >= 0.9999
            );
          });

          // Trimmed: partially trimmed, still has remaining shares
          const trimmed = trades.filter((t) => {
            const trimmedPct = Number(t.trimmedPct ?? t.trimmed_pct ?? 0);
            const isTrimmed = trimmedPct > 0 || t.status === "TP_HIT_TRIM";
            return isTrimmed && hasRemainingShares(t) && trimmedPct < 0.9999;
          });

          // Open: no trim, not closed
          const open = trades.filter((t) => {
            const trimmedPct = Number(t.trimmedPct ?? t.trimmed_pct ?? 0);
            const isTrimmed = trimmedPct > 0 || t.status === "TP_HIT_TRIM";
            const isClosed =
              isClosedStatus(t.status) ||
              trimmedPct >= 0.9999;
            return (
              (t.status === "OPEN" || !t.status) && !isTrimmed && !isClosed
            );
          });

          const openTrades = open.length;
          const trimmedTrades = trimmed.length;
          const closedTrades = closed.length;
          const totalTrades = openTrades + trimmedTrades + closedTrades; // Sum of all categories

          const wins = closed.filter((t) => t.status === "WIN").length;
          const losses = closed.filter((t) => t.status === "LOSS").length;
          const flats = closed.filter((t) => t.status === "FLAT").length;
          const decisiveTrades = wins + losses; // Exclude flats from win rate calculation
          const winRate = decisiveTrades > 0 ? (wins / decisiveTrades) * 100 : 0;

          // Calculate Closed P&L: includes fully closed trades + realized P&L from trimmed positions
          const closedPnl = closed.reduce((sum, t) => sum + (t.pnl || 0), 0);

          // Calculate realized P&L from trimmed positions
          const trimmedRealizedPnl = trimmed.reduce((sum, t) => {
            const tickerSym = String(t.ticker || "").toUpperCase();
            const isFut = FUTURES_SPECS[tickerSym] || tickerSym.endsWith("1!");
            const pointVal =
              isFut && FUTURES_SPECS[tickerSym]
                ? FUTURES_SPECS[tickerSym].pointValue
                : 1;
            const shares =
              t.shares ||
              (isFut && FUTURES_SPECS[tickerSym]
                ? 1
                : TRADE_SIZE / (t.entryPrice || 1));
            const trimmedPct = t.trimmedPct || 0;
            const trimmedShares = shares * trimmedPct;
            const entryPrice = t.entryPrice || 0;
            const tp = t.tp || entryPrice; // Use TP price where trimmed occurred

            if (trimmedShares > 0 && entryPrice > 0) {
              const direction = t.direction || "LONG";
              if (direction === "LONG") {
                // LONG: profit = (TP - Entry) * trimmed shares * point value
                const priceDiff = tp - entryPrice;
                return sum + priceDiff * trimmedShares * pointVal;
              } else {
                // SHORT: profit = (Entry - TP) * trimmed shares * point value
                const priceDiff = entryPrice - tp;
                return sum + priceDiff * trimmedShares * pointVal;
              }
            }
            return sum;
          }, 0);

          // Total Closed P&L = fully closed + trimmed realized
          const totalPnl = closedPnl + trimmedRealizedPnl;

          // Open P&L: prefer D1 pre-computed pnl (accurate from replay) over client-side calculation
          const openPnl = [...open, ...trimmed].reduce((sum, t) => {
            // Use stored P&L if available (from replay/trade engine)
            const storedPnl = Number(t.pnl ?? t.pnl_amount);
            if (Number.isFinite(storedPnl)) return sum + storedPnl;

            // Fallback: compute from currentPrice
            const shares = t.shares || TRADE_SIZE / (t.entryPrice || 1);
            const trimmedPct = t.trimmedPct || 0;
            const remainingShares = shares - shares * trimmedPct;
            const entryPrice = t.entryPrice || 0;
            const currentPrice = t.currentPrice || entryPrice;

            if (remainingShares > 0 && entryPrice > 0) {
              const direction = t.direction || "LONG";
              if (direction === "LONG") {
                return sum + (currentPrice - entryPrice) * remainingShares;
              } else {
                return sum + (entryPrice - currentPrice) * remainingShares;
              }
            }
            return sum;
          }, 0);

          // Calculate average win/loss
          const winningTrades = closed.filter((t) => t.status === "WIN");
          const losingTrades = closed.filter((t) => t.status === "LOSS");
          const avgWin =
            winningTrades.length > 0
              ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) /
                winningTrades.length
              : 0;
          const avgLoss =
            losingTrades.length > 0
              ? losingTrades.reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0) /
                losingTrades.length
              : 0;
          const profitFactor =
            avgLoss > 0 ? avgWin / avgLoss : avgWin > 0 ? Infinity : 0;

          const excursionStats = closed
            .map((t) => computeExcursions(t))
            .filter(Boolean);
          const avgMfePct =
            excursionStats.length > 0
              ? excursionStats.reduce((s, x) => s + (x.mfePct || 0), 0) /
                excursionStats.length
              : 0;
          const avgMaePct =
            excursionStats.length > 0
              ? excursionStats.reduce((s, x) => s + (x.maePct || 0), 0) /
                excursionStats.length
              : 0;

          const capturedStats = closed
            .map((t) => {
              const entry = Number(t.entryPrice);
              const exit = Number(t.exitPrice ?? t.exit_price);
              const target = Number(t.tp_target_price ?? t.tp);
              if (
                !Number.isFinite(entry) ||
                !Number.isFinite(exit) ||
                !Number.isFinite(target)
              )
                return null;
              const isLong =
                String(t.direction || "").toUpperCase() !== "SHORT";
              const denom = isLong ? target - entry : entry - target;
              const num = isLong ? exit - entry : entry - exit;
              if (!Number.isFinite(denom) || Math.abs(denom) < EPS) return null;
              const pct = (num / denom) * 100;
              return Number.isFinite(pct) ? pct : null;
            })
            .filter((v) => Number.isFinite(v));
          const avgCapturedPct =
            capturedStats.length > 0
              ? capturedStats.reduce((s, v) => s + v, 0) / capturedStats.length
              : 0;

          const horizonStats = {};
          for (const t of closed) {
            const key = horizonKeyForTrade(t);
            if (!horizonStats[key]) {
              horizonStats[key] = {
                n: 0,
                wins: 0,
                losses: 0,
                totalPnl: 0,
                mfePct: 0,
                maePct: 0,
                capturedPct: 0,
                capturedN: 0,
              };
            }
            const bucket = horizonStats[key];
            bucket.n += 1;
            if (t.status === "WIN") bucket.wins += 1;
            if (t.status === "LOSS") bucket.losses += 1;
            bucket.totalPnl += Number(t.pnl || 0);
            const ex = computeExcursions(t);
            if (ex && Number.isFinite(ex.mfePct)) bucket.mfePct += ex.mfePct;
            if (ex && Number.isFinite(ex.maePct)) bucket.maePct += ex.maePct;
            const entry = Number(t.entryPrice);
            const exit = Number(t.exitPrice ?? t.exit_price);
            const target = Number(t.tp_target_price ?? t.tp);
            const isLong = String(t.direction || "").toUpperCase() !== "SHORT";
            if (
              Number.isFinite(entry) &&
              Number.isFinite(exit) &&
              Number.isFinite(target)
            ) {
              const denom = isLong ? target - entry : entry - target;
              const num = isLong ? exit - entry : entry - exit;
              if (Number.isFinite(denom) && Math.abs(denom) > EPS) {
                bucket.capturedPct += (num / denom) * 100;
                bucket.capturedN += 1;
              }
            }
          }

          Object.keys(horizonStats).forEach((key) => {
            const s = horizonStats[key];
            const n = Math.max(1, s.n);
            const winRateH = s.n > 0 ? (s.wins / s.n) * 100 : 0;
            const avgWinH =
              s.wins > 0
                ? closed
                    .filter(
                      (t) =>
                        horizonKeyForTrade(t) === key && t.status === "WIN",
                    )
                    .reduce((sum, t) => sum + (t.pnl || 0), 0) / s.wins
                : 0;
            const avgLossH =
              s.losses > 0
                ? closed
                    .filter(
                      (t) =>
                        horizonKeyForTrade(t) === key && t.status === "LOSS",
                    )
                    .reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0) /
                  s.losses
                : 0;
            s.winRate = winRateH;
            s.expectancy =
              (winRateH / 100) * avgWinH - (1 - winRateH / 100) * avgLossH;
            s.avgMfePct = s.mfePct / n;
            s.avgMaePct = s.maePct / n;
            s.avgCapturedPct =
              s.capturedN > 0 ? s.capturedPct / s.capturedN : 0;
          });

          // Analyze by signal combinations
          const signalAnalysis = {};
          closed.forEach((trade) => {
            const signals = [];
            if (trade.flags?.sq30_release) signals.push("SqueezeRelease");
            if (trade.flags?.sq30_on) signals.push("SqueezeOn");
            if (trade.flags?.phase_zone_change) signals.push("PhaseZoneChange");
            if (trade.inCorridor) signals.push("InCorridor");
            const key = signals.sort().join("+") || "None";

            if (!signalAnalysis[key]) {
              signalAnalysis[key] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") signalAnalysis[key].wins++;
            if (trade.status === "LOSS") signalAnalysis[key].losses++;
            signalAnalysis[key].totalPnl += trade.pnl || 0;
          });

          // Analyze by RR ranges
          const rrAnalysis = {};
          closed.forEach((trade) => {
            const rr = trade.rr || 0;
            let range = "Unknown";
            if (rr >= 2.0) range = "RR â‰¥ 2.0";
            else if (rr >= 1.5) range = "RR 1.5-2.0";
            else if (rr >= 1.0) range = "RR 1.0-1.5";
            else if (rr > 0) range = "RR < 1.0";

            if (!rrAnalysis[range]) {
              rrAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rrAnalysis[range].wins++;
            if (trade.status === "LOSS") rrAnalysis[range].losses++;
            rrAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Analyze by rank ranges
          const rankAnalysis = {};
          closed.forEach((trade) => {
            const rank = trade.rank || 0;
            let range = "Unknown";
            if (rank >= 80) range = "Rank â‰¥ 80";
            else if (rank >= 70) range = "Rank 70-80";
            else if (rank >= 60) range = "Rank 60-70";
            else if (rank > 0) range = "Rank < 60";

            if (!rankAnalysis[range]) {
              rankAnalysis[range] = { wins: 0, losses: 0, totalPnl: 0 };
            }
            if (trade.status === "WIN") rankAnalysis[range].wins++;
            if (trade.status === "LOSS") rankAnalysis[range].losses++;
            rankAnalysis[range].totalPnl += trade.pnl || 0;
          });

          // Generate recommendations
          const recommendations = { filters: [], management: [] };

          const pushRec = (bucket, rec) => {
            if (!bucket || !recommendations[bucket]) return;
            recommendations[bucket].push(rec);
          };

          // Find best performing signal combinations
          const bestSignals = Object.entries(signalAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5) // Reduce noise
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              // Prefer higher winrate, then larger sample, then higher pnl
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })
            .slice(0, 3);

          if (bestSignals.length > 0) {
            const [sigKey, stats] = bestSignals[0];
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (wr >= 0.55 && n >= 5) {
              pushRec("filters", {
                type: "signal",
                priority: n >= 15 ? "high" : "medium",
                message: `Filters: Favor ${sigKey} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)} per trade, n=${n}, confidence ${confidenceLabel(n)})`,
              });
            }
          }

          // Find best RR range
          const bestRR = Object.entries(rrAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5)
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })[0];

          if (bestRR) {
            const [range, stats] = bestRR;
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (n >= 5 && (wr >= 0.52 || avgPnl > 0)) {
              pushRec("filters", {
                type: "rr",
                priority: n >= 15 ? "medium" : "low",
                message: `Filters: RR sweet spot looks like ${range} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)}, n=${n})`,
              });
            }
          }

          // Find best rank range
          const bestRank = Object.entries(rankAnalysis)
            .filter(([_, stats]) => stats.wins + stats.losses >= 5)
            .sort((a, b) => {
              const aN = a[1].wins + a[1].losses;
              const bN = b[1].wins + b[1].losses;
              const aRate = smoothWinRate(a[1].wins, a[1].losses);
              const bRate = smoothWinRate(b[1].wins, b[1].losses);
              if (bRate !== aRate) return bRate - aRate;
              if (bN !== aN) return bN - aN;
              return (b[1].totalPnl || 0) - (a[1].totalPnl || 0);
            })[0];

          if (bestRank) {
            const [range, stats] = bestRank;
            const n = stats.wins + stats.losses;
            const wr = smoothWinRate(stats.wins, stats.losses);
            const avgPnl = n > 0 ? (stats.totalPnl || 0) / n : 0;
            if (n >= 5 && (wr >= 0.52 || avgPnl > 0)) {
              pushRec("filters", {
                type: "rank",
                priority: n >= 15 ? "medium" : "low",
                message: `Filters: Best rank bucket so far is ${range} (smoothed win rate ${(wr * 100).toFixed(1)}%, avg $${avgPnl.toFixed(2)}, n=${n})`,
              });
            }
          }

          // Profit factor recommendations - only show if we have enough closed trades to analyze
          if (profitFactor < 1.0 && closedTrades >= 10) {
            pushRec("filters", {
              type: "risk",
              priority: "high",
              message: `Profit factor is ${profitFactor.toFixed(2)}. Consider tightening stops or improving entry selection.`,
            });
          }

          // Win rate recommendations - only show if we have enough closed trades to analyze
          if (winRate < 40 && closedTrades >= 10) {
            pushRec("filters", {
              type: "filter",
              priority: "high",
              message: `Win rate is ${winRate.toFixed(1)}%. Consider raising minimum rank threshold or requiring squeeze release.`,
            });
          }

          // Management learning (post-entry): trims + exit reasons
          if (closedTrades >= 5) {
            const closedWithTrim = closed.filter((t) => hasTrimEvent(t));
            const closedNoTrim = closed.filter((t) => !hasTrimEvent(t));

            const summarize = (arr) => {
              const n = arr.length;
              const w = arr.filter((t) => t.status === "WIN").length;
              const l = arr.filter((t) => t.status === "LOSS").length;
              const wr = smoothWinRate(w, l);
              const totalP = arr.reduce((s, t) => s + (t.pnl || 0), 0);
              const avgP = n > 0 ? totalP / n : 0;
              return { n, w, l, wr, avgP };
            };

            const trimStats = summarize(closedWithTrim);
            const noTrimStats = summarize(closedNoTrim);
            if (trimStats.n >= 5 || noTrimStats.n >= 5) {
              const better =
                trimStats.n >= 5 && noTrimStats.n >= 5
                  ? trimStats.avgP - noTrimStats.avgP
                  : 0;
              if (
                trimStats.n >= 5 &&
                noTrimStats.n >= 5 &&
                Math.abs(better) > 1e-9
              ) {
                pushRec("management", {
                  type: "trim_vs_no_trim",
                  priority: "medium",
                  message: `Management: Trades with trims avg $${trimStats.avgP.toFixed(2)} (n=${trimStats.n}) vs no-trim avg $${noTrimStats.avgP.toFixed(2)} (n=${noTrimStats.n}). ${better > 0 ? "Trimming is helping." : "Trimming may be hurting."}`,
                });
              } else if (trimStats.n >= 5 && noTrimStats.n < 5) {
                pushRec("management", {
                  type: "trim_data",
                  priority: "low",
                  message: `Management: Most closed trades include trims (n=${trimStats.n}). Keep logging trims + exits to learn hold/trim improvements.`,
                });
              }
            }

            const exitReasonStats = {};
            closed.forEach((t) => {
              const r = getExitReason(t) || "UNKNOWN";
              if (!exitReasonStats[r])
                exitReasonStats[r] = { n: 0, wins: 0, losses: 0, pnl: 0 };
              exitReasonStats[r].n += 1;
              if (t.status === "WIN") exitReasonStats[r].wins += 1;
              if (t.status === "LOSS") exitReasonStats[r].losses += 1;
              exitReasonStats[r].pnl += t.pnl || 0;
            });

            const topExit = Object.entries(exitReasonStats)
              .filter(([_, s]) => s.n >= 3)
              .sort((a, b) => (b[1].pnl || 0) - (a[1].pnl || 0))[0];

            if (topExit) {
              const [reason, s] = topExit;
              const wr = smoothWinRate(s.wins, s.losses);
              const avgP = s.n > 0 ? (s.pnl || 0) / s.n : 0;
              pushRec("management", {
                type: "exit_reason",
                priority: reason === "SL" ? "high" : "low",
                message: `Management: Exit reason ${reason} avg $${avgP.toFixed(2)} (smoothed win rate ${(wr * 100).toFixed(1)}%, n=${s.n}).`,
              });
            }
          } else {
            pushRec("management", {
              type: "needs_data",
              priority: "low",
              message: `Management: Need more closed trades (currently n=${closedTrades}) to learn trim/exit improvements reliably.`,
            });
          }

          return {
            totalTrades,
            openTrades,
            trimmedTrades,
            closedTrades,
            wins,
            losses,
            winRate,
            totalPnl,
            openPnl,
            avgWin,
            avgLoss,
            profitFactor,
            avgMfePct,
            avgMaePct,
            avgCapturedPct,
            horizonStats,
            signalAnalysis,
            rrAnalysis,
            rankAnalysis,
            recommendations,
          };
        }, [trades]);
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Components
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Format RR display (e.g., "2.10:1" or "1:2.10")
      function formatRR(rr) {
        if (!rr || !Number.isFinite(rr)) return "N/A";
        if (rr >= 1) {
          return `${rr.toFixed(2)}:1`;
        } else {
          return `1:${(1 / rr).toFixed(2)}`;
        }
      }

      // Trade History Component (entry, add entry, trim, exit with full details)
      function TradeHistory({ history = [], fmtUsd: fmt }) {
        const fmtUsd = fmt || (v => (Number.isFinite(Number(v)) ? new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(Number(v)) : "â€”"));
        if (!history || history.length === 0) {
          return (
            <div className="text-xs text-[var(--tt-text-faint)] italic p-2">
              No history available
            </div>
          );
        }

        const getEventIcon = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "ðŸ“¥";
          if (t === "SCALE_IN" || t === "ADD_ENTRY") return "âž•";
          if (t === "TRIM") return "âœ‚ï¸";
          if (t === "EXIT") return "ðŸ“¤";
          return "â€¢";
        };

        const getEventColor = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "text-[var(--tt-accent)]";
          if (t === "SCALE_IN" || t === "ADD_ENTRY") return "text-[var(--tt-text)]";
          if (t === "TRIM") return "text-[var(--tt-text-muted)]";
          if (t === "EXIT") return "text-[var(--tt-negative)]";
          return "text-[var(--tt-text-muted)]";
        };

        return (
          <div className="space-y-2 max-h-[400px] overflow-y-auto">
            {history.map((event, idx) => {
              const eventDate = new Date(event.timestamp);
              const formattedDate = eventDate.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
              });
              const formattedTime = eventDate.toLocaleTimeString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                hour12: true,
              });

              return (
                <div
                  key={idx}
                  className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-3"
                >
                  <div className="flex items-start gap-3">
                    <div className={`text-xl ${getEventColor(event.type)}`}>
                      {getEventIcon(event.type)}
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center justify-between mb-1">
                        <span
                          className={`text-sm font-semibold ${getEventColor(event.type)}`}
                        >
                          {event.type.replace("_", " ")}
                        </span>
                        <span className="text-xs text-[var(--tt-text-faint)]">
                          {formattedDate} {formattedTime}
                        </span>
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mb-2">
                        {event.note}
                      </div>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 text-xs">
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Price:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            ${Number(event.price).toFixed(2)}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Shares:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            {event.shares}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Value:</span>
                          <span className="ml-1 font-semibold text-[var(--tt-text)]">
                            ${Number(event.value).toFixed(2)}
                          </span>
                        </div>
                        {event.pnl_realized != null && Number.isFinite(Number(event.pnl_realized)) && (
                          <div className="sm:col-span-2">
                            <span className="text-[var(--tt-text-faint)]">Net P&L:</span>
                            <span className={`ml-1 font-semibold ${Number(event.pnl_realized) >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                              {fmtUsd(Number(event.pnl_realized))}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      // Ledger trade history (date asc): execution timeline â€” mirrors Trade Journey image (cards with type Â· date time, then details)
      function LedgerTradeHistory({ events = [], trade = null, fmtUsd }) {
        if (!events || events.length === 0) {
          return (
            <div className="text-xs text-[var(--tt-text-faint)] italic p-3">
              No actions yet for this position.
            </div>
          );
        }
        const sorted = [...events].sort((a, b) => (a.ts || 0) - (b.ts || 0));
        const actionLabel = (type) => {
          const t = String(type || "").toUpperCase();
          if (t === "ENTRY") return "Entry";
          if (t === "ADD_ENTRY" || t === "SCALE_IN") return "Add entry";
          if (t === "TRIM") return "Trim";
          if (t === "EXIT") return "Exit";
          return t || "â€”";
        };
        return (
          <div className="space-y-3 max-h-[400px] overflow-y-auto">
            {sorted.map((ev, idx) => {
              const d = ev.ts != null ? new Date(Number(ev.ts)) : null;
              const dateStr = d ? d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "â€”";
              const timeStr = d ? d.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true }) : "â€”";
              const t = ev.trade || trade || {};
              const qty = ev.shares ?? ev.qty ?? (t.shares != null ? t.shares : (t.entry_price > 0 ? Math.round(TRADE_SIZE / t.entry_price) : null));
              const price = ev.price != null ? Number(ev.price) : (ev.type === "ENTRY" || ev.type === "ADD_ENTRY" || ev.type === "SCALE_IN" ? Number(t.entry_price ?? t.entryPrice) : ev.type === "EXIT" ? Number(t.exit_price ?? t.exitPrice) : null);
              const value = ev.value != null ? Number(ev.value) : (Number.isFinite(price) && Number.isFinite(qty) ? price * qty : null);
              const pnl = ev.pnl_realized != null ? Number(ev.pnl_realized) : null;
              const trimmedPct = ev.trimmed_pct != null ? Number(ev.trimmed_pct) : (t.trimmed_pct != null ? Number(t.trimmed_pct) : (t.trimmedPct != null ? Number(t.trimmedPct) : null));
              const label = actionLabel(ev.type);
              const typeUpper = String(ev.type || "").toUpperCase();
              return (
                <div
                  key={idx}
                  className="rounded-lg p-3 border border-[var(--tt-border)] bg-[var(--tt-bg-surface)]"
                >
                  <div className="font-medium text-white text-sm">
                    {label} Â· {dateStr} {timeStr}
                  </div>
                  <div className="mt-1.5 space-y-0.5 text-xs text-[var(--tt-text-muted)]">
                    {Number.isFinite(price) && <div>Price: {fmtUsd(price)}</div>}
                    {Number.isFinite(value) && <div>Value: {fmtUsd(value)}</div>}
                    {Number.isFinite(qty) && <div>Qty: {Number(qty).toFixed(FUTURES_SPECS[t?.ticker] ? 0 : 4)}</div>}
                    {typeUpper === "TRIM" && (() => {
                      const pct = trimmedPct ?? t.trimmed_pct ?? t.trimmedPct;
                      if (pct == null || !Number.isFinite(Number(pct))) return null;
                      return <div>Trimmed {Math.round(Number(pct) * 100)}%</div>;
                    })()}
                    {Number.isFinite(pnl) && (
                      <div className={pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>
                        Net P&L: {fmtUsd(pnl)}
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      // Universal Right Rail (shared component from shared-right-rail.js)
      const _fmtUsd = typeof fmtUsd === "function" ? fmtUsd : (v) => (Number.isFinite(Number(v)) ? new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(Number(v)) : "â€”");
      const _fmtUsdAbs = typeof fmtUsdAbs === "function" ? fmtUsdAbs : (n) => (Number.isFinite(Number(n)) ? `$${Math.abs(Number(n)).toFixed(2)}` : "â€”");
      const TickerDetailRightRail = window.TickerDetailRightRailFactory({
        React,
        API_BASE,
        fmtUsd: _fmtUsd,
        fmtUsdAbs: _fmtUsdAbs,
        getDailyChange,
        isPrimeBubble,
        entryType,
        getActionDescription,
        rankScoreForTicker,
        getRankedTickers,
        getRankPosition,
        getRankPositionFromMap,
        detectPatterns,
        normalizeTrailPoints,
        phaseToColor,
        completionForSize,
        computeHorizonBucket,
        computeEtaDays,
        computeReturnPct,
        computeRiskPct,
        computeTpTargetPrice,
        computeTpMaxPrice,
        summarizeEntryDecision,
        getDirectionFromState,
        getDirection,
        numFromAny,
        groupsForTicker,
        GROUP_ORDER,
        GROUP_LABELS,
        TRADE_SIZE,
        FUTURES_SPECS,
        getStaleInfo,
        isNyRegularMarketOpen,
        downsampleByInterval,
        getTickerSector,
        normalizeSectorKey,
        sectorKeyToCanonicalName,
      });

      function TradeRow({ trade, tickerData, onTickerClick, onTradeClick }) {
        const pnlColor = trade.pnl >= 0 ? "text-green-400" : "text-red-400";
        const statusColor =
          trade.status === "WIN"
            ? "text-green-400"
            : trade.status === "LOSS"
              ? "text-red-400"
              : trade.status === "TP_HIT_TRIM"
                ? "text-blue-400"
                : "text-yellow-400";

        // Determine if this is a futures contract
        const tickerSymbol = String(trade.ticker || "").toUpperCase();
        const isFutures =
          FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");
        const pointValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? FUTURES_SPECS[tickerSymbol].pointValue
            : 1;

        // Metrics derived from latest ticker data (preferred) or trade data
        const metricsSource = tickerData || trade;
        const horizon = computeHorizonBucket(metricsSource);
        const eta = computeEtaDays(metricsSource);
        const retPct = computeReturnPct(metricsSource);
        const riskPct = computeRiskPct(metricsSource);
        const tpTarget = computeTpTargetPrice(metricsSource);
        const avgCorr = Number(metricsSource?.avg_corr);
        const diversity = Number(metricsSource?.diversity_score);
        const exitPrice = Number(trade.exitPrice ?? trade.exit_price);
        const trimPrice = Number(trade.trimPrice ?? trade.trim_price);

        // Calculate position values
        // For futures: shares = contracts (always 1), for stocks: calculate from TRADE_SIZE
        const shares =
          trade.shares ||
          (isFutures && FUTURES_SPECS[tickerSymbol]
            ? 1
            : TRADE_SIZE / (trade.entryPrice || 1));
        const currentPrice = trade.currentPrice || trade.entryPrice;

        // For futures: value calculation is different (contracts * point value * price)
        // For stocks: shares * price
        const marketValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? shares * currentPrice * pointValue
            : shares * currentPrice;
        const entryValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? shares * trade.entryPrice * pointValue
            : shares * trade.entryPrice;
        const trimmedPct = trade.trimmedPct || 0;
        const trimmedShares = shares * trimmedPct;
        const remainingShares = shares - trimmedShares;
        const trimmedValue =
          trimmedShares > 0
            ? isFutures && FUTURES_SPECS[tickerSymbol]
              ? trimmedShares * (trade.tp || currentPrice) * pointValue
              : trimmedShares * (trade.tp || currentPrice)
            : 0;
        const currentMarketValue =
          isFutures && FUTURES_SPECS[tickerSymbol]
            ? remainingShares * currentPrice * pointValue
            : remainingShares * currentPrice;

        // Recalculate P&L using correct futures logic (override stored value)
        // Note: trimmedPct is already declared above (line 1336)
        let recalculatedPnl = 0;
        let recalculatedPnlPct = 0;
        const priceDiff = currentPrice - trade.entryPrice;

        if (trade.direction === "LONG") {
          const hitTP = currentPrice >= trade.tp;
          const hitSL = currentPrice <= trade.sl;

          if (hitTP) {
            if (trimmedPct === 0) {
              // First TP hit - trim 50%
              const tpDiff = trade.tp - trade.entryPrice;
              recalculatedPnl = tpDiff * shares * pointValue * 0.5;
              recalculatedPnlPct =
                ((trade.tp - trade.entryPrice) / trade.entryPrice) * 100;
            } else {
              // Already trimmed - full exit at TP
              const tpDiff = trade.tp - trade.entryPrice;
              recalculatedPnl = tpDiff * shares * pointValue;
              recalculatedPnlPct =
                ((trade.tp - trade.entryPrice) / trade.entryPrice) * 100;
            }
          } else if (hitSL) {
            const slDiff = trade.sl - trade.entryPrice;
            recalculatedPnl = slDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.sl - trade.entryPrice) / trade.entryPrice) * 100;
          } else {
            // Still open - calculate current P&L
            recalculatedPnl = priceDiff * shares * pointValue;
            recalculatedPnlPct =
              ((currentPrice - trade.entryPrice) / trade.entryPrice) * 100;
          }
        } else {
          // SHORT
          const hitTP = currentPrice <= trade.tp;
          const hitSL = currentPrice >= trade.sl;

          if (hitTP) {
            if (trimmedPct === 0) {
              // First TP hit - trim 50%
              const tpDiff = trade.entryPrice - trade.tp;
              recalculatedPnl = tpDiff * shares * pointValue * 0.5;
              recalculatedPnlPct =
                ((trade.entryPrice - trade.tp) / trade.entryPrice) * 100;
            } else {
              // Already trimmed - full exit at TP
              const tpDiff = trade.entryPrice - trade.tp;
              recalculatedPnl = tpDiff * shares * pointValue;
              recalculatedPnlPct =
                ((trade.entryPrice - trade.tp) / trade.entryPrice) * 100;
            }
          } else if (hitSL) {
            const slDiff = trade.entryPrice - trade.sl;
            recalculatedPnl = slDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.entryPrice - trade.sl) / trade.entryPrice) * 100;
          } else {
            // Still open - calculate current P&L
            const shortPriceDiff = trade.entryPrice - currentPrice;
            recalculatedPnl = shortPriceDiff * shares * pointValue;
            recalculatedPnlPct =
              ((trade.entryPrice - currentPrice) / trade.entryPrice) * 100;
          }
        }

        // Parse entryTime - now uses current time when trade was created (not trigger_ts)
        const entryDate = new Date(trade.entryTime);
        const formattedDate = entryDate.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric",
          year: "numeric",
        });
        const formattedTime = entryDate.toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });

        return (
          <tr
            className="border-b border-[var(--tt-border)] hover:bg-[var(--tt-bg-elevated)] cursor-pointer transition-colors"
            onClick={() => {
              if (onTradeClick) onTradeClick(trade);
              else if (onTickerClick) onTickerClick(trade.ticker);
            }}
          >
            <td className="p-2 text-sm">{trade.ticker}</td>
            <td className="p-2 text-sm">
              <span
                className={`px-2 py-1 rounded text-xs ${
                  trade.direction === "LONG"
                    ? "bg-green-500/20 text-green-400"
                    : "bg-red-500/20 text-red-400"
                }`}
              >
                {trade.direction}
              </span>
            </td>
            <td className="p-2 text-sm">${trade.entryPrice.toFixed(2)}</td>
            <td className="p-2 text-sm">${currentPrice.toFixed(2)}</td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)]">
              <div className="font-semibold text-white">{formattedDate}</div>
              <div className="text-[var(--tt-text-faint)]">{formattedTime}</div>
            </td>
            <td className="p-2 text-sm font-mono">
              {isFutures && FUTURES_SPECS[tickerSymbol] ? (
                <>
                  <div className="text-xs text-[var(--tt-text-muted)]">
                    Total: {shares.toFixed(0)} contract{shares !== 1 ? "s" : ""}
                  </div>
                  {trimmedShares > 0 && (
                    <div className="text-xs text-blue-400">
                      Remaining: {remainingShares.toFixed(2)} contract
                      {remainingShares !== 1 ? "s" : ""}
                    </div>
                  )}
                </>
              ) : (
                <>
                  <div className="text-xs text-[var(--tt-text-muted)]">
                    Total: {shares.toFixed(4)}
                  </div>
                  {trimmedShares > 0 && (
                    <div className="text-xs text-blue-400">
                      Remaining: {remainingShares.toFixed(4)}
                    </div>
                  )}
                </>
              )}
            </td>
            <td className="p-2 text-sm">
              <div className="text-xs text-[var(--tt-text-muted)]">
                Entry: ${entryValue.toFixed(2)}
              </div>
              <div
                className={`font-semibold ${trade.status === "OPEN" || trade.status === "TP_HIT_TRIM" ? "text-yellow-400" : ""}`}
              >
                Current: ${currentMarketValue.toFixed(2)}
              </div>
            </td>
            <td className="p-2 text-sm">
              {trimmedShares > 0 ? (
                <div className="text-xs text-blue-400">
                  <div>${trimmedValue.toFixed(2)}</div>
                  <div className="text-[var(--tt-text-muted)]">
                    ({(trimmedPct * 100).toFixed(0)}%)
                  </div>
                </div>
              ) : (
                <span className="text-xs text-[var(--tt-text-faint)]">-</span>
              )}
            </td>
            <td className="p-2 text-sm">${trade.sl.toFixed(2)}</td>
            <td
              className="p-2 text-sm"
              title={tpList ? `TP Levels: ${tpList}` : ""}
            >
              $
              {Number.isFinite(tpTarget)
                ? tpTarget.toFixed(2)
                : trade.tp.toFixed(2)}
            </td>
            <td className="p-2 text-sm text-green-400">
              {Number.isFinite(retPct) ? `${retPct.toFixed(1)}%` : "â€”"}
            </td>
            <td className="p-2 text-sm text-red-400">
              {Number.isFinite(riskPct) ? `${riskPct.toFixed(1)}%` : "â€”"}
            </td>
            <td className="p-2 text-sm">
              {Number.isFinite(eta) ? `${eta.toFixed(1)}d` : "â€”"}
            </td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)]">{horizon}</td>
            <td className="p-2 text-sm text-[var(--tt-text-muted)]">
              {Number.isFinite(diversity) ? Math.round(diversity) : "â€”"}
            </td>
            <td className="p-2 text-sm text-[var(--tt-text-muted)]">
              {Number.isFinite(avgCorr) ? avgCorr.toFixed(2) : "â€”"}
            </td>
            <td className="p-2 text-sm">{formatRR(trade.rr)}</td>
            <td className="p-2 text-sm">{trade.rank}</td>
            <td
              className={`p-2 text-sm font-semibold ${recalculatedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
            >
              ${recalculatedPnl.toFixed(2)}
            </td>
            <td
              className={`p-2 text-sm font-semibold ${recalculatedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
            >
              {recalculatedPnlPct.toFixed(2)}%
            </td>
            <td className={`p-2 text-sm font-semibold ${statusColor}`}>
              <div>
                {trade.status === "TP_HIT_TRIM"
                  ? `TRIMMED (${((trade.trimmedPct || 0) * 100).toFixed(0)}%)`
                  : trade.status || "OPEN"}
              </div>
              {trade.status === "TP_HIT_TRIM" && Number.isFinite(trimPrice) && (
                <div className="text-[10px] text-yellow-300">
                  Trim @ ${trimPrice.toFixed(2)}
                </div>
              )}
              {(trade.status === "WIN" || trade.status === "LOSS") &&
                Number.isFinite(exitPrice) && (
                  <div className="text-[10px] text-purple-300">
                    Exit @ ${exitPrice.toFixed(2)}
                  </div>
                )}
            </td>
            <td className="p-2 text-xs text-[var(--tt-text-muted)] font-mono">
              {trade.scriptVersion || "unknown"}
            </td>
          </tr>
        );
      }

      function AnalyticsPanel({ analytics }) {
        return (
          <div className="space-y-4">
            {/* Overall Stats */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Overall Performance</h3>
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-4">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Total Trades</div>
                  <div className="text-2xl font-bold">
                    {analytics.totalTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Open Trades</div>
                  <div className="text-2xl font-bold text-yellow-400">
                    {analytics.openTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Trimmed Trades</div>
                  <div className="text-2xl font-bold text-blue-400">
                    {analytics.trimmedTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Closed Trades</div>
                  <div className="text-2xl font-bold text-white">
                    {analytics.closedTrades}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Win Rate</div>
                  <div className="text-2xl font-bold text-green-400">
                    {analytics.winRate.toFixed(1)}%
                  </div>
                </div>
              </div>
              <div className="grid grid-cols-2 md:grid-cols-2 gap-4 pt-4 border-t border-[var(--tt-border)]">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Closed P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.totalPnl >= 0
                        ? "text-green-400"
                        : "text-red-400"
                    }`}
                  >
                    ${analytics.totalPnl.toFixed(2)}
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Open P&L</div>
                  <div
                    className={`text-2xl font-bold ${
                      analytics.openPnl >= 0
                        ? "text-green-400"
                        : "text-yellow-400"
                    }`}
                  >
                    ${analytics.openPnl.toFixed(2)}
                  </div>
                </div>
              </div>
              {analytics.totalTrades > 0 && (
                <div className="grid grid-cols-2 md:grid-cols-3 gap-4 pt-4 border-t border-[var(--tt-border)]">
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Avg Win</div>
                    <div className="text-lg font-bold text-green-400">
                      ${analytics.avgWin.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Avg Loss</div>
                    <div className="text-lg font-bold text-red-400">
                      ${analytics.avgLoss.toFixed(2)}
                    </div>
                  </div>
                  <div>
                    <div className="text-xs text-[var(--tt-text-muted)]">Profit Factor</div>
                    <div
                      className={`text-lg font-bold ${
                        analytics.profitFactor >= 1.5
                          ? "text-green-400"
                          : analytics.profitFactor >= 1.0
                            ? "text-yellow-400"
                            : "text-red-400"
                      }`}
                    >
                      {analytics.profitFactor.toFixed(2)}
                    </div>
                  </div>
                </div>
              )}
            </div>

            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Excursion & Capture</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg MFE %</div>
                  <div className="text-lg font-bold text-green-400">
                    {analytics.avgMfePct.toFixed(1)}%
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg MAE %</div>
                  <div className="text-lg font-bold text-red-400">
                    {analytics.avgMaePct.toFixed(1)}%
                  </div>
                </div>
                <div>
                  <div className="text-xs text-[var(--tt-text-muted)]">Avg Captured %</div>
                  <div className="text-lg font-bold text-blue-400">
                    {analytics.avgCapturedPct.toFixed(1)}%
                  </div>
                </div>
              </div>
            </div>

            {analytics.horizonStats && (
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
                <h3 className="text-lg font-bold mb-4">Horizon Performance</h3>
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead>
                      <tr className="border-b border-[var(--tt-border)] text-left text-xs text-[var(--tt-text-muted)]">
                        <th className="p-2">Horizon</th>
                        <th className="p-2">Trades</th>
                        <th className="p-2">Win %</th>
                        <th className="p-2">Expectancy</th>
                        <th className="p-2">MFE %</th>
                        <th className="p-2">MAE %</th>
                        <th className="p-2">Captured %</th>
                      </tr>
                    </thead>
                    <tbody>
                      {Object.entries(analytics.horizonStats).map(
                        ([key, s]) => (
                          <tr
                            key={key}
                            className="border-b border-[var(--tt-border)]/50"
                          >
                            <td className="p-2 text-xs text-[var(--tt-text-muted)]">
                              {String(key).replace("_", " ")}
                            </td>
                            <td className="p-2">{s.n}</td>
                            <td className="p-2">{s.winRate.toFixed(1)}%</td>
                            <td className="p-2">
                              {Number.isFinite(s.expectancy)
                                ? `$${s.expectancy.toFixed(2)}`
                                : "â€”"}
                            </td>
                            <td className="p-2">{s.avgMfePct.toFixed(1)}%</td>
                            <td className="p-2">{s.avgMaePct.toFixed(1)}%</td>
                            <td className="p-2">
                              {s.avgCapturedPct.toFixed(1)}%
                            </td>
                          </tr>
                        ),
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            )}

            {/* Self-Learning Recommendations */}
            {(() => {
              const recs = analytics.recommendations || {};
              const filterRecs = Array.isArray(recs.filters)
                ? recs.filters
                : [];
              const mgmtRecs = Array.isArray(recs.management)
                ? recs.management
                : [];
              const hasAny = filterRecs.length + mgmtRecs.length > 0;
              if (!hasAny) return null;

              const renderRec = (rec, idx) => (
                <div
                  key={idx}
                  className={`p-3 rounded-lg border ${
                    rec.priority === "high"
                      ? "bg-yellow-500/10 border-yellow-500/30"
                      : "bg-blue-500/10 border-blue-500/30"
                  }`}
                >
                  <div className="flex items-start gap-2">
                    <span className="text-lg">
                      {rec.priority === "high" ? "âš ï¸" : "ðŸ’¡"}
                    </span>
                    <div className="flex-1">
                      <div className="text-sm font-semibold">{rec.message}</div>
                    </div>
                  </div>
                </div>
              );

              return (
                <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
                  <h3 className="text-lg font-bold mb-4">
                    ðŸŽ“ Self-Learning Recommendations
                  </h3>

                  {filterRecs.length > 0 && (
                    <div className="mb-4">
                      <div className="text-xs text-[var(--tt-text-muted)] font-semibold mb-2">
                        Filters (before entry)
                      </div>
                      <div className="space-y-2">
                        {filterRecs.map(renderRec)}
                      </div>
                    </div>
                  )}

                  {mgmtRecs.length > 0 && (
                    <div>
                      <div className="text-xs text-[var(--tt-text-muted)] font-semibold mb-2">
                        Management (after entry)
                      </div>
                      <div className="space-y-2">{mgmtRecs.map(renderRec)}</div>
                    </div>
                  )}
                </div>
              );
            })()}

            {/* Signal Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Signal Performance</h3>
              <div className="space-y-2 max-h-[300px] overflow-y-auto">
                {Object.entries(analytics.signalAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([signals, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={signals}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">
                            {signals || "No Signals"}
                          </div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* RR Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">
                Risk/Reward Performance
              </h3>
              <div className="space-y-2">
                {Object.entries(analytics.rrAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>

            {/* Rank Analysis */}
            <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
              <h3 className="text-lg font-bold mb-4">Rank Performance</h3>
              <div className="space-y-2">
                {Object.entries(analytics.rankAnalysis)
                  .sort((a, b) => {
                    const aRate = a[1].wins / (a[1].wins + a[1].losses || 1);
                    const bRate = b[1].wins / (b[1].wins + b[1].losses || 1);
                    return bRate - aRate;
                  })
                  .map(([range, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? (stats.wins / total) * 100 : 0;
                    return (
                      <div
                        key={range}
                        className="flex items-center justify-between p-2 bg-[var(--tt-bg-surface)] rounded"
                      >
                        <div className="flex-1">
                          <div className="text-sm font-semibold">{range}</div>
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            {stats.wins}W / {stats.losses}L ({total} trades)
                          </div>
                        </div>
                        <div className="text-right">
                          <div
                            className={`text-sm font-bold ${
                              winRate >= 50 ? "text-green-400" : "text-red-400"
                            }`}
                          >
                            {winRate.toFixed(1)}%
                          </div>
                          <div
                            className={`text-xs ${
                              stats.totalPnl >= 0
                                ? "text-green-400"
                                : "text-red-400"
                            }`}
                          >
                            ${stats.totalPnl.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>
          </div>
        );
      }

      function KpiCard({ label, value, sub = null, tone = "neutral" }) {
        const toneBar =
          tone === "green"
            ? "from-green-400 to-emerald-500"
            : tone === "red"
              ? "from-red-400 to-rose-500"
              : tone === "yellow"
                ? "from-yellow-300 to-amber-500"
                : tone === "blue"
                  ? "from-blue-400 to-cyan-400"
                  : "from-[var(--tt-text-faint)] to-[var(--tt-border)]";

        return (
          <div className="relative bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-xl p-3 overflow-hidden">
            <div
              className={`absolute left-0 top-0 bottom-0 w-1 bg-gradient-to-b ${toneBar}`}
            />
            <div className="pl-2">
              <div className="text-[11px] uppercase tracking-wide text-[var(--tt-text-muted)]">
                {label}
              </div>
              <div className="mt-1 text-lg font-bold text-white leading-tight">
                {value}
              </div>
              {sub ? (
                <div className="mt-1 text-[11px] text-[var(--tt-text-faint)]">{sub}</div>
              ) : null}
            </div>
          </div>
        );
      }

      function PerformanceDashboard({ mode, ledgerSummary, analytics }) {
        const isLedger = mode === "ledger";

        const loading = isLedger ? !!ledgerSummary?.loading : false;
        const err = isLedger ? ledgerSummary?.error : null;
        const t = isLedger ? ledgerSummary?.data?.totals : null;

        const totalTrades = isLedger
          ? Number(t?.totalTrades || 0)
          : Number(analytics?.totalTrades || 0);
        const openTrades = isLedger
          ? Number(t?.openTrades || 0)
          : Number(analytics?.openTrades || 0);
        const trimmedTrades = isLedger
          ? 0
          : Number(analytics?.trimmedTrades || 0);
        const closedTrades = isLedger
          ? Number(t?.closedTrades || 0)
          : Number(analytics?.closedTrades || 0);
        const wins = isLedger
          ? Number(t?.wins || 0)
          : Number(analytics?.wins || 0);
        const losses = isLedger
          ? Number(t?.losses || 0)
          : Number(analytics?.losses || 0);
        const winRate = isLedger
          ? Number(t?.winRate || 0)
          : Number(analytics?.winRate || 0);

        const closedPnl = isLedger
          ? Number(t?.closedPnl || 0)
          : Number(analytics?.totalPnl || 0);
        const openPnl = !isLedger ? Number(analytics?.openPnl || 0) : null;

        const avgWin = isLedger
          ? Number(t?.avgWin || 0)
          : Number(analytics?.avgWin || 0);
        const avgLoss = isLedger
          ? Number(t?.avgLoss || 0)
          : Number(analytics?.avgLoss || 0);
        const profitFactor = isLedger
          ? Number(t?.profitFactor || 0)
          : Number(analytics?.profitFactor || 0);
        const expectancy = isLedger
          ? Number(t?.expectancy || 0)
          : closedTrades > 0
            ? closedPnl / closedTrades
            : 0;

        const openCapitalTrades = isLedger
          ? openTrades
          : openTrades + trimmedTrades;
        const openCapital = openCapitalTrades * TRADE_SIZE;
        const totalCapital = totalTrades * TRADE_SIZE;

        const pfLabel =
          Number.isFinite(profitFactor) && profitFactor !== Infinity
            ? profitFactor.toFixed(2)
            : "âˆž";

        const cards = [
          { label: "Total Trades", value: fmtInt(totalTrades) },
          {
            label: "Open Trades",
            value: fmtInt(openTrades),
            sub: isLedger ? "status â‰  WIN/LOSS" : "no trims yet",
            tone: "yellow",
          },
          ...(!isLedger
            ? [
                {
                  label: "Trimmed Trades",
                  value: fmtInt(trimmedTrades),
                  sub: "partial position left",
                  tone: "blue",
                },
              ]
            : []),
          { label: "Wins", value: fmtInt(wins), tone: "green" },
          { label: "Losses", value: fmtInt(losses), tone: "red" },
          {
            label: "Win Rate",
            value: `${Number.isFinite(winRate) ? winRate.toFixed(1) : "0.0"}%`,
            tone: winRate >= 55 ? "green" : winRate >= 45 ? "yellow" : "red",
          },
          {
            label: "Closed P&L",
            value: fmtUsd(closedPnl),
            sub: `${fmtInt(closedTrades)} closed`,
            tone: closedPnl >= 0 ? "green" : "red",
          },
          ...(!isLedger
            ? [
                {
                  label: "Open P&L",
                  value: fmtUsd(openPnl),
                  sub: "unrealized",
                  tone: (openPnl || 0) >= 0 ? "green" : "yellow",
                },
              ]
            : []),
          { label: "Avg Win", value: fmtUsd(avgWin), tone: "green" },
          { label: "Avg Loss", value: fmtUsd(avgLoss), tone: "red" },
          {
            label: "Profit Factor",
            value: pfLabel,
            sub: "gross wins / gross losses",
            tone:
              profitFactor >= 1.5
                ? "green"
                : profitFactor >= 1.0
                  ? "yellow"
                  : "red",
          },
          {
            label: "Expectancy",
            value: fmtUsd(expectancy),
            sub: "avg per closed trade",
            tone: expectancy >= 0 ? "green" : "red",
          },
          {
            label: "Open Capital",
            value: fmtUsd(openCapital),
            sub: `${fmtUsd(TRADE_SIZE)} model / trade`,
            tone: "blue",
          },
        ];

        return (
          <div className="mb-6 bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-4">
            <div className="flex items-center justify-between gap-3 flex-wrap mb-3">
              <div>
                <div className="text-xs text-[var(--tt-text-muted)]">Dashboard</div>
                <div className="text-lg font-bold">
                  {isLedger ? "Ledger KPIs" : "Legacy KPIs"}
                </div>
              </div>
              <div className="text-xs text-[var(--tt-text-faint)]">
                {isLedger ? "Source: D1 ledger" : "Source: KV + live prices"}
              </div>
            </div>

            {loading ? (
              <div className="text-sm text-[var(--tt-text-muted)]">
                Loading dashboard metricsâ€¦
              </div>
            ) : err ? (
              <div className="text-sm text-[var(--tt-negative)]">
                Dashboard unavailable: {err}
              </div>
            ) : (
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">
                {cards.map((c, idx) => (
                  <KpiCard
                    key={`${c.label}-${idx}`}
                    label={c.label}
                    value={c.value}
                    sub={c.sub || null}
                    tone={c.tone || "neutral"}
                  />
                ))}
              </div>
            )}
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Helper Functions for TickerDetails
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // Calculate score breakdown (mirrors computeDynamicScore / backend-style scoring)
      function calculateScoreBreakdown(ticker) {
        const htf = Number(ticker?.htf_score) || 0;
        const ltf = Number(ticker?.ltf_score) || 0;
        const phase = Number(ticker?.phase_pct) || 0;
        const rr = Number(ticker?.rr) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker?.flags || {};
        const state = String(ticker?.state || "");
        const ent = entryType(ticker || {});
        const inCorridor = !!ent?.corridor;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;

        const breakdown = {
          base: Number(ticker?.rank) || 50,
          corridor: inCorridor ? 12 : 0,
          corridorAligned: inCorridor && aligned ? 8 : 0,
          squeezeRelease: sqRel && inCorridor ? 10 : 0,
          squeezeOn: sqOn && inCorridor && !sqRel ? 5 : 0,
          rr: rr >= 2.0 ? 8 : rr >= 1.5 ? 5 : rr >= 1.0 ? 2 : 0,
          phase: phase < 0.3 ? 6 : phase < 0.5 ? 3 : phase > 0.7 ? -5 : 0,
          completion: comp < 0.3 ? 5 : comp > 0.8 ? -8 : 0,
          htfStrength: Math.min(8, Math.abs(htf) * 0.15),
          ltfStrength: Math.min(6, Math.abs(ltf) * 0.12),
          phaseZoneChange: phaseZoneChange ? 4 : 0,
        };

        breakdown.total = Math.max(
          0,
          breakdown.base +
            breakdown.corridor +
            breakdown.corridorAligned +
            breakdown.squeezeRelease +
            breakdown.squeezeOn +
            breakdown.rr +
            breakdown.phase +
            breakdown.completion +
            breakdown.htfStrength +
            breakdown.ltfStrength +
            breakdown.phaseZoneChange,
        );

        return breakdown;
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(204 + (174 - 204) * t)}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(174 + (156 - 174) * t)}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(156 + (126 - 156) * t)}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(126 + (76 - 126) * t)}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(76 + (57 - 76) * t)}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }

      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      function completionForSize(ticker) {
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      function computeDynamicRank(ticker) {
        const baseRank = Number(ticker.rank) || 50;
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        let dynamicScore = baseRank;
        if (inCorridor) {
          dynamicScore += 12;
          if (aligned) dynamicScore += 8;
        }
        if (sqRel && inCorridor) dynamicScore += 10;
        if (sqOn && inCorridor && !sqRel) dynamicScore += 5;
        if (rr >= 2.0) dynamicScore += 8;
        else if (rr >= 1.5) dynamicScore += 5;
        else if (rr >= 1.0) dynamicScore += 2;
        if (phase < 0.3) dynamicScore += 6;
        else if (phase < 0.5) dynamicScore += 3;
        else if (phase > 0.7) dynamicScore -= 5;
        if (comp < 0.3) dynamicScore += 5;
        else if (comp > 0.8) dynamicScore -= 8;
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;
        if (phaseZoneChange) dynamicScore += 4;
        return Math.max(0, Math.min(100, Math.round(dynamicScore)));
      }

      function toTickerArray(source) {
        if (!source) return [];
        if (Array.isArray(source)) {
          return source.filter((t) => t && typeof t === "object" && t.ticker);
        }
        if (typeof source === "object") {
          return Object.values(source).filter(
            (t) => t && typeof t === "object" && t.ticker,
          );
        }
        return [];
      }

      function rankScoreForTicker(ticker) {
        const rankScore = Number(ticker?.rank_score);
        if (Number.isFinite(rankScore)) return rankScore;
        const dynamicRank = Number(ticker?.dynamicRank);
        if (Number.isFinite(dynamicRank)) return dynamicRank;
        const dynamicScore = Number(ticker?.dynamicScore);
        if (Number.isFinite(dynamicScore)) return dynamicScore;
        return Number(computeDynamicRank(ticker)) || 0;
      }

      function getRankedTickers(source) {
        const list = toTickerArray(source);
        const withScores = list.map((t) => ({
          ...t,
          __rankPos: Number(t?.rank_position),
          __rankScore: rankScoreForTicker(t),
        }));
        withScores.sort((a, b) => {
          const rankA = Number(a.__rankPos);
          const rankB = Number(b.__rankPos);
          const hasRankA = Number.isFinite(rankA) && rankA > 0;
          const hasRankB = Number.isFinite(rankB) && rankB > 0;
          if (hasRankA && hasRankB) return rankA - rankB;
          if (hasRankA) return -1;
          if (hasRankB) return 1;
          const scoreA = Number(a.__rankScore) || 0;
          const scoreB = Number(b.__rankScore) || 0;
          return scoreB - scoreA;
        });
        return withScores;
      }

      function getRankPositionFromMap(rankPositions, tickerSymbol) {
        if (!rankPositions) return null;
        const sym = String(tickerSymbol || "")
          .trim()
          .toUpperCase();
        if (!sym) return null;
        const pos = Number(rankPositions[sym]);
        return Number.isFinite(pos) && pos > 0 ? pos : null;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Opportunities Panel (unified: Prime / Eligible / Watch)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function OpportunitiesPanel({
        tickers = [],
        rankPositions = null,
        onSelectTicker,
        defaultView = "prime",
      }) {
        const [view, setView] = React.useState(defaultView); // prime | eligible | watch | all
        const [dir, setDir] = React.useState("ALL"); // ALL | LONG | SHORT
        const [horizon, setHorizon] = React.useState("ALL"); // ALL | SHORT_TERM | SWING | POSITIONAL
        const [query, setQuery] = React.useState("");

        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const formatAge = (t) => {
          const raw = t?.ingest_ts ?? t?.ingest_time ?? t?.ts ?? t?.timestamp;
          if (!raw) return "â€”";
          let ms = null;
          if (typeof raw === "number" && Number.isFinite(raw)) ms = raw;
          else if (typeof raw === "string") {
            const parsed = new Date(raw).getTime();
            ms = Number.isFinite(parsed) ? parsed : null;
          } else {
            const n = Number(raw);
            ms = Number.isFinite(n) ? n : null;
          }
          if (!ms) return "â€”";
          const ageMs = Date.now() - ms;
          const ageMin = Math.floor(ageMs / 60000);
          if (ageMin < 60) return `${Math.max(0, ageMin)}m ago`;
          const ageHr = Math.floor(ageMin / 60);
          if (ageHr < 24) return `${ageHr}h ago`;
          const ageDay = Math.floor(ageHr / 24);
          return `${ageDay}d ago`;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isEligible = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);
          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct)
            return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct)
            return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf)
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr)
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const toBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const classify = (t) => {
          const prime = isPrimeBubble(t);
          const eligible = isEligible(t);
          return {
            prime,
            eligible,
            bucket: toBucket(t),
            dir: getDirection(t)?.text || "NEUTRAL",
          };
        };

        const counts = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          let prime = 0;
          let eligible = 0;
          for (const t of list) {
            const c = classify(t);
            if (c.prime) prime++;
            if (c.eligible) eligible++;
          }
          return { prime, eligible, all: list.length };
        }, [tickers]);

        const filtered = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const q = String(query || "")
            .trim()
            .toUpperCase();
          return list
            .map((t) => {
              const c = classify(t);
              const status = c.prime
                ? "prime"
                : c.eligible
                  ? "eligible"
                  : "watch";
              const score = Number(rankScoreForTicker(t) || 0);
              const rp =
                getRankPositionFromMap(
                  rankPositions,
                  String(t?.ticker || "").toUpperCase(),
                ) ?? Number(t?.rank_position);
              return {
                t,
                c,
                status,
                score,
                rp: Number.isFinite(rp) ? rp : null,
              };
            })
            .filter(({ t, c, status }) => {
              if (!t?.ticker) return false;
              if (view !== "all" && status !== view) return false;
              if (dir !== "ALL" && c.dir !== dir) return false;
              if (horizon !== "ALL" && c.bucket !== horizon) return false;
              if (q && !String(t.ticker).toUpperCase().includes(q))
                return false;
              return true;
            })
            .sort((a, b) => {
              const pri = (x) =>
                x.status === "prime" ? 0 : x.status === "eligible" ? 1 : 2;
              const dp = pri(a) - pri(b);
              if (dp !== 0) return dp;
              const ds = (b.score || 0) - (a.score || 0);
              if (ds !== 0) return ds;
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              return String(a.t.ticker).localeCompare(String(b.t.ticker));
            });
        }, [tickers, view, dir, horizon, query, rankPositions]);

        const pill = (label, isActive, onClick) => (
          <button
            onClick={onClick}
            className={`px-2.5 py-1 rounded-lg border text-xs font-semibold transition-all ${
              isActive
                ? "border-blue-400 bg-blue-500/20 text-blue-200"
                : "border-[var(--tt-border)] bg-[var(--tt-bg-surface)] text-[var(--tt-text-muted)] hover:text-white"
            }`}
          >
            {label}
          </button>
        );

        return (
          <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-xl p-3">
            <div className="flex items-start justify-between gap-3 flex-wrap">
              <div>
                <div className="text-sm font-bold text-white">
                  âœ¨ Opportunities
                </div>
                <div className="text-[10px] text-[var(--tt-text-muted)] mt-0.5">
                  Prime {counts.prime} â€¢ Eligible {counts.eligible} â€¢ Total{" "}
                  {counts.all}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <input
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  placeholder="Tickerâ€¦"
                  className="px-2 py-1 text-xs bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded text-white w-[110px]"
                />
              </div>
            </div>

            <div className="mt-2 flex items-center gap-2 flex-wrap">
              {pill("Prime", view === "prime", () => setView("prime"))}
              {pill("Eligible", view === "eligible", () => setView("eligible"))}
              {pill("Watch", view === "watch", () => setView("watch"))}
              {pill("All", view === "all", () => setView("all"))}
              <div className="w-px h-6 bg-[var(--tt-bg-elevated)] mx-1" />
              {pill("All", dir === "ALL", () => setDir("ALL"))}
              {pill("Long", dir === "LONG", () => setDir("LONG"))}
              {pill("Short", dir === "SHORT", () => setDir("SHORT"))}
              <div className="w-px h-6 bg-[var(--tt-bg-elevated)] mx-1" />
              {pill("Any horizon", horizon === "ALL", () => setHorizon("ALL"))}
              {pill("â‰¤7d", horizon === "SHORT_TERM", () =>
                setHorizon("SHORT_TERM"),
              )}
              {pill("8â€“30d", horizon === "SWING", () => setHorizon("SWING"))}
              {pill("31d+", horizon === "POSITIONAL", () =>
                setHorizon("POSITIONAL"),
              )}
            </div>

            <div className="mt-3 max-h-[420px] overflow-y-auto space-y-2 pr-1">
              {filtered.length === 0 ? (
                <div className="text-xs text-[var(--tt-text-faint)] p-3">No matches.</div>
              ) : (
                filtered.slice(0, 75).map((item) => {
                  const t = item.t;
                  const c = item.c;
                  const actionInfo = getActionDescription(t);
                  const price = Number(t?.price);
                  const rr = Number(t?.rr);
                  const eta = computeEtaDays(t);
                  const age = formatAge(t);
                  const statusPill =
                    item.status === "prime"
                      ? "bg-yellow-500/15 text-yellow-300 border-yellow-500/40"
                      : item.status === "eligible"
                        ? "bg-green-500/15 text-green-400 border-green-500/40"
                        : "bg-[var(--tt-bg-elevated)] text-[var(--tt-text-muted)] border-[var(--tt-border)]";
                  const dirPill =
                    c.dir === "LONG"
                      ? "bg-green-500/10 text-green-400 border-green-500/30"
                      : c.dir === "SHORT"
                        ? "bg-red-500/10 text-red-400 border-red-500/30"
                        : "bg-[var(--tt-bg-elevated)] text-[var(--tt-text-muted)] border-[var(--tt-border)]";
                  return (
                    <button
                      key={t.ticker}
                      onClick={() => onSelectTicker && onSelectTicker(t.ticker)}
                      className="w-full text-left px-3 py-2 rounded-lg border border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-elevated)] hover:border-[var(--tt-border-strong)] transition-all"
                      title="Open in right rail"
                    >
                      <div className="flex items-start justify-between gap-2">
                        <div className="min-w-0">
                          <div className="flex items-center gap-2 flex-wrap">
                            <div className="font-bold text-white">
                              {t.ticker}
                            </div>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${statusPill}`}
                            >
                              {item.status === "prime"
                                ? "Prime"
                                : item.status === "eligible"
                                  ? "Eligible"
                                  : "Watch"}
                            </span>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${dirPill}`}
                            >
                              {c.dir}
                            </span>
                            {c.bucket && c.bucket !== "UNKNOWN" && (
                              <span className="px-2 py-0.5 rounded border border-[var(--tt-border)] bg-[var(--tt-bg-surface)] text-[10px] text-[var(--tt-text-muted)]">
                                {c.bucket === "SHORT_TERM"
                                  ? "â‰¤7d"
                                  : c.bucket === "SWING"
                                    ? "8â€“30d"
                                    : "31d+"}
                              </span>
                            )}
                          </div>
                          <div className="mt-0.5 text-[11px] text-[var(--tt-text-muted)] whitespace-nowrap overflow-hidden text-ellipsis">
                            <span className="text-[var(--tt-text-faint)]">
                              {actionInfo.action}
                            </span>
                          </div>
                        </div>

                        <div className="flex-shrink-0 text-right text-[11px]">
                          <div className="text-white">
                            {Number.isFinite(price)
                              ? `$${price.toFixed(2)}`
                              : "â€”"}
                          </div>
                          <div className="text-[var(--tt-text-faint)]">{age}</div>
                        </div>
                      </div>

                      <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[var(--tt-text-muted)]">
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Score</span>{" "}
                          <span className="text-white font-semibold">
                            {(() => {
                              const s = rankScoreForTicker(t);
                              return Number.isFinite(s) ? s.toFixed(1) : "â€”";
                            })()}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">Rank</span>{" "}
                          <span className="text-white font-semibold">
                            {item.rp != null ? `#${item.rp}` : "â€”"}
                          </span>
                        </div>
                        <div>
                          <span className="text-[var(--tt-text-faint)]">RR/ETA</span>{" "}
                          <span className="text-white font-semibold">
                            {Number.isFinite(rr) ? rr.toFixed(2) : "â€”"} /{" "}
                            {eta != null ? `${eta.toFixed(1)}d` : "â€”"}
                          </span>
                        </div>
                      </div>

                      {(() => {
                        const phaseP = Math.max(
                          0,
                          Math.min(1, Number(t?.phase_pct) || 0),
                        );
                        const compP = completionForSize(t);
                        const phaseColor = phaseToColor(phaseP);
                        const compColor = phaseToColor(compP);
                        const Bar = ({ label, p, color }) => (
                          <div className="flex items-center gap-2">
                            <div className="w-20 text-[10px] text-[var(--tt-text-faint)]">
                              {label}
                            </div>
                            <div className="flex-1 h-1.5 rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] overflow-hidden">
                              <div
                                className="h-full"
                                style={{
                                  width: `${Math.round(p * 100)}%`,
                                  background: color,
                                }}
                              />
                            </div>
                            <div className="w-10 text-right text-[10px] text-[var(--tt-text-muted)]">
                              {Math.round(p * 100)}%
                            </div>
                          </div>
                        );
                        return (
                          <div className="mt-2 space-y-1">
                            <Bar label="Phase" p={phaseP} color={phaseColor} />
                            <Bar
                              label="Completion"
                              p={compP}
                              color={compColor}
                            />
                          </div>
                        );
                      })()}
                    </button>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      function normalizeTrailPoints(trail) {
        if (!Array.isArray(trail)) return [];
        return trail
          .map((p) => {
            if (!p || typeof p !== "object") return null;
            const ltf = p.ltf_score ?? p.ltfScore ?? p.ltf ?? p.x ?? p.ltf_value ?? p.ltfValue ?? p.ltf_score_value;
            const htf = p.htf_score ?? p.htfScore ?? p.htf ?? p.y ?? p.htf_value ?? p.htfValue ?? p.htf_score_value;
            const phase = p.phase_pct ?? p.phasePct ?? p.phase ?? p.phase_completion ?? p.phaseCompletion;
            const completion = p.completion ?? p.comp ?? p.completion_pct ?? p.completionPct;
            return {
              ...p,
              ltf_score: Number.isFinite(Number(ltf)) ? Number(ltf) : 0,
              htf_score: Number.isFinite(Number(htf)) ? Number(htf) : 0,
              phase_pct: Number.isFinite(Number(phase)) ? Math.max(0, Math.min(1, Number(phase))) : Number.isFinite(Number(p.phase_pct)) ? Number(p.phase_pct) : 0,
              completion: Number.isFinite(Number(completion)) ? Math.max(0, Math.min(1, Number(completion))) : Number.isFinite(Number(p.completion)) ? Number(p.completion) : 0,
            };
          })
          .filter(Boolean);
      }

      function downsampleByInterval(points, intervalMs) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const buckets = new Map();
        points.forEach((p) => {
          const tsRaw = p.__ts_ms ?? p.ts ?? p.ingest_ts ?? p.ingest_time;
          const ts =
            typeof tsRaw === "string"
              ? new Date(tsRaw).getTime()
              : Number(tsRaw);
          if (!Number.isFinite(ts)) return;
          const bucket = Math.floor(ts / intervalMs) * intervalMs;
          const prev = buckets.get(bucket);
          if (!prev || ts > prev.__ts_ms) {
            buckets.set(bucket, { ...p, __ts_ms: ts, __bucket: bucket });
          }
        });
        return Array.from(buckets.values()).sort(
          (a, b) => a.__ts_ms - b.__ts_ms,
        );
      }

      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const isAligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(0)}% completion. Consider taking profits or trimming 50-75% of position.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(0)}% indicates late-cycle conditions. Wait for pullback or trim existing positions.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20",
          };
        }
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock showing Prime setup with exceptional alignment. High-probability setup with strong fundamentals.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. Enter on pullback or break.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase and low completion suggest room to run.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. Wait for better conditions or confirmation signals.`,
          color: "text-[var(--tt-text-muted)]",
          bg: "bg-[var(--tt-bg-elevated)]",
        };
      }

      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK")
          return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL")
          return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR")
          return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK")
          return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map((p) => p.state).filter(Boolean);
        for (let i = 1; i < states.length; i++) {
          if (
            states[i - 1] === "HTF_BULL_LTF_PULLBACK" &&
            states[i] === "HTF_BULL_LTF_BULL"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1â†’Q2 transition (Bull Entry)",
              quadrant: "Q1â†’Q2",
              confidence: "HIGH",
            });
          }
          if (
            states[i - 1] === "HTF_BEAR_LTF_PULLBACK" &&
            states[i] === "HTF_BEAR_LTF_BEAR"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4â†’Q3 transition (Bear Entry)",
              quadrant: "Q4â†’Q3",
              confidence: "HIGH",
            });
          }
        }
        return patterns;
      }

      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = useState([]);
        const [loading, setLoading] = useState(false);
        const [hasLoaded, setHasLoaded] = useState(false);
        useEffect(() => {
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const res = await fetch(
                  `${API_BASE}/timed/trail?ticker=${encodeURIComponent(ticker.ticker)}`,
                );
                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && Array.isArray(data.trail)) {
                    setTrail(data.trail);
                  }
                }
              } catch (e) {
                console.error("Failed to load trail:", e);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300);
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);
        const sampledTrail = useMemo(
          () => downsampleByInterval(trail, 15 * 60 * 1000),
          [trail],
        );
        const patterns = detectPatterns(sampledTrail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = sampledTrail
          .map((p) => getQuadrantFromState(p.state))
          .filter(Boolean);
        return (
          <div className="mb-4 p-4 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
            <div className="text-sm font-bold mb-3 text-[var(--tt-text-muted)]">
              Quadrant Progression (15m increments)
            </div>
            <div className="grid grid-cols-2 gap-2 mb-4">
              {[1, 2, 4, 3].map((q) => {
                const quad =
                  q === 1
                    ? { q: 1, name: "Q1", label: "Bull Setup", color: "blue" }
                    : q === 2
                      ? {
                          q: 2,
                          name: "Q2",
                          label: "Bull Momentum",
                          color: "green",
                        }
                      : q === 4
                        ? {
                            q: 4,
                            name: "Q4",
                            label: "Bear Setup",
                            color: "orange",
                          }
                        : {
                            q: 3,
                            name: "Q3",
                            label: "Bear Momentum",
                            color: "red",
                          };
                const isActive = currentQuad?.q === quad.q;
                const hasHistory = quadHistory.some(
                  (qh) => qh && qh.q === quad.q,
                );
                return (
                  <div
                    key={q}
                    className={`p-3 rounded-lg border-2 ${
                      isActive
                        ? `border-${quad.color}-400 bg-${quad.color}-500/20`
                        : hasHistory
                          ? `border-${quad.color}-500/50 bg-${quad.color}-500/10`
                          : "border-[var(--tt-border)] bg-[var(--tt-bg-surface)]"
                    }`}
                  >
                    <div className={`text-xs font-bold text-${quad.color}-400`}>
                      {quad.name}: {quad.label}
                    </div>
                  </div>
                );
              })}
            </div>
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[var(--tt-border)]">
                <div className="text-xs font-bold text-yellow-400 mb-2">
                  ðŸŽ¯ Detected Patterns
                </div>
                {patterns.map((pattern, idx) => (
                  <div
                    key={idx}
                    className="p-2 rounded border bg-yellow-500/20 border-yellow-400/50 mb-2"
                  >
                    <div className="text-xs font-bold text-white">
                      {pattern.description}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      }

      function TickerDetails({ ticker, onClose, allLoadedData = null }) {
        if (!ticker) return null;
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) return allLoadedData;
            return Object.values(allLoadedData).filter(
              (t) => t && typeof t === "object" && t.ticker,
            );
          }
          return [];
        })();
        const baseScore = Number(ticker.rank) || 0;
        const displayScore = rankScoreForTicker(ticker);
        const dynamicRank = computeDynamicRank(ticker);
        const allTickersWithRank = allLoadedTickersArray.map((t) => ({
          ...t,
          dynamicRank: computeDynamicRank(t),
        }));
        const sortedByDynamic = [...allTickersWithRank].sort(
          (a, b) => b.dynamicRank - a.dynamicRank,
        );
        const rankPosition =
          sortedByDynamic.findIndex(
            (t) =>
              String(t.ticker || "").toUpperCase() ===
              String(ticker.ticker || "").toUpperCase(),
          ) + 1;
        const totalTickers = allLoadedTickersArray.length;
        return (
          <div className="w-full h-full flex flex-col">
            <div className="w-full h-full flex flex-col slide-in-right shadow-2xl rounded-xl border-2" style={{ background: "#0c0f14", borderColor: "var(--tt-border)" }}>
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button
                    onClick={onClose}
                    className="text-[var(--tt-text-muted)] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)]"
                  >
                    âœ•
                  </button>
                </div>
                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      ðŸš€ MOMENTUM ELITE ðŸš€
                    </div>
                  </div>
                )}
                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500">
                    â­ PRIME SETUP â­
                  </div>
                )}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] border-2 border-[var(--tt-border)] rounded-lg">
                      <div className="text-sm text-[var(--tt-text-muted)] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color}`}
                      >
                        {dir.text === "LONG"
                          ? "ðŸ“ˆ L"
                          : dir.text === "SHORT"
                            ? "ðŸ“‰ S"
                            : dir.text}
                      </div>
                    </div>
                  );
                })()}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[var(--tt-text-muted)]">
                    {actionInfo.description}
                  </div>
                </div>
                <QuadrantProgression ticker={ticker} flags={flags} />
                <div className="mb-4 p-3 bg-[var(--tt-bg-surface)] rounded-lg border border-[var(--tt-border)]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[var(--tt-text-muted)]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                    </span>
                  </div>
                  <div className="h-3 bg-[var(--tt-bg-elevated)] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                      }}
                    />
                  </div>
                </div>
                <div className="space-y-2.5 text-sm">
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Score</span>
                    <span className="font-semibold text-blue-400 text-lg">
                      {Number.isFinite(displayScore)
                        ? displayScore.toFixed(1)
                        : "â€”"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Rank</span>
                    <span className="font-semibold">
                      {rankPosition > 0
                        ? `#${rankPosition} of ${totalTickers}`
                        : "â€”"}
                    </span>
                  </div>
                  {dynamicRank !== baseScore && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Dynamic Score</span>
                      <span className="font-semibold text-green-400">
                        {dynamicRank}
                      </span>
                    </div>
                  )}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const components = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(1)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(1)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return (
                      <div className="mt-4 pt-4 border-t border-[var(--tt-border)]">
                        <div className="text-xs text-[var(--tt-text-muted)] mb-3 font-semibold">
                          Score Breakdown
                        </div>
                        <div className="space-y-1.5">
                          {components.map((comp, idx) => (
                            <div
                              key={idx}
                              className="flex justify-between items-center text-xs"
                            >
                              <span className="text-[var(--tt-text-muted)]">
                                {comp.label}
                              </span>
                              <span className={`font-semibold ${comp.color}`}>
                                {comp.value}
                              </span>
                            </div>
                          ))}
                          <div className="flex justify-between items-center pt-2 mt-2 border-t border-[var(--tt-border)]/50">
                            <span className="text-[var(--tt-text-muted)] font-semibold">
                              Total Score
                            </span>
                            <span className="font-bold text-lg text-blue-400">
                              {Math.round(breakdown.total)}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "â€”"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">State</span>
                    <span className="font-semibold">{ticker.state || "â€”"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Completion</span>
                    <span className="font-semibold">
                      {Math.round(completionForSize(ticker) * 100)}%
                    </span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                      <span className="text-[var(--tt-text-muted)]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                        {ent.side}
                      </span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">Current Price</span>
                    <span className="font-semibold text-lg">
                      {ticker.price
                        ? `$${Number(ticker.price).toFixed(2)}`
                        : "â€”"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]">TP (Primary)</span>
                    <span className="font-semibold">
                      {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "â€”"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[var(--tt-border)]/50">
                    <span className="text-[var(--tt-text-muted)]" title="Trailing Stop Loss">TSL</span>
                    <span className="font-semibold">
                      {ticker.sl ? Number(ticker.sl).toFixed(2) : "â€”"}
                    </span>
                  </div>
                </div>
                {(flags.sq30_on ||
                  flags.sq30_release ||
                  flags.phase_dot ||
                  flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[var(--tt-text-muted)] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && (
                        <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                          ðŸ§¨ Squeeze ON
                        </span>
                      )}
                      {flags.sq30_release && (
                        <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                          âš¡ Squeeze Release
                        </span>
                      )}
                      {flags.phase_dot && (
                        <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                          Phase Dot
                        </span>
                      )}
                      {flags.phase_zone_change && (
                        <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                          Zone Change
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </div>
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[var(--tt-border)] bg-[var(--tt-bg-elevated)]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(ticker.ticker)}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  ðŸ“Š Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // TickerDetailsLoader - Loads ticker data and passes to unified component
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const TickerDetailsLoader = ({
        tickerSymbol,
        trade = null,
        onClose,
        allLoadedData = null,
        sectors = [],
        rankedTickers = null,
        rankedTickerPositions = null,
        positionEvents = null,
      }) => {
        const [tickerData, setTickerData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              const res = await fetch(
                `${API_BASE}/timed/latest?ticker=${encodeURIComponent(tickerSymbol)}`,
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok || !json.data) {
                throw new Error(json.error || "Ticker not found");
              }
              setTickerData(json.data || json.latestData);
            } catch (err) {
              console.error("Failed to fetch ticker:", err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };
          fetchTicker();
        }, [tickerSymbol]);

        if (loading) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[var(--tt-bg-surface)]">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[var(--tt-text-muted)]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }

        if (error || !tickerData) {
          return (
            <div className="w-full h-full flex items-center justify-center bg-[var(--tt-bg-surface)]">
              <div className="text-center">
                <div className="text-red-400 mb-2">
                  Failed to load {tickerSymbol}
                </div>
                <div className="text-[var(--tt-text-muted)] text-sm mb-4">
                  {error || "No data available"}
                </div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-elevated)] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }

        return (
          <TickerDetailRightRail
            ticker={tickerData}
            trade={trade}
            onClose={onClose}
            allLoadedData={allLoadedData}
            sectors={sectors}
            rankedTickers={rankedTickers}
            rankedTickerPositions={rankedTickerPositions}
            initialRailTab={trade ? "TRADE_HISTORY" : null}
          />
        );
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Welcome Modal Component - Dashboard Guide (Trading Concepts)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function DashboardWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Timed Trading! ðŸŽ¯",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  This dashboard helps you find high-quality trading setups by
                  combining multiple timeframes and technical indicators.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸŽ“ How to Use This Guide
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    Click "Next" to learn about each concept, or use the
                    navigation dots to jump to any section. You can always
                    reopen this guide from the navigation bar.
                  </p>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    âœ¨ Quick Start
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">green zones</strong> (Q1 &
                      Q2) for LONG setups
                    </li>
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">red zones</strong> (Q3 &
                      Q4) for SHORT setups
                    </li>
                    <li>Click on any bubble to see detailed information</li>
                    <li>Use filters to narrow down the best opportunities</li>
                  </ol>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding the Quadrants ðŸ“Š",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The chart is divided into <strong>4 quadrants</strong> based
                  on two scores:
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                    <h3 className="text-green-400 font-semibold mb-2">
                      HTF Score (Y-axis)
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      <strong className="text-white">Higher Timeframe</strong> -
                      Shows the overall trend direction.
                      <br />â€¢ Positive = Bullish trend
                      <br />â€¢ Negative = Bearish trend
                    </p>
                  </div>
                  <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                    <h3 className="text-blue-400 font-semibold mb-2">
                      LTF Score (X-axis)
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      <strong className="text-white">Lower Timeframe</strong> -
                      Shows entry timing.
                      <br />â€¢ Positive = Momentum/Continuation
                      <br />â€¢ Negative = Pullback/Setup
                    </p>
                  </div>
                </div>
                <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-3">
                    The 4 Quadrants:
                  </h3>
                  <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q1: Long Setup ðŸ“ˆ
                      </div>
                      <div className="text-[var(--tt-text-muted)]">
                        HTF Bull + LTF Pullback
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Best entry zone for LONG trades
                      </div>
                    </div>
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q2: Long Momentum ðŸš€
                      </div>
                      <div className="text-[var(--tt-text-muted)]">HTF Bull + LTF Bull</div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q3: Short Momentum ðŸ“‰
                      </div>
                      <div className="text-[var(--tt-text-muted)]">HTF Bear + LTF Bear</div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q4: Short Setup ðŸ”»
                      </div>
                      <div className="text-[var(--tt-text-muted)]">
                        HTF Bear + LTF Pullback
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)] mt-1">
                        Best entry zone for SHORT trades
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Prime Setups â­",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  <strong className="text-yellow-400">Prime Setups</strong> are
                  the highest-quality opportunities. They have a â­ icon and
                  appear with a green glow.
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    Prime Setup Criteria:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Rank â‰¥ 75</strong> - High
                      overall quality score
                    </li>
                    <li>
                      <strong className="text-white">Risk/Reward â‰¥ 1.5</strong>{" "}
                      - Good profit potential vs risk
                    </li>
                    <li>
                      <strong className="text-white">Completion â‰¤ 40%</strong> -
                      Still early in the move
                    </li>
                    <li>
                      <strong className="text-white">In Corridor</strong> -
                      Valid entry zone
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸ’¡ How to Find Prime Setups:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"Prime Only"</strong>{" "}
                      filter button
                    </li>
                    <li>Look for bubbles with â­ icons and green borders</li>
                    <li>Click on a bubble to see detailed entry/exit levels</li>
                    <li>Check the Risk/Reward ratio - higher is better!</li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Tip:</strong> Prime
                    setups are rare but offer the best risk/reward. Focus on Q1
                    (Long Setup) and Q4 (Short Setup) quadrants for the best
                    entries.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "In Corridor ðŸŽ¯",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The <strong className="text-cyan-400">Corridor</strong> is a
                  specific zone where entries are considered valid and safe.
                </p>
                <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                  <h3 className="text-cyan-400 font-semibold mb-2">
                    What is a Corridor?
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                    A corridor is a narrow band on the chart where price action
                    is optimal for entry. Think of it as a "sweet spot" where
                    the setup is most likely to succeed.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Long Corridor ðŸ“ˆ
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        HTF Score &gt; 0<br />
                        LTF Score: -8 to +12
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Short Corridor ðŸ“‰
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        HTF Score &lt; 0<br />
                        LTF Score: -12 to +8
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸŽ¯ How to Use Corridor Filter:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"In Corridor"</strong>{" "}
                      filter button
                    </li>
                    <li>This shows only tickers in valid entry zones</li>
                    <li>These are the safest setups to trade</li>
                    <li>
                      Combine with "Prime Only" for the best opportunities
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">
                      Why Corridors Matter:
                    </strong>{" "}
                    Tickers outside corridors may be too early, too late, or in
                    unfavorable conditions. Corridor entries have the highest
                    probability of success.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "TD Sequential (TD9) ðŸ”¢",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  <strong className="text-purple-400">TD Sequential</strong> is
                  a powerful indicator that identifies potential reversal
                  points.
                </p>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    What is TD9?
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                    TD Sequential counts consecutive bars in one direction. When
                    it reaches <strong className="text-white">9</strong>, it
                    signals potential exhaustion and reversal.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        TD9 Bullish ðŸ“ˆ
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        Signals potential <strong>bottom</strong> and upward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for LONG entries
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        TD9 Bearish ðŸ“‰
                      </div>
                      <div className="text-xs text-[var(--tt-text-muted)]">
                        Signals potential <strong>top</strong> and downward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for SHORT entries or exit
                        LONGs
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸ”¢ How to Use TD9 Filter:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"TD9 Setup"</strong> filter
                      button
                    </li>
                    <li>This shows only tickers with active TD9 signals</li>
                    <li>
                      TD9 signals are strongest when combined with other
                      factors:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>
                          In the correct quadrant (Q1 for bullish, Q4 for
                          bearish)
                        </li>
                        <li>In corridor</li>
                        <li>With good Risk/Reward</li>
                      </ul>
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Pro Tip:</strong> TD9
                    signals are most powerful at extremes. If you see a TD9
                    signal in Q1 (Long Setup) or Q4 (Short Setup), it's a strong
                    confirmation of a reversal setup.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Squeeze Indicators ðŸ§¨âš¡",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The <strong className="text-yellow-400">Squeeze</strong>{" "}
                  indicator shows when volatility is building up, like a spring
                  being compressed before release.
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                    <h3 className="text-yellow-400 font-semibold mb-2 flex items-center gap-2">
                      ðŸ§¨ In Squeeze
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                      Volatility is{" "}
                      <strong className="text-white">compressed</strong> - price
                      is consolidating.
                    </p>
                    <div className="text-xs text-[var(--tt-text-muted)] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        Energy is building up
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Watch
                        closely - a big move is coming
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Wait for squeeze release
                      </div>
                    </div>
                  </div>
                  <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                    <h3 className="text-cyan-400 font-semibold mb-2 flex items-center gap-2">
                      âš¡ Squeeze Release
                    </h3>
                    <p className="text-sm text-[var(--tt-text-muted)] mb-3">
                      Volatility has{" "}
                      <strong className="text-white">exploded</strong> - price
                      is breaking out.
                    </p>
                    <div className="text-xs text-[var(--tt-text-muted)] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        The spring has released!
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Strong
                        momentum signal
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Enter on pullback or breakout
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸŽ¯ How to Use Squeeze Filters:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">
                        "In Squeeze" Filter:
                      </strong>{" "}
                      Shows tickers where volatility is building. These are good
                      to watch but wait for release before entering.
                    </div>
                    <div>
                      <strong className="text-white">
                        "Squeeze Release" Filter:
                      </strong>{" "}
                      Shows tickers where the squeeze has fired. These often
                      have strong momentum - combine with Prime filter for best
                      results.
                    </div>
                  </div>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ðŸ’¡ Best Practices:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">
                        Squeeze Release + Prime Setup
                      </strong>{" "}
                      = Very strong signal
                    </li>
                    <li>
                      <strong className="text-white">
                        Squeeze Release + In Corridor
                      </strong>{" "}
                      = High probability entry
                    </li>
                    <li>
                      <strong className="text-white">In Squeeze</strong> =
                      Prepare but don't enter yet
                    </li>
                    <li>
                      Look for squeeze release in the direction of the HTF trend
                    </li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together ðŸŽ“",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  Now that you understand the concepts, here's a{" "}
                  <strong className="text-yellow-400">
                    step-by-step workflow
                  </strong>{" "}
                  to find great setups:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    ðŸ“‹ Your Trading Workflow:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Step 1: Choose Your Direction
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ For LONG trades: Focus on Q1 (Long Setup) quadrant
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ For SHORT trades: Focus on Q4 (Short Setup) quadrant
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 2: Apply Quality Filters
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Click "Prime Only" to see only high-quality setups
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Click "In Corridor" to ensure valid entry zones
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 3: Look for Confirmation Signals
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ TD9 Setup: Strong reversal signal
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Squeeze Release âš¡: Strong momentum
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Momentum Elite ðŸš€: Best fundamentals
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 4: Analyze the Setup
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Click on a bubble to see details
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Check Risk/Reward ratio (aim for â‰¥ 1.5)
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Verify entry price, stop loss, and take profit levels
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 5: Execute Your Trade
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Enter at the suggested entry price
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Set stop loss at the SL level
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Target the TP levels (consider trimming at first TP)
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    â­ The Perfect Setup Checklist:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>
                      âœ… In the correct quadrant (Q1 for LONG, Q4 for SHORT)
                    </div>
                    <div>âœ… Prime Setup (â­ icon)</div>
                    <div>âœ… In Corridor</div>
                    <div>âœ… Risk/Reward â‰¥ 1.5</div>
                    <div>âœ… Completion â‰¤ 40% (still early)</div>
                    <div>
                      âœ… TD9 signal OR Squeeze Release (bonus confirmation)
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Remember:</strong> Not
                    every setup will have all these factors. Use your judgment
                    and risk management. Start with paper trading if you're new!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[var(--tt-bg-base)] border-2 border-[var(--tt-border)] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[var(--tt-border)] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[var(--tt-bg-elevated)]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[var(--tt-text-muted)] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)] transition-colors"
                  title="Close Welcome Guide"
                >
                  Ã—
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[var(--tt-border)] p-4 flex items-center justify-between bg-[var(--tt-bg-surface)]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[var(--tt-border)] text-[var(--tt-text-muted)] opacity-50 cursor-not-allowed"
                      : "border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-hover)] text-white"
                  }`}
                >
                  â† Previous
                </button>
                <div className="text-sm text-[var(--tt-text-muted)]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next â†’
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Trading! ðŸš€
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Welcome Modal Component - Simulated Trades Guide
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function TrackerWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Trade Tracker! ðŸ“Š",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  The Trade Tracker automatically simulates trades based on
                  alerts from the main dashboard, helping you learn which setups
                  work best.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸŽ¯ How It Works:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-1">
                    <li>
                      When an alert fires from TradingView, a simulated trade is
                      automatically created
                    </li>
                    <li>
                      Each trade uses a{" "}
                      <strong className="text-white">
                        $1,000 position size
                      </strong>
                    </li>
                    <li>
                      Trades are tracked in real-time with live P&L updates
                    </li>
                    <li>
                      When price hits Stop Loss or Take Profit, the trade closes
                      automatically
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    âœ¨ What You'll Learn:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>Which setups have the best win rate</li>
                    <li>How different Risk/Reward ratios perform</li>
                    <li>Which model versions work best</li>
                    <li>Performance by rank, sector, and other factors</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Note:</strong> These are
                    simulated trades for learning purposes only. Always do your
                    own research before making real trades!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding Trade Statuses ðŸ·ï¸",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  Each trade has a <strong>status</strong> that tells you its
                  current state:
                </p>
                <div className="grid grid-cols-1 gap-3">
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>ðŸŸ¢ OPEN</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade is active and being tracked. P&L updates in
                      real-time as price moves. The trade will close when it
                      hits Stop Loss or Take Profit.
                    </p>
                  </div>
                  <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                    <div className="font-bold text-blue-400 mb-2 flex items-center gap-2">
                      <span>ðŸ”µ TP_HIT_TRIM</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      First Take Profit level was hit! The system automatically
                      trimmed (sold) part of the position to lock in profits.
                      The remaining position stays open to target higher TP
                      levels.
                    </p>
                  </div>
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>âœ… WIN</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade closed profitably! Either hit a Take Profit level or
                      was manually closed in profit. Check the trade history to
                      see the exit details.
                    </p>
                  </div>
                  <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                    <div className="font-bold text-red-400 mb-2 flex items-center gap-2">
                      <span>âŒ LOSS</span>
                    </div>
                    <p className="text-sm text-[var(--tt-text-muted)]">
                      Trade hit Stop Loss and closed at a loss. This is normal -
                      not every trade wins! Review what went wrong to improve
                      future setups.
                    </p>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Tip:</strong> Click on
                    any trade row to see detailed information including entry
                    price, stop loss, take profit levels, and full trade
                    history.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Reading the Trade Table ðŸ“‹",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The trade table shows all your simulated trades. Here's what
                  each column means:
                </p>
                <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                  <div className="space-y-3 text-sm">
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Ticker
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        The stock or futures contract symbol
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Direction
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        LONG (buy) or SHORT (sell)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Entry Price
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Price when the trade was opened
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Current Price
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Live market price (updates every 30 seconds)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Profit or Loss in dollars.{" "}
                        <span className="text-green-400">Green = profit</span>,
                        <span className="text-red-400"> red = loss</span>
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L %
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Profit or Loss as a percentage
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Shares/Contracts
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        For stocks: number of shares (based on $1,000 position).
                        For futures: number of contracts (usually 1)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Status
                      </span>
                      <span className="text-[var(--tt-text-muted)]">
                        Current trade status (OPEN, WIN, LOSS, etc.)
                      </span>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸ’¡ Pro Tips:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      Click any trade row to see detailed information and trade
                      history
                    </li>
                    <li>
                      Use the version filter to compare different model versions
                    </li>
                    <li>
                      Open trades show live P&L that updates automatically
                    </li>
                    <li>Closed trades show final P&L and exit reason</li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "How P&L is Calculated ðŸ’°",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  Understanding how profit and loss is calculated helps you
                  interpret the results:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ðŸ“ˆ For Stocks:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">Position Size:</strong>{" "}
                      $1,000 per trade
                    </div>
                    <div>
                      <strong className="text-white">Shares:</strong> $1,000 Ã·
                      Entry Price
                    </div>
                    <div>
                      <strong className="text-white">P&L (LONG):</strong>{" "}
                      (Current Price - Entry Price) Ã— Shares
                    </div>
                    <div>
                      <strong className="text-white">P&L (SHORT):</strong>{" "}
                      (Entry Price - Current Price) Ã— Shares
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸ“Š For Futures:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-2">
                    <div>
                      <strong className="text-white">Contracts:</strong> Usually
                      1 contract per trade
                    </div>
                    <div>
                      <strong className="text-white">Point Value:</strong> Each
                      futures contract has a point value:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>NQ1! (Nasdaq): $20 per point</li>
                        <li>ES1! (S&P 500): $50 per point</li>
                        <li>Other futures vary</li>
                      </ul>
                    </div>
                    <div>
                      <strong className="text-white">P&L:</strong> (Price
                      Change) Ã— Contracts Ã— Point Value
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2">
                    ðŸŽ¯ Example:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>
                      <strong className="text-white">Stock Trade:</strong> AAPL
                      at $150 entry, $155 current
                    </div>
                    <div className="ml-4">
                      Shares: $1,000 Ã· $150 = 6.67 shares
                    </div>
                    <div className="ml-4">
                      P&L: ($155 - $150) Ã— 6.67 ={" "}
                      <span className="text-green-400">+$33.35</span>
                    </div>
                    <div className="mt-2">
                      <strong className="text-white">Futures Trade:</strong>{" "}
                      NQ1! at 15,000 entry, 15,100 current
                    </div>
                    <div className="ml-4">
                      Price Change: 15,100 - 15,000 = 100 points
                    </div>
                    <div className="ml-4">
                      P&L: 100 Ã— 1 Ã— $20 ={" "}
                      <span className="text-green-400">+$2,000</span>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Tracking & Analytics ðŸ“Š",
            content: (
              <div className="space-y-4">
                <p className="text-[var(--tt-text)]">
                  The Trade Tracker provides powerful analytics to help you
                  learn:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ðŸ“ˆ Performance Metrics:
                  </h3>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Win Rate:</strong>{" "}
                      Percentage of winning trades
                    </li>
                    <li>
                      <strong className="text-white">Total P&L:</strong> Sum of
                      all profits and losses
                    </li>
                    <li>
                      <strong className="text-white">Average Win/Loss:</strong>{" "}
                      Average profit per win vs loss
                    </li>
                    <li>
                      <strong className="text-white">Best/Worst Trade:</strong>{" "}
                      Your biggest winners and losers
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    ðŸ” Filter by Version:
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)] mb-2">
                    Use the "Model Version" dropdown to compare performance
                    across different versions of the trading model. This helps
                    you see which improvements work best.
                  </p>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-white">Tip:</strong> Newer versions
                    often include improvements, but older versions may have
                    proven track records.
                  </p>
                </div>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    ðŸ“Š Daily Summary:
                  </h3>
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    Click "View Daily Summary" to see performance breakdowns by:
                  </p>
                  <ul className="text-sm text-[var(--tt-text-muted)] list-disc list-inside space-y-1 mt-2">
                    <li>Rank ranges (which ranked setups perform best)</li>
                    <li>Risk/Reward ratios (which RR ratios win more)</li>
                    <li>Quadrants (which chart zones are most profitable)</li>
                    <li>Overall statistics and insights</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">Remember:</strong> The
                    goal is to learn which setups work best. Review your wins
                    and losses regularly to improve your trading strategy!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together ðŸŽ“",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[var(--tt-text)]">
                  Here's your{" "}
                  <strong className="text-yellow-400">workflow</strong> for
                  using the Trade Tracker:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    ðŸ“‹ Daily Workflow:
                  </h3>
                  <ol className="text-sm text-[var(--tt-text-muted)] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Monitor Open Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Check the "Open Trades" section regularly
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Watch P&L update in real-time
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Click trades to see detailed information
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Review Closed Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Check "Closed Trades" to see final results
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Review trade history to understand what happened
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Learn from both wins and losses
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Analyze Performance
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Use the version filter to compare models
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Check daily summary for insights
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Look for patterns in winning vs losing trades
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Improve Your Strategy
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Focus on setups with high win rates
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Avoid setups that consistently lose
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        â€¢ Adjust filters on the main dashboard based on results
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    â­ Key Takeaways:
                  </h3>
                  <div className="text-sm text-[var(--tt-text-muted)] space-y-1">
                    <div>âœ… Trades are created automatically from alerts</div>
                    <div>âœ… Each trade uses $1,000 position size</div>
                    <div>âœ… P&L updates in real-time for open trades</div>
                    <div>âœ… Trades close automatically at SL or TP</div>
                    <div>âœ… Use analytics to learn which setups work best</div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[var(--tt-text-muted)]">
                    <strong className="text-yellow-400">
                      Ready to start tracking?
                    </strong>{" "}
                    The Trade Tracker refreshes every 30 seconds to show the
                    latest trades and updates. Click "Start Tracking!" to begin!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[var(--tt-bg-base)] border-2 border-[var(--tt-border)] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[var(--tt-border)] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-green-400"
                              : "bg-[var(--tt-bg-elevated)]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[var(--tt-text-muted)] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[var(--tt-bg-hover)] transition-colors"
                  title="Close Welcome Guide"
                >
                  Ã—
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[var(--tt-border)] p-4 flex items-center justify-between bg-[var(--tt-bg-surface)]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[var(--tt-border)] text-[var(--tt-text-muted)] opacity-50 cursor-not-allowed"
                      : "border-[var(--tt-border)] bg-[var(--tt-bg-elevated)] hover:bg-[var(--tt-bg-hover)] text-white"
                  }`}
                >
                  â† Previous
                </button>
                <div className="text-sm text-[var(--tt-text-muted)]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next â†’
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Tracking! ðŸš€
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Paper portfolio proof section (extracted from IIFE to fix Babel parse error)
      function PaperPortfolioProofSection({
        paperPortfolio,
        ledgerRangeDays,
        ledgerClosedTrades,
        setLedgerTab,
        setSelectedTicker,
        setSelectedTrade,
      }) {
        const pp = paperPortfolio ?? {};
        const p = pp.data?.portfolio || {};
        const ex = pp.data?.executions || {};
        const byDay =
          ex.byDay && typeof ex.byDay === "object" ? ex.byDay : {};
        const proof = pp.data?.proof;
        const proofByDay =
          proof && typeof proof.byDay === "object" ? proof.byDay : null;
        const openPos = Array.isArray(p.openPositions) ? p.openPositions : [];
        const dayKeyUtc = (ts) => {
          const d = new Date(Number(ts));
          if (!Number.isFinite(d.getTime())) return null;
          return d.toISOString().slice(0, 10);
        };
        const daysBackKeys = (n) => {
          const keys = [];
          for (let i = 0; i < n; i++) {
            const d = new Date();
            d.setUTCDate(d.getUTCDate() - i);
            keys.push(d.toISOString().slice(0, 10));
          }
          return keys;
        };
        const windowDays = Math.max(1, Number(ledgerRangeDays) || 7);
        const windowKeys = daysBackKeys(Math.min(60, windowDays));
        const entryByTradeId = new Map();
        const allEvents = [];
        for (const k of Object.keys(byDay)) {
          const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
          for (const e of arr) allEvents.push(e);
        }
        for (const e of allEvents) {
          const type = String(e?.type || "").toUpperCase();
          const tradeId = String(e?.trade_id || "");
          if (!tradeId || type !== "ENTRY") continue;
          const entryPrice = Number(e?.price);
          const direction = String(e?.direction || "").toUpperCase();
          if (
            Number.isFinite(entryPrice) &&
            (direction === "LONG" || direction === "SHORT")
          ) {
            entryByTradeId.set(tradeId, {
              entryPrice,
              direction,
              entryShares: Number.isFinite(Number(e?.shares)) ? Number(e?.shares) : null,
              entryTs: Number.isFinite(Number(e?.ts)) ? Number(e.ts) : null,
            });
          }
        }
        const pnlForEvent = (e) => {
          const type = String(e?.type || "").toUpperCase();
          if (type !== "TRIM" && type !== "EXIT") return null;
          const meta = entryByTradeId.get(String(e?.trade_id || ""));
          if (!meta) return null;
          const price = Number(e?.price);
          const shares = Number(e?.shares);
          if (!Number.isFinite(price) || !Number.isFinite(shares)) return null;
          const sign = meta.direction === "SHORT" ? -1 : 1;
          return (price - meta.entryPrice) * shares * sign;
        };
        const summarizeKeys = (keys) => {
          const out = { entries: 0, trims: 0, exits: 0, realizedPnl: 0, wins: 0, losses: 0 };
          const closedByTradeId = new Map();
          for (const k of keys) {
            const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
            for (const e of arr) {
              const type = String(e?.type || "").toUpperCase();
              if (type === "ENTRY") out.entries += 1;
              if (type === "TRIM") out.trims += 1;
              if (type === "EXIT") out.exits += 1;
              const pnl = pnlForEvent(e);
              if (Number.isFinite(pnl)) {
                out.realizedPnl += pnl;
                if (type === "EXIT" && e?.trade_id)
                  closedByTradeId.set(String(e.trade_id), pnl);
              }
            }
          }
          for (const pnl of closedByTradeId.values()) {
            if (Number.isFinite(pnl) && pnl !== 0) pnl > 0 ? (out.wins += 1) : (out.losses += 1);
          }
          const denom = out.wins + out.losses;
          out.winRate = denom > 0 ? (out.wins / denom) * 100 : null;
          out.closedTrades = denom;
          return out;
        };
        const summarizeOpen = () => {
          let unreal = 0;
          const rows = [];
          for (const pos of openPos) {
            const direction = String(pos?.direction || "").toUpperCase();
            const sign = direction === "SHORT" ? -1 : 1;
            const avgEntry = Number(pos?.avgEntry);
            const mark = Number(pos?.mark);
            const shares = Number(pos?.shares);
            if (!Number.isFinite(avgEntry) || !Number.isFinite(mark) || !Number.isFinite(shares)) continue;
            unreal += (mark - avgEntry) * shares * sign;
            rows.push({ ...pos, __unreal: (mark - avgEntry) * shares * sign });
          }
          rows.sort((a, b) => Number(b.__unreal) - Number(a.__unreal));
          return { unrealizedPnl: unreal, rows };
        };
        const today = summarizeKeys([new Date().toISOString().slice(0, 10)]);
        const week = summarizeKeys(daysBackKeys(7));
        const windowSum = summarizeKeys(windowKeys);
        const open = summarizeOpen();
        return (
          <div className="space-y-4">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 text-sm">
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Today</div>
                <div className="font-bold">{fmtInt(today.entries)} entries / {fmtInt(today.exits)} exits</div>
                <div className={today.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(today.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Week</div>
                <div className="font-bold">{fmtInt(week.closedTrades)} closed</div>
                <div className={week.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(week.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Window ({windowDays}d)</div>
                <div className="font-bold">{fmtInt(windowSum.closedTrades)} closed</div>
                <div className={windowSum.realizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(windowSum.realizedPnl)}</div>
              </div>
              <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-lg p-3">
                <div className="text-xs text-[var(--tt-text-muted)]">Open</div>
                <div className="font-bold">{fmtInt(openPos.length)} positions</div>
                <div className={open.unrealizedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}>{fmtUsd(open.unrealizedPnl)}</div>
              </div>
            </div>
            <div className="text-xs text-[var(--tt-text-muted)]">
              <button type="button" onClick={() => setLedgerTab && setLedgerTab("trades")} className="text-[var(--tt-accent)] hover:underline">
                Open Trades tab for full detail â†’
              </button>
            </div>
          </div>
        );
      }

      // Date range slider: start and end date thumbs, default full range
      function DateRangeSlider({ range, onRangeChange, sliderDays = 90 }) {
        const trackRef = useRef(null);
        const [dragging, setDragging] = useState(null); // 'start' | 'end'

        const minDate = (() => {
          const d = new Date();
          d.setDate(d.getDate() - sliderDays);
          d.setHours(0, 0, 0, 0);
          return d.getTime();
        })();
        const maxDate = (() => {
          const d = new Date();
          d.setHours(23, 59, 59, 999);
          return d.getTime();
        })();

        const rangeMs = maxDate - minDate;
        const startPct = Math.max(0, Math.min(100, ((range.start.getTime() - minDate) / rangeMs) * 100));
        const endPct = Math.max(0, Math.min(100, ((range.end.getTime() - minDate) / rangeMs) * 100));

        const moveToX = useCallback(
          (clientX, which) => {
            const el = trackRef.current;
            if (!el) return;
            const rect = el.getBoundingClientRect();
            const pct = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            const t = minDate + (pct / 100) * rangeMs;
            const d = new Date(t);
            if (which === "start") {
              const endTs = range.end.getTime();
              d.setTime(Math.min(d.getTime(), endTs));
              onRangeChange({ start: d, end: range.end });
            } else {
              const startTs = range.start.getTime();
              d.setTime(Math.max(d.getTime(), startTs));
              onRangeChange({ start: range.start, end: d });
            }
          },
          [minDate, rangeMs, range, onRangeChange],
        );

        useEffect(() => {
          if (!dragging) return;
          const onMove = (e) => moveToX(e.clientX, dragging);
          const onUp = () => setDragging(null);
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onUp);
          return () => {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onUp);
          };
        }, [dragging, moveToX]);

        const fmt = (d) => d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
        return (
          <div className="flex items-center gap-3">
            <div className="flex flex-col gap-1">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Start</div>
              <div className="text-xs font-medium text-[var(--tt-text)]">{fmt(range.start)}</div>
            </div>
            <div className="relative flex-1 min-w-[200px] max-w-[340px] h-6 flex items-center" ref={trackRef}>
              <div className="absolute inset-0 rounded-full bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)]" />
              <div
                className="absolute h-full rounded-full bg-[var(--tt-accent)]/30"
                style={{ left: `${startPct}%`, width: `${endPct - startPct}%` }}
              />
              <div
                role="slider"
                aria-label="Start date"
                tabIndex={0}
                className="absolute w-4 h-4 rounded-full border-2 border-[var(--tt-accent)] bg-[var(--tt-bg-surface)] cursor-ew-resize touch-none"
                style={{ left: `calc(${startPct}% - 8px)`, top: "50%", transform: "translateY(-50%)" }}
                onMouseDown={() => setDragging("start")}
              />
              <div
                role="slider"
                aria-label="End date"
                tabIndex={0}
                className="absolute w-4 h-4 rounded-full border-2 border-[var(--tt-accent)] bg-[var(--tt-bg-surface)] cursor-ew-resize touch-none"
                style={{ left: `calc(${endPct}% - 8px)`, top: "50%", transform: "translateY(-50%)" }}
                onMouseDown={() => setDragging("end")}
              />
            </div>
            <div className="flex flex-col gap-1">
              <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">End</div>
              <div className="text-xs font-medium text-[var(--tt-text)]">{fmt(range.end)}</div>
            </div>
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Investor Portfolio Panel â€” shown when "Investor" tab is active
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Map raw investor reason codes to human-readable descriptions
      function investorReasonLabel(reason, action) {
        if (!reason) return "â€”";
        const map = {
          auto_entry_accumulate: "Auto-buy: Accumulate stage (5-7% allocation)",
          auto_entry_watch: "Auto-buy: Watch stage (2% starter position)",
          auto_entry_core_hold: "Auto-buy: Core Hold (adding to position)",
          auto_reduce: "Auto-trim: Reduce stage (25% reduction)",
          auto_exit: "Auto-exit: Score dropped below threshold",
          manual_buy: "Manual buy",
          manual_sell: "Manual sell",
          initial_entry: "Initial position entry",
          dca_buy: "Dollar-cost average buy",
          test_cleanup: "Test / cleanup",
          rebalance_add: "Rebalance: adding to reach target allocation",
          rebalance_trim: "Rebalance: trimming to reduce overweight",
          score_drop: "Score dropped â€” reducing exposure",
          trend_reversal: "Weekly trend reversed â€” reducing exposure",
          rs_weak: "Relative strength weakened â€” reducing exposure",
        };
        return map[reason] || reason.replace(/_/g, " ");
      }

      function InvestorPortfolioPanel({ summary, trades, positions, loading, positionsLoading, tickerData }) {
        const startCash = summary?.startCash || 100000;
        const acctVal = summary?.accountValue ?? startCash;
        const totalRealized = summary?.totalRealized ?? 0;
        const unrealized = summary?.unrealized ?? 0;
        const totalPnl = totalRealized + unrealized;
        const pct = startCash ? (totalPnl / startCash) * 100 : 0;

        // Compute stats from trades
        const buys = (trades || []).filter(t => t.action === "BUY" || t.action === "DCA_BUY");
        const sells = (trades || []).filter(t => t.action === "SELL");
        const entries = buys.length;
        const exits = sells.length;
        const wins = sells.filter(t => (t.pnl || 0) > 0).length;
        const losses = sells.filter(t => (t.pnl || 0) < 0).length;
        const winRate = exits > 0 ? (wins / exits * 100) : 0;

        // Chart range state
        const [invChartRange, setInvChartRange] = useState("1Y");
        const [invChartHover, setInvChartHover] = useState(null);
        const chartRangeMs = { "1D": 864e5, "5D": 432e6, "10D": 864e6, "30D": 2592e6, "1Y": 31536e6 }[invChartRange] || 31536e6;

        // Build cumulative P&L chart points from sell trades
        const chartPoints = useMemo(() => {
          const pts = [{ ts: 0, value: 0 }];
          const sellsSorted = [...(trades || [])].filter(t => t.action === "SELL" && t.entry_ts).sort((a, b) => new Date(a.entry_ts) - new Date(b.entry_ts));
          let running = 0;
          for (const t of sellsSorted) {
            running += Number(t.pnl) || 0;
            pts.push({ ts: new Date(t.entry_ts).getTime(), value: running });
          }
          // Add current unrealized at now
          if (unrealized !== 0) pts.push({ ts: Date.now(), value: running + unrealized });
          return pts;
        }, [trades, unrealized]);

        // Filter chart points to range
        const chartPtsInRange = useMemo(() => {
          const now = Date.now();
          const start = now - chartRangeMs;
          const sorted = [...chartPoints].sort((a, b) => a.ts - b.ts);
          const before = sorted.filter(p => p.ts <= start);
          const startVal = before.length > 0 ? before[before.length - 1].value : 0;
          const inRange = sorted.filter(p => p.ts >= start);
          if (inRange.length === 0) return [{ ts: start, value: startVal }, { ts: now, value: startVal }];
          return inRange[0].ts > start ? [{ ts: start, value: startVal }, ...inRange] : inRange;
        }, [chartPoints, chartRangeMs]);

        // Sort positions by market value descending
        const sortedPositions = useMemo(() => {
          if (!positions) return [];
          return [...positions].sort((a, b) => (b.marketValue || 0) - (a.marketValue || 0));
        }, [positions]);

        // Trade by ticker
        const byTicker = useMemo(() => {
          const map = {};
          for (const t of trades || []) {
            if (!map[t.ticker]) map[t.ticker] = { ticker: t.ticker, buys: 0, sells: 0, totalPnl: 0, lots: [] };
            if (t.action === "BUY" || t.action === "DCA_BUY") map[t.ticker].buys++;
            if (t.action === "SELL") { map[t.ticker].sells++; map[t.ticker].totalPnl += (t.pnl || 0); }
            map[t.ticker].lots.push(t);
          }
          return Object.values(map).sort((a, b) => b.totalPnl - a.totalPnl);
        }, [trades]);

        // Trade by day
        const byDay = useMemo(() => {
          const map = {};
          for (const t of trades || []) {
            const day = t.entry_ts ? new Date(t.entry_ts).toISOString().slice(0, 10) : "unknown";
            if (!map[day]) map[day] = { day, entries: 0, exits: 0, pnl: 0, actions: [] };
            if (t.action === "BUY" || t.action === "DCA_BUY") map[day].entries++;
            if (t.action === "SELL") { map[day].exits++; map[day].pnl += (t.pnl || 0); }
            map[day].actions.push(t);
          }
          return Object.values(map).sort((a, b) => b.day.localeCompare(a.day));
        }, [trades]);

        // Today's activity
        const todayKey = new Date().toISOString().slice(0, 10);
        const todayTrades = useMemo(() => (trades || []).filter(t => {
          const d = t.entry_ts ? new Date(t.entry_ts).toISOString().slice(0, 10) : "";
          return d === todayKey;
        }), [trades, todayKey]);
        const todayBuys = todayTrades.filter(t => t.action === "BUY" || t.action === "DCA_BUY");
        const todaySells = todayTrades.filter(t => t.action === "SELL");
        const todayPnl = todaySells.reduce((s, t) => s + (Number(t.pnl) || 0), 0);

        // Total cost basis and market value from positions
        const totalCost = sortedPositions.reduce((s, p) => s + (Number(p.cost_basis) || 0), 0);
        const totalMktVal = sortedPositions.reduce((s, p) => s + (Number(p.marketValue) || 0), 0);

        // Accordion state for "By Day" trade history
        const [invExpandedByDayKey, setInvExpandedByDayKey] = useState(null);

        return (
          <div className="space-y-6">
            {/* â•â•â• Account value chart â€” hero section (matches Active Trader) â•â•â• */}
            <div className="tt-card overflow-hidden p-6">
              <div className="flex items-center justify-between mb-4">
                <div>
                  <p className="tt-label mb-0.5">Account value</p>
                  <p className="text-2xl font-semibold tracking-tight text-[var(--tt-text)]">{fmtUsd(acctVal)}</p>
                  <p className={`text-sm font-medium mt-1 ${totalPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                    {totalPnl >= 0 ? "Up" : "Down"} {fmtUsd(Math.abs(totalPnl))} ({pct >= 0 ? "+" : ""}{pct.toFixed(2)}%) from baseline
                  </p>
                </div>
                <div className="flex gap-1">
                  {["1D", "5D", "10D", "30D", "1Y"].map((r) => (
                    <button key={r} type="button" onClick={() => setInvChartRange(r)}
                      className={`px-3 py-1.5 rounded-lg text-xs font-medium transition-colors ${
                        invChartRange === r
                          ? "bg-[var(--tt-accent)]/20 text-[var(--tt-accent)] border border-[var(--tt-accent)]/40"
                          : "bg-transparent text-[var(--tt-text-muted)] border border-[var(--tt-border)] hover:text-[var(--tt-text)]"
                      }`}
                    >{r}</button>
                  ))}
                </div>
              </div>
              <div className="h-[120px] w-full flex items-center relative" aria-hidden="true">
                {chartPtsInRange.length >= 2 ? (() => {
                  const pts = chartPtsInRange;
                  const vals = pts.map(p => startCash + p.value);
                  const minV = Math.min(...vals);
                  const maxV = Math.max(...vals);
                  const rangeV = maxV - minV || 1;
                  const pad = 4, w = 600, h = 112;
                  const x = (i) => (pts.length <= 1 ? 0 : (i / (pts.length - 1)) * (w - 2 * pad) + pad);
                  const y = (v) => h - pad - ((v - minV) / rangeV) * (h - 2 * pad);
                  const d = pts.map((p, i) => `${i === 0 ? "M" : "L"} ${x(i)} ${y(startCash + p.value)}`).join(" ");
                  return (
                    <>
                    <svg width="100%" height="100%" viewBox={`0 0 ${w} ${h}`} preserveAspectRatio="none"
                      className="overflow-visible cursor-crosshair"
                      onMouseMove={(e) => {
                        const svg = e.currentTarget;
                        const rect = svg.getBoundingClientRect();
                        const mouseX = ((e.clientX - rect.left) / rect.width) * w;
                        let closest = 0, closestDist = Infinity;
                        for (let i = 0; i < pts.length; i++) {
                          const dist = Math.abs(x(i) - mouseX);
                          if (dist < closestDist) { closestDist = dist; closest = i; }
                        }
                        const p = pts[closest];
                        const val = startCash + p.value;
                        setInvChartHover({ idx: closest, x: x(closest), y: y(val), val, ts: p.ts, pnl: p.value });
                      }}
                      onMouseLeave={() => setInvChartHover(null)}
                    >
                      <defs>
                        <linearGradient id="inv-chart-grad" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="0%" stopColor="var(--tt-accent)" stopOpacity="0.25" />
                          <stop offset="100%" stopColor="var(--tt-accent)" stopOpacity="0" />
                        </linearGradient>
                      </defs>
                      <path fill="url(#inv-chart-grad)" d={`${d} L ${x(pts.length - 1)} ${h} L ${x(0)} ${h} Z`} />
                      <path fill="none" stroke="var(--tt-accent)" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" d={d} />
                      {invChartHover && (
                        <>
                          <line x1={invChartHover.x} y1={0} x2={invChartHover.x} y2={h} stroke="var(--tt-text-faint)" strokeWidth="1" strokeDasharray="3,3" />
                          <circle cx={invChartHover.x} cy={invChartHover.y} r="4" fill="var(--tt-accent)" stroke="var(--tt-bg)" strokeWidth="2" />
                        </>
                      )}
                    </svg>
                    {invChartHover && (
                      <div className="absolute pointer-events-none z-10"
                        style={{ left: `${Math.min((invChartHover.x / w) * 100, 80)}%`, top: `${Math.max(2, (invChartHover.y / h) * 100 - 15)}%` }}>
                        <div className="px-2.5 py-1 rounded text-[10px] font-semibold whitespace-nowrap"
                          style={{ background: "var(--tt-bg-elevated)", border: "1px solid var(--tt-border)", color: "var(--tt-text)" }}>
                          {fmtUsd(invChartHover.val)} {invChartHover.ts > 0 ? new Date(invChartHover.ts).toLocaleDateString() : ""}
                        </div>
                      </div>
                    )}
                    </>
                  );
                })() : (
                  <div className="flex-1 flex items-center justify-center text-[var(--tt-text-faint)] text-sm">
                    No history yet. Trades will appear as they close.
                  </div>
                )}
              </div>
              <p className="text-[10px] text-[var(--tt-text-faint)] mt-2">Baseline {fmtUsd(startCash)}</p>
            </div>

            {/* â•â•â• Stats grid (matches Active Trader 6-stat layout) â•â•â• */}
            <div className="grid grid-cols-2 sm:grid-cols-6 gap-3">
              <div className="tt-card p-3">
                <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Account</div>
                <div className="text-lg font-bold text-[var(--tt-text)]">{fmtUsd(acctVal)}</div>
              </div>
              <div className="tt-card p-3">
                <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Total P&L</div>
                <div className={`text-lg font-bold ${totalPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(totalPnl)}</div>
              </div>
              <div className="tt-card p-3">
                <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Today</div>
                <div className={`text-lg font-bold ${todayPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(todayPnl)}</div>
              </div>
              <div className="tt-card p-3">
                <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Open P&L</div>
                <div className={`text-lg font-bold ${unrealized >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(unrealized)}</div>
              </div>
              <div className="tt-card p-3">
                <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Closed</div>
                <div className="text-lg font-bold text-[var(--tt-text)]">{exits}</div>
              </div>
              <div className="tt-card p-3">
                <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Realized P&L</div>
                <div className={`text-lg font-bold ${totalRealized >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(totalRealized)}</div>
              </div>
            </div>

            {/* â•â•â• Today's Activity (matches Active Trader) â•â•â• */}
            <div className="tt-card p-4">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-sm font-semibold text-[var(--tt-text)] uppercase tracking-wide">Today's Activity</h2>
                <div className="text-xs text-[var(--tt-text-faint)]">
                  {new Date().toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" })}
                </div>
              </div>
              <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-4">
                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Entries</div>
                  <div className="text-lg font-bold text-cyan-400">{todayBuys.length}</div>
                </div>
                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Adds</div>
                  <div className="text-lg font-bold text-yellow-400">{todayTrades.filter(t => t.action === "DCA_BUY").length}</div>
                </div>
                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Exits</div>
                  <div className="flex items-baseline gap-1">
                    <span className="text-lg font-bold text-orange-400">{todaySells.length}</span>
                    {todaySells.length > 0 && (
                      <span className="text-[10px] text-[var(--tt-text-muted)]">
                        ({todaySells.filter(t => (t.pnl || 0) > 0).length}W / {todaySells.filter(t => (t.pnl || 0) < 0).length}L)
                      </span>
                    )}
                  </div>
                </div>
                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Realized P&L</div>
                  <div className={`text-lg font-bold ${todayPnl >= 0 ? "text-green-400" : "text-red-400"}`}>{fmtUsd(todayPnl)}</div>
                </div>
              </div>
            </div>

            {/* â•â•â• Open Positions â€” Compact card style (matches Active Trader) â•â•â• */}
            {(() => {
              const numFromAny = (v) => { const n = Number(v); return Number.isFinite(n) && n > 0 ? n : null; };
              const stageColors = {
                accumulate: { bg: "bg-emerald-500/15", color: "text-emerald-400", label: "ACCUMULATE" },
                core_hold: { bg: "bg-blue-500/15", color: "text-blue-400", label: "CORE HOLD" },
                watch: { bg: "bg-amber-500/15", color: "text-amber-400", label: "WATCH" },
                reduce: { bg: "bg-rose-500/15", color: "text-rose-400", label: "REDUCE" },
                research: { bg: "bg-white/10", color: "text-white/50", label: "RESEARCH" },
              };

              const renderInvCard = (p, i) => {
                const td = tickerData && (tickerData[p.ticker] || tickerData[p.ticker?.toUpperCase?.()]);
                const ep = numFromAny(p.avg_entry);
                const cp = numFromAny(p.currentPrice);
                const qty = numFromAny(p.total_shares);
                const pnl = p.unrealizedPnl || 0;
                const pnlPct = p.unrealizedPnlPct || 0;
                const isPositive = pnl >= 0;
                const dc = p.dailyChangePct || 0;
                const hasDayChg = Number.isFinite(dc);
                const stageLower = String(p.investor_stage || "").toLowerCase();
                const si = stageColors[stageLower] || { bg: "bg-white/10", color: "text-white/50", label: String(p.investor_stage || "â€”").toUpperCase() };

                // Progress bar: SL, EP, CP, TP from ticker data
                const slP = numFromAny(td?.sl || td?.sl_price || td?.stop_loss);
                const tpArr = Array.isArray(td?.tpArray) ? td.tpArray : [];
                const tp1 = numFromAny(tpArr[0]?.price || td?.tp_trim);
                const tp2 = numFromAny(tpArr[1]?.price || td?.tp_exit);
                const xp = numFromAny(tpArr[2]?.price || td?.tp_runner || td?.tp || td?.tp_max_price);

                const vals = [slP, ep, cp, tp1, tp2, xp].filter(v => v != null && v > 0);
                const hasBar = vals.length >= 2;
                let pctFn = () => 50;
                let fillPct = 0;
                let fillColor = "bg-white/[0.30]";
                let slMovedPastEntry = false;
                if (hasBar) {
                  const rawLo = Math.min(...vals);
                  const rawHi = Math.max(...vals);
                  const pad = (rawHi - rawLo) * 0.08;
                  const lo = rawLo - pad;
                  const hi = rawHi + pad;
                  const range = hi - lo;
                  pctFn = (v) => range <= 0 ? 50 : Math.max(0, Math.min(100, ((v - lo) / range) * 100));
                  fillPct = cp ? pctFn(cp) : 0;
                  slMovedPastEntry = ep && slP && slP > ep;
                  fillColor = fillPct >= 50 ? (fillPct >= 80 ? "bg-emerald-500/70" : "bg-emerald-500/50") : (fillPct <= 20 ? "bg-rose-500/55" : "bg-white/[0.30]");
                }

                const Mk = ({ val, label, color, tc, bottom }) => {
                  if (!val) return null;
                  return (
                    <div className="absolute" style={{ left: `${pctFn(val)}%`, width: "20px", marginLeft: "-10px", top: "-12px", bottom: "-12px" }}
                      title={`${label}: $${val.toFixed(2)}`}>
                      <div className={`absolute left-1/2 -translate-x-1/2 w-0.5 ${color}`} style={{ top: "12px", bottom: "12px" }} />
                      <span className={`absolute left-1/2 ${bottom ? "bottom-0" : "top-0"} -translate-x-1/2 text-[7px] font-extrabold ${tc} whitespace-nowrap`}>{label}</span>
                    </div>
                  );
                };

                return (
                  <div key={p.id || i} className="w-full text-left py-1.5 px-2 border-b border-white/[0.04] hover:bg-white/[0.02] transition-all">
                    {/* Row 1: Ticker, P&L, Entry, Current Price, Day Chg, Qty, Stage */}
                    <div className="flex items-center gap-2">
                      <span className="text-[11px] font-bold text-white w-[44px] shrink-0">{p.ticker}</span>
                      <span className="text-[9px] font-bold w-[10px] shrink-0 text-[#00c853]">L</span>
                      <span className={`text-[11px] font-semibold tabular-nums w-[60px] text-right shrink-0 ${isPositive ? "text-[#00c853]" : "text-[#ff5252]"}`}>
                        {fmtUsd(pnl)}
                      </span>
                      <span className={`text-[9px] tabular-nums w-[38px] text-right shrink-0 ${isPositive ? "text-[#00c853]/70" : "text-[#ff5252]/70"}`}>
                        {pnlPct >= 0 ? "+" : ""}{pnlPct.toFixed(1)}%
                      </span>
                      <span className="text-[10px] text-amber-300/90 tabular-nums w-[56px] shrink-0 text-right" title="Entry">
                        {ep ? `$${ep.toFixed(2)}` : "â€”"}
                      </span>
                      <span className="text-[10px] text-white tabular-nums w-[56px] shrink-0 text-right font-medium">
                        {cp ? `$${cp.toFixed(2)}` : "â€”"}
                      </span>
                      <span className={`text-[10px] tabular-nums w-[70px] shrink-0 text-right ${dc >= 0 ? "text-[#00c853]" : "text-[#ff5252]"}`}>
                        {hasDayChg ? `${dc >= 0 ? "+" : ""}${dc.toFixed(2)}%` : "â€”"}
                      </span>
                      <span className="text-[10px] text-[#9ca3af] tabular-nums w-[40px] shrink-0 text-right" title="Quantity">
                        {qty != null ? qty.toFixed(2) : "â€”"}
                      </span>
                      <span className="text-[9px] text-[#6b7280] w-[72px] shrink-0 truncate" title="Market Value">
                        {fmtUsd(p.marketValue || 0)}
                      </span>
                      <span className={`text-[8px] px-1.5 py-px rounded ${si.bg} ${si.color} font-medium shrink-0 ml-auto`}>
                        {si.label}
                      </span>
                    </div>
                  </div>
                );
              };

              return (
                <div className="p-4">
                  <div className="flex items-center justify-between mb-3">
                    <h2 className="text-[13px] font-medium text-[#d1d5db]">Open Positions</h2>
                    <div className="flex gap-4 text-[11px] text-[#4b5563]">
                      <span>{sortedPositions.length} open</span>
                      <span>Cost: {fmtUsd(totalCost)}</span>
                      <span>Mkt Val: {fmtUsd(totalMktVal)}</span>
                    </div>
                  </div>
                  {positionsLoading ? (
                    <div className="text-center py-8 text-[var(--tt-text-muted)]">Loading positions...</div>
                  ) : sortedPositions.length === 0 ? (
                    <div className="text-center py-8 text-[var(--tt-text-muted)]">No open positions</div>
                  ) : (
                    <div className="space-y-0">
                      {/* Column headers */}
                      <div className="flex items-center gap-2 px-2 py-1 border-b border-white/[0.06] text-[8px] font-semibold uppercase tracking-wider text-[#6b7280]">
                        <span className="w-[44px] shrink-0">Ticker</span>
                        <span className="w-[10px] shrink-0"></span>
                        <span className="w-[60px] shrink-0 text-right">P&L</span>
                        <span className="w-[38px] shrink-0 text-right">%</span>
                        <span className="w-[56px] shrink-0 text-right">Entry</span>
                        <span className="w-[56px] shrink-0 text-right">Current Price</span>
                        <span className="w-[70px] shrink-0 text-right">Day Chg</span>
                        <span className="w-[40px] shrink-0 text-right">Qty</span>
                        <span className="w-[72px] shrink-0">Mkt Value</span>
                        <span className="shrink-0 text-center ml-auto" style={{ width: "60px" }}>Stage</span>
                      </div>
                      {[...sortedPositions].sort((a, b) => String(a.ticker || "").localeCompare(String(b.ticker || ""))).map((p, i) => renderInvCard(p, i))}
                    </div>
                  )}
                </div>
              );
            })()}

            {/* â•â•â• Trade History â€” Today (full width table), then By Day (accordion) + P&L by Ticker (2 cols) â•â•â• */}
            <div className="tt-card p-4">
              <h2 className="text-sm font-semibold text-[var(--tt-text)] uppercase tracking-wide mb-3">Trade History</h2>

              {/* Row 1: Today's Trades â€” full width table */}
              <div className="mb-4">
                <h3 className="text-xs font-medium text-[var(--tt-text-faint)] mb-2 uppercase tracking-wider">Today</h3>
                <div className="max-h-[600px] overflow-y-auto overflow-x-auto">
                  {(() => {
                    const todayKey = new Date().toISOString().slice(0, 10);
                    const todayTrades = (trades || []).filter(t => {
                      const d = t.entry_ts ? new Date(t.entry_ts).toISOString().slice(0, 10) : "";
                      return d === todayKey;
                    });
                    if (loading) return <div className="text-[13px] text-[var(--tt-text-faint)] py-2">Loading...</div>;
                    if (todayTrades.length === 0) return <div className="text-[13px] text-[var(--tt-text-faint)] py-2">No activity today</div>;
                    return (
                      <>
                        <div className="grid grid-cols-[50px_52px_48px_68px_50px_68px_1fr] gap-1.5 px-2 py-1 border-b border-white/[0.06] text-[9px] font-semibold uppercase tracking-wider text-[#6b7280]">
                          <span>Time</span><span>Ticker</span><span>Action</span><span className="text-right">Price</span><span className="text-right">Qty</span><span className="text-right">P&L</span><span className="truncate">Reason</span>
                        </div>
                        {todayTrades.slice(0, 100).map((t, idx) => {
                          const isBuy = t.action === "BUY" || t.action === "DCA_BUY";
                          const isSell = t.action === "SELL";
                          const ts = t.entry_ts ? new Date(t.entry_ts) : null;
                          const actionLabel = t.action === "DCA_BUY" ? "ADD" : t.action;
                          const actionColor = isBuy ? "text-cyan-400" : isSell ? "text-rose-400" : "text-yellow-400";
                          const pnlStr = isSell && t.pnl != null ? fmtUsd(t.pnl) : "";
                          const pnlColor = (t.pnl || 0) >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]";
                          const qty = Number(t.shares || 0);
                          const reason = String(t.reason || "").replace(/_/g, " ");
                          return (
                            <div key={t.trade_id || idx} className="grid grid-cols-[50px_52px_48px_68px_50px_68px_1fr] gap-1.5 px-2 py-1.5 text-[12px] border-b border-white/[0.02] hover:bg-white/[0.02]">
                              <span className="text-[var(--tt-text-muted)]">{ts ? ts.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" }) : "â€”"}</span>
                              <span className="font-medium text-[var(--tt-text)] truncate">{t.ticker}</span>
                              <span className={`${actionColor} font-semibold`}>{actionLabel}</span>
                              <span className="text-right text-[var(--tt-text)]">{t.entry_price != null ? `$${Number(t.entry_price).toFixed(2)}` : "â€”"}</span>
                              <span className="text-right text-[var(--tt-text-muted)]">{qty > 0 ? qty.toFixed(2) : "â€”"}</span>
                              <span className={`text-right font-semibold ${pnlColor}`}>{pnlStr}</span>
                              <span className="text-[var(--tt-text-faint)] truncate capitalize" title={reason}>{reason || "â€”"}</span>
                            </div>
                          );
                        })}
                      </>
                    );
                  })()}
                </div>
              </div>

              {/* Row 2: By Day (accordion) + P&L by Ticker â€” 2-column */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Col 1: By Day â€” accordion */}
                <div>
                  <h3 className="text-xs font-medium text-[var(--tt-text-faint)] mb-2 uppercase tracking-wider">By day</h3>
                  <div className="space-y-1 max-h-[800px] overflow-y-auto">
                    {byDay.length === 0 ? (
                      <div className="text-[13px] text-[var(--tt-text-faint)] py-2">No trades by day</div>
                    ) : byDay.slice(0, 100).map(d => {
                      const isExpanded = invExpandedByDayKey === d.day;
                      return (
                        <div key={d.day} className="rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] overflow-hidden">
                          <div
                            className="flex items-center justify-between py-2 px-3 hover:bg-[var(--tt-bg-hover)] cursor-pointer transition-colors"
                            onClick={() => setInvExpandedByDayKey(isExpanded ? null : d.day)}
                          >
                            <div className="flex items-center gap-2">
                              <button type="button" className="text-[var(--tt-text-muted)] hover:text-[var(--tt-text)] text-xs w-5 h-5 flex items-center justify-center" aria-label={isExpanded ? "Collapse" : "Expand"}>
                                {isExpanded ? "âˆ’" : "+"}
                              </button>
                              <span className="text-[13px] font-medium text-[var(--tt-text)]">{d.day}</span>
                            </div>
                            <div className="flex items-center gap-3 text-[13px]">
                              <span className="text-[var(--tt-text-muted)]">{d.entries}E/{d.exits}X</span>
                              <span className={`font-semibold ${d.pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                                {d.pnl !== 0 ? fmtUsd(d.pnl) : "â€”"}
                              </span>
                            </div>
                          </div>
                          {isExpanded && d.actions && d.actions.length > 0 && (
                            <div className="px-3 pb-2 pt-0 border-t border-[var(--tt-border)]">
                              <div className="mt-1.5 space-y-1 text-[13px]">
                                <div className="grid grid-cols-[70px_50px_60px_70px_70px] gap-1.5 px-1 text-[11px] text-[var(--tt-text-faint)] font-medium uppercase">
                                  <span>Ticker</span><span>Action</span><span>Time</span><span>Price</span><span className="text-right">P&L</span>
                                </div>
                                {d.actions.sort((a, b) => String(a.ticker || "").localeCompare(String(b.ticker || "")) || new Date(a.entry_ts || 0) - new Date(b.entry_ts || 0)).map((t, i) => {
                                  const isBuy = t.action === "BUY" || t.action === "DCA_BUY";
                                  const isSell = t.action === "SELL";
                                  const ts = t.entry_ts ? new Date(t.entry_ts) : null;
                                  const actionColor = isBuy ? "text-cyan-400" : isSell ? "text-rose-400" : "text-yellow-400";
                                  return (
                                    <div key={`${t.ticker}-${i}`} className="grid grid-cols-[70px_50px_60px_70px_70px] gap-1.5 py-1 px-1 rounded bg-[var(--tt-bg)] items-center">
                                      <span className="font-medium text-[var(--tt-text)] truncate">{t.ticker}</span>
                                      <span className={`${actionColor} font-semibold`}>{t.action === "DCA_BUY" ? "ADD" : t.action}</span>
                                      <span className="text-[var(--tt-text-muted)]">{ts ? ts.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", hour12: true }) : "â€”"}</span>
                                      <span className="text-[var(--tt-text)]">{t.entry_price != null ? `$${Number(t.entry_price).toFixed(2)}` : "â€”"}</span>
                                      <span className={`text-right font-semibold ${(t.pnl || 0) >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{isSell && t.pnl != null ? fmtUsd(t.pnl) : ""}</span>
                                    </div>
                                  );
                                })}
                              </div>
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>
                {/* Col 2: P&L by Ticker */}
                <div>
                  <h3 className="text-xs font-medium text-[var(--tt-text-faint)] mb-2 uppercase tracking-wider">P&L by Ticker</h3>
                  <div className="space-y-1 max-h-[800px] overflow-y-auto">
                    {byTicker.length === 0 ? (
                      <div className="text-[13px] text-[var(--tt-text-faint)] py-2">No trades</div>
                    ) : (() => {
                      const maxAbs = Math.max(...byTicker.map(r => Math.abs(r.totalPnl)), 1);
                      return byTicker.slice(0, 100).map(t => {
                        const pctBar = Math.min(Math.abs(t.totalPnl) / maxAbs, 1) * 100;
                        const isGain = t.totalPnl >= 0;
                        return (
                          <div key={t.ticker} className="relative flex items-center justify-between py-2 px-3 rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] hover:bg-[var(--tt-bg-hover)] transition-colors overflow-hidden">
                            <div className="absolute top-0 bottom-0 left-0" style={{ width: `${pctBar}%`, background: isGain ? "rgba(0,200,83,0.10)" : "rgba(255,82,82,0.10)" }} />
                            <div className="relative flex items-center gap-2">
                              <span className="text-[13px] font-medium text-[var(--tt-text)]">{t.ticker}</span>
                            </div>
                            <div className="relative flex items-center gap-3 text-[13px]">
                              <span className="text-[var(--tt-text-muted)]">{t.buys}B / {t.sells}S</span>
                              <span className={`font-semibold ${isGain ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                                {isGain ? "+" : ""}{fmtUsd(t.totalPnl)}
                              </span>
                            </div>
                          </div>
                        );
                      });
                    })()}
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Main App
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function App() {
        const { data, loading, refreshing, error, lastUpdate, refetch } =
          useTickerData();
        const {
          trades,
          loading: tradesLoading,
          refreshing: tradesRefreshing,
          error: tradesError,
          addTrade,
          updateTrade,
          refetch: refetchTrades,
        } = useSimulatedTrades();
        const { sectors } = useSectors();
        const { summary: acctSummary } = useAccountSummary("trader");

        // â”€â”€ Investor portfolio data â”€â”€
        const { summary: investorSummary } = useAccountSummary("investor");
        const [investorTrades, setInvestorTrades] = useState(null);
        const [investorTradesLoading, setInvestorTradesLoading] = useState(false);
        const [investorPositions, setInvestorPositions] = useState(null);
        const [investorPosLoading, setInvestorPosLoading] = useState(false);
        const [portfolioTab, setPortfolioTab] = useState("trader"); // "trader" | "investor"

        // Fetch investor trades + open positions when tab is active
        useEffect(() => {
          if (portfolioTab !== "investor") return;
          let cancelled = false;
          setInvestorTradesLoading(true);
          setInvestorPosLoading(true);
          // Fetch trades and positions in parallel
          Promise.all([
            fetch(`${API_BASE}/timed/ledger/trades?mode=investor&limit=500`).then(r => r.json()),
            fetch(`${API_BASE}/timed/investor/positions?status=OPEN&compact=true`).then(r => r.json()),
          ]).then(([tradesJson, posJson]) => {
            if (cancelled) return;
            if (tradesJson.ok) setInvestorTrades(tradesJson.trades || []);
            if (posJson.ok) setInvestorPositions(posJson.positions || []);
          }).catch(() => {}).finally(() => {
            if (!cancelled) { setInvestorTradesLoading(false); setInvestorPosLoading(false); }
          });
          return () => { cancelled = true; };
        }, [portfolioTab]);

        // Welcome Guide state
        const [showWelcomeDashboard, setShowWelcomeDashboard] = useState(false);
        const [showWelcomeTracker, setShowWelcomeTracker] = useState(() => {
          const hasSeenWelcome = localStorage.getItem(
            "timedTrading_welcomeSeen",
          );
          return !hasSeenWelcome;
        });

        const handleWelcomeDashboardClose = () => {
          setShowWelcomeDashboard(false);
        };

        const handleWelcomeTrackerClose = () => {
          setShowWelcomeTracker(false);
          localStorage.setItem("timedTrading_welcomeSeen", "true");
        };

        // Version filter state
        const [selectedVersion, setSelectedVersion] = useState("all");
        const [horizonFilter, setHorizonFilter] = useState("ALL");

        // Unified experience: D1-backed Trade Journey (single mode)
        const trackerMode = "ledger";
        // Make Proof the default landing view (high-signal summary).
        // Single view: no Proof/Trades/Alerts tabs
        const [accountChartRange, setAccountChartRange] = useState("1D"); // 1D | 5D | 10D | 30D | 1Y
        const [chartHover, setChartHover] = useState(null); // { idx, x, y, val, ts, pnl }
        const [expandedPositionTicker, setExpandedPositionTicker] = useState(null); // ticker for expanded card
        const initialLedgerTicker = (() => {
          try {
            const t =
              new URLSearchParams(window.location.search).get("ticker") || "";
            return String(t).trim().toUpperCase();
          } catch {
            return "";
          }
        })();
        const [ledgerTickerFilter, setLedgerTickerFilter] =
          useState(initialLedgerTicker);
        const [ledgerStatusFilter, setLedgerStatusFilter] = useState("all");
        // Date range for Trade Tracker: start and end (default Feb 2 = first trade)
        const SLIDER_RANGE_DAYS = 90;
        const [ledgerDateRange, setLedgerDateRange] = useState(() => {
          const end = new Date();
          end.setHours(23, 59, 59, 999);
          const start = new Date(end.getFullYear(), 1, 2); // Feb 2 (month 1 = February)
          start.setHours(0, 0, 0, 0);
          if (start.getTime() > end.getTime()) start.setFullYear(start.getFullYear() - 1);
          return { start, end };
        });
        const [ledgerIncludeEvidence, setLedgerIncludeEvidence] =
          useState(true);

        const ledgerRangeDays = useMemo(() => {
          const a = ledgerDateRange.start.getTime();
          const b = ledgerDateRange.end.getTime();
          return Math.max(1, Math.round((b - a) / (24 * 60 * 60 * 1000)));
        }, [ledgerDateRange]);

        const windowLabel = useMemo(() => {
          const days = ledgerRangeDays;
          return days === 1 ? "Today" : `Last ${days}d`;
        }, [ledgerRangeDays]);

        // P&L by ticker: computed at component level so Engine calibration / P&L section (outside paperPortfolio IIFE) can use it.
        const pnlByTickerWindow = useMemo(() => {
          const pp = paperPortfolio ?? {};
          const openPos = Array.isArray(pp.data?.portfolio?.openPositions)
            ? pp.data.portfolio.openPositions
            : [];
          const byDay = pp.data?.executions?.byDay && typeof pp.data.executions.byDay === "object"
            ? pp.data.executions.byDay
            : {};
          const windowDays = Math.max(1, Number(ledgerRangeDays) || 7);
          const daysBackKeys = (n) => {
            const keys = [];
            for (let i = 0; i < n; i++) {
              const d = new Date();
              d.setUTCDate(d.getUTCDate() - i);
              keys.push(d.toISOString().slice(0, 10));
            }
            return keys;
          };
          const windowKeys = daysBackKeys(Math.min(60, windowDays));

          const entryByTradeId = new Map();
          for (const k of Object.keys(byDay)) {
            const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
            for (const e of arr) {
              const type = String(e?.type || "").toUpperCase();
              const tradeId = String(e?.trade_id || "");
              if (!tradeId || type !== "ENTRY") continue;
              const entryPrice = Number(e?.price);
              const entryShares = Number(e?.shares);
              const entryTs = Number(e?.ts);
              const direction = String(e?.direction || "").toUpperCase();
              if (Number.isFinite(entryPrice) && (direction === "LONG" || direction === "SHORT")) {
                entryByTradeId.set(tradeId, { entryPrice, direction, entryShares: Number.isFinite(entryShares) ? entryShares : null, entryTs: Number.isFinite(entryTs) ? entryTs : null });
              }
            }
          }
          const pnlForEvent = (e) => {
            const type = String(e?.type || "").toUpperCase();
            if (type !== "TRIM" && type !== "EXIT") return null;
            const tradeId = String(e?.trade_id || "");
            const meta = tradeId ? entryByTradeId.get(tradeId) : null;
            if (!meta) return null;
            const price = Number(e?.price);
            const shares = Number(e?.shares);
            if (!Number.isFinite(price) || !Number.isFinite(shares)) return null;
            const sign = meta.direction === "SHORT" ? -1 : 1;
            return (price - meta.entryPrice) * shares * sign;
          };

          const fromTape = () => {
            const realized = new Map();
            for (const k of windowKeys) {
              const arr = Array.isArray(byDay[k]) ? byDay[k] : [];
              for (const e of arr) {
                const pnl = pnlForEvent(e);
                if (!Number.isFinite(pnl) || pnl === 0) continue;
                const tkr = String(e?.ticker || "").toUpperCase();
                if (!tkr) continue;
                realized.set(tkr, (realized.get(tkr) || 0) + pnl);
              }
            }
            const unreal = new Map();
            for (const pos of openPos) {
              const tkr = String(pos?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const direction = String(pos?.direction || "").toUpperCase();
              const sign = direction === "SHORT" ? -1 : 1;
              const avgEntry = Number(pos?.avgEntry);
              const mark = Number(pos?.mark);
              const shares = Number(pos?.shares);
              if (!Number.isFinite(avgEntry) || !Number.isFinite(mark) || !Number.isFinite(shares)) continue;
              const pnl = (mark - avgEntry) * shares * sign;
              if (!Number.isFinite(pnl) || pnl === 0) continue;
              unreal.set(tkr, (unreal.get(tkr) || 0) + pnl);
            }
            const tickers = new Set([...realized.keys(), ...unreal.keys()]);
            const rows = Array.from(tickers)
              .map((ticker) => ({
                ticker,
                realized: Number(realized.get(ticker) || 0),
                unrealized: Number(unreal.get(ticker) || 0),
                total: Number(realized.get(ticker) || 0) + Number(unreal.get(ticker) || 0),
              }))
              .filter((r) => Number.isFinite(r.total) && r.total !== 0);
            rows.sort((a, b) => Math.abs(b.total) - Math.abs(a.total));
            const maxAbs = rows.reduce((m, r) => Math.max(m, Math.abs(r.total)), 0);
            return { rows, maxAbs };
          };

          let out = fromTape();
          if (out.rows.length === 0 && ((Array.isArray(ledgerClosedTrades) && ledgerClosedTrades.length > 0) || openPos.length > 0)) {
            const realized = new Map();
            for (const t of ledgerClosedTrades || []) {
              const tkr = String(t?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const pnl = Number(t?.pnl);
              if (!Number.isFinite(pnl)) continue;
              realized.set(tkr, (realized.get(tkr) || 0) + pnl);
            }
            const unreal = new Map();
            for (const pos of openPos) {
              const tkr = String(pos?.ticker || "").toUpperCase();
              if (!tkr) continue;
              const dir = String(pos?.direction || "").toUpperCase();
              const sign = dir === "SHORT" ? -1 : 1;
              const avg = Number(pos?.avgEntry);
              const mark = Number(pos?.mark);
              const sh = Number(pos?.shares);
              if (!Number.isFinite(avg) || !Number.isFinite(mark) || !Number.isFinite(sh)) continue;
              unreal.set(tkr, (unreal.get(tkr) || 0) + (mark - avg) * sh * sign);
            }
            const tickers = new Set([...realized.keys(), ...unreal.keys()]);
            const rows = Array.from(tickers)
              .map((ticker) => {
                const r = Number(realized.get(ticker) || 0);
                const u = Number(unreal.get(ticker) || 0);
                return { ticker, realized: r, unrealized: u, total: r + u };
              })
              .filter((r) => Number.isFinite(r.total) && r.total !== 0);
            rows.sort((a, b) => Math.abs(b.total) - Math.abs(a.total));
            const maxAbs = rows.reduce((m, r) => Math.max(m, Math.abs(r.total)), 0);
            out = { rows, maxAbs };
          }
          return out;
        }, [paperPortfolio?.data, ledgerClosedTrades, ledgerRangeDays]);

        const startOfDay = (d) => {
          const x = new Date(d);
          x.setHours(0, 0, 0, 0);
          return x;
        };
        const endOfDay = (d) => {
          const x = new Date(d);
          x.setHours(23, 59, 59, 999);
          return x;
        };
        const ledgerSince = useMemo(
          () => startOfDay(ledgerDateRange.start).getTime(),
          [ledgerDateRange.start],
        );
        const ledgerUntil = useMemo(
          () => endOfDay(ledgerDateRange.end).getTime(),
          [ledgerDateRange.end],
        );

        const ledgerTrades = useLedgerTrades({
          ticker: ledgerTickerFilter.trim(),
          status: ledgerStatusFilter,
          since: ledgerSince,
          until: ledgerUntil,
          pageSize: 200,
        });
        const ledgerAlerts = useLedgerAlerts({
          ticker: ledgerTickerFilter.trim(),
          since: ledgerSince,
          until: ledgerUntil,
          pageSize: 200,
        });
        const ledgerSummary = useLedgerSummary({
          since: ledgerSince,
          until: ledgerUntil,
        });
        const paperPortfolio = usePaperPortfolio();
        // Legacy "Trade Detail" right rail removed; use unified ticker right rail instead.

        const rankedTickers = useMemo(() => {
          return getRankedTickers(data);
        }, [data]);

        const rankedTickerPositions = useMemo(() => {
          const map = {};
          rankedTickers.forEach((t, idx) => {
            const sym = String(t.ticker || "")
              .trim()
              .toUpperCase();
            const pos = Number(t?.rank_position);
            const rankPos = Number.isFinite(pos) && pos > 0 ? pos : idx + 1;
            if (sym && map[sym] == null) {
              map[sym] = rankPos;
            }
          });
          return map;
        }, [rankedTickers]);

        // All trades (unfiltered) â€” used for account value so it's always consistent
        const allLedgerItems = useMemo(() => {
          const lt = ledgerTrades ?? {};
          return Array.isArray(lt.items) ? lt.items : [];
        }, [ledgerTrades?.items]);

        const ledgerFilteredTrades = useMemo(() => {
          if (horizonFilter === "ALL") return allLedgerItems;
          return allLedgerItems.filter((t) => {
            const sym = String(t.ticker || "").toUpperCase();
            const live = data && (data[sym] || data[t.ticker]);
            const key = computeHorizonKey(live || t);
            return key === horizonFilter;
          });
        }, [allLedgerItems, horizonFilter, data]);

        // Open: not WIN/LOSS, no exit_ts, trimmed_pct < 100% (safety net)
        const ledgerOpenTrades = useMemo(
          () =>
            ledgerFilteredTrades.filter((t) => {
              const trimmedPct = Number(t.trimmed_pct ?? t.trimmedPct ?? 0);
              return (
                t.status !== "WIN" &&
                t.status !== "LOSS" &&
                !t.exit_ts &&
                trimmedPct < 0.9999
              );
            }),
          [ledgerFilteredTrades],
        );

        // Closed: WIN/LOSS/FLAT or 100% trimmed
        const ledgerClosedTrades = useMemo(
          () =>
            ledgerFilteredTrades.filter(
              (t) =>
                t.status === "WIN" ||
                t.status === "LOSS" ||
                t.status === "FLAT" ||
                Number(t.trimmed_pct ?? t.trimmedPct ?? 0) >= 0.9999,
            ),
          [ledgerFilteredTrades],
        );

        const ledgerActivityDays = useMemo(() => {
          const MIN_SANE_TS = 946684800000; // Jan 1, 2000 â€” skip bogus epoch/pre-2000 so they don't show as "Dec 31, 1969"
          const sane = (ts) => ts != null && Number.isFinite(ts) && ts > 0 && ts >= MIN_SANE_TS;
          const events = [];
          const dayKeyFor = (ts) => {
            const d = new Date(Number(ts));
            if (!Number.isFinite(d.getTime())) return "unknown";
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, "0");
            const dd = String(d.getDate()).padStart(2, "0");
            return `${yyyy}-${mm}-${dd}`;
          };

          for (const t of ledgerFilteredTrades) {
            const entryTs = tsToMs(t.entry_ts);
            if (sane(entryTs)) {
              events.push({
                ts: entryTs,
                type: "ENTRY",
                trade: t,
                price: Number(t.entry_price),
              });
            }
            const trimTsRaw = t.trim_ts ?? t.updated_at ?? t.exit_ts ?? t.entry_ts;
            if (
              (t.status === "TP_HIT_TRIM" || Number(t.trimmed_pct) > 0) &&
              trimTsRaw != null &&
              Number.isFinite(Number(trimTsRaw))
            ) {
              const trimTs = tsToMs(trimTsRaw) ?? Number(trimTsRaw);
              if (sane(trimTs)) {
                events.push({
                  ts: trimTs,
                  type: "TRIM",
                  trade: t,
                  price: null,
                });
              }
            }
            const exitTs = tsToMs(t.exit_ts);
            const trimmedPct = Number(t.trimmed_pct ?? t.trimmedPct ?? 0);
            const isClosed = t.status === "WIN" || t.status === "LOSS" || trimmedPct >= 0.9999;
            if (isClosed && sane(exitTs)) {
              events.push({
                ts: exitTs,
                type: "EXIT",
                trade: t,
                price: Number(t.exit_price),
              });
            }
          }

          const groups = new Map();
          for (const ev of events) {
            const key = dayKeyFor(ev.ts);
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(ev);
          }

          const keys = Array.from(groups.keys()).sort((a, b) =>
            a < b ? 1 : -1,
          );
          return keys.map((key) => {
            const items = groups.get(key) || [];
            items.sort((a, b) => b.ts - a.ts);
            const stats = items.reduce(
              (acc, ev) => {
                if (ev.type === "ENTRY") acc.entries += 1;
                if (ev.type === "TRIM") acc.trims += 1;
                if (ev.type === "EXIT") acc.exits += 1;
                if (ev.type === "EXIT")
                  acc.closedPnl += Number(ev.trade.pnl || 0);
                return acc;
              },
              { entries: 0, trims: 0, exits: 0, closedPnl: 0 },
            );
            const label =
              key === "unknown"
                ? "Unknown date"
                : new Date(`${key}T00:00:00`).toLocaleDateString(undefined, {
                    weekday: "short",
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                  });
            return { key, label, events: items, stats };
          });
        }, [ledgerFilteredTrades]);

        const ledgerClosedByTicker = useMemo(() => {
          const groups = new Map();
          for (const t of ledgerClosedTrades) {
            const key = String(t.ticker || "").toUpperCase();
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(t);
          }
          const tickers = Array.from(groups.keys()).sort((a, b) =>
            a.localeCompare(b),
          );
          return tickers.map((ticker) => {
            const trades = groups.get(ticker) || [];
            trades.sort(
              (a, b) => Number(b.exit_ts || 0) - Number(a.exit_ts || 0),
            );
            const totalPnl = trades.reduce(
              (sum, t) => sum + Number(t.pnl || 0),
              0,
            );
            return { ticker, trades, totalPnl };
          });
        }, [ledgerClosedTrades]);

        const todayActions = useMemo(() => {
          const todayKey = (() => {
            const d = new Date();
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, "0");
            const dd = String(d.getDate()).padStart(2, "0");
            return `${yyyy}-${mm}-${dd}`;
          })();
          const todayStartMs = new Date(todayKey + "T00:00:00").getTime();
          const todayEndMs = todayStartMs + 24 * 60 * 60 * 1000;
          const actions = [];
          const seenActionKeys = new Set();
          for (const t of (ledgerFilteredTrades || [])) {
            const entryTs = tsToMs(t.entry_ts);
            if (entryTs >= todayStartMs && entryTs < todayEndMs) {
              const key = `entry-${t.ticker}-${entryTs}`;
              if (!seenActionKeys.has(key)) {
                seenActionKeys.add(key);
                actions.push({ ts: entryTs, type: "ENTRY", ticker: t.ticker, direction: t.direction || "LONG", price: Number(t.entry_price), pnl: null, trade: t });
              }
            }
            const trimTsRaw = t.trim_ts ?? t.updated_at;
            const trimTs = trimTsRaw ? tsToMs(trimTsRaw) : null;
            if (trimTs >= todayStartMs && trimTs < todayEndMs && Number(t.trimmed_pct) > 0) {
              const key = `trim-${t.ticker}-${trimTs}`;
              if (!seenActionKeys.has(key)) {
                seenActionKeys.add(key);
                actions.push({ ts: trimTs, type: "TRIM", ticker: t.ticker, direction: t.direction || "LONG", price: Number(t.trim_price) || null, trimmedPct: Number(t.trimmed_pct) || 0, pnl: null, trade: t });
              }
            }
            const exitTs = tsToMs(t.exit_ts);
            if (exitTs >= todayStartMs && exitTs < todayEndMs && (t.status === "WIN" || t.status === "LOSS")) {
              const key = `exit-${t.ticker}-${exitTs}`;
              if (!seenActionKeys.has(key)) {
                seenActionKeys.add(key);
                actions.push({ ts: exitTs, type: "EXIT", ticker: t.ticker, direction: t.direction || "LONG", price: Number(t.exit_price), pnl: Number(t.pnl || 0), status: t.status, trade: t });
              }
            }
          }
          actions.sort((a, b) => b.ts - a.ts);
          return actions;
        }, [ledgerFilteredTrades]);

        const portfolioSummary = useMemo(() => {
          let netPnl = 0;
          let totalGain = 0;
          let totalLoss = 0;
          for (const t of ledgerFilteredTrades) {
            const pnl = Number(t.pnl);
            if (!Number.isFinite(pnl)) continue;
            netPnl += pnl;
            if (pnl >= 0) totalGain += pnl;
            else totalLoss += pnl;
          }
          return {
            netPnl,
            totalGain,
            totalLoss,
            totalTrades: ledgerFilteredTrades.length,
          };
        }, [ledgerFilteredTrades]);

        const getPositionMetrics = (trade, live) => {
          const sym = String(trade.ticker || "").toUpperCase();
          const isFutures = FUTURES_SPECS[sym] || sym.endsWith("1!");
          const pointValue =
            isFutures && FUTURES_SPECS[sym] ? FUTURES_SPECS[sym].pointValue : 1;
          const entryPrice = Number(trade.entry_price ?? trade.entryPrice ?? 0);
          const shares =
            trade.shares ?? trade.quantity ??
            (isFutures ? 1 : entryPrice > 0 ? TRADE_SIZE / entryPrice : 0);
          // Prefer live price feed (_live_price) so Open Positions matches Right Rail and actual current price
          const livePriceRaw = Number(live?._live_price ?? live?.price);
          const livePrice = Number.isFinite(livePriceRaw) && livePriceRaw > 0 ? livePriceRaw : null;
          const direction = String(trade.direction || "").toUpperCase();
          const signed = direction === "SHORT" ? -1 : 1;

          // Prefer D1 pre-computed P&L (accurate from replay) over live price calculation when no live feed.
          // When we have live price from /timed/prices, use it so UI matches Right Rail.
          const tradePnl = Number(trade.pnl ?? trade.pnl_amount);
          const tradePnlPct = Number(trade.pnlPct ?? trade.pnl_pct);
          const hasStoredPnl = Number.isFinite(tradePnl);
          const hasStoredPnlPct = Number.isFinite(tradePnlPct);

          // Determine current price: live feed (_live_price) > stored P&L back-compute > live?.price
          let current = null;
          let pnlOpen = null;
          let retOpenPct = null;

          if (Number.isFinite(livePrice) && entryPrice > 0) {
            current = livePrice;
            pnlOpen = (current - entryPrice) * shares * pointValue * signed;
            retOpenPct = ((current - entryPrice) / entryPrice) * 100 * signed;
          } else if (hasStoredPnl) {
            pnlOpen = tradePnl;
            retOpenPct = hasStoredPnlPct ? tradePnlPct : (entryPrice > 0 ? (tradePnl / (entryPrice * shares * pointValue)) * 100 : null);
            current = entryPrice > 0 ? entryPrice + (tradePnl / (shares * pointValue)) * signed : null;
          }

          return {
            isFutures,
            pointValue,
            entryPrice,
            shares,
            current,
            pnlOpen,
            retOpenPct,
          };
        };

        // Aggregate metrics when same ticker has multiple open entries (e.g. two ENTRY events)
        const getAggregatedPositionMetrics = (trades, live) => {
          if (!trades || trades.length === 0) return null;
          if (trades.length === 1) return getPositionMetrics(trades[0], live);
          const sym = String(trades[0].ticker || "").toUpperCase();
          const isFutures = FUTURES_SPECS[sym] || sym.endsWith("1!");
          const pointValue = isFutures && FUTURES_SPECS[sym] ? FUTURES_SPECS[sym].pointValue : 1;
          const livePriceRaw = Number(live?._live_price ?? live?.price);
          const livePrice = Number.isFinite(livePriceRaw) && livePriceRaw > 0 ? livePriceRaw : null;
          let totalShares = 0;
          let costBasis = 0;
          let pnlOpen = 0;
          let hasAllStoredPnl = true;
          for (const t of trades) {
            const entryPrice = Number(t.entry_price ?? t.entryPrice ?? 0);
            const shares = t.shares ?? t.quantity ?? (isFutures ? 1 : entryPrice > 0 ? TRADE_SIZE / entryPrice : 0);
            const direction = String(t.direction || "").toUpperCase();
            const signed = direction === "SHORT" ? -1 : 1;
            totalShares += shares;
            costBasis += entryPrice * shares;
            // Prefer stored P&L from D1 (accurate from replay)
            const tradePnl = Number(t.pnl ?? t.pnl_amount);
            if (Number.isFinite(tradePnl)) {
              pnlOpen += tradePnl;
            } else if (Number.isFinite(livePrice) && entryPrice > 0) {
              pnlOpen += (livePrice - entryPrice) * shares * pointValue * signed;
              hasAllStoredPnl = false;
            } else {
              hasAllStoredPnl = false;
            }
          }
          const entryPrice = totalShares > 0 ? costBasis / totalShares : 0;
          const direction = String(trades[0].direction || "").toUpperCase();
          const signed = direction === "SHORT" ? -1 : 1;
          // Back-compute current price from aggregate P&L for display
          const current = Number.isFinite(livePrice)
            ? livePrice
            : (hasAllStoredPnl && totalShares > 0 && entryPrice > 0
              ? entryPrice + (pnlOpen / (totalShares * pointValue)) * signed
              : null);
          const retOpenPct = entryPrice > 0 && current != null
            ? ((current - entryPrice) / entryPrice) * 100 * signed
            : null;
          return {
            isFutures,
            pointValue,
            entryPrice,
            shares: totalShares,
            current,
            pnlOpen: Number.isFinite(pnlOpen) ? pnlOpen : null,
            retOpenPct,
          };
        };

        // All positions grouped by ticker â€” unified view (open + closed combined)
        const ledgerAllByTicker = useMemo(() => {
          const groups = new Map();
          for (const t of ledgerFilteredTrades) {
            const key = String(t.ticker || "").toUpperCase();
            if (!groups.has(key)) groups.set(key, { open: [], closed: [] });
            const isClosed = t.status === "WIN" || t.status === "LOSS" || Number(t.trimmed_pct ?? t.trimmedPct ?? 0) >= 0.9999;
            if (isClosed) groups.get(key).closed.push(t);
            else groups.get(key).open.push(t);
          }
          return Array.from(groups.keys()).sort((a, b) => a.localeCompare(b)).map((ticker) => {
            const { open, closed } = groups.get(ticker);
            const allTrades = [...open, ...closed].sort((a, b) => Number(b.entry_ts || 0) - Number(a.entry_ts || 0));
            const live = data && (data[ticker] || data[allTrades[0]?.ticker]);
            const unrealizedPnl = open.reduce((sum, t) => {
              const m = getPositionMetrics(t, live);
              return sum + (Number(m.pnlOpen) || 0);
            }, 0);
            const closedPnl = closed.reduce((sum, t) => sum + Number(t.pnl || 0), 0);
            const totalPnl = unrealizedPnl + closedPnl;
            const wins = closed.filter(t => Number(t.pnl || 0) > 0).length;
            const losses = closed.filter(t => Number(t.pnl || 0) < 0).length;
            const direction = allTrades[0]?.direction || "LONG";
            return { ticker, trades: allTrades, open, closed, unrealizedPnl, closedPnl, totalPnl, wins, losses, direction, hasOpen: open.length > 0 };
          });
        }, [ledgerFilteredTrades, data]);

        // Open positions grouped by ticker (for By Ticker column)
        const ledgerOpenByTicker = useMemo(() => {
          const groups = new Map();
          for (const t of ledgerOpenTrades) {
            const key = String(t.ticker || "").toUpperCase();
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(t);
          }
          return Array.from(groups.keys()).sort((a, b) => a.localeCompare(b)).map((ticker) => {
            const trades = groups.get(ticker) || [];
            const live = data && (data[ticker] || data[trades[0]?.ticker]);
            const unrealizedPnl = trades.reduce((sum, t) => {
              const m = getPositionMetrics(t, live);
              return sum + (Number(m.pnlOpen) || 0);
            }, 0);
            const totalQty = trades.reduce((sum, t) => sum + (Number(t.qty ?? t.total_qty) || 0), 0);
            const direction = trades[0]?.direction || "LONG";
            return { ticker, trades, unrealizedPnl, totalQty, direction, isOpen: true };
          });
        }, [ledgerOpenTrades, data]);

        // Range in ms for account chart (1D, 5D, 10D, 30D, 1Y)
        const accountChartRangeMs = useMemo(() => {
          const day = 24 * 60 * 60 * 1000;
          const map = { "1D": 1 * day, "5D": 5 * day, "10D": 10 * day, "30D": 30 * day, "1Y": 365 * day };
          return map[accountChartRange] ?? 1 * day;
        }, [accountChartRange]);

        // Overall account value over time â€” ALWAYS uses ALL trades (unfiltered) to stay
        // in lockstep with the Dashboard's Account Value calculation.
        const allOpenTrades = useMemo(
          () => allLedgerItems.filter((t) => {
            const trimmedPct = Number(t.trimmed_pct ?? t.trimmedPct ?? 0);
            return t.status !== "WIN" && t.status !== "LOSS" && !t.exit_ts && trimmedPct < 0.9999;
          }),
          [allLedgerItems],
        );
        const portfolioChartPoints = useMemo(() => {
          const points = [{ ts: 0, value: 0 }];
          const closed = allLedgerItems.filter(
            (t) =>
              t.status === "WIN" ||
              t.status === "LOSS" ||
              Number(t.trimmed_pct ?? t.trimmedPct ?? 0) >= 0.9999,
          );
          const sorted = [...closed].sort(
            (a, b) => (tsToMs(a.exit_ts) ?? 0) - (tsToMs(b.exit_ts) ?? 0),
          );
          let running = 0;
          for (const t of sorted) {
            const exitTs = tsToMs(t.exit_ts);
            if (exitTs == null) continue;
            running += Number(t.pnl) || 0;
            points.push({ ts: exitTs, value: running });
          }
          const openPnl = allOpenTrades.reduce((sum, t) => {
            const m = getPositionMetrics(
              t,
              data && (data[t.ticker] || data[String(t.ticker).toUpperCase()]),
            );
            return sum + (Number(m.pnlOpen) || 0);
          }, 0);
          points.push({
            ts: Date.now(),
            value: running + openPnl,
          });
          return points;
        }, [
          allLedgerItems,
          allOpenTrades,
          data,
        ]);

        // Filter chart points to selected time frame; add start-of-range point for clean line
        const portfolioChartPointsInRange = useMemo(() => {
          const now = Date.now();
          const start = now - accountChartRangeMs;
          const sorted = [...portfolioChartPoints].sort((a, b) => a.ts - b.ts);
          const beforeStart = sorted.filter((p) => p.ts <= start);
          const startValue = beforeStart.length > 0 ? beforeStart[beforeStart.length - 1].value : 0;
          const inRange = sorted.filter((p) => p.ts >= start);
          if (inRange.length === 0) return [{ ts: start, value: startValue }, { ts: now, value: startValue }];
          const firstInRange = inRange[0];
          const withStart = firstInRange.ts > start
            ? [{ ts: start, value: startValue }, ...inRange]
            : inRange;
          return withStart;
        }, [portfolioChartPoints, accountChartRangeMs]);

        // Positions with trade history in asc time order (Robinhood-style)
        // Group open trades by ticker so multiple entries (e.g. AEHR 36 + 35) aggregate qty and P&L
        const positionsWithHistory = useMemo(() => {
          const byTicker = new Map();
          for (const t of ledgerFilteredTrades) {
            const ticker = String(t.ticker || "").toUpperCase();
            if (!ticker) continue;
            const entryTs = tsToMs(t.entry_ts);
            if (entryTs != null) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              byTicker.get(ticker).push({
                ts: entryTs,
                type: "ENTRY",
                trade: t,
                price: Number(t.entry_price),
              });
            }
            const trimTs = tsToMs(t.trim_ts ?? t.updated_at ?? t.exit_ts ?? t.entry_ts);
            if (
              (t.status === "TP_HIT_TRIM" || Number(t.trimmed_pct) > 0) &&
              trimTs != null
            ) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              const trimPrice = Number(t.trim_price ?? t.trimPrice ?? t.tp ?? t.tp_price) || null;
              byTicker.get(ticker).push({
                ts: trimTs,
                type: "TRIM",
                trade: t,
                price: Number.isFinite(trimPrice) ? trimPrice : null,
              });
            }
            const exitTs = tsToMs(t.exit_ts);
            if (
              (t.status === "WIN" || t.status === "LOSS") &&
              exitTs != null
            ) {
              if (!byTicker.has(ticker)) byTicker.set(ticker, []);
              byTicker.get(ticker).push({
                ts: exitTs,
                type: "EXIT",
                trade: t,
                price: Number(t.exit_price),
              });
            }
          }
          const openByTicker = new Map();
          for (const t of ledgerOpenTrades) {
            const ticker = String(t.ticker || "").toUpperCase();
            if (!ticker) continue;
            if (!openByTicker.has(ticker)) openByTicker.set(ticker, []);
            openByTicker.get(ticker).push(t);
          }
          const result = [];
          for (const [ticker, trades] of openByTicker) {
            const live = data && (data[ticker] || data[trades[0].ticker]);
            const metrics = getAggregatedPositionMetrics(trades, live);
            const events = (byTicker.get(ticker) || []).sort(
              (a, b) => a.ts - b.ts,
            );
            result.push({
              ticker,
              isOpen: true,
              qty: metrics.shares,
              entryPrice: metrics.entryPrice,
              mktValue:
                Number.isFinite(metrics.current) && Number.isFinite(metrics.shares)
                  ? metrics.current * metrics.shares
                  : null,
              current: metrics.current,
              pnlOpen: metrics.pnlOpen,
              retOpenPct: metrics.retOpenPct,
              trade: trades[0],
              events,
            });
          }
          for (const [ticker, events] of byTicker) {
            if (openByTicker.has(ticker)) continue;
            const sorted = events.sort((a, b) => a.ts - b.ts);
            const lastTrade = sorted.length
              ? sorted[sorted.length - 1].trade
              : null;
            result.push({
              ticker,
              isOpen: false,
              qty: null,
              entryPrice: lastTrade
                ? Number(lastTrade.entry_price ?? lastTrade.entryPrice)
                : null,
              mktValue: null,
              current: null,
              pnlOpen: null,
              trade: lastTrade,
              events: sorted,
            });
          }
          result.sort((a, b) => a.ticker.localeCompare(b.ticker));
          return result;
        }, [ledgerFilteredTrades, ledgerOpenTrades, data]);

        const openPositionCards = useMemo(
          () => positionsWithHistory.filter((p) => p.isOpen),
          [positionsWithHistory],
        );

        // Daily summary state
        const [dailySummary, setDailySummary] = useState(null);
        const [summaryLoading, setSummaryLoading] = useState(false);
        const [showSummary, setShowSummary] = useState(false);

        // Selected ticker for detail view
        const [selectedTicker, setSelectedTicker] = useState(null);

        // Expanded day key for By-day events (ticker, action, time, price)
        const [expandedByDayKey, setExpandedByDayKey] = useState(null);

        // Selected trade for right rail; positionEvents for Trade Tracker history
        const [selectedTrade, setSelectedTrade] = useState(null);
        const [selectedPositionEvents, setSelectedPositionEvents] = useState(null);

        // Trade Tracker date range filter
        const [tradeDateRange, setTradeDateRange] = useState({
          startDate: (() => {
            const today = new Date();
            return today.toISOString().split("T")[0];
          })(),
          endDate: (() => {
            const today = new Date();
            return today.toISOString().split("T")[0];
          })(),
        });

        // Get unique versions from trades (for dropdown)
        const availableVersions = useMemo(() => {
          const versionSet = new Set(
            trades.map((t) => t.scriptVersion || "unknown").filter(Boolean),
          );
          return Array.from(versionSet).sort().reverse(); // Most recent first
        }, [trades]);

        // Filter trades by version (client-side), de-dupe only exact duplicates, and sort alphabetically
        const filteredTrades = useMemo(() => {
          let filtered =
            selectedVersion === "all"
              ? trades
              : trades.filter(
                  (t) => (t.scriptVersion || "unknown") === selectedVersion,
                );

          // Remove duplicates: keep the most recent trade for each exact trade key
          // (Ticker + Direction + EntryTime/Id). This prevents accidental collapsing of real historical trades.
          const tradeMap = new Map();
          filtered.forEach((trade) => {
            const entryKey =
              trade.entryTime ||
              trade.entryTs ||
              trade.trigger_ts ||
              trade.id ||
              "";
            const key = `${trade.ticker}_${trade.direction}_${entryKey}`;
            const existing = tradeMap.get(key);
            if (!existing) {
              tradeMap.set(key, trade);
            } else {
              // Keep the most recent one (by entryTime)
              const existingTime = new Date(existing.entryTime || 0).getTime();
              const currentTime = new Date(trade.entryTime || 0).getTime();
              if (currentTime > existingTime) {
                tradeMap.set(key, trade);
              }
            }
          });

          // Convert back to array and sort alphabetically by ticker
          filtered = Array.from(tradeMap.values());
          filtered.sort((a, b) => {
            const tickerA = String(a.ticker || "").toUpperCase();
            const tickerB = String(b.ticker || "").toUpperCase();
            return tickerA.localeCompare(tickerB);
          });

          return filtered;
        }, [trades, selectedVersion]);

        // Keep Current Price fresh by overriding open/trimmed trades with latest ticker prices.
        // Trades returned by the Worker can lag between runs; this makes the UI reflect latest ingested prices.
        // GUARD: Only override P&L if live price is reasonably fresh (< 60 min old).
        // Stale KV prices (e.g. from old TradingView captures) cause wildly wrong P&L display.
        const filteredTradesWithLivePrices = useMemo(() => {
          if (!Array.isArray(filteredTrades)) return [];
          return filteredTrades.map((t) => {
            const symRaw = t?.ticker;
            if (!symRaw) return t;
            const sym = String(symRaw).toUpperCase();
            const live = (data && (data[sym] || data[symRaw])) || null;
            const livePrice =
              live && live.price != null ? Number(live.price) : NaN;
            const isOpenLike =
              t.status === "OPEN" || !t.status || t.status === "TP_HIT_TRIM";
            if (!isOpenLike || !Number.isFinite(livePrice)) return t;

            // Staleness check: don't override D1 P&L with stale price data
            const livePriceTs = Number(live.data_source_ts || live.ts || live.ingest_ts || 0);
            const tradeUpdatedAt = Number(t.updated_at || t.entry_ts || 0);
            const priceAgeMs = Date.now() - livePriceTs;
            const isStale = priceAgeMs > 60 * 60 * 1000; // > 1 hour old
            const tradeHasStoredPnl = Number.isFinite(Number(t.pnl));

            // If live price is stale but trade has D1 pnl, keep the stored values
            if (isStale && tradeHasStoredPnl) return t;

            const next = {
              ...t,
              currentPrice: livePrice,
              _uiPriceTs: livePriceTs || null,
            };

            // Recompute P&L using latest price so the UI always reflects the latest move.
            // This does not change status; the Worker remains the source of truth for state transitions.
            const tickerSymbol = String(next.ticker || "").toUpperCase();
            const isFutures =
              FUTURES_SPECS[tickerSymbol] || tickerSymbol.endsWith("1!");
            const pointValue =
              isFutures && FUTURES_SPECS[tickerSymbol]
                ? FUTURES_SPECS[tickerSymbol].pointValue
                : 1;
            const entryPrice = Number(next.entryPrice);
            const tp = Number(next.tp);
            const sl = Number(next.sl);
            const currentPrice = Number(next.currentPrice);
            const trimmedPct = Number(next.trimmedPct) || 0;
            const shares =
              next.shares ||
              (isFutures && FUTURES_SPECS[tickerSymbol]
                ? 1
                : TRADE_SIZE / (entryPrice || 1));

            if (
              Number.isFinite(entryPrice) &&
              Number.isFinite(tp) &&
              Number.isFinite(sl) &&
              Number.isFinite(currentPrice) &&
              Number.isFinite(shares)
            ) {
              let pnl = 0;
              let pnlPct = 0;

              if (next.direction === "LONG") {
                const hitTP = currentPrice >= tp;
                const hitSL = currentPrice <= sl;
                if (hitTP) {
                  const tpDiff = tp - entryPrice;
                  pnl =
                    tpDiff * shares * pointValue * (trimmedPct === 0 ? 0.5 : 1);
                  pnlPct = ((tp - entryPrice) / entryPrice) * 100;
                } else if (hitSL) {
                  const slDiff = sl - entryPrice;
                  pnl = slDiff * shares * pointValue;
                  pnlPct = ((sl - entryPrice) / entryPrice) * 100;
                } else {
                  const priceDiff = currentPrice - entryPrice;
                  pnl = priceDiff * shares * pointValue;
                  pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;
                }
              } else if (next.direction === "SHORT") {
                const hitTP = currentPrice <= tp;
                const hitSL = currentPrice >= sl;
                if (hitTP) {
                  const tpDiff = entryPrice - tp;
                  pnl =
                    tpDiff * shares * pointValue * (trimmedPct === 0 ? 0.5 : 1);
                  pnlPct = ((entryPrice - tp) / entryPrice) * 100;
                } else if (hitSL) {
                  const slDiff = entryPrice - sl;
                  pnl = slDiff * shares * pointValue;
                  pnlPct = ((entryPrice - sl) / entryPrice) * 100;
                } else {
                  const priceDiff = entryPrice - currentPrice;
                  pnl = priceDiff * shares * pointValue;
                  pnlPct = ((entryPrice - currentPrice) / entryPrice) * 100;
                }
              }

              next.pnl = pnl;
              next.pnlPct = pnlPct;
            }

            return next;
          });
        }, [filteredTrades, data]);

        const tradesForDisplay = useMemo(() => {
          if (!Array.isArray(filteredTradesWithLivePrices)) return [];
          if (horizonFilter === "ALL") return filteredTradesWithLivePrices;
          return filteredTradesWithLivePrices.filter((t) => {
            const sym = String(t.ticker || "").toUpperCase();
            const live = data && (data[sym] || data[t.ticker]);
            const key = computeHorizonKey(live || t);
            return key === horizonFilter;
          });
        }, [filteredTradesWithLivePrices, data, horizonFilter]);

        const analytics = useTradeAnalytics(filteredTradesWithLivePrices);

        // Trade simulation is handled by Worker - just refresh trades periodically
        useEffect(() => {
          // Initial fetch on mount
          refetchTrades();

          // Refresh trades every 30 seconds to get latest updates from Worker
          const refreshInterval = setInterval(() => {
            refetchTrades();
          }, 30000);

          return () => clearInterval(refreshInterval);
        }, [refetchTrades]);

        // Fetch daily summary
        const fetchDailySummary = useCallback(async () => {
          setSummaryLoading(true);
          try {
            const res = await fetch(`${API_BASE}/timed/ai/daily-summary`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) {
              setDailySummary(json);
              setShowSummary(true);
            } else {
              throw new Error(json.error || "Failed to fetch summary");
            }
          } catch (err) {
            console.error("Daily summary error:", err);
            alert(`Failed to fetch daily summary: ${err.message}`);
          } finally {
            setSummaryLoading(false);
          }
        }, []);

        const openTrades = tradesForDisplay.filter(
          (t) => t.status === "OPEN" || !t.status || t.status === "TP_HIT_TRIM",
        );
        const closedTrades = tradesForDisplay.filter(
          (t) => t.status === "WIN" || t.status === "LOSS",
        );

        return (
          <div className="tt-root">
            <div className="min-h-screen p-0" style={{ background: "var(--tt-bg-base)" }}>
              {/* â•â•â• Unified Nav Bar â•â•â• */}
              <nav className="sticky top-0 z-50 flex items-center justify-between px-4 py-2.5 border-b border-white/[0.06]" style={{background:"rgba(10,10,15,0.95)",backdropFilter:"blur(12px)"}}>
                <div className="flex items-center gap-5">
                  <a href="index-react.html" className="flex items-center gap-2.5 no-underline">
                    <div className="w-[32px] h-[32px] rounded-[8px] flex items-center justify-center" style={{background:"linear-gradient(135deg, #00c853, #00e676, #69f0ae)"}}>
                      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                        <polyline points="22 7 13.5 15.5 8.5 10.5 2 17" />
                        <polyline points="16 7 22 7 22 13" />
                      </svg>
                    </div>
                    <span className="text-[15px] font-bold text-white" style={{letterSpacing:"-0.03em"}}>Timed Trading</span>
                  </a>
                  <div className="flex items-center gap-0.5">
                    <a href="index-react.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Active Trader</a>
                    <a href="investor-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Investor</a>
                    <a href="simulation-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-white bg-white/[0.07] font-medium">Trades</a>
                    <a href="model-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Model</a>
                    <a href="screener.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Screener</a>
                    <a href="ticker-management.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Tickers</a>
                    <a href="daily-brief.html" id="nav-daily-brief" className="relative px-3 py-1 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium">
                      Daily Brief
                      <span id="brief-badge" className="hidden absolute -top-0.5 -right-0.5 w-2 h-2 rounded-full bg-[#f59e0b]" style={{animation: "pulse-badge 2s ease-in-out infinite"}} />
                    </a>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <span className="text-[11px] text-[#4b5563]">Paper Â· $1k/trade</span>
                  {window.TimedUserBadge && <window.TimedUserBadge user={window.TimedAuthHelpers?.getStoredSession()} compact />}
                </div>
              </nav>

              <div className="w-full mx-auto px-4 pt-2">
                {/* â•â•â• Portfolio Tab Toggle â•â•â• */}
                <div className="flex items-center gap-1 mb-4 border-b border-[var(--tt-border)]">
                  <button
                    onClick={() => setPortfolioTab("trader")}
                    className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${
                      portfolioTab === "trader"
                        ? "border-[var(--tt-accent)] text-[var(--tt-accent)]"
                        : "border-transparent text-[var(--tt-text-muted)] hover:text-[var(--tt-text)]"
                    }`}
                  >
                    Active Trader
                  </button>
                  <button
                    onClick={() => setPortfolioTab("investor")}
                    className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${
                      portfolioTab === "investor"
                        ? "border-[var(--tt-accent)] text-[var(--tt-accent)]"
                        : "border-transparent text-[var(--tt-text-muted)] hover:text-[var(--tt-text)]"
                    }`}
                  >
                    Investor
                  </button>
                </div>

                {/* â•â•â• Investor Portfolio Panel â•â•â• */}
                {portfolioTab === "investor" && (
                  <InvestorPortfolioPanel
                    summary={investorSummary}
                    trades={investorTrades}
                    positions={investorPositions}
                    loading={investorTradesLoading}
                    positionsLoading={investorPosLoading}
                    tickerData={data}
                  />
                )}

                {/* â•â•â• Active Trader Portfolio â•â•â• */}
                {portfolioTab === "trader" && (<>
                <header className="flex items-center justify-between gap-4 flex-wrap mb-6">
                  <div className="flex items-center gap-4">
                    <h1 className="text-lg font-semibold tracking-tight text-[var(--tt-text)]">
                      Active Trader Account
                    </h1>
                  </div>
                  <div className="flex items-center gap-4 flex-wrap">
                    <DateRangeSlider
                      range={ledgerDateRange}
                      onRangeChange={setLedgerDateRange}
                      sliderDays={SLIDER_RANGE_DAYS}
                    />
                    {(loading || tradesLoading) && (
                      <div className="loading-spinner" />
                    )}
                    {lastUpdate && (
                      <span className="text-xs text-[var(--tt-text-faint)]">
                        Updated {lastUpdate.toLocaleTimeString()}
                        {(refreshing || tradesRefreshing) && " Â· refreshingâ€¦"}
                      </span>
                    )}
                    <button
                      onClick={() => { refetch(); refetchTrades(); }}
                      className="tt-pill tt-pill-active text-[13px]"
                    >
                      Refresh
                    </button>
                    <button
                      type="button"
                      onClick={async () => {
                        try {
                          const res = await fetch(`${API_BASE}/timed/trades?source=positions`, { cache: "no-store" });
                          const json = await res.json();
                          if (!res.ok || !json.ok) throw new Error(json.error || res.statusText);
                          const blob = new Blob([JSON.stringify({ exported: new Date().toISOString(), trades: json.trades || [], count: json.count }, null, 2)], { type: "application/json" });
                          const a = document.createElement("a");
                          a.href = URL.createObjectURL(blob);
                          a.download = `timed-positions-${new Date().toISOString().slice(0, 10)}.json`;
                          a.click();
                          URL.revokeObjectURL(a.href);
                        } catch (e) {
                          console.error("Export failed:", e);
                        }
                      }}
                      className="tt-pill tt-pill-inactive text-[13px]"
                      title="Export positions (reconciliation)"
                    >
                      Export
                    </button>
                  </div>
                </header>

                {/* Single view: account value ($100k baseline) + open position cards (wider content when no rail) */}
                <div className="flex gap-4 items-start">
                  <div className={`flex-1 min-w-0 max-w-full ${selectedTicker || selectedTrade ? "mr-[470px]" : ""}`}>
                    {(ledgerTrades ?? {}).loading ? (
                      <div className="text-sm text-[var(--tt-text-muted)] py-8">Loadingâ€¦</div>
                    ) : (ledgerTrades ?? {}).error ? (
                      <div className="text-sm text-[var(--tt-negative)] py-4">Ledger unavailable: {(ledgerTrades ?? {}).error}</div>
                    ) : (
                      <div className="space-y-6">
                        {/* Account value chart â€” hero section */}
                        <div className="tt-card overflow-hidden p-6">
                          <div className="flex items-center justify-between mb-4">
                            <div>
                              <p className="tt-label mb-0.5">Account value</p>
                              <p className="text-2xl font-semibold tracking-tight text-[var(--tt-text)]">
                                {fmtUsd(acctSummary?.accountValue ?? BASELINE_ACCOUNT)}
                              </p>
                              {(() => {
                                const acctVal = acctSummary?.accountValue ?? BASELINE_ACCOUNT;
                                const pnl = acctVal - BASELINE_ACCOUNT;
                                const pct = BASELINE_ACCOUNT ? (pnl / BASELINE_ACCOUNT) * 100 : 0;
                                return (
                                  <p className={`text-sm font-medium mt-1 ${pnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                                    {pnl >= 0 ? "Up" : "Down"} {fmtUsd(Math.abs(pnl))} ({pct >= 0 ? "+" : ""}{pct.toFixed(2)}%) from baseline
                                  </p>
                                );
                              })()}
                            </div>
                            <div className="flex gap-1">
                              {["1D", "5D", "10D", "30D", "1Y"].map((r) => (
                                <button
                                  key={r}
                                  type="button"
                                  onClick={() => setAccountChartRange(r)}
                                  className={`px-3 py-1.5 rounded-lg text-xs font-medium transition-colors ${
                                    accountChartRange === r
                                      ? "bg-[var(--tt-accent)]/20 text-[var(--tt-accent)] border border-[var(--tt-accent)]/40"
                                      : "bg-transparent text-[var(--tt-text-muted)] border border-[var(--tt-border)] hover:text-[var(--tt-text)]"
                                  }`}
                                >
                                  {r}
                                </button>
                              ))}
                            </div>
                          </div>
                          <div className="h-[120px] w-full flex items-center relative" aria-hidden="true">
                            {portfolioChartPointsInRange.length >= 2 ? (() => {
                              const pts = portfolioChartPointsInRange;
                              const vals = pts.map((p) => BASELINE_ACCOUNT + p.value);
                              const minV = Math.min(...vals);
                              const maxV = Math.max(...vals);
                              const rangeV = maxV - minV || 1;
                              const pad = 4;
                              const w = 600;
                              const h = 112;
                              const x = (i) => (pts.length <= 1 ? 0 : (i / (pts.length - 1)) * (w - 2 * pad) + pad);
                              const y = (v) => h - pad - ((v - minV) / rangeV) * (h - 2 * pad);
                              const d = pts.map((p, i) => `${i === 0 ? "M" : "L"} ${x(i)} ${y(BASELINE_ACCOUNT + p.value)}`).join(" ");
                              return (
                                <>
                                <svg
                                  width="100%" height="100%"
                                  viewBox={`0 0 ${w} ${h}`}
                                  preserveAspectRatio="none"
                                  className="overflow-visible cursor-crosshair"
                                  onMouseMove={(e) => {
                                    const svg = e.currentTarget;
                                    const rect = svg.getBoundingClientRect();
                                    const mouseX = ((e.clientX - rect.left) / rect.width) * w;
                                    let closest = 0;
                                    let closestDist = Infinity;
                                    for (let i = 0; i < pts.length; i++) {
                                      const dist = Math.abs(x(i) - mouseX);
                                      if (dist < closestDist) { closestDist = dist; closest = i; }
                                    }
                                    const p = pts[closest];
                                    const val = BASELINE_ACCOUNT + p.value;
                                    setChartHover({ idx: closest, x: x(closest), y: y(val), val, ts: p.ts, pnl: p.value });
                                  }}
                                  onMouseLeave={() => setChartHover(null)}
                                >
                                  <defs>
                                    <linearGradient id="tt-chart-gradient" x1="0" y1="0" x2="0" y2="1">
                                      <stop offset="0%" stopColor="var(--tt-accent)" stopOpacity="0.25" />
                                      <stop offset="100%" stopColor="var(--tt-accent)" stopOpacity="0" />
                                    </linearGradient>
                                  </defs>
                                  <path fill="url(#tt-chart-gradient)" d={`${d} L ${x(pts.length - 1)} ${h} L ${x(0)} ${h} Z`} />
                                  <path fill="none" stroke="var(--tt-accent)" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" d={d} />
                                  {chartHover && (
                                    <>
                                      <line x1={chartHover.x} y1={0} x2={chartHover.x} y2={h} stroke="var(--tt-text-faint)" strokeWidth="1" strokeDasharray="3,3" />
                                      <circle cx={chartHover.x} cy={chartHover.y} r="4" fill="var(--tt-accent)" stroke="var(--tt-bg)" strokeWidth="2" />
                                    </>
                                  )}
                                </svg>
                                {chartHover && (
                                  <div
                                    className="absolute pointer-events-none z-10"
                                    style={{
                                      left: `${Math.min((chartHover.x / w) * 100, 80)}%`,
                                      top: `${Math.max(2, (chartHover.y / h) * 100 - 15)}%`,
                                    }}
                                  >
                                    <div className="px-2.5 py-1 rounded text-[10px] font-semibold whitespace-nowrap"
                                      style={{
                                        background: "var(--tt-bg-elevated)",
                                        border: "1px solid var(--tt-border)",
                                        color: "var(--tt-text)",
                                      }}>
                                      {fmtUsd(chartHover.val)} {chartHover.ts > 0 ? new Date(chartHover.ts).toLocaleDateString() : ""}
                                    </div>
                                  </div>
                                )}
                                </>
                              );
                            })() : (
                              <div className="flex-1 flex items-center justify-center text-[var(--tt-text-faint)] text-sm">
                                No history yet. Trades will appear as they close.
                              </div>
                            )}
                          </div>
                          <p className="text-[10px] text-[var(--tt-text-faint)] mt-2">Baseline {fmtUsd(BASELINE_ACCOUNT)}</p>
                        </div>

                        {/* Account summary stats â€” uses server-side account_ledger for consistency */}
                        <div className="grid grid-cols-2 sm:grid-cols-6 gap-3">
                          {(() => {
                            const acctVal = acctSummary?.accountValue ?? BASELINE_ACCOUNT;
                            const totalRealized = acctSummary?.totalRealized ?? ledgerClosedTrades.reduce((s, t) => s + (Number(t.pnl) || 0), 0);
                            const openPnl = acctSummary?.unrealized ?? ledgerOpenTrades.reduce((sum, t) => {
                              const m = getPositionMetrics(t, data && (data[t.ticker] || data[String(t.ticker).toUpperCase()]));
                              return sum + (Number(m.pnlOpen) || 0);
                            }, 0);
                            const totalPnl = totalRealized + openPnl;
                            const todayKey = new Date().toISOString().slice(0, 10);
                            const todayPnl = ledgerClosedTrades.filter((t) => {
                              const exitTs = tsToMs(t.exit_ts);
                              if (!exitTs) return false;
                              return new Date(exitTs).toISOString().slice(0, 10) === todayKey;
                            }).reduce((s, t) => s + (Number(t.pnl) || 0), 0);
                            return (
                              <>
                                <div className="tt-card p-3">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Account</div>
                                  <div className="text-lg font-bold text-[var(--tt-text)]">{fmtUsd(acctVal)}</div>
                                </div>
                                <div className="tt-card p-3">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Total P&L</div>
                                  <div className={`text-lg font-bold ${totalPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(totalPnl)}</div>
                                </div>
                                <div className="tt-card p-3">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Today</div>
                                  <div className={`text-lg font-bold ${todayPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(todayPnl)}</div>
                                </div>
                                <div className="tt-card p-3">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Open P&L</div>
                                  <div className={`text-lg font-bold ${openPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(openPnl)}</div>
                                </div>
                                <div className="tt-card p-3">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Closed</div>
                                  <div className="text-lg font-bold text-[var(--tt-text)]">{ledgerClosedTrades.length}</div>
                                </div>
                                <div className="tt-card p-3">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] uppercase tracking-wide">Realized P&L</div>
                                  <div className={`text-lg font-bold ${totalRealized >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                                    {fmtUsd(totalRealized)}
                                  </div>
                                </div>
                              </>
                            );
                          })()}
                        </div>

                        {/* Today's Trading Summary */}
                        {(() => {
                          const entries = todayActions.filter(a => a.type === "ENTRY");
                          const trims = todayActions.filter(a => a.type === "TRIM");
                          const exits = todayActions.filter(a => a.type === "EXIT");
                          const todayPnl = exits.reduce((sum, e) => sum + (e.pnl || 0), 0);
                          const wins = exits.filter(e => e.status === "WIN").length;
                          const losses = exits.filter(e => e.status === "LOSS").length;
                          const winRate = exits.length > 0 ? (wins / exits.length * 100) : 0;
                          
                          // Format time
                          const fmtTime = (ms) => {
                            const d = new Date(ms);
                            return d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
                          };
                          
                          // Get action icon and color
                          const getActionStyle = (action) => {
                            switch(action.type) {
                              case "ENTRY": return { icon: "ðŸš€", color: "text-cyan-400", bgColor: "bg-cyan-500/10", label: "Entered" };
                              case "TRIM": return { icon: "ðŸ“Š", color: "text-yellow-400", bgColor: "bg-yellow-500/10", label: "Trimmed" };
                              case "EXIT": return action.status === "WIN" 
                                ? { icon: "âœ…", color: "text-green-400", bgColor: "bg-green-500/10", label: "Exited" }
                                : { icon: "âŒ", color: "text-red-400", bgColor: "bg-red-500/10", label: "Stopped" };
                              default: return { icon: "â€¢", color: "text-gray-400", bgColor: "bg-gray-500/10", label: "" };
                            }
                          };
                          
                          return (
                            <div className="tt-card p-4">
                              <div className="flex items-center justify-between mb-4">
                                <h2 className="text-sm font-semibold text-[var(--tt-text)] uppercase tracking-wide">Today's Activity</h2>
                                <div className="text-xs text-[var(--tt-text-faint)]">
                                  {new Date().toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" })}
                                </div>
                              </div>
                              
                              {/* Stats row */}
                              <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-4">
                                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Entries</div>
                                  <div className="text-lg font-bold text-cyan-400">{entries.length}</div>
                                </div>
                                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Trims</div>
                                  <div className="text-lg font-bold text-yellow-400">{trims.length}</div>
                                </div>
                                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Exits</div>
                                  <div className="flex items-baseline gap-1">
                                    <span className="text-lg font-bold text-orange-400">{exits.length}</span>
                                    {exits.length > 0 && (
                                      <span className="text-[10px] text-[var(--tt-text-muted)]">
                                        ({wins}W / {losses}L)
                                      </span>
                                    )}
                                  </div>
                                </div>
                                <div className="bg-[var(--tt-bg-surface)] rounded-lg p-3 border border-[var(--tt-border)]">
                                  <div className="text-[10px] text-[var(--tt-text-faint)] mb-1">Realized P&L</div>
                                  <div className={`text-lg font-bold ${todayPnl >= 0 ? "text-green-400" : "text-red-400"}`}>
                                    {fmtUsd(todayPnl)}
                                  </div>
                                </div>
                              </div>
                              
                            </div>
                          );
                        })()}

                        {/* Open positions â€” Compact cards split by LONG/SHORT with stage badges */}
                        {openPositionCards.length > 0 ? (
                          (() => {
                            const dirPillLong = "bg-green-500/10 text-green-400 border-green-500/30";
                            const dirPillShort = "bg-red-500/10 text-red-400 border-red-500/30";
                            
                            // Get stage for a position
                            const getPositionStage = (pos) => {
                              const trade = pos.trade;
                              const trimmedPct = Number(trade?.trimmedPct || 0);
                              const entryTs = Number(trade?.entry_ts || trade?.entryTime || 0);
                              const now = Date.now();
                              const entryMs = entryTs < 1e12 ? entryTs * 1000 : entryTs;
                              const ageMs = now - entryMs;
                              const isJustEntered = ageMs >= 0 && ageMs < 15 * 60 * 1000;
                              
                              const tickerData = data && (data[pos.ticker] || data[pos.ticker?.toUpperCase?.()]);
                              const kanbanStage = tickerData?.kanban_stage || trade?.kanban_stage;
                              
                              // New dual-mode 6-stage system: active, trim, exit, closed for management mode
                              if (kanbanStage === "exit" || kanbanStage === "closed") return { stage: kanbanStage, label: kanbanStage === "exit" ? "EXIT" : "CLOSED", color: "text-red-400", bg: "bg-red-500/15" };
                              if (trimmedPct >= 0.5 || kanbanStage === "trim") return { stage: "trim", label: "TRIM", color: "text-yellow-400", bg: "bg-yellow-500/15" };
                              // Legacy support: just_entered, hold -> active
                              if (isJustEntered || kanbanStage === "just_entered" || kanbanStage === "active") return { stage: "active", label: "ACTIVE", color: "text-cyan-400", bg: "bg-cyan-500/15" };
                              if (kanbanStage === "hold") return { stage: "active", label: "ACTIVE", color: "text-blue-400", bg: "bg-blue-500/15" };
                              return { stage: "active", label: "ACTIVE", color: "text-blue-400", bg: "bg-blue-500/15" };
                            };
                            
                            const longPositions = openPositionCards.filter(p => String(p.trade?.direction || "").toUpperCase() === "LONG");
                            const shortPositions = openPositionCards.filter(p => String(p.trade?.direction || "").toUpperCase() === "SHORT");
                            
                            // â”€â”€ Compact Position Row â€” 2-line card with progress bar â”€â”€
                            const numFromAnyPos = (v) => { const n = Number(v); return Number.isFinite(n) && n > 0 ? n : null; };
                            const renderCompactCard = (pos) => {
                              const dir = String(pos.trade?.direction || "LONG").toUpperCase();
                              const isLong = dir === "LONG";
                              const tickerData = data && (data[pos.ticker] || data[pos.ticker?.toUpperCase?.()]);
                              const currentPrice = pos.current || Number(tickerData?._live_price ?? tickerData?.price) || null;
                              const entryPrice = pos.entryPrice ?? Number(pos.trade?.entry_price ?? pos.trade?.entryPrice) ?? null;
                              const qty = pos.qty ?? pos.trade?.shares ?? pos.trade?.total_qty ?? null;
                              const entryTs = pos.trade?.entry_ts ?? pos.trade?.entryTime ?? pos.trade?.created_at;
                              const entryDateLabel = entryTs != null
                                ? (() => {
                                    const d = typeof entryTs === "string" ? new Date(entryTs) : new Date(Number(entryTs) < 1e12 ? Number(entryTs) * 1000 : Number(entryTs));
                                    return isNaN(d.getTime()) ? "" : d.toLocaleDateString(undefined, { month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" });
                                  })()
                                : "";
                              const dailyResult = getDailyChange(tickerData) || {};
                              const dayChg = Number.isFinite(dailyResult.dayChg) ? dailyResult.dayChg : null;
                              const dayChgPct = Number.isFinite(dailyResult.dayPct) ? dailyResult.dayPct : null;
                              const hasDayChg = dayChg !== null;
                              const hasDayChgPct = dayChgPct !== null;
                              const pnlOpen = pos.pnlOpen;
                              const retOpenPct = pos.retOpenPct;
                              const stageInfo = getPositionStage(pos);
                              const isPositive = (retOpenPct ?? 0) >= 0;
                              
                              // â”€â”€ Progress bar data: SL, EP, CP, TP, TP2, XP â”€â”€
                              const slRaw = Number(pos.trade?.stop_loss || pos.trade?.sl || tickerData?.sl || tickerData?.sl_price || tickerData?.stop_loss) || null;
                              const tpArr = Array.isArray(pos.trade?.tpArray) ? pos.trade.tpArray : (Array.isArray(tickerData?.tpArray) ? tickerData.tpArray : []);
                              const tpRaw = Number(pos.trade?.take_profit || tickerData?.tp || tickerData?.tp_max_price || tickerData?.tp_target_price) || null;
                              const tp1Raw = numFromAnyPos(tpArr[0]?.price || tickerData?.tp_trim);
                              const tp2Raw = numFromAnyPos(tpArr[1]?.price || tickerData?.tp_exit);
                              const xpRaw = numFromAnyPos(tpArr[2]?.price || tickerData?.tp_runner || tpRaw);
                              const ep = entryPrice;
                              const cp = currentPrice;
                              const slP = numFromAnyPos(slRaw);
                              // Original SL for TSL detection
                              const slOrigRaw = Number(pos.trade?.sl_original ?? tickerData?.position_sl_original ?? 0);
                              const slOrig = Number.isFinite(slOrigRaw) && slOrigRaw > 0 ? slOrigRaw : null;
                              const tslActive = slP && slOrig && Math.abs(slP - slOrig) / slOrig > 0.005;
                              // Sanity: TP levels should be ahead of current price
                              const tpSanity = (v) => {
                                if (!Number.isFinite(v) || v <= 0 || !cp) return null;
                                if (isLong && v <= cp) return null;
                                if (!isLong && v >= cp) return null;
                                return v;
                              };
                              const tp1 = tpSanity(tp1Raw);
                              const tp2 = tpSanity(tp2Raw);
                              const xp = tpSanity(xpRaw);
                              
                              // Compute progress bar range
                              const vals = [slP, slOrig, ep, cp, tp1, tp2, xp].filter(v => v != null && v > 0);
                              const hasBar = vals.length >= 2;
                              let pct = () => 50;
                              let fillPct = 0;
                              let fillColor = "bg-white/[0.30]";
                              let slMovedPastEntry = false;
                              if (hasBar) {
                                const rawLo = Math.min(...vals);
                                const rawHi = Math.max(...vals);
                                const pad = (rawHi - rawLo) * 0.08;
                                const lo = rawLo - pad;
                                const hi = rawHi + pad;
                                const range = hi - lo;
                                // For SHORT: mirror positions so SL=left, TP=right
                                pct = (v) => {
                                  if (range <= 0) return 50;
                                  const raw = Math.max(0, Math.min(100, ((v - lo) / range) * 100));
                                  return isLong ? raw : (100 - raw);
                                };
                                fillPct = cp ? pct(cp) : 0;
                                slMovedPastEntry = ep && slP && ((isLong && slP > ep) || (!isLong && slP < ep));
                                fillColor = fillPct >= 50
                                  ? (fillPct >= 80 ? "bg-emerald-500/70" : "bg-emerald-500/50")
                                  : (fillPct <= 20 ? "bg-rose-500/55" : "bg-white/[0.30]");
                              }
                              
                              const Mk = ({ val, label, color, tc, bottom, dimmed }) => {
                                if (!val) return null;
                                return (
                                  <div className="absolute" style={{ left: `${pct(val)}%`, width: "20px", marginLeft: "-10px", top: "-12px", bottom: "-12px" }}
                                    title={`${label}: $${val.toFixed(2)}`}>
                                    <div className={`absolute left-1/2 -translate-x-1/2 w-0.5 ${color}`} style={{ top: "12px", bottom: "12px", ...(dimmed ? { opacity: 0.5 } : {}) }} />
                                    <span className={`absolute left-1/2 ${bottom ? "bottom-0" : "top-0"} -translate-x-1/2 text-[7px] font-extrabold ${tc} whitespace-nowrap`}
                                      style={dimmed ? { opacity: 0.6 } : {}}>{label}</span>
                                  </div>
                                );
                              };
                              
                              return (
                                <button
                                  key={pos.ticker}
                                  type="button"
                                  onClick={() => {
                                    setSelectedTicker(pos.ticker);
                                    setSelectedTrade(pos.trade);
                                    const events = pos.events || pos.trade?.history || [];
                                    const match = trades.find(t => (t.id || t.trade_id) === pos.trade?.id);
                                    const evts = (match?.history?.length ? match.history : events);
                                    setSelectedPositionEvents(Array.isArray(evts) ? evts : []);
                                  }}
                                  className="w-full text-left py-1.5 px-2 border-b border-white/[0.04] hover:bg-white/[0.02] transition-all"
                                  title="Open in right rail"
                                >
                                  {/* Row 1: Ticker, P&L, Entry, Current Price, Day Chg, Qty, Opened, Status */}
                                  <div className="flex items-center gap-2">
                                    {/* Ticker + Dir */}
                                    <span className="text-[11px] font-bold text-white w-[44px] shrink-0">{pos.ticker}</span>
                                    <span className={`text-[9px] font-bold w-[10px] shrink-0 ${isLong ? "text-[#00c853]" : "text-[#ff5252]"}`}>{isLong ? "L" : "S"}</span>
                                    {/* P&L $ */}
                                    <span className={`text-[11px] font-semibold tabular-nums w-[60px] text-right shrink-0 ${isPositive ? "text-[#00c853]" : "text-[#ff5252]"}`}>
                                      {pnlOpen != null ? `${isPositive ? "+" : ""}${fmtUsd(pnlOpen)}` : "â€”"}
                                    </span>
                                    {/* P&L % */}
                                    <span className={`text-[9px] tabular-nums w-[38px] text-right shrink-0 ${isPositive ? "text-[#00c853]/70" : "text-[#ff5252]/70"}`}>
                                      {retOpenPct != null ? `${isPositive ? "+" : ""}${retOpenPct.toFixed(1)}%` : ""}
                                    </span>
                                    {/* Entry Price */}
                                    <span className="text-[10px] text-amber-300/90 tabular-nums w-[56px] shrink-0 text-right" title="Entry">
                                      {Number.isFinite(entryPrice) ? `$${entryPrice.toFixed(2)}` : "â€”"}
                                    </span>
                                    {/* Current Price */}
                                    <span className="text-[10px] text-white tabular-nums w-[56px] shrink-0 text-right font-medium">
                                      {Number.isFinite(currentPrice) ? `$${currentPrice.toFixed(2)}` : "â€”"}
                                    </span>
                                    {/* Daily change */}
                                    <span className={`text-[10px] tabular-nums w-[70px] shrink-0 text-right ${(hasDayChgPct && dayChgPct >= 0) || (hasDayChg && dayChg >= 0) ? "text-[#00c853]" : "text-[#ff5252]"}`}>
                                      {hasDayChg ? `${dayChg >= 0 ? "+" : ""}$${dayChg.toFixed(2)}` : ""}
                                      {hasDayChg && hasDayChgPct ? " " : ""}
                                      {hasDayChgPct ? `(${dayChgPct >= 0 ? "+" : ""}${dayChgPct.toFixed(2)}%)` : ""}
                                      {!hasDayChg && !hasDayChgPct ? "â€”" : ""}
                                    </span>
                                    {/* Qty */}
                                    <span className="text-[10px] text-[#9ca3af] tabular-nums w-[40px] shrink-0 text-right" title="Quantity">
                                      {qty != null && Number.isFinite(Number(qty)) ? Number(qty).toFixed(2) : "â€”"}
                                    </span>
                                    {/* Date/Time */}
                                    <span className="text-[9px] text-[#6b7280] w-[72px] shrink-0 truncate" title="Entry time">
                                      {entryDateLabel || "â€”"}
                                    </span>
                                    {/* Stage pill */}
                                    <span className={`text-[8px] px-1.5 py-px rounded ${stageInfo.bg} ${stageInfo.color} font-medium shrink-0 ml-auto`}>
                                      {stageInfo.label}
                                    </span>
                                  </div>
                                  {/* Row 2: Full progress bar with SL, EP, CP, TP, XP markers */}
                                  {hasBar ? (
                                    <div className="mt-1 px-1">
                                      <div className="relative h-[8px] rounded bg-white/[0.06] border border-white/[0.08] overflow-visible mt-2.5 mb-2.5">
                                        {cp && (
                                          <div
                                            className={`absolute top-0 bottom-0 rounded left-0 ${fillColor}`}
                                            style={{ width: `${fillPct}%` }}
                                            title={`CP: $${cp.toFixed(2)}`}
                                          >
                                            <span className="absolute -translate-x-1/2 text-[7px] font-extrabold text-white whitespace-nowrap"
                                              style={{ left: "100%", bottom: "-12px" }}>CP</span>
                                          </div>
                                        )}
                                        {tslActive && <Mk val={slOrig} label="SL" color="bg-rose-500/40" tc="text-rose-400" dimmed />}
                                        <Mk val={slP} label={tslActive ? "TSL" : "SL"} color={slMovedPastEntry ? "bg-teal-500" : "bg-rose-500/80"} tc={slMovedPastEntry ? "text-teal-400" : "text-rose-400"} />
                                        <Mk val={ep} label="EP" color="bg-yellow-400/80" tc="text-yellow-300" />
                                        <Mk val={tp1} label="TP" color="bg-teal-400/80" tc="text-teal-300" />
                                        <Mk val={tp2} label="TP2" color="bg-teal-400/80" tc="text-teal-300" bottom />
                                        <Mk val={xp} label="XP" color="bg-emerald-400" tc="text-emerald-300" />
                                      </div>
                                    </div>
                                  ) : (
                                    <div className="mt-1 px-1">
                                      <div className="h-[8px] rounded bg-white/[0.04] mt-2.5 mb-2.5" />
                                    </div>
                                  )}
                                </button>
                              );
                            };
                            
                            return (
                              <div className="p-4">
                                <div className="flex items-center justify-between mb-3">
                                  <h2 className="text-[13px] font-medium text-[#d1d5db]">Open Positions</h2>
                                  <span className="text-[11px] text-[#4b5563]">{openPositionCards.length} open</span>
                                </div>
                                <div className="space-y-0">
                                  {/* Column headers */}
                                  <div className="flex items-center gap-2 px-2 py-1 border-b border-white/[0.06] text-[8px] font-semibold uppercase tracking-wider text-[#6b7280]">
                                    <span className="w-[44px] shrink-0">Ticker</span>
                                    <span className="w-[10px] shrink-0"></span>
                                    <span className="w-[60px] shrink-0 text-right">P&L</span>
                                    <span className="w-[38px] shrink-0 text-right">%</span>
                                    <span className="w-[56px] shrink-0 text-right">Entry</span>
                                    <span className="w-[56px] shrink-0 text-right">Current Price</span>
                                    <span className="w-[70px] shrink-0 text-right">Day Chg</span>
                                    <span className="w-[40px] shrink-0 text-right">Qty</span>
                                    <span className="w-[72px] shrink-0">Opened</span>
                                    <span className="shrink-0 text-center ml-auto" style={{ width: "42px" }}>Status</span>
                                  </div>
                                  {/* All positions sorted alphabetically */}
                                  {[...openPositionCards].sort((a, b) => String(a.ticker || "").localeCompare(String(b.ticker || ""))).map(pos => renderCompactCard(pos))}
                                </div>
                                {false && <div>
                                  {/* OLD LONG positions */}
                                  <div>
                                    <div className="flex items-center gap-2 mb-2">
                                      <span className="text-emerald-400 font-semibold text-xs">LONG</span>
                                      <span className="text-[var(--tt-text-faint)] text-[10px]">({longPositions.length})</span>
                                    </div>
                                    {longPositions.length > 0 ? (
                                      <div className="grid gap-2 grid-cols-1 sm:grid-cols-2 xl:grid-cols-3">
                                        {longPositions.map(renderCompactCard)}
                                      </div>
                                    ) : (
                                      <p className="text-xs text-[var(--tt-text-faint)]">No long positions</p>
                                    )}
                                  </div>
                                  {/* SHORT positions */}
                                  <div>
                                    <div className="flex items-center gap-2 mb-2">
                                      <span className="text-rose-400 font-semibold text-xs">SHORT</span>
                                      <span className="text-[var(--tt-text-faint)] text-[10px]">({shortPositions.length})</span>
                                    </div>
                                    {shortPositions.length > 0 ? (
                                      <div className="grid gap-2 grid-cols-1 sm:grid-cols-2 xl:grid-cols-3">
                                        {shortPositions.map(renderCompactCard)}
                                      </div>
                                    ) : (
                                      <p className="text-xs text-[var(--tt-text-faint)]">No short positions</p>
                                    )}
                                  </div>
                                </div>}
                              </div>
                            );
                          })()
                        ) : (
                          <div className="tt-card p-6 text-center text-[var(--tt-text-muted)] text-sm">
                            No open positions in this range.
                          </div>
                        )}

                        {/* Trade History â€” Today (full width table), then By day + P&L by ticker (2 cols) */}
                        <div className="tt-card p-4">
                            <h2 className="text-sm font-semibold text-[var(--tt-text)] uppercase tracking-wide mb-3">Trade History</h2>

                            {/* Row 1: Today's Trades â€” full width table */}
                            <div className="mb-4">
                              <h3 className="text-xs font-medium text-[var(--tt-text-faint)] mb-2 uppercase tracking-wider">Today</h3>
                              <div className="max-h-[600px] overflow-y-auto overflow-x-auto">
                                {todayActions.length > 0 ? (
                                  <>
                                    <div className="grid grid-cols-[50px_52px_48px_68px_50px_68px_1fr] gap-1.5 px-2 py-1 border-b border-white/[0.06] text-[9px] font-semibold uppercase tracking-wider text-[#6b7280]">
                                      <span>Time</span><span>Ticker</span><span>Action</span><span className="text-right">Price</span><span className="text-right">Qty</span><span className="text-right">P&L</span><span className="truncate">Reason</span>
                                    </div>
                                    {todayActions.slice(0, 160).map((action, idx) => {
                                      const actionColor = action.type === "ENTRY" ? "text-cyan-400" : action.type === "EXIT" ? (action.status === "WIN" ? "text-green-400" : "text-red-400") : "text-yellow-400";
                                      const fmtTime = (ms) => new Date(ms).toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
                                      const pnlStr = action.type === "EXIT" && action.pnl != null ? fmtUsd(action.pnl) : "";
                                      const pnlColor = (action.pnl || 0) >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]";
                                      const t = action.trade || {};
                                      const qty = Number(t.shares || t.total_qty || 0);
                                      const reason = String(t.exit_reason || t.__entry_reason || t.__trim_reason || "").replace(/_/g, " ");
                                      return (
                                        <div
                                          key={`${action.type}-${action.ticker}-${idx}`}
                                          className="grid grid-cols-[50px_52px_48px_68px_50px_68px_1fr] gap-1.5 px-2 py-1.5 text-[12px] border-b border-white/[0.02] hover:bg-white/[0.02] cursor-pointer"
                                          onClick={() => action.trade && (setSelectedTicker(action.ticker), setSelectedTrade(action.trade), setSelectedPositionEvents(action.trade?.history || []))}
                                        >
                                          <span className="text-[var(--tt-text-muted)]">{fmtTime(action.ts)}</span>
                                          <span className="font-medium text-[var(--tt-text)] truncate">{action.ticker}</span>
                                          <span className={`${actionColor} font-semibold`}>{action.type}</span>
                                          <span className="text-right text-[var(--tt-text)]">{action.price != null ? `$${action.price.toFixed(2)}` : "â€”"}</span>
                                          <span className="text-right text-[var(--tt-text-muted)]">{qty > 0 ? qty.toFixed(2) : "â€”"}</span>
                                          <span className={`text-right font-semibold ${pnlColor}`}>{pnlStr}</span>
                                          <span className="text-[var(--tt-text-faint)] truncate capitalize" title={reason}>{reason || "â€”"}</span>
                                        </div>
                                      );
                                    })}
                                  </>
                                ) : (
                                  <div className="text-[13px] text-[var(--tt-text-faint)] py-2">No activity today</div>
                                )}
                              </div>
                            </div>

                            {/* Row 2: By Day (accordion) + P&L by Ticker â€” 2-column */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                              {/* Col 2: By day */}
                              <div>
                                <h3 className="text-xs font-medium text-[var(--tt-text-faint)] mb-2 uppercase tracking-wider">By day</h3>
                                <div className="space-y-1 max-h-[1120px] overflow-y-auto">
                                  {ledgerActivityDays.length === 0 ? (
                                    <div className="text-[13px] text-[var(--tt-text-faint)] py-2">No closed trades by day</div>
                                  ) : ledgerActivityDays.slice(0, 160).map((day) => {
                                    const isExpanded = expandedByDayKey === day.key;
                                    return (
                                      <div key={day.key} className="rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] overflow-hidden">
                                        <div
                                          className="flex items-center justify-between py-2 px-3 hover:bg-[var(--tt-bg-hover)] cursor-pointer transition-colors"
                                          onClick={(e) => {
                                            if (e.target.closest('.expand-toggle')) {
                                              setExpandedByDayKey(isExpanded ? null : day.key);
                                            } else if (day.events?.[0]?.trade) {
                                              setSelectedTrade(day.events[0].trade);
                                              setSelectedTicker(day.events[0].trade?.ticker);
                                              setSelectedPositionEvents(day.events);
                                            }
                                          }}
                                        >
                                          <div className="flex items-center gap-2">
                                            <button type="button" className="expand-toggle text-[var(--tt-text-muted)] hover:text-[var(--tt-text)] text-xs w-5 h-5 flex items-center justify-center" aria-label={isExpanded ? "Collapse" : "Expand"}>
                                              {isExpanded ? "âˆ’" : "+"}
                                            </button>
                                            <span className="text-[13px] font-medium text-[var(--tt-text)]">{day.label}</span>
                                          </div>
                                          <div className="flex items-center gap-3 text-[13px]">
                                            <span className="text-[var(--tt-text-muted)]">{day.stats.entries}E/{day.stats.exits}X</span>
                                            <span className={`font-semibold ${day.stats.closedPnl >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>{fmtUsd(day.stats.closedPnl)}</span>
                                          </div>
                                        </div>
                                        {isExpanded && day.events && day.events.length > 0 && (
                                          <div className="px-3 pb-2 pt-0 border-t border-[var(--tt-border)]">
                                            {/* Group by ticker (alphabetical), then sort by time within each group */}
                                            {(() => {
                                              const byTicker = {};
                                              for (const ev of day.events) {
                                                const tk = (ev.trade?.ticker || "â€”").toUpperCase();
                                                if (!byTicker[tk]) byTicker[tk] = [];
                                                byTicker[tk].push(ev);
                                              }
                                              // Sort tickers alphabetically
                                              const sortedTickers = Object.keys(byTicker).sort();
                                              return (
                                                <div className="mt-1.5 space-y-1 text-[13px]">
                                                  {/* Table header */}
                                                  <div className="grid grid-cols-[70px_50px_60px_70px_70px] gap-1.5 px-1 text-[11px] text-[var(--tt-text-faint)] font-medium uppercase">
                                                    <span>Ticker</span><span>Action</span><span>Time</span><span>Price</span><span className="text-right">P&L</span>
                                                  </div>
                                                  {sortedTickers.map(tk => {
                                                    const evs = byTicker[tk].sort((a, b) => (a.ts || 0) - (b.ts || 0));
                                                    return evs.map((ev, i) => {
                                                      const action = ev.type;
                                                      const timeStr = ev.ts != null ? new Date(ev.ts).toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", hour12: true }) : "â€”";
                                                      const priceStr = ev.price != null && Number.isFinite(ev.price) ? `$${Number(ev.price).toFixed(2)}` : "â€”";
                                                      const actionColor = action === "ENTRY" ? "text-cyan-400" : action === "EXIT" ? (ev.trade?.status === "WIN" ? "text-green-400" : "text-red-400") : "text-yellow-400";
                                                      const pnlStr = action === "EXIT" && ev.trade?.pnl != null ? fmtUsd(Number(ev.trade.pnl)) : "";
                                                      const pnlColor = Number(ev.trade?.pnl) >= 0 ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]";
                                                      return (
                                                        <div key={`${tk}-${i}`} className="grid grid-cols-[70px_50px_60px_70px_70px] gap-1.5 py-1 px-1 rounded bg-[var(--tt-bg)] items-center">
                                                          <span className="font-medium text-[var(--tt-text)] truncate">{i === 0 ? tk : ""}</span>
                                                          <span className={`${actionColor} font-semibold`}>{action}</span>
                                                          <span className="text-[var(--tt-text-muted)]">{timeStr}</span>
                                                          <span className="text-[var(--tt-text)]">{priceStr}</span>
                                                          <span className={`text-right font-semibold ${pnlColor}`}>{pnlStr}</span>
                                                        </div>
                                                      );
                                                    });
                                                  })}
                                                </div>
                                              );
                                            })()}
                                          </div>
                                        )}
                                      </div>
                                    );
                                  })}
                                </div>
                              </div>
                              {/* Col 3: By ticker â€” Unified P&L view */}
                              <div>
                                <h3 className="text-xs font-medium text-[var(--tt-text-faint)] mb-2 uppercase tracking-wider">P&L by Ticker</h3>
                                <div className="space-y-1 max-h-[800px] overflow-y-auto">
                                  {ledgerAllByTicker.length === 0 ? (
                                    <div className="text-[13px] text-[var(--tt-text-faint)] py-2">No trades</div>
                                  ) : (() => {
                                    const maxAbs = Math.max(...ledgerAllByTicker.map((r) => Math.abs(r.totalPnl)), 1);
                                    return ledgerAllByTicker.slice(0, 200).map((row) => {
                                      const pct = Math.min(Math.abs(row.totalPnl) / maxAbs, 1) * 100;
                                      const isGain = row.totalPnl >= 0;
                                      return (
                                        <div
                                          key={`all-${row.ticker}`}
                                          className="relative flex items-center justify-between py-2 px-3 rounded bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] hover:bg-[var(--tt-bg-hover)] cursor-pointer transition-colors overflow-hidden"
                                          onClick={() => {
                                            if (row.trades?.[0]) {
                                              setSelectedTrade(row.trades[0]);
                                              setSelectedTicker(row.ticker);
                                              setSelectedPositionEvents(row.trades[0]?.history || []);
                                            }
                                          }}
                                        >
                                          <div className="absolute top-0 bottom-0 left-0" style={{
                                            width: `${pct}%`,
                                            background: isGain ? "rgba(0,200,83,0.10)" : "rgba(255,82,82,0.10)",
                                          }} />
                                          <div className="relative flex items-center gap-2">
                                            <span className="text-[13px] font-medium text-[var(--tt-text)]">{row.ticker}</span>
                                            {row.hasOpen && (
                                              <span className="w-1.5 h-1.5 rounded-full bg-blue-400" title="Has open position" />
                                            )}
                                          </div>
                                          <div className="relative flex items-center gap-3 text-[13px]">
                                            <span className="text-[var(--tt-text-muted)]">{row.trades.length}T</span>
                                            {row.wins > 0 && <span className="text-[var(--tt-accent)]">{row.wins}W</span>}
                                            {row.losses > 0 && <span className="text-[var(--tt-negative)]">{row.losses}L</span>}
                                            <span className={`font-semibold ${isGain ? "text-[var(--tt-accent)]" : "text-[var(--tt-negative)]"}`}>
                                              {isGain ? "+" : ""}{fmtUsd(row.totalPnl)}
                                            </span>
                                          </div>
                                        </div>
                                      );
                                    });
                                  })()}
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                    )}
                  </div>
                </div>
                </>)}

                  {/* Right rail â€” same component and look as Dashboard */}
                  {(selectedTicker || selectedTrade) && (
                    <div className="fixed right-0 top-[49px] w-[450px] bottom-0 z-40 slide-in-right shadow-2xl overflow-y-auto bg-[#0b0e11] border-l border-white/[0.04]">
                      <TickerDetailsLoader
                        tickerSymbol={selectedTrade ? selectedTrade.ticker : selectedTicker}
                        trade={selectedTrade}
                        positionEvents={selectedPositionEvents}
                        onClose={() => {
                          setSelectedTrade(null);
                          setSelectedTicker(null);
                          setSelectedPositionEvents(null);
                        }}
                        allLoadedData={data}
                        sectors={sectors}
                        rankedTickers={rankedTickers}
                        rankedTickerPositions={rankedTickerPositions}
                      />
                    </div>
                  )}
              </div>
            </div>

                {/* Daily Summary Modal */}
                {showSummary && dailySummary && (
                  <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div className="bg-[var(--tt-bg-elevated)] border border-[var(--tt-border)] rounded-xl p-6 max-w-3xl w-full max-h-[90vh] overflow-y-auto">
                      <div className="flex items-center justify-between mb-4">
                        <h2 className="text-2xl font-bold">
                          ðŸ“Š Daily Summary -{" "}
                          {new Date(
                            dailySummary.stats.date,
                          ).toLocaleDateString()}
                        </h2>
                        <button
                          onClick={() => setShowSummary(false)}
                          className="text-[var(--tt-text-muted)] hover:text-white text-xl"
                        >
                          âœ•
                        </button>
                      </div>

                      {/* Stats Grid */}
                      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            New Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.newTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Closed Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.closedTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Trimmed Trades
                          </div>
                          <div className="text-xl font-bold text-white">
                            {dailySummary.stats.trimmedTrades}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">Win Rate</div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.winRate >= 50 ? "text-green-400" : "text-red-400"}`}
                          >
                            {dailySummary.stats.winRate}%
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Closed P&L
                          </div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.closedPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                          >
                            ${dailySummary.stats.closedPnl}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">Open P&L</div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.openPnl >= 0 ? "text-green-400" : "text-yellow-400"}`}
                          >
                            ${dailySummary.stats.openPnl}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] p-3 rounded-lg border border-[var(--tt-border)]">
                          <div className="text-xs text-[var(--tt-text-muted)]">
                            Total P&L
                          </div>
                          <div
                            className={`text-xl font-bold ${dailySummary.stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                          >
                            ${dailySummary.stats.totalPnl}
                          </div>
                        </div>
                      </div>

                      {/* AI Summary */}
                      <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-6 mb-4">
                        <h3 className="text-xl font-bold mb-4 flex items-center gap-2">
                          <span className="text-2xl">ðŸ¤–</span>
                          <span>AI Analysis & Recommendations</span>
                        </h3>
                        <div className="text-sm text-[var(--tt-text)] leading-relaxed">
                          {(() => {
                            // Enhanced markdown renderer
                            const renderMarkdown = (text) => {
                              const parts = [];
                              let currentIndex = 0;

                              // Split by double newlines for paragraphs
                              const paragraphs = text.split(/\n\n+/);

                              return paragraphs.map((paragraph, pIdx) => {
                                if (!paragraph.trim()) return null;

                                // Headers (## or ###)
                                const headerMatch = paragraph
                                  .trim()
                                  .match(/^(#{2,3})\s+(.+)$/m);
                                if (headerMatch) {
                                  const level = headerMatch[1].length;
                                  const content = headerMatch[2];
                                  return React.createElement(
                                    level === 2 ? "h2" : "h3",
                                    {
                                      key: pIdx,
                                      className:
                                        level === 2
                                          ? "text-lg font-bold mt-6 mb-3 text-white border-b border-[var(--tt-border)] pb-2 first:mt-0"
                                          : "text-base font-semibold mt-4 mb-2 text-white",
                                    },
                                    content,
                                  );
                                }

                                // Lists (bulleted or numbered)
                                if (
                                  paragraph.trim().match(/^[-*â€¢]\s+/m) ||
                                  paragraph.trim().match(/^\d+\.\s+/m)
                                ) {
                                  const listItems = paragraph
                                    .split("\n")
                                    .filter((l) => l.trim());
                                  const isOrdered = listItems[0]
                                    ?.trim()
                                    .match(/^\d+\./);

                                  return React.createElement(
                                    isOrdered ? "ol" : "ul",
                                    {
                                      key: pIdx,
                                      className:
                                        "list-none space-y-2 my-3 ml-4",
                                    },
                                    listItems.map((item, iIdx) => {
                                      const cleanItem = item
                                        .replace(/^[-*â€¢]\s+/, "")
                                        .replace(/^\d+\.\s+/, "");
                                      return React.createElement(
                                        "li",
                                        {
                                          key: iIdx,
                                          className: "flex items-start gap-2",
                                        },
                                        [
                                          React.createElement(
                                            "span",
                                            {
                                              key: "bullet",
                                              className:
                                                "text-blue-400 mt-1.5 flex-shrink-0",
                                            },
                                            isOrdered ? `${iIdx + 1}.` : "â€¢",
                                          ),
                                          React.createElement("span", {
                                            key: "content",
                                            className: "flex-1",
                                            dangerouslySetInnerHTML: {
                                              __html:
                                                formatInlineMarkdown(cleanItem),
                                            },
                                          }),
                                        ],
                                      );
                                    }),
                                  );
                                }

                                // Regular paragraph
                                return React.createElement(
                                  "div",
                                  {
                                    key: pIdx,
                                    className: "mb-4 last:mb-0",
                                  },
                                  paragraph.split("\n").map((line, lIdx) => {
                                    if (!line.trim()) {
                                      return React.createElement("br", {
                                        key: lIdx,
                                      });
                                    }

                                    // Check for special formatting patterns
                                    const isBoldLine =
                                      line.match(/^\*\*(.+)\*\*$/);
                                    if (isBoldLine) {
                                      return React.createElement(
                                        "p",
                                        {
                                          key: lIdx,
                                          className:
                                            "font-semibold text-white mb-2",
                                        },
                                        isBoldLine[1],
                                      );
                                    }

                                    // Check for emoji-prefixed lines (opportunities, warnings, etc.)
                                    const emojiMatch = line.match(
                                      /^([ðŸŽ¯âš ï¸ðŸ“ŠðŸ’¡ðŸš€]+)\s+(.+)$/,
                                    );
                                    if (emojiMatch) {
                                      const emoji = emojiMatch[1];
                                      const content = emojiMatch[2];
                                      const bgColor = emoji.includes("ðŸŽ¯")
                                        ? "bg-blue-500/10 border-blue-500/30"
                                        : emoji.includes("âš ï¸")
                                          ? "bg-yellow-500/10 border-yellow-500/30"
                                          : emoji.includes("ðŸ“Š")
                                            ? "bg-purple-500/10 border-purple-500/30"
                                            : emoji.includes("ðŸ’¡")
                                              ? "bg-green-500/10 border-green-500/30"
                                              : "bg-[var(--tt-bg-elevated)]/50 border-[var(--tt-border)]";

                                      return React.createElement(
                                        "div",
                                        {
                                          key: lIdx,
                                          className: `flex items-start gap-3 p-3 rounded-lg border ${bgColor} mb-2`,
                                        },
                                        [
                                          React.createElement(
                                            "span",
                                            {
                                              key: "emoji",
                                              className:
                                                "text-xl flex-shrink-0",
                                            },
                                            emoji,
                                          ),
                                          React.createElement("div", {
                                            key: "content",
                                            className: "flex-1",
                                            dangerouslySetInnerHTML: {
                                              __html:
                                                formatInlineMarkdown(content),
                                            },
                                          }),
                                        ],
                                      );
                                    }

                                    return React.createElement("p", {
                                      key: lIdx,
                                      className: "mb-2 leading-relaxed",
                                      dangerouslySetInnerHTML: {
                                        __html:
                                          formatInlineMarkdown(line) ||
                                          "&nbsp;",
                                      },
                                    });
                                  }),
                                );
                              });
                            };

                            // Format inline markdown (bold, code, links, etc.)
                            const formatInlineMarkdown = (text) => {
                              // Sanitize: strip dangerous HTML tags and event handlers
                              let formatted = text
                                .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")
                                .replace(/<iframe\b[^>]*>.*?<\/iframe>/gi, "")
                                .replace(/<object\b[^>]*>.*?<\/object>/gi, "")
                                .replace(/<embed\b[^>]*>/gi, "")
                                .replace(/\bon\w+\s*=\s*["'][^"']*["']/gi, "")
                                .replace(/\bon\w+\s*=\s*[^\s>]*/gi, "")
                                .replace(/javascript\s*:/gi, "")
                                .replace(/data\s*:\s*text\/html/gi, "");

                              // Bold (**text**)
                              formatted = formatted.replace(
                                /\*\*(.+?)\*\*/g,
                                '<strong class="font-semibold text-white">$1</strong>',
                              );

                              // Inline code (`code`)
                              formatted = formatted.replace(
                                /`([^`]+)`/g,
                                '<code class="bg-[var(--tt-bg-elevated)] px-1.5 py-0.5 rounded text-xs font-mono text-blue-300">$1</code>',
                              );

                              // Links [text](url) - not common in AI responses but good to have
                              formatted = formatted.replace(
                                /\[([^\]]+)\]\(([^)]+)\)/g,
                                '<a href="$2" class="text-blue-400 hover:text-blue-300 underline" target="_blank" rel="noopener noreferrer">$1</a>',
                              );

                              // Ticker symbols (uppercase 2-5 letter codes)
                              formatted = formatted.replace(
                                /\b([A-Z]{2,5})\b/g,
                                '<span class="font-semibold text-blue-300">$1</span>',
                              );

                              // Numbers with $ (prices)
                              formatted = formatted.replace(
                                /\$(\d+\.?\d*)/g,
                                '<span class="text-green-400 font-medium">$$1</span>',
                              );

                              // Percentages
                              formatted = formatted.replace(
                                /(\d+\.?\d*)%/g,
                                '<span class="text-yellow-400 font-medium">$1%</span>',
                              );

                              // RR ratios (X:1 or 1:X)
                              formatted = formatted.replace(
                                /(\d+\.?\d*):1/g,
                                '<span class="text-purple-400 font-medium">$1:1</span>',
                              );

                              // Table separators (|)
                              formatted = formatted.replace(
                                /\|/g,
                                '<span class="text-[var(--tt-text-faint)] mx-1">|</span>',
                              );

                              return formatted;
                            };

                            return renderMarkdown(dailySummary.summary);
                          })()}
                        </div>
                      </div>

                      {/* Performance Breakdown */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                          <h4 className="text-sm font-semibold mb-2">
                            Performance by Rank
                          </h4>
                          <div className="space-y-1 text-xs">
                            {Object.entries(
                              dailySummary.stats.rankAnalysis || {},
                            ).map(([range, stats]) => (
                              <div key={range} className="flex justify-between">
                                <span className="text-[var(--tt-text-muted)]">{range}:</span>
                                <span
                                  className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                                >
                                  {stats.wins}W/{stats.losses}L ($
                                  {stats.totalPnl.toFixed(2)})
                                </span>
                              </div>
                            ))}
                          </div>
                        </div>
                        <div className="bg-[var(--tt-bg-surface)] border border-[var(--tt-border)] rounded-lg p-4">
                          <h4 className="text-sm font-semibold mb-2">
                            Performance by RR
                          </h4>
                          <div className="space-y-1 text-xs">
                            {Object.entries(
                              dailySummary.stats.rrAnalysis || {},
                            ).map(([range, stats]) => (
                              <div key={range} className="flex justify-between">
                                <span className="text-[var(--tt-text-muted)]">{range}:</span>
                                <span
                                  className={`font-semibold ${stats.totalPnl >= 0 ? "text-green-400" : "text-red-400"}`}
                                >
                                  {stats.wins}W/{stats.losses}L ($
                                  {stats.totalPnl.toFixed(2)})
                                </span>
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
          </div>
        );
      }

      // Error boundary so render errors show in UI instead of blank screen
      class TrackerErrorBoundary extends React.Component {
        state = { error: null };
        static getDerivedStateFromError(err) {
          return { error: err };
        }
        componentDidCatch(err, info) {
          console.error("Tracker render error:", err, info);
        }
        render() {
          if (this.state.error) {
            return (
              <div className="p-10 text-center font-sans" style={{ color: "var(--tt-text)" }}>
                <h2 className="text-[var(--tt-negative)]">Trade Tracker failed to load</h2>
                <p style={{ marginTop: 16 }}>{this.state.error.message}</p>
                <pre style={{ textAlign: "left", marginTop: 16, padding: 16, background: "var(--tt-bg-surface)", overflow: "auto", fontSize: 12 }}>
                  {this.state.error.stack}
                </pre>
              </div>
            );
          }
          return this.props.children;
        }
      }

      try {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          throw new Error("React or ReactDOM not loaded");
        }
        const rootElement = document.getElementById("root");
        if (!rootElement) {
          throw new Error("Root element not found");
        }
        const AuthGate = window.TimedAuthGate;
        const root = ReactDOM.createRoot ? ReactDOM.createRoot(rootElement) : null;
        const app = (
          <AuthGate apiBase={API_BASE}>
            {(user) => (
              <TrackerErrorBoundary>
                <App user={user} />
              </TrackerErrorBoundary>
            )}
          </AuthGate>
        );
        if (root) {
          root.render(app);
        } else {
          ReactDOM.render(app, rootElement);
        }
      } catch (error) {
        console.error("Error rendering app:", error);
        const root = document.getElementById("root");
        if (root) {
          root.innerHTML = `
          <div className="p-10 text-center" style={{ color: "var(--tt-text)" }}>
            <h2 className="text-[var(--tt-negative)]">Error Loading Trade Tracker</h2>
            <p>${error.message}</p>
            <p style="margin-top: 20px; color: var(--tt-text-muted);">Check the browser console (F12) for details.</p>
          </div>`;
        }
      }
    </script>
    <script>
      (function() {
        fetch("/timed/daily-brief/badge", { cache: "no-store" })
          .then(r => r.json())
          .then(d => {
            if (d?.badge?.ts) {
              const seen = Number(localStorage.getItem("tt_brief_seen") || 0);
              if (d.badge.ts > seen) {
                const el = document.getElementById("brief-badge");
                if (el) el.classList.remove("hidden");
              }
            }
          })
          .catch(() => {});
      })();
    </script>
  </body>
</html>
