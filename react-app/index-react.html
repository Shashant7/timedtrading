<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timed Trading â€” React Dashboard</title>

    <!-- React & ReactDOM via CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
      onerror="console.error('Failed to load React')"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      onerror="console.error('Failed to load ReactDOM')"
    ></script>

    <!-- Babel Standalone for JSX -->
    <script
      src="https://unpkg.com/@babel/standalone/babel.min.js"
      onerror="console.error('Failed to load Babel')"
    ></script>

    <!-- Tailwind CSS -->
    <script
      src="https://cdn.tailwindcss.com"
      onerror="console.error('Failed to load Tailwind')"
    ></script>

    <!-- Recharts for lightweight charting - try multiple sources -->
    <script
      src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"
      onerror="console.error('Failed to load Recharts from unpkg, trying alternative...'); loadRechartsFallback();"
    ></script>
    <script>
      function loadRechartsFallback() {
        // Try alternative CDN
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/recharts@2.10.3/umd/Recharts.js';
        script.onerror = function() {
          console.error('Recharts failed to load from all sources');
          window.RechartsFailed = true;
        };
        script.onload = function() {
          console.log('Recharts loaded from jsdelivr');
        };
        document.head.appendChild(script);
      }
      
      // Check if Recharts loaded after a delay
      window.addEventListener('load', function() {
        setTimeout(function() {
          if (typeof Recharts === 'undefined' && !window.RechartsFailed) {
            console.warn('Recharts may not have loaded yet');
          }
        }, 2000);
      });
    </script>

    <!-- Loading indicator while scripts load -->
    <script>
      window.addEventListener("load", function () {
        // Check if all scripts loaded
        setTimeout(function () {
          const root = document.getElementById("root");
          if (root && root.innerHTML === "") {
            if (typeof React === "undefined") {
              root.innerHTML =
                '<div style="padding: 40px; text-align: center; color: #e7ecff;"><h2 style="color: #e74c3c;">Loading Error</h2><p>React failed to load. Check console (F12) for details.</p></div>';
            }
          }
        }, 2000);
      });
    </script>

    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --text: #e7ecff;
        --muted: #93a4d6;
        --line: #26325f;
        --good: #2ecc71;
        --bad: #e74c3c;
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Arial;
        background: var(--bg);
        color: var(--text);
      }

      .loading-spinner {
        border: 2px solid var(--line);
        border-top: 2px solid var(--text);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .prime-glow {
        box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        animation: pulse-glow 2s ease-in-out infinite;
      }
      
      @keyframes pulse-glow {
        0%, 100% { box-shadow: 0 0 12px rgba(46, 204, 113, 0.4); }
        50% { box-shadow: 0 0 20px rgba(46, 204, 113, 0.6); }
      }

      .momentum-elite-glow {
        box-shadow: 0 0 15px rgba(168, 85, 247, 0.5), 0 0 25px rgba(236, 72, 153, 0.3);
        animation: momentum-pulse 2.5s ease-in-out infinite;
      }
      
      @keyframes momentum-pulse {
        0%, 100% {
          box-shadow: 0 0 15px rgba(168, 85, 247, 0.5), 0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(168, 85, 247, 0.8), 0 0 45px rgba(236, 72, 153, 0.6);
        }
      }
      
      /* Slide-in overlay from right */
      .slide-in-right {
        animation: slideInRight 0.3s ease-out;
      }
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      
      /* Comet trail effect */
      .comet-trail {
        stroke-dasharray: 5, 5;
        animation: cometMove 2s linear infinite;
      }
      @keyframes cometMove {
        from { stroke-dashoffset: 0; }
        to { stroke-dashoffset: 20; }
      }
      
      @keyframes momentum-pulse-old {
        0%, 100% { 
          box-shadow: 0 0 15px rgba(168, 85, 247, 0.5), 0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% { 
          box-shadow: 0 0 25px rgba(168, 85, 247, 0.7), 0 0 35px rgba(236, 72, 153, 0.5);
        }
      }
      
      .bubble-transition {
        transition: all 0.2s ease-out;
      }
      
      .bubble-hover {
        transform: scale(1.15);
        filter: brightness(1.2);
      }
      
      .fade-in {
        animation: fadeIn 0.3s ease-in;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .slide-in {
        animation: slideIn 0.3s ease-out;
      }
      
      @keyframes slideIn {
        from { opacity: 0; transform: translateX(-20px); }
        to { opacity: 1; transform: translateX(0); }
      }
      
      /* Phase color gradient helper */
      .phase-gradient {
        background: linear-gradient(to right, 
          #2ecc71 0%, 
          #27ae60 20%, 
          #f39c12 40%, 
          #e67e22 60%, 
          #e74c3c 80%, 
          #c0392b 100%
        );
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div style="padding: 40px; text-align: center; color: #e7ecff">
        <div class="loading-spinner" style="margin: 0 auto 20px"></div>
        <p>Loading dashboard...</p>
      </div>
    </div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef, memo } = React;
      
      // Get Recharts components with fallback
      let RechartsComponents = null;
      if (typeof Recharts !== 'undefined') {
        RechartsComponents = {
          ScatterChart: Recharts.ScatterChart,
          Scatter: Recharts.Scatter,
          XAxis: Recharts.XAxis,
          YAxis: Recharts.YAxis,
          CartesianGrid: Recharts.CartesianGrid,
          Tooltip: Recharts.Tooltip,
          ResponsiveContainer: Recharts.ResponsiveContainer,
        };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Types & Constants
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
      const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
      const API_BASE = "https://timed-trading-ingest.shashant.workers.dev";

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Hooks
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);

        const fetchData = useCallback(async () => {
          try {
            setLoading(true);
            setError(null); // Clear any previous errors
            // Add timeout to prevent hanging - increased to 30s for large datasets
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout
            
            // Fetch both ticker data and ticker index to ensure all 133 tickers are shown
            const [dataRes, tickersRes] = await Promise.all([
              fetch(`${API_BASE}/timed/all`, {
                signal: controller.signal,
                headers: { 'Accept': 'application/json' }
              }),
              fetch(`${API_BASE}/timed/tickers`, {
                signal: controller.signal,
                headers: { 'Accept': 'application/json' }
              })
            ]);
            
            clearTimeout(timeoutId);
            
            if (!dataRes.ok) {
              const errorText = await dataRes.text();
              throw new Error(`HTTP ${dataRes.status}: ${errorText || 'Unknown error'}`);
            }
            
            const dataJson = await dataRes.json();
            const tickersJson = await tickersRes.json();
            
            if (dataJson.ok) {
              const tickerData = dataJson.data || {};
              const allTickers = (tickersJson.ok && tickersJson.tickers) ? tickersJson.tickers : [];
              
              // Merge: ensure all tickers from index are present, even if no recent data
              // This maintains the full 133 ticker baseline
              const mergedData = { ...tickerData };
              allTickers.forEach(ticker => {
                if (!mergedData[ticker]) {
                  // Add placeholder for tickers without recent data
                  // They'll appear on the chart with their last known position (if available)
                  // or won't render until data comes in
                  mergedData[ticker] = {
                    ticker: ticker,
                    // Note: Without data, these tickers won't render bubbles
                    // but they'll be available when data arrives
                  };
                }
              });
              
              setData(mergedData);
              setLastUpdate(new Date());
              setError(null);
              
              // Log ticker counts for debugging
              const tickersWithData = Object.keys(mergedData).filter(t => {
                const d = mergedData[t];
                return d && d.htf_score !== undefined && d.ltf_score !== undefined;
              });
              console.log(`[UI] Loaded ${tickersWithData.length} tickers with data, ${allTickers.length} total in index`);
              console.log(`[UI] Version: 2.4.0 - RR calculation uses fused SL levels, Activity Feed matches Bubble Chart`);
            } else {
              setError(`API Error: ${dataJson.error || 'Failed to fetch data'}`);
            }
          } catch (e) {
            if (e.name === 'AbortError') {
              setError("Request timeout - please try again");
            } else if (e.message.includes('Failed to fetch') || e.message.includes('Load failed')) {
              setError("Network error - check console for details. API may be temporarily unavailable.");
            } else {
              setError(e.message);
            }
            console.error('Fetch error:', e);
            console.error('Error details:', {
              name: e.name,
              message: e.message,
              stack: e.stack
            });
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 180000); // 3 minutes auto-refresh
          return () => clearInterval(interval);
        }, [fetchData]);

        return { data, loading, error, lastUpdate, refetch: fetchData };
      }

      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = useState(value);

        useEffect(() => {
          const handler = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);

          return () => {
            clearTimeout(handler);
          };
        }, [value, delay]);

        return debouncedValue;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Groups (matching original)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const GROUPS = {
        UPTICKS: new Set([
          "TSLA", "STX", "AU", "CCJ", "CLS", "CRS", "VST", "FSLR", "JCI",
          "ORCL", "AMZN", "BRK.B", "BABA", "WMT", "PH", "GEV", "HII", "ULTA", "SHOP",
          "CSX", "PWR", "HOOD", "SPGI", "APP", "PANW", "RDDT", "TT", "GLXY", "ETHA",
        ]),
        SuperGranny: new Set(["META", "NVDA", "AMD", "ANET", "GS"]),
        GRNI: new Set([
          "VST", "TSLA", "TJX", "SPGI", "SOFI", "PWR", "PNC", "PLTR", "PANW", "NVDA",
          "NFLX", "MSTR", "MSFT", "MNST", "META", "LRCX", "KLAC", "JPM", "HOOD", "GS",
          "GOOGL", "GEV", "GE", "EXPE", "ETN", "EMR", "DE", "CRWD", "COST", "CDNS",
          "CAT", "BK", "AXP", "AXON", "AVGO", "ANET", "AMZN", "AMD", "AAPL",
        ]),
        GRNJ: new Set([
          "RKLB", "LITE", "SN", "ALB", "RDDT", "RGLD", "MTZ", "ON", "ALLY", "DY",
          "CCJ", "EWBC", "PATH", "WFRD", "WAL", "IESC", "ENS", "TWLO", "MLI", "KTOS",
          "MDB", "TLN", "EME", "AWI", "IBP", "DCI", "WTS", "FIX", "UTHR", "NBIS",
          "SGI", "AYI", "RIOT", "NXT", "SANM", "BWXT", "PEGA", "JOBY", "IONQ", "SOFI",
          "ITT", "STRL", "QLYS", "MP", "GLXY", "HIMS", "IOT", "BE", "NEU", "AVAV",
          "PSTG", "RBLX",
        ]),
        GRNY: new Set([
          "GEV", "LRCX", "PNC", "GOOGL", "GS", "META", "MNST", "KLAC", "TJX", "GE",
          "EXPE", "CAT", "BK", "SPGI", "TSLA", "EMR", "JPM", "AXP", "ANET", "AXON",
          "AAPL", "NVDA", "AVGO", "PWR", "CDNS", "DE", "MSFT", "COST", "VST", "PLTR",
          "AMZN", "HOOD", "ETN", "SOFI", "AMD", "PANW", "CRWD", "NFLX", "MSTR",
        ]),
        Social: new Set(["CSCO", "BA", "NKE", "AAPL", "PI", "APLD", "MU"]),
        SP_Sectors: new Set([
          "XLK", "XLF", "XLY", "XLP", "XLC", "XLI", "XLB", "XLE", "XLRE", "XLU", "XLV",
        ]),
      };

      const GROUP_LABELS = {
        SP_Sectors: "S&P Sectors",
      };

      const GROUP_ORDER = [
        "SP_Sectors",
        "UPTICKS",
        "SuperGranny",
        "GRNI",
        "GRNJ",
        "GRNY",
        "Social",
      ];

      function normTicker(t) {
        const s = String(t || "").trim().toUpperCase();
        if (s === "BRK-B") return "BRK.B";
        return s;
      }

      function groupsForTicker(t) {
        const T = normTicker(t);
        const out = [];
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) out.push(g);
        return out;
      }

      // Check if ticker is in any group
      function isTickerInGroups(t) {
        const T = normTicker(t);
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) return true;
        return false;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Utils
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Phase-based color (Turbo-like gradient: 0=green, 0.5=yellow, 1=red)
      // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
      function phaseCompletionToColor(phasePct) {
        const p = Math.max(0, Math.min(1, phasePct));
        if (p < 0.3) {
          // Green: #2ecc71 (under 30%)
          return "#2ecc71";
        } else if (p < 0.6) {
          // Yellow: #f39c12 (30-60%)
          return "#f39c12";
        } else {
          // Red: #e74c3c (60-100%)
          return "#e74c3c";
        }
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          // Green to light green: #2ecc71 to #27ae60
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(204 + (174 - 204) * t)}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          // Light green to yellow: #27ae60 to #f39c12
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(174 + (156 - 174) * t)}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          // Yellow to orange: #f39c12 to #e67e22
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(156 + (126 - 156) * t)}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          // Orange to red: #e67e22 to #e74c3c
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(126 + (76 - 126) * t)}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          // Red to dark red: #e74c3c to #c0392b
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(76 + (57 - 76) * t)}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }
      
      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";

        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function completionForSize(ticker) {
        // Use the completion value from Pine Script payload directly
        // Pine Script calculates: completion = abs(close - triggerPrice) / expectedMove
        // This is more accurate than recalculating from trigger to TP because:
        // 1. It accounts for expectedMove (which may differ from TP distance)
        // 2. It handles direction correctly
        // 3. It works even when price hasn't reached trigger yet
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      // Dynamic ranking that considers real-time conditions
      function computeDynamicRank(ticker) {
        const baseRank = Number(ticker.rank) || 50;
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        
        let dynamicScore = baseRank;
        
        // Corridor bonus (high priority - active setups)
        if (inCorridor) {
          dynamicScore += 12; // Strong bonus for being in corridor
          
          // Extra bonus if aligned AND in corridor (perfect setup)
          if (aligned) {
            dynamicScore += 8;
          }
        }
        
        // Squeeze release in corridor = very strong signal
        if (sqRel && inCorridor) {
          dynamicScore += 10;
        }
        
        // Squeeze on in corridor = building pressure
        if (sqOn && inCorridor && !sqRel) {
          dynamicScore += 5;
        }
        
        // RR bonus (scaled - better RR = higher rank)
        if (rr >= 2.0) {
          dynamicScore += 8; // Excellent RR
        } else if (rr >= 1.5) {
          dynamicScore += 5; // Good RR
        } else if (rr >= 1.0) {
          dynamicScore += 2; // Acceptable RR
        }
        
        // Phase bonus (early phase = better opportunity)
        if (phase < 0.3) {
          dynamicScore += 6; // Very early
        } else if (phase < 0.5) {
          dynamicScore += 3; // Early
        } else if (phase > 0.7) {
          dynamicScore -= 5; // Late phase penalty
        }
        
        // Completion bonus (low completion = more room to run)
        if (comp < 0.3) {
          dynamicScore += 5; // Early in move
        } else if (comp > 0.8) {
          dynamicScore -= 8; // Near completion penalty
        }
        
        // Score strength bonus (strong HTF/LTF scores)
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;
        
        // Phase zone change bonus
        if (phaseZoneChange) {
          dynamicScore += 4;
        }
        
        // Clamp to 0-100 range
        dynamicScore = Math.max(0, Math.min(100, dynamicScore));
        
        return Math.round(dynamicScore);
      }

      // Parse natural language query into filter conditions
      function parseNaturalLanguageQuery(query) {
        if (!query || typeof query !== 'string') return null;
        
        const queryLower = query.toLowerCase().trim();
        const conditions = {};
        
        // Multi-ticker search: "AAPL, GOOGL, TSLA"
        if (query.includes(',') && !query.match(/rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup/)) {
          return { type: 'multi-ticker', tickers: query.split(',').map(t => t.trim().toUpperCase()) };
        }
        
        // Top 40 filter
        if (queryLower.match(/\btop\s*40\b|\btop40\b/)) {
          conditions.top40 = true;
        }
        
        // Top Long Setup
        if (queryLower.match(/\btop\s*long\s*setup\b|\btop\s*long\b/)) {
          conditions.topLongSetup = true;
        }
        
        // Top Short Setup
        if (queryLower.match(/\btop\s*short\s*setup\b|\btop\s*short\b/)) {
          conditions.topShortSetup = true;
        }
        
        // Prime setup
        if (queryLower.match(/\bprime\b|\bprime setup\b/)) {
          conditions.prime = true;
        }
        
        // Momentum Elite
        if (queryLower.match(/\bmomentum elite\b|\belite\b/)) {
          conditions.momentumElite = true;
        }
        
        // In corridor
        if (queryLower.match(/\bin corridor\b|\bcorridor\b/)) {
          conditions.inCorridor = true;
        }
        
        // Squeeze release
        if (queryLower.match(/\bsqueeze release\b|\bsqueeze released\b/)) {
          conditions.squeezeRelease = true;
        }
        
        // Helper function to extract numeric value with various operators
        const extractNumericCondition = (pattern, fieldName, isPercentage = false) => {
          // Match operators: >, >=, <, <=, above, below, over, under, greater than, less than, at least, at most
          const operators = {
            '>': 'min',
            '>=': 'min',
            'above': 'min',
            'over': 'min',
            'greater than': 'min',
            'at least': 'min',
            '<': 'max',
            '<=': 'max',
            'below': 'max',
            'under': 'max',
            'less than': 'max',
            'at most': 'max'
          };
          
          for (const [op, type] of Object.entries(operators)) {
            const regex = new RegExp(`\\b${pattern}\\s*(?:${op.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})\\s*([\\d.]+)\\s*%?`, 'i');
            const match = queryLower.match(regex);
            if (match) {
              const value = isPercentage ? parseFloat(match[1]) / 100 : parseFloat(match[1]);
              return { type, value };
            }
          }
          return null;
        };
        
        // Rank conditions: "rank > 75", "rank above 75", "rank over 75", "rank below 50", "rank under 50"
        const rankCondition = extractNumericCondition('rank', 'rank');
        if (rankCondition) {
          if (rankCondition.type === 'min') {
            conditions.minRank = rankCondition.value;
          } else {
            // For max rank, we'd need a maxRank filter - skip for now
          }
        }
        
        // RR/Risk-Reward conditions: "RR > 2", "risk reward over 2", "RR above 1.5"
        const rrCondition = extractNumericCondition('(?:rr|risk[\\s-]?reward)', 'rr');
        if (rrCondition && rrCondition.type === 'min') {
          conditions.minRR = rrCondition.value;
        }
        
        // Phase conditions: "phase > 50%", "phase over 50%", "phase above 50", "phase under 30%"
        const phaseMinCondition = extractNumericCondition('phase', 'phase', true);
        if (phaseMinCondition && phaseMinCondition.type === 'min') {
          conditions.minPhase = phaseMinCondition.value;
        }
        const phaseMaxCondition = extractNumericCondition('phase', 'phase', true);
        if (phaseMaxCondition && phaseMaxCondition.type === 'max') {
          conditions.maxPhase = phaseMaxCondition.value;
        }
        
        // Completion conditions: "completion < 30%", "completion under 30%", "completion below 50%"
        const compCondition = extractNumericCondition('completion', 'completion', true);
        if (compCondition && compCondition.type === 'max') {
          conditions.maxCompletion = compCondition.value;
        }
        
        // Price change: "moved 5 points", "moved $5", "price change > 5", "price change over 5"
        const priceChangeMatch = queryLower.match(/\b(?:moved|price\s*change)\s+(?:over|above|greater\s*than|>|>=|at\s*least)\s*(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/);
        if (priceChangeMatch) {
          conditions.minPriceChange = parseFloat(priceChangeMatch[1]);
        } else {
          // Also support "moved 5 points" without operator
          const simplePriceChangeMatch = queryLower.match(/\bmoved\s+(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/);
          if (simplePriceChangeMatch) {
            conditions.minPriceChange = parseFloat(simplePriceChangeMatch[1]);
          }
        }
        
        // If we found any conditions, return them
        if (Object.keys(conditions).length > 0) {
          return { type: 'query', conditions };
        }
        
        return null;
      }

      function applyFilters(dataObj, filters) {
        const out = [];
        
        // Parse natural language query if search field looks like a query
        const queryResult = parseNaturalLanguageQuery(filters.search);
        let effectiveFilters = { ...filters };
        let multiTickerList = null;
        
        if (queryResult) {
          if (queryResult.type === 'multi-ticker') {
            multiTickerList = queryResult.tickers;
            // Clear search filter since we're handling it manually
            effectiveFilters = { ...effectiveFilters, search: '' };
          } else if (queryResult.type === 'query') {
            // Merge query conditions into filters
            effectiveFilters = { ...effectiveFilters, ...queryResult.conditions, search: '' };
          }
        }
        
        for (const [tickerRaw, d] of Object.entries(dataObj)) {
          // Skip completely empty entries, but allow entries with just ticker name
          if (!d || typeof d !== 'object') continue;
          const ticker = String(tickerRaw || d.ticker || '').trim().toUpperCase();
          if (!ticker) continue;

          // Only show tickers that are in at least one group OR are S&P Sectors
          // S&P Sectors should always be visible
          const isSPSector = GROUPS.SP_Sectors && GROUPS.SP_Sectors.has(normTicker(ticker));
          if (!isSPSector && !isTickerInGroups(ticker)) continue;
          
          // Skip tickers that don't have scores (can't render without position data)
          // These will appear once they receive data from TradingView
          if (d.htf_score === undefined && d.ltf_score === undefined) continue;

          // Multi-ticker search
          if (multiTickerList && multiTickerList.length > 0) {
            if (!multiTickerList.includes(ticker)) continue;
          } else if (effectiveFilters.search && !ticker.includes(effectiveFilters.search.toUpperCase())) {
            // Regular search (if not multi-ticker)
            continue;
          }
          
          // Group filter
          if (effectiveFilters.group && effectiveFilters.group !== "ALL") {
            const T = normTicker(ticker);
            const gs = groupsForTicker(T);
            if (effectiveFilters.group === "ANY") {
              if (gs.length === 0) continue;
            } else if (effectiveFilters.group === "UNGROUPED") {
              if (gs.length > 0) continue;
            } else {
              if (!gs.includes(effectiveFilters.group)) continue;
            }
          }

          // Handle Top Long Setup and Top Short Setup from natural language
          if (effectiveFilters.topLongSetup === true) {
            if (d.state !== "HTF_BULL_LTF_PULLBACK") continue;
          }
          if (effectiveFilters.topShortSetup === true) {
            if (d.state !== "HTF_BEAR_LTF_PULLBACK") continue;
          }
          
          if (effectiveFilters.quadrants && !effectiveFilters.quadrants.includes(d.state))
            continue;
          if (effectiveFilters.minRank && (Number(d.rank) || 0) < effectiveFilters.minRank)
            continue;
          if (effectiveFilters.minRR && (Number(d.rr) || 0) < effectiveFilters.minRR) continue;
          if (
            effectiveFilters.maxCompletion &&
            completionForSize(d) > effectiveFilters.maxCompletion
          )
            continue;
          if (effectiveFilters.inCorridor === true) {
            const ent = entryType(d);
            if (!ent.corridor) continue;
          }
          if (effectiveFilters.squeezeRelease === true) {
            const flags = d.flags || {};
            if (!flags.sq30_release) continue;
          }
          if (effectiveFilters.momentumElite === true) {
            const flags = d.flags || {};
            if (!flags.momentum_elite) continue;
          }
          if (effectiveFilters.prime === true) {
            if (!isPrimeBubble(d)) continue;
          }
          if (effectiveFilters.minPriceChange !== undefined) {
            // Calculate price change from trigger price to current price
            const currentPrice = Number(d.price) || 0;
            const triggerPrice = Number(d.trigger_price) || 0;
            if (triggerPrice > 0) {
              const priceChange = Math.abs(currentPrice - triggerPrice);
              if (priceChange < effectiveFilters.minPriceChange) continue;
            } else {
              // No trigger price, skip this filter
              continue;
            }
          }
          if (effectiveFilters.minPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase < effectiveFilters.minPhase) continue;
          }
          if (effectiveFilters.maxPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase > effectiveFilters.maxPhase) continue;
          }

          out.push({ ticker, ...d });
        }
        
        // Apply Top 40 filter if active (after computing dynamic ranks)
        if (effectiveFilters.top40 === true) {
          const withRanks = out.map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }));
          withRanks.sort((a, b) => b.dynamicRank - a.dynamicRank);
          return withRanks.slice(0, 40);
        }
        
        return out;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Components
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Native SVG Bubble component (works without Recharts)
      const SVGBubble = memo(({ ticker, onClick, onHover, isHovered, scaleX, scaleY, offsetX, offsetY, showLabels }) => {
        const comp = Number(ticker.completion) || 0;
        const phasePct = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        
        // Bubble size based on RR, adjusted for completion (lower completion = larger size)
        // RR is the opportunity, but we want to reduce size as completion increases
        // Formula: baseSize + (RR * multiplier) * (1 - completion)
        // This makes high RR + low completion = largest bubbles
        // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
        const cappedRR = Math.min(rr, 5); // Cap RR at 5 for size calculation
        const completionPenalty = 1 - comp; // 1.0 when completion is 0, 0.0 when completion is 1
        const baseSize = 8;
        const rrMultiplier = 6; // Scale factor for RR
        const size = baseSize + (cappedRR * rrMultiplier * completionPenalty);
        
        const prime = isPrimeBubble(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);

        // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
        const color = phaseCompletionToColor(phasePct);
        const opacity = isHovered ? 1 : (prime ? 0.9 : 0.7);
        const borderWidth = prime ? 3 : flags.sq30_release ? 2 : flags.sq30_on ? 2 : 1;
        const borderColor = prime 
          ? "#2ecc71" 
          : flags.sq30_release 
          ? "#00ffff" 
          : flags.sq30_on
          ? "#ffd700"
          : "#ffffff";
        
        const bubbleSize = isHovered ? size * 1.2 : size;

        const x = (Number(ticker.ltf_score) || 0) * scaleX + offsetX;
        const y = (Number(ticker.htf_score) || 0) * scaleY + offsetY;

        // Determine emoji and label position
        const hasSqueeze = flags.sq30_release || flags.sq30_on;
        const emoji = prime ? "â­" : flags.sq30_release ? "âš¡" : flags.sq30_on ? "ðŸ§¨" : "";
        const labelY = y - bubbleSize - (emoji ? 12 : 8);

        return (
          <g
            onClick={() => onClick(ticker.ticker)}
            onMouseEnter={() => onHover(ticker.ticker)}
            onMouseLeave={() => onHover(null)}
            style={{ cursor: "pointer", transition: "all 0.2s ease-out" }}
          >
            {/* Glow effect for prime */}
            {prime && (
              <circle
                cx={x}
                cy={y}
                r={bubbleSize + 2}
                fill="none"
                stroke="#2ecc71"
                strokeWidth="1"
                opacity="0.3"
              />
            )}
            <circle
              cx={x}
              cy={y}
              r={bubbleSize}
              fill={color}
              fillOpacity={opacity}
              stroke={borderColor}
              strokeWidth={borderWidth}
              style={{ transition: "all 0.2s ease-out" }}
            />
            {/* Emoji above bubble */}
            {emoji && (
              <text
                x={x}
                y={labelY}
                textAnchor="middle"
                fontSize={prime ? "14" : "12"}
                fill={prime ? "#2ecc71" : flags.sq30_release ? "#00ffff" : "#ffd700"}
                fontWeight="bold"
                style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
              >
                {emoji}
              </text>
            )}
            {/* Ticker label */}
            {(showLabels || isHovered) && (
              <text
                x={x}
                y={labelY - (emoji ? 14 : 8)}
                textAnchor="middle"
                fontSize="10"
                fill="#e7ecff"
                fontWeight="600"
                style={{ 
                  textShadow: "0 0 4px rgba(0,0,0,0.9)",
                  pointerEvents: "none"
                }}
              >
                {ticker.ticker}
              </text>
            )}
          </g>
        );
      });

      const Bubble = memo(({ ticker, onClick, onHover, isHovered, showLabels }) => {
        const comp = Number(ticker.completion) || 0;
        const phasePct = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        
        // Bubble size based on RR, adjusted for completion (lower completion = larger size)
        // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
        const cappedRR = Math.min(rr, 5); // Cap RR at 5 for size calculation
        const completionPenalty = 1 - comp; // 1.0 when completion is 0, 0.0 when completion is 1
        const baseSize = 8;
        const rrMultiplier = 6; // Scale factor for RR
        const size = baseSize + (cappedRR * rrMultiplier * completionPenalty);
        
        const prime = isPrimeBubble(ticker);
        const flags = ticker.flags || {};

        // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
        const color = phaseCompletionToColor(phasePct);
        const opacity = isHovered ? 1 : (prime ? 0.9 : 0.7);
        const borderWidth = prime ? 3 : flags.sq30_release ? 2 : flags.sq30_on ? 2 : 1;
        const borderColor = prime 
          ? "#2ecc71" 
          : flags.sq30_release 
          ? "#00ffff" 
          : flags.sq30_on
          ? "#ffd700"
          : "#ffffff";
        
        const bubbleSize = isHovered ? size * 1.2 : size;
        const x = Number(ticker.ltf_score) || 0;
        const y = Number(ticker.htf_score) || 0;

        // Determine emoji and label position
        const hasSqueeze = flags.sq30_release || flags.sq30_on;
        const emoji = prime ? "â­" : flags.sq30_release ? "âš¡" : flags.sq30_on ? "ðŸ§¨" : "";
        const labelY = y - bubbleSize - (emoji ? 12 : 8);

        return (
          <g
            onClick={() => onClick(ticker.ticker)}
            onMouseEnter={() => onHover(ticker.ticker)}
            onMouseLeave={() => onHover(null)}
            style={{ cursor: "pointer", transition: "all 0.2s ease-out" }}
          >
            {/* Glow effect for prime */}
            {prime && (
              <circle
                cx={x}
                cy={y}
                r={bubbleSize + 2}
                fill="none"
                stroke="#2ecc71"
                strokeWidth="1"
                opacity="0.3"
              />
            )}
            <circle
              cx={x}
              cy={y}
              r={bubbleSize}
              fill={color}
              fillOpacity={opacity}
              stroke={borderColor}
              strokeWidth={borderWidth}
              style={{ transition: "all 0.2s ease-out" }}
            />
            {/* Emoji above bubble */}
            {emoji && (
              <text
                x={x}
                y={labelY}
                textAnchor="middle"
                fontSize={prime ? "14" : "12"}
                fill={prime ? "#2ecc71" : flags.sq30_release ? "#00ffff" : "#ffd700"}
                fontWeight="bold"
                style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
              >
                {emoji}
              </text>
            )}
            {/* Ticker label */}
            {(showLabels || isHovered) && (
              <text
                x={x}
                y={labelY - (emoji ? 14 : 8)}
                textAnchor="middle"
                fontSize="10"
                fill="#e7ecff"
                fontWeight="600"
                style={{ 
                  textShadow: "0 0 4px rgba(0,0,0,0.9)",
                  pointerEvents: "none"
                }}
              >
                {ticker.ticker}
              </text>
            )}
          </g>
        );
      });

      function BubbleChart({ tickers, onBubbleClick, hoveredTicker, onHover, selectedTicker, selectedTrail, allData }) {
        const [tooltip, setTooltip] = useState(null);
        const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
        const [showLabels, setShowLabels] = useState(true);
        const containerRef = React.useRef(null);
        const [dimensions, setDimensions] = React.useState({ width: 1600, height: 1000 });
        
        // Update dimensions on mount and resize to use full container space
        React.useEffect(() => {
          const updateDimensions = () => {
            if (containerRef.current) {
              const rect = containerRef.current.getBoundingClientRect();
              // Use actual container size, with minimums
              setDimensions({ 
                width: Math.max(rect.width - 16, 1200), // Account for padding
                height: Math.max(rect.height - 16, 800) 
              });
            }
          };
          // Initial update
          const timeoutId = setTimeout(updateDimensions, 100);
          window.addEventListener('resize', updateDimensions);
          return () => {
            clearTimeout(timeoutId);
            window.removeEventListener('resize', updateDimensions);
          };
        }, []);
        
        // Fallback: Native SVG chart (works without Recharts)
        if (!RechartsComponents) {
          const chartWidth = dimensions.width;
          const chartHeight = dimensions.height;
          const margin = 50; // Reduced margin for more plot space
          const plotWidth = chartWidth - 2 * margin;
          const plotHeight = chartHeight - 2 * margin;
          
          // More precise scaling for better granularity
          const scaleX = plotWidth / 100; // -50 to 50 range
          const scaleY = plotHeight / 100;
          const offsetX = margin;
          const offsetY = margin;
          
          const handleMouseMove = (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            setTooltipPos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
          };
          
          return (
            <div ref={containerRef} className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-2 relative">
              {/* Label toggle */}
              <div className="absolute top-2 right-2 z-10">
                <button
                  onClick={() => setShowLabels(!showLabels)}
                  className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f] text-xs text-[#93a4d6] hover:bg-[#1a2550] transition-colors"
                >
                  {showLabels ? "Hide Labels" : "Show Labels"}
                </button>
              </div>
              <svg 
                width="100%" 
                height="100%" 
                viewBox={`0 0 ${chartWidth} ${chartHeight}`}
                preserveAspectRatio="xMidYMid meet"
                onMouseMove={handleMouseMove}
                onMouseLeave={() => setTooltip(null)}
                className="w-full h-full"
              >
                {/* Grid with better styling */}
                <defs>
                  <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                    <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#26325f" strokeWidth="0.5" opacity="0.5"/>
                  </pattern>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                    <feMerge>
                      <feMergeNode in="coloredBlur"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />
                
                {/* Axes - Much more visible - Both center lines same style */}
                {/* Vertical center line (x=0) */}
                <line x1={offsetX + 50 * scaleX} y1={offsetY} x2={offsetX + 50 * scaleX} y2={offsetY + plotHeight} stroke="#e7ecff" strokeWidth="3" opacity="0.9" />
                <line x1={offsetX + 50 * scaleX} y1={offsetY} x2={offsetX + 50 * scaleX} y2={offsetY + plotHeight} stroke="#ffffff" strokeWidth="1" opacity="0.5" />
                {/* Horizontal center line (y=0) */}
                <line x1={offsetX} y1={offsetY + plotHeight / 2} x2={offsetX + plotWidth} y2={offsetY + plotHeight / 2} stroke="#e7ecff" strokeWidth="3" opacity="0.9" />
                <line x1={offsetX} y1={offsetY + plotHeight / 2} x2={offsetX + plotWidth} y2={offsetY + plotHeight / 2} stroke="#ffffff" strokeWidth="1" opacity="0.5" />
                {/* Vertical axis line (y-axis) */}
                <line x1={offsetX} y1={offsetY} x2={offsetX} y2={offsetY + plotHeight} stroke="#93a4d6" strokeWidth="2" opacity="0.6" />
                
                {/* Axis labels */}
                <text 
                  x={offsetX - 50} 
                  y={offsetY + plotHeight / 2} 
                  fill="#93a4d6" 
                  textAnchor="middle" 
                  fontSize="13" 
                  fontWeight="600"
                  transform={`rotate(-90 ${offsetX - 50} ${offsetY + plotHeight / 2})`}
                >
                  HTF Score
                </text>
                <text x={offsetX + plotWidth / 2} y={offsetY + plotHeight + 40} fill="#93a4d6" textAnchor="middle" fontSize="13" fontWeight="600">LTF Score</text>
                
                {/* Axis scale markers */}
                {[-50, -25, 0, 25, 50].map(val => {
                  const x = offsetX + (val + 50) * scaleX;
                  const y = offsetY + plotHeight / 2;
                  return (
                    <g key={`x-${val}`}>
                      <line x1={x} y1={y - 5} x2={x} y2={y + 5} stroke="#93a4d6" strokeWidth="2" />
                      <text x={x} y={y + 20} fill="#93a4d6" textAnchor="middle" fontSize="10">{val}</text>
                    </g>
                  );
                })}
                {[-50, -25, 0, 25, 50].map(val => {
                  const x = offsetX;
                  const y = offsetY + plotHeight - (val + 50) * scaleY;
                  return (
                    <g key={`y-${val}`}>
                      <line x1={x - 5} y1={y} x2={x + 5} y2={y} stroke="#93a4d6" strokeWidth="2" />
                      <text x={x - 15} y={y + 4} fill="#93a4d6" textAnchor="end" fontSize="10">{val}</text>
                    </g>
                  );
                })}
                
                {/* Quadrant labels - moved further from center for more bubble space */}
                <text x={offsetX + plotWidth * 0.12} y={offsetY + 20} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q1 Prep</text>
                <text x={offsetX + plotWidth * 0.88} y={offsetY + 20} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q2 Bull</text>
                <text x={offsetX + plotWidth * 0.12} y={offsetY + plotHeight - 5} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q3 Bear</text>
                <text x={offsetX + plotWidth * 0.88} y={offsetY + plotHeight - 5} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q4 Pullback</text>
                
                {/* Corridors */}
                <rect 
                  x={offsetX + (LONG_CORRIDOR.ltfMin + 50) * scaleX} 
                  y={offsetY} 
                  width={(LONG_CORRIDOR.ltfMax - LONG_CORRIDOR.ltfMin) * scaleX} 
                  height={plotHeight / 2} 
                  fill="rgba(46,204,113,0.1)" 
                />
                <rect 
                  x={offsetX + (SHORT_CORRIDOR.ltfMin + 50) * scaleX} 
                  y={offsetY + plotHeight / 2} 
                  width={(SHORT_CORRIDOR.ltfMax - SHORT_CORRIDOR.ltfMin) * scaleX} 
                  height={plotHeight / 2} 
                  fill="rgba(231,76,60,0.1)" 
                />
                
                {/* Bubbles - Show only selected ticker with trail if selected, otherwise show all */}
                {selectedTicker && selectedTrail ? (
                  <>
                    {/* Trail path - comet effect */}
                    {selectedTrail.length > 1 && selectedTrail.map((point, idx) => {
                      if (idx === 0) return null;
                      const prevPoint = selectedTrail[idx - 1];
                      const x1 = (Number(prevPoint.ltf_score) || 0) * scaleX + offsetX + 50 * scaleX;
                      const y1 = (Number(prevPoint.htf_score) || 0) * -scaleY + offsetY + plotHeight - 50 * scaleY;
                      const x2 = (Number(point.ltf_score) || 0) * scaleX + offsetX + 50 * scaleX;
                      const y2 = (Number(point.htf_score) || 0) * -scaleY + offsetY + plotHeight - 50 * scaleY;
                      const opacity = 0.3 + (idx / selectedTrail.length) * 0.5; // Fade in from past to present
                      return (
                        <line
                          key={`trail-${idx}`}
                          x1={x1}
                          y1={y1}
                          x2={x2}
                          y2={y2}
                          stroke="#00ffff"
                          strokeWidth="2"
                          opacity={opacity}
                          className="comet-trail"
                        />
                      );
                    })}
                    {/* Trail points (smaller bubbles) - show historical positions */}
                    {selectedTrail.slice(0, -1).map((point, idx) => {
                      // Create a ticker-like object from trail point
                      const tickerData = {
                        ticker: selectedTicker,
                        htf_score: point.htf_score || 0,
                        ltf_score: point.ltf_score || 0,
                        phase_pct: point.phase_pct || 0,
                        completion: point.completion || 0,
                        flags: {},
                        state: point.state || '',
                      };
                      const x = (Number(tickerData.ltf_score) || 0) * scaleX + offsetX + 50 * scaleX;
                      const y = (Number(tickerData.htf_score) || 0) * -scaleY + offsetY + plotHeight - 50 * scaleY;
                      const size = 3 + (idx / selectedTrail.length) * 4; // Smaller, growing towards present
                      const opacity = 0.3 + (idx / selectedTrail.length) * 0.4; // Fade in from past to present
                      
                      return (
                        <circle
                          key={`trail-point-${idx}`}
                          cx={x}
                          cy={y}
                          r={size}
                          fill="#00ffff"
                          fillOpacity={opacity}
                          stroke="#00ffff"
                          strokeWidth="1"
                          strokeOpacity={opacity * 0.5}
                        />
                      );
                    })}
                    {/* Current position (larger, highlighted) */}
                    {(() => {
                      // Try to find ticker in filtered list first
                      let currentTicker = tickers.find(t => {
                        if (!t || typeof t !== 'object') return false;
                        const tTicker = String(t.ticker || '').toUpperCase();
                        return tTicker === String(selectedTicker).toUpperCase();
                      });
                      
                      // If not in filtered list, try to get from allData (for tickers filtered out but selected)
                      if (!currentTicker && allData && typeof allData === 'object') {
                        const tickerUpper = String(selectedTicker).toUpperCase();
                        if (allData[tickerUpper]) {
                          currentTicker = allData[tickerUpper];
                        } else {
                          // Search through values
                          const dataArray = Object.values(allData);
                          currentTicker = dataArray.find(t => {
                            if (!t || typeof t !== 'object') return false;
                            const tTicker = String(t.ticker || '').toUpperCase();
                            return tTicker === tickerUpper;
                          });
                        }
                      }
                      
                      // Only render if we have valid scores to position the bubble
                      if (currentTicker && 
                          (currentTicker.htf_score !== undefined || currentTicker.ltf_score !== undefined)) {
                        return (
                          <SVGBubble
                            key={selectedTicker}
                            ticker={currentTicker}
                            onClick={() => {}}
                            onHover={() => {}}
                            isHovered={true}
                            scaleX={scaleX}
                            scaleY={-scaleY}
                            offsetX={offsetX + 50 * scaleX}
                            offsetY={offsetY + plotHeight - 50 * scaleY}
                            showLabels={true}
                          />
                        );
                      }
                      return null;
                    })()}
                  </>
                ) : (
                  tickers.map(ticker => (
                    <SVGBubble
                      key={ticker.ticker}
                      ticker={ticker}
                      onClick={onBubbleClick}
                      onHover={(t) => {
                        onHover(t);
                        if (t) setTooltip(tickers.find(tt => tt.ticker === t));
                      }}
                      isHovered={hoveredTicker === ticker.ticker}
                      scaleX={scaleX}
                      scaleY={-scaleY}
                      offsetX={offsetX + 50 * scaleX}
                      offsetY={offsetY + plotHeight - 50 * scaleY}
                      showLabels={showLabels}
                    />
                  ))
                )}
              </svg>
              
                {/* Tooltip */}
              {tooltip && (
                <div 
                  className="absolute bg-[#121a33] border-2 border-[#26325f] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl fade-in"
                  style={{ 
                    left: tooltipPos.x + 10, 
                    top: tooltipPos.y - 10,
                    minWidth: "200px"
                  }}
                >
                  <div className="font-bold text-base mb-2">{tooltip.ticker}</div>
                  {isPrimeBubble(tooltip) && (
                    <div className="mb-2 px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold text-center">
                      â­ PRIME SETUP
                    </div>
                  )}
                  <div className="space-y-1">
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Rank</span>
                      <span className="font-semibold">{tooltip.rank || "â€”"}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">RR</span>
                      <span className="font-semibold">{tooltip.rr ? Number(tooltip.rr).toFixed(2) : "â€”"}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">State</span>
                      <span className="font-semibold">{tooltip.state || "â€”"}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Phase</span>
                      <span className="font-semibold" style={{ color: phaseToColor(Number(tooltip.phase_pct) || 0) }}>
                        {Math.round((Number(tooltip.phase_pct) || 0) * 100)}%
                        {tooltip.phase_zone && ` (${tooltip.phase_zone})`}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Completion</span>
                      <span className="font-semibold">{Math.round(completionForSize(tooltip) * 100)}%</span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }
        
        // Recharts version (if loaded)
        const { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } = RechartsComponents;
        
        const data = useMemo(
          () =>
            tickers.map((t) => ({
              x: Number(t.ltf_score) || 0,
              y: Number(t.htf_score) || 0,
              ticker: t,
            })),
          [tickers]
        );

        return (
          <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-4">
            <ResponsiveContainer width="100%" height="100%">
              <ScatterChart
                margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#26325f" />
                <XAxis
                  type="number"
                  dataKey="x"
                  name="LTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <YAxis
                  type="number"
                  dataKey="y"
                  name="HTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <Tooltip
                  content={({ active, payload }) => {
                    if (!active || !payload?.[0]) return null;
                    const t = payload[0].payload.ticker;
                    return (
                      <div className="bg-[#121a33] border border-[#26325f] rounded p-3 text-sm">
                        <div className="font-bold">{t.ticker}</div>
                        <div>Rank: {t.rank || "â€”"}</div>
                        <div>RR: {t.rr ? Number(t.rr).toFixed(2) : "â€”"}</div>
                        <div>State: {t.state || "â€”"}</div>
                        {isPrimeBubble(t) && (
                          <div className="text-[#2ecc71]">â­ PRIME SETUP</div>
                        )}
                      </div>
                    );
                  }}
                />
                <Scatter data={data}>
                  {data.map((entry, index) => (
                    <Bubble
                      key={entry.ticker.ticker}
                      ticker={entry.ticker}
                      onClick={onBubbleClick}
                      onHover={onHover}
                      isHovered={hoveredTicker === entry.ticker.ticker}
                    />
                  ))}
                </Scatter>
              </ScatterChart>
            </ResponsiveContainer>
          </div>
        );
      }

      // Format date/time from timestamp
      function formatTriggerDateTime(ts) {
        if (!ts || typeof ts !== "number") return "â€”";
        const date = new Date(ts);
        return {
          date: date.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }),
          time: date.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true }),
        };
      }

      // Get "Why" reason from ticker data
      function getWhyReason(ticker) {
        const reasons = ticker.reasons || [];
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        
        if (flags.sq30_release) return "Squeeze Release";
        if (flags.phase_zone_change) return "Phase Zone Change";
        if (state.includes("BULL") && state.includes("BULL")) return "Both Timeframes Bullish";
        if (state.includes("BEAR") && state.includes("BEAR")) return "Both Timeframes Bearish";
        if (reasons.length > 0) return reasons[0];
        return "Setup Active";
      }

      // Get direction from state
      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL")) return { text: "LONG", color: "text-green-400", bg: "bg-green-500/20" };
        if (state.includes("BEAR")) return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: "â€”", color: "text-[#93a4d6]", bg: "bg-[#26325f]" };
      }

      function SetupCard({ ticker, isSelected, onClick }) {
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const momentumElite = !!flags.momentum_elite;
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const dir = getDirection(ticker);
        const why = getWhyReason(ticker);
        const triggerDT = formatTriggerDateTime(ticker.trigger_ts);
        const tpLevels = ticker.tp_levels || [];
        const comp = completionForSize(ticker);

        return (
          <div
            className={`p-2 rounded-lg border cursor-pointer transition-all ${
              isSelected
                ? "border-blue-500 bg-blue-500/10 shadow-lg"
                : momentumElite
                ? "border-purple-500 bg-purple-500/15 momentum-elite-glow border-2"
                : prime
                ? "border-green-500 bg-green-500/10 prime-glow"
                : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0]"
            }`}
            onClick={onClick}
          >
            {/* Header */}
            <div className="flex items-center justify-between mb-1.5">
              <div className="flex items-center gap-1.5">
                <span className="font-bold text-sm">{ticker.ticker}</span>
                {momentumElite && <span className="text-purple-400 text-xs font-bold" title="Momentum Elite">ðŸš€</span>}
                {prime && <span className="text-green-500 text-xs">â­</span>}
                {flags.sq30_release && <span className="text-cyan-400 text-xs">âš¡</span>}
                {flags.sq30_on && <span className="text-yellow-400 text-xs">ðŸ§¨</span>}
              </div>
              <div className="flex items-center gap-1.5">
                {ticker.price && (
                  <span className="text-xs font-semibold text-white">
                    ${Number(ticker.price).toFixed(2)}
                  </span>
                )}
                <div className={`px-1.5 py-0.5 rounded font-bold text-[10px] ${dir.bg} ${dir.color}`}>
                  {dir.text}
                </div>
              </div>
            </div>

            {/* Why and Action - Compact */}
            <div className="mb-1.5">
              <div className="text-[9px] text-[#93a4d6] mb-0.5">Why: <span className="text-white font-semibold text-[10px]">{why}</span></div>
              {(() => {
                const actionInfo = getActionDescription(ticker);
                return (
                  <div className={`text-[9px] ${actionInfo.color} font-semibold`}>
                    {actionInfo.action}
                  </div>
                );
              })()}
            </div>

            {/* Price, SL, TP - Compact inline */}
            <div className="grid grid-cols-3 gap-1.5 mb-1.5 text-[9px]">
              {ticker.price && (
                <div>
                  <div className="text-[8px] text-[#93a4d6]">Price</div>
                  <div className="font-semibold text-white">${Number(ticker.price).toFixed(2)}</div>
                </div>
              )}
              <div>
                <div className="text-[8px] text-[#93a4d6]">SL</div>
                <div className="font-semibold text-red-400">
                  {ticker.sl ? `$${Number(ticker.sl).toFixed(2)}` : "â€”"}
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6]">TP</div>
                <div className="font-semibold text-green-400">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "â€”"}
                </div>
              </div>
            </div>

            {/* Trigger Info - Compact */}
            {ticker.trigger_price && (
              <div className="mb-1.5 text-[9px]">
                <span className="text-[#93a4d6]">Trigger: </span>
                <span className="text-white font-semibold">${Number(ticker.trigger_price).toFixed(2)}</span>
                {ticker.trigger_ts && (
                  <>
                    <span className="text-[#93a4d6] ml-2">@ </span>
                    <span className="text-white text-[8px]">{triggerDT.date} {triggerDT.time}</span>
                  </>
                )}
              </div>
            )}

            {/* Phase and Completion - Compact */}
            <div className="grid grid-cols-2 gap-1.5 mb-1.5">
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Phase</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full transition-all"
                    style={{
                      width: `${phase * 100}%`,
                      backgroundColor: phaseColor,
                    }}
                  />
                </div>
                <div className="text-[9px] mt-0.5" style={{ color: phaseColor }}>
                  {Math.round(phase * 100)}%
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Complete</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full bg-blue-500 transition-all"
                    style={{ width: `${comp * 100}%` }}
                  />
                </div>
                <div className="text-[9px] mt-0.5 text-blue-400">
                  {Math.round(comp * 100)}%
                </div>
              </div>
            </div>

            {/* TP Levels - Compact */}
            {tpLevels.length > 1 && (
              <div className="mb-1.5">
                <div className="flex flex-wrap gap-1">
                  {tpLevels.slice(0, 2).map((tp, idx) => (
                    <span
                      key={idx}
                      className="px-1 py-0.5 rounded bg-green-500/20 text-green-400 text-[8px] font-mono"
                    >
                      TP{idx + 1}: ${Number(tp).toFixed(2)}
                    </span>
                  ))}
                  {tpLevels.length > 2 && (
                    <span className="px-1 py-0.5 rounded bg-[#26325f] text-[#93a4d6] text-[8px]">
                      +{tpLevels.length - 2}
                    </span>
                  )}
                </div>
              </div>
            )}

            {/* Additional Info - Compact */}
            <div className="flex items-center justify-between text-[9px] pt-1 border-t border-[#26325f]/50">
              <div className="flex gap-1">
                <span className="px-1 py-0.5 rounded bg-[#26325f]">
                  R{ticker.rank || "â€”"}
                </span>
                {ticker.rr && (
                  <span className="px-1 py-0.5 rounded bg-[#26325f]">
                    RR{Number(ticker.rr).toFixed(1)}
                  </span>
                )}
              </div>
              {ent.corridor && (
                <span className={`px-1 py-0.5 rounded text-[8px] font-semibold ${dir.bg} ${dir.color}`}>
                  {ent.side}
                </span>
              )}
            </div>
          </div>
        );
      }

      // Generate plain English action description
      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const momentumPct = ticker.momentum_pct || {};
        
        const isAligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback = state === "HTF_BULL_LTF_PULLBACK" || state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        
        // High completion = near target, consider exit/trim
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(0)}% completion, indicating the move is near its target. ${momentumElite ? 'Despite Momentum Elite status, ' : ''}Consider taking profits or trimming 50-75% of position to lock in gains while allowing runners to continue. Monitor for signs of reversal or continuation beyond TP levels.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20"
          };
        }
        
        // High phase = late in cycle, be cautious
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(0)}% indicates late-cycle conditions. ${momentumElite ? 'While Momentum Elite suggests continued strength, ' : ''}Market is approaching exhaustion zone. Wait for pullback to better entry or trim existing positions by 30-50% to reduce risk. Look for phase reset or continuation signals before adding size.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20"
          };
        }
        
        // Momentum Elite + Prime setup = strongest signal
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          const momentumStr = momentumPct.month != null ? ` with ${Number(momentumPct.month).toFixed(0)}% monthly momentum` : '';
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock${momentumStr} showing Prime setup with exceptional alignment. Both HTF and LTF are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(2)}:1). This represents a high-probability setup with strong fundamentals backing the technical signal. Consider entering with full position size, using TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // Momentum Elite + Squeeze release = strong momentum signal
        if (momentumElite && sqRelease && inCorridor && isAligned) {
          const momentumStr = momentumPct.week != null ? ` (${Number(momentumPct.week).toFixed(0)}% weekly)` : '';
          return {
            action: "Initiate Position - Momentum Breakout",
            description: `Momentum Elite stock${momentumStr} experiencing squeeze release with timeframe alignment. This indicates pent-up energy being released in the direction of the trend. The combination of Momentum Elite fundamentals and technical squeeze release creates a high-probability momentum continuation setup. Enter on pullback to corridor or on break of squeeze high/low, targeting TP levels.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // Prime setup with good conditions = initiate
        if (isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - Prime Setup",
            description: `Prime setup detected with strong technical alignment. Both timeframes are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(2)}:1). ${momentumElite ? 'Momentum Elite status adds fundamental strength to this technical setup. ' : ''}Early phase (${(phase * 100).toFixed(0)}%) with low completion (${(comp * 100).toFixed(0)}%) suggests room to run. Consider entering position, using SL for risk management and TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // Momentum Elite + In corridor = quality momentum play
        if (momentumElite && inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Momentum Elite Setup",
            description: `Momentum Elite stock in favorable technical setup. Price is in entry corridor with both timeframes aligned, early phase (${(phase * 100).toFixed(0)}%), and low completion (${(comp * 100).toFixed(0)}%) indicating room for continuation. ${sqRelease ? 'Squeeze release adds momentum confirmation. ' : sqOn ? 'Squeeze building suggests potential breakout. ' : ''}The combination of strong fundamentals (Momentum Elite) and favorable technicals creates a quality setup. Enter on confirmation or pullback, targeting TP levels.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20"
          };
        }
        
        // Squeeze release in corridor = strong signal
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. This indicates pent-up energy being released in the direction of the trend. ${momentumElite ? 'Momentum Elite status adds fundamental backing to this technical signal. ' : ''}Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(comp * 100).toFixed(0)}%) suggest continuation potential. Enter on pullback or break, using SL for protection and TP levels as targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // In corridor and aligned = good setup
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(comp * 100).toFixed(0)}%) suggest room to run. ${momentumElite ? 'Momentum Elite status adds quality to this setup. ' : ''}${sqOn ? 'Squeeze building suggests potential momentum. ' : ''}Rank is ${rank >= 70 ? 'strong' : 'moderate'} (${rank}) with RR of ${rr.toFixed(2)}:1. Monitor for entry confirmation or wait for squeeze release signal before initiating position.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20"
          };
        }
        
        // Pullback setup = wait for confirmation
        if (isPullback && !inCorridor) {
          return {
            action: "Wait for Entry - Pullback Setup",
            description: `Pullback detected (${state}) but price not yet in entry corridor. ${momentumElite ? 'Momentum Elite status suggests this pullback may be shallow and could present a quality entry. ' : ''}Wait for price to enter corridor (Q1â†’Q2 for LONG, Q4â†’Q3 for SHORT) before considering entry. ${sqOn ? 'Squeeze building suggests potential momentum when released. ' : ''}Monitor for corridor entry and confirmation signals before initiating position.`,
            color: "text-cyan-400",
            bg: "bg-cyan-500/20"
          };
        }
        
        // Squeeze on but not released = building pressure
        if (sqOn && !sqRelease) {
          return {
            action: "Monitor Closely - Squeeze Building",
            description: `Squeeze building but not yet released, indicating pressure is accumulating. ${momentumElite ? 'Momentum Elite status suggests when released, the move could be significant. ' : ''}${inCorridor ? 'Price is in entry corridor, making this a high-probability setup when squeeze releases. ' : 'Wait for price to enter corridor and squeeze to release before entering. '}Monitor closely for squeeze release signal, which typically provides strong directional momentum.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20"
          };
        }
        
        // Default: wait
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. ${momentumElite ? 'Momentum Elite status is positive, but ' : ''}Technical conditions need improvement. ${!inCorridor ? 'Price needs to enter entry corridor. ' : ''}${!isAligned ? 'Timeframes need better alignment. ' : ''}${comp > 0.5 ? `Completion is high (${(comp * 100).toFixed(0)}%), reducing upside potential. ` : ''}Wait for better conditions, confirmation signals, or entry corridor alignment before considering position.`,
          color: "text-[#93a4d6]",
          bg: "bg-[#26325f]"
        };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Activity Feed Component
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function ActivityFeed({ onTickerClick, tickerData }) {
        const [events, setEvents] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const feedRef = React.useRef(null);
        
        // Helper to get latest ticker data and merge with event
        // IMPORTANT: Always use latest RR from tickerData to match Bubble Chart (which recomputes RR)
        // This ensures Activity Feed RR matches Bubble Chart RR (both use recomputed values from /timed/all)
        const getEventWithTickerData = useCallback((event) => {
          const latestData = tickerData?.[event.ticker] || {};
          // Merge event data with latest ticker data, preferring latest data for RR (matches Bubble Chart computation)
          // Use event data for historical snapshots (price, sl, tp at event time) but latest RR for consistency
          return {
            ...event,
            price: event.price || latestData.price,
            sl: event.sl !== undefined ? event.sl : latestData.sl,
            tp: event.tp !== undefined ? event.tp : latestData.tp,
            tp_levels: event.tp_levels || latestData.tp_levels,
            // Always use latest RR to match Bubble Chart (which uses recomputed RR from /timed/all)
            // This ensures consistency since worker recomputes RR using fused SL levels
            rr: latestData.rr !== undefined ? latestData.rr : event.rr,
            phase_pct: event.phase_pct !== undefined ? event.phase_pct : latestData.phase_pct,
            completion: event.completion !== undefined ? event.completion : latestData.completion,
            // Include momentum_pct from latest data if available
            momentum_pct: latestData.momentum_pct || event.momentum_pct,
          };
        }, [tickerData]);

        const fetchActivity = React.useCallback(async () => {
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            
            const res = await fetch(
              'https://timed-trading-ingest.shashant.workers.dev/timed/activity?limit=50',
              { signal: controller.signal }
            );
            clearTimeout(timeoutId);
            
            const data = await res.json();
            
            if (res.ok && data.ok && Array.isArray(data.events)) {
              setEvents(data.events);
              setError(null); // Clear any previous errors
            } else {
              // Log error for debugging
              console.warn('Activity feed response:', {
                status: res.status,
                ok: res.ok,
                dataOk: data.ok,
                error: data.error,
                eventsCount: data.events?.length || 0
              });
              
              // Handle rate limit error
              if (res.status === 429) {
                setError('Rate limit exceeded. Please wait a moment and refresh.');
              } else if (data.error) {
                setError(data.error);
              } else {
                setError(null);
              }
              
              // Still set events if it's an empty array (no error, just no data)
              if (res.ok && Array.isArray(data.events)) {
                setEvents(data.events);
              }
            }
          } catch (err) {
            if (err.name !== 'AbortError') {
              console.error('Activity feed fetch error:', err);
              setError('Failed to load activity feed');
            }
          } finally {
            setLoading(false);
          }
        }, []);

        // Initial fetch and periodic refresh
        React.useEffect(() => {
          fetchActivity();
          const interval = setInterval(fetchActivity, 5 * 60 * 1000); // Refresh every 5 minutes to align with data updates
          return () => clearInterval(interval);
        }, [fetchActivity]);

        // Auto-scroll to top when new events arrive
        React.useEffect(() => {
          if (feedRef.current && events.length > 0) {
            feedRef.current.scrollTop = 0;
          }
        }, [events.length]);

        const formatTime = (ts) => {
          const date = new Date(ts);
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / 60000);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);

          if (diffMins < 1) return 'just now';
          if (diffMins < 60) return `${diffMins}m ago`;
          if (diffHours < 24) return `${diffHours}h ago`;
          if (diffDays < 7) return `${diffDays}d ago`;
          return date.toLocaleDateString();
        };

        const getEventIcon = (type) => {
          switch (type) {
            case 'corridor_entry': return 'ðŸšª';
            case 'squeeze_start': return 'âš¡';
            case 'squeeze_release': return 'ðŸ’¥';
            case 'state_aligned': return 'ðŸŽ¯';
            case 'momentum_elite': return 'ðŸš€';
            default: return 'ðŸ“Š';
          }
        };

        const getEventColor = (type) => {
          switch (type) {
            case 'corridor_entry': return 'text-blue-400';
            case 'squeeze_start': return 'text-yellow-400';
            case 'squeeze_release': return 'text-green-400';
            case 'state_aligned': return 'text-purple-400';
            case 'momentum_elite': return 'text-pink-400';
            default: return 'text-gray-400';
          }
        };

        const getEventLabel = (event) => {
          switch (event.type) {
            case 'corridor_entry':
              return `${event.ticker} entered ${event.side || 'corridor'}`;
            case 'squeeze_start':
              return `${event.ticker} squeeze started`;
            case 'squeeze_release':
              return `${event.ticker} squeeze released${event.side ? ` (${event.side})` : ''}`;
            case 'state_aligned':
              return `${event.ticker} aligned ${event.side || ''}`;
            case 'momentum_elite':
              return `${event.ticker} Momentum Elite`;
            default:
              return `${event.ticker} event`;
          }
        };

        return (
          <div className="w-80 bg-[#0f1630] border border-[#26325f] rounded-xl p-4 flex flex-col">
            <div className="flex items-center justify-between mb-3 pb-2 border-b border-[#26325f]">
              <h3 className="text-lg font-semibold text-white">Activity Feed</h3>
              <button
                onClick={fetchActivity}
                className="text-xs text-[#93a4d6] hover:text-white transition-colors"
                title="Refresh"
              >
                â†»
              </button>
            </div>
            
            <div
              ref={feedRef}
              className="flex-1 overflow-y-auto space-y-2 pr-2"
              style={{ maxHeight: '760px' }}
            >
              {loading && events.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  <div className="loading-spinner mx-auto mb-2"></div>
                  Loading events...
                </div>
              ) : error ? (
                <div className="text-center text-yellow-400 py-8 px-2">
                  <div className="text-sm mb-2">{error}</div>
                  <button
                    onClick={fetchActivity}
                    className="text-xs text-[#93a4d6] hover:text-white underline"
                  >
                    Retry
                  </button>
                </div>
              ) : events.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  No recent activity
                </div>
              ) : (
                events.map((event) => {
                  const eventData = getEventWithTickerData(event);
                  // Calculate Max TP from tp_levels array
                  let maxTP = eventData.tp;
                  if (eventData.tp_levels && Array.isArray(eventData.tp_levels) && eventData.tp_levels.length > 0) {
                    const tpPrices = eventData.tp_levels
                      .map(tpItem => {
                        if (typeof tpItem === 'object' && tpItem !== null && tpItem.price != null) {
                          return Number(tpItem.price);
                        }
                        return typeof tpItem === 'number' ? tpItem : Number(tpItem);
                      })
                      .filter(p => Number.isFinite(p));
                    if (tpPrices.length > 0) {
                      maxTP = Math.max(...tpPrices);
                    }
                  }
                  
                  return (
                    <div
                      key={event.id || `${event.ticker}-${event.ts}`}
                      onClick={() => onTickerClick && onTickerClick(event.ticker)}
                      className="bg-[#121a33] border border-[#26325f] rounded p-2 text-xs hover:border-[#3a4a7a] hover:bg-[#1a2440] transition-colors cursor-pointer"
                    >
                      <div className="flex items-start justify-between gap-2 mb-1.5">
                        <div className="flex items-center gap-1.5 flex-1 min-w-0">
                          <span className="text-base">{getEventIcon(event.type)}</span>
                          <span className={`font-semibold ${getEventColor(event.type)} truncate`}>
                            {getEventLabel(event)}
                          </span>
                        </div>
                        <span className="text-[#6b7a9f] text-[10px] whitespace-nowrap">
                          {formatTime(event.ts)}
                        </span>
                      </div>
                      
                      {/* Standardized Fields - Always Show */}
                      <div className="space-y-1.5 border-t border-[#26325f]/50 pt-1.5 mt-1.5">
                        {/* Price Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">Price:</span>
                          <span className="text-white font-semibold text-[10px]">
                            {eventData.price ? `$${Number(eventData.price).toFixed(2)}` : 'â€”'}
                          </span>
                        </div>
                        
                        {/* SL Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">SL:</span>
                          <span className="text-red-400 font-mono text-[10px]">
                            {eventData.sl != null ? `$${Number(eventData.sl).toFixed(2)}` : 'â€”'}
                          </span>
                        </div>
                        
                        {/* Max TP Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">Max TP:</span>
                          <span className="text-green-400 font-mono text-[10px]">
                            {maxTP != null ? `$${Number(maxTP).toFixed(2)}` : 'â€”'}
                          </span>
                        </div>
                        
                        {/* RR Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">RR:</span>
                          <span className="text-blue-400 font-mono text-[10px]">
                            {eventData.rr != null ? Number(eventData.rr).toFixed(2) : 'â€”'}
                          </span>
                        </div>
                        
                        {/* Phase Complete Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">Phase:</span>
                          <div className="flex items-center gap-1.5">
                            <div className="w-16 h-1 bg-[#26325f] rounded-full overflow-hidden">
                              <div
                                className="h-full rounded-full transition-all"
                                style={{
                                  width: `${(Number(eventData.phase_pct) || 0) * 100}%`,
                                  backgroundColor: (() => {
                                    const phase = Number(eventData.phase_pct) || 0;
                                    if (phase < 0.3) return '#2ecc71';
                                    if (phase < 0.6) return '#f39c12';
                                    return '#e74c3c';
                                  })(),
                                }}
                              />
                            </div>
                            <span className="text-white font-mono text-[10px] min-w-[2.5rem]">
                              {eventData.phase_pct != null ? `${Math.round(Number(eventData.phase_pct) * 100)}%` : 'â€”'}
                            </span>
                          </div>
                        </div>
                      </div>
                      
                      {/* Additional Info - Compact */}
                      {(event.rank || event.state || event.trigger_dir) && (
                        <div className="flex items-center gap-2 text-[#6b7a9f] text-[10px] mt-1.5 pt-1.5 border-t border-[#26325f]/30">
                          {event.rank && <span>Rank {event.rank}</span>}
                          {event.state && (
                            <span className="truncate" title={event.state}>
                              {event.state.split('_').pop()}
                            </span>
                          )}
                          {event.trigger_dir && (
                            <span>Dir: {event.trigger_dir}</span>
                          )}
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      function QuickFilters({ filters, onFilterChange }) {
        const presets = [
          {
            label: "Prime Only",
            filter: { minRank: 75, minRR: 1.5, maxCompletion: 0.4 },
            icon: "â­",
          },
          { 
            label: "In Corridor", 
            filter: { inCorridor: true },
            icon: "ðŸŽ¯",
          },
          { 
            label: "Squeeze Release", 
            filter: { squeezeRelease: true },
            icon: "âš¡",
          },
          {
            label: "Momentum Elite",
            filter: { momentumElite: true },
            icon: "ðŸš€",
          },
          {
            label: "Q1: Bull Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "ðŸ“ˆ",
          },
          {
            label: "Q2: Bull Momentum",
            filter: { quadrants: ["HTF_BULL_LTF_BULL"] },
            icon: "ðŸš€",
          },
          {
            label: "Q3: Bear Momentum",
            filter: { quadrants: ["HTF_BEAR_LTF_BEAR"] },
            icon: "ðŸ“‰",
          },
          {
            label: "Q4: Bear Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "ðŸ”»",
          },
          // List filters (Top 40, Top Long Setup, Top Short Setup)
          {
            label: "Top 40",
            filter: { top40: true },
            icon: "ðŸ†",
          },
          {
            label: "Top Long Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "ðŸ“ˆ",
          },
          {
            label: "Top Short Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "ðŸ“‰",
          },
          // Group filters
          {
            label: "Upticks",
            filter: { group: "UPTICKS" },
            icon: "ðŸ“Š",
          },
          {
            label: "Super Granny",
            filter: { group: "SuperGranny" },
            icon: "â­",
          },
          {
            label: "GRNI",
            filter: { group: "GRNI" },
            icon: "ðŸ”µ",
          },
          {
            label: "GRNJ",
            filter: { group: "GRNJ" },
            icon: "ðŸŸ¢",
          },
          {
            label: "GRNY",
            filter: { group: "GRNY" },
            icon: "ðŸŸ¡",
          },
          {
            label: "Social",
            filter: { group: "Social" },
            icon: "ðŸ’¬",
          },
          {
            label: "SP Sectors",
            filter: { group: "SP_Sectors" },
            icon: "ðŸ“ˆ",
          },
        ];

        const isActive = (preset) => {
          if (preset.label === "Prime Only") {
            return filters.minRank === 75 && filters.minRR === 1.5 && filters.maxCompletion === 0.4;
          }
          if (preset.label === "In Corridor") {
            return filters.inCorridor === true;
          }
          if (preset.label === "Squeeze Release") {
            return filters.squeezeRelease === true;
          }
          if (preset.label === "ðŸš€ Momentum Elite") {
            return filters.momentumElite === true;
          }
          // Check for "Top Long Setup" and "Top Short Setup" specifically
          if (preset.label === "Top Long Setup") {
            const currentQuadrants = filters.quadrants || [];
            return currentQuadrants.length === 1 && currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK";
          }
          if (preset.label === "Top Short Setup") {
            const currentQuadrants = filters.quadrants || [];
            return currentQuadrants.length === 1 && currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK";
          }
          // Check if quadrant filter matches (for Q1, Q2, Q3, Q4 labels)
          if (preset.label.startsWith("Q")) {
            const presetQuadrants = preset.filter.quadrants || [];
            const currentQuadrants = filters.quadrants || [];
            // Check if preset quadrants are the only ones selected
            if (presetQuadrants.length === 1 && currentQuadrants.length === 1) {
              return presetQuadrants[0] === currentQuadrants[0];
            }
            // Check if preset quadrants are subset of current (and no others)
            if (presetQuadrants.length === 1 && currentQuadrants.includes(presetQuadrants[0])) {
              return currentQuadrants.length === 1;
            }
          }
          // Check if group filter matches
          if (preset.filter.group) {
            return filters.group === preset.filter.group;
          }
          // Check if Top 40 filter matches
          if (preset.filter.top40) {
            return filters.top40 === true;
          }
          return false;
        };

        const handlePresetClick = (preset) => {
          const active = isActive(preset);
          if (active) {
            // Toggle off - remove this specific filter, keep others
            const newFilters = { ...filters };
            
            if (preset.label === "Prime Only") {
              // Reset Prime Only filters to defaults
              newFilters.minRank = 0;
              newFilters.minRR = 0;
              newFilters.maxCompletion = 1.01;
            } else if (preset.label === "In Corridor") {
              delete newFilters.inCorridor;
            } else if (preset.label === "Squeeze Release") {
              delete newFilters.squeezeRelease;
            } else if (preset.label === "ðŸš€ Momentum Elite") {
              // Explicitly delete to ensure it's removed
              delete newFilters.momentumElite;
              // Set to undefined so handleFilterChange properly removes it
              newFilters.momentumElite = undefined;
            } else if (preset.label === "Top Long Setup") {
              // Restore all quadrants if Top Long Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (currentQuadrants.length === 1 && currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK") {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label === "Top Short Setup") {
              // Restore all quadrants if Top Short Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (currentQuadrants.length === 1 && currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK") {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label.startsWith("Q")) {
              // For Q1-Q4, restore all quadrants if this was the only one
              const presetQuadrants = preset.filter.quadrants || [];
              const currentQuadrants = filters.quadrants || [];
              if (presetQuadrants.length === 1 && currentQuadrants.length === 1 && currentQuadrants[0] === presetQuadrants[0]) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.filter.group) {
              // Reset group filter
              newFilters.group = "ALL";
            } else if (preset.filter.top40) {
              delete newFilters.top40;
            }
            
            onFilterChange(newFilters);
          } else {
            // Toggle on - apply filter, merge with existing filters
            const mergedFilters = { ...filters, ...preset.filter };
            
            // Special handling for quadrant filters - replace, don't merge arrays
            if (preset.filter.quadrants) {
              mergedFilters.quadrants = preset.filter.quadrants;
            }
            
            onFilterChange(mergedFilters);
          }
        };

        const resetAllFilters = () => {
          // Explicitly reset all filters including boolean flags
          // Use onFilterChange to ensure proper state updates
          const defaultFilters = {
            search: "",
            quadrants: [
              "HTF_BULL_LTF_PULLBACK",
              "HTF_BULL_LTF_BULL",
              "HTF_BEAR_LTF_BEAR",
              "HTF_BEAR_LTF_PULLBACK",
            ],
            minRank: 0,
            minRR: 0,
            maxCompletion: 1.01,
            group: "ALL",
          };
          // Explicitly clear all boolean filters by setting to undefined
          // handleFilterChange will delete undefined values
          onFilterChange({
            ...defaultFilters,
            inCorridor: undefined,
            squeezeRelease: undefined,
            momentumElite: undefined,
            top40: undefined,
          });
        };

        // Build group options
        const groupKeys = Object.keys(GROUPS).filter(Boolean);
        const ordered = [];
        for (const k of GROUP_ORDER) if (groupKeys.includes(k)) ordered.push(k);
        const remaining = groupKeys.filter((k) => !ordered.includes(k)).sort();
        ordered.push(...remaining);

        return (
          <div className="space-y-3 mb-4">
            <div className="flex gap-2 flex-wrap items-center">
              {presets.map((preset, i) => {
                const active = isActive(preset);
                return (
                  <button
                    key={i}
                    className={`px-4 py-2 rounded-lg border text-sm font-semibold transition-all ${
                      active
                        ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                        : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
                    }`}
                    onClick={() => handlePresetClick(preset)}
                  >
                    {preset.icon} {preset.label}
                  </button>
                );
              })}
              {/* Reset Filters Button */}
              <button
                onClick={resetAllFilters}
                className="px-4 py-2 rounded-lg border border-red-500/50 bg-red-500/10 hover:bg-red-500/20 text-red-400 text-sm font-semibold transition-all"
                title="Reset all filters to defaults"
              >
                ðŸ”„ Reset Filters
              </button>
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm text-[#93a4d6] font-semibold">Group:</label>
              <select
                value={filters.group || "ALL"}
                onChange={(e) => onFilterChange({ group: e.target.value })}
                className="px-3 py-2 rounded-lg border border-[#26325f] bg-[#0f1630] text-[#93a4d6] text-sm hover:bg-[#1a2550] focus:outline-none focus:border-[#3a4aa0]"
              >
                <option value="ALL">All Tickers</option>
                <option value="ANY">Any Group</option>
                <option value="UNGROUPED">Ungrouped</option>
                <option value="__DIVIDER__" disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                {ordered.map((key) => (
                  <option key={key} value={key}>
                    {GROUP_LABELS[key] || key}
                  </option>
                ))}
              </select>
            </div>
          </div>
        );
      }

      // Helper: Get quadrant from state
      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK") return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL") return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR") return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK") return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      // Pattern detection
      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map(p => p.state).filter(Boolean);
        const safeFlags = flags || {};
        
        // Pattern 1: Clean Q1â†’Q2 or Q4â†’Q3 transition (ideal entry)
        for (let i = 1; i < states.length; i++) {
          if (states[i-1] === "HTF_BULL_LTF_PULLBACK" && states[i] === "HTF_BULL_LTF_BULL") {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1â†’Q2 transition (Bull Entry)",
              quadrant: "Q1â†’Q2",
              timestamp: trail[i].ts,
              confidence: "HIGH"
            });
          }
          if (states[i-1] === "HTF_BEAR_LTF_PULLBACK" && states[i] === "HTF_BEAR_LTF_BEAR") {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4â†’Q3 transition (Bear Entry)",
              quadrant: "Q4â†’Q3",
              timestamp: trail[i].ts,
              confidence: "HIGH"
            });
          }
        }

        // Pattern 2: Momentum Elite + Setup quadrant
        const currentState = states[states.length - 1];
        if ((currentState === "HTF_BULL_LTF_PULLBACK" || currentState === "HTF_BEAR_LTF_PULLBACK") && safeFlags.momentum_elite) {
          patterns.push({
            type: "ELITE_SETUP",
            description: "Momentum Elite in Setup Quadrant",
            quadrant: getQuadrantFromState(currentState)?.name,
            confidence: "HIGH"
          });
        }

        // Pattern 3: Squeeze release in setup quadrant
        const lastPoint = trail[trail.length - 1];
        if (lastPoint && lastPoint.flags && lastPoint.flags.sq30_release) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "SQUEEZE_SETUP",
              description: "Squeeze Release in Setup Quadrant",
              quadrant: q.name,
              confidence: "HIGH"
            });
          }
        }

        // Pattern 4: Multiple quadrant visits (chop vs clean)
        const uniqueQuads = new Set(states.map(s => getQuadrantFromState(s)?.q).filter(Boolean));
        if (uniqueQuads.size > 2 && states.length > 5) {
          patterns.push({
            type: "CHOPPY",
            description: "Multiple quadrant visits (choppy action)",
            confidence: "MEDIUM"
          });
        } else if (uniqueQuads.size === 1 && states.length >= 3) {
          patterns.push({
            type: "STABLE",
            description: "Stable quadrant (consistent state)",
            quadrant: getQuadrantFromState(states[0])?.name,
            confidence: "MEDIUM"
          });
        }

        // Pattern 5: Phase zone change in setup
        if (lastPoint && lastPoint.flags && lastPoint.flags.phase_zone_change) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "PHASE_SHIFT",
              description: "Phase zone change in Setup",
              quadrant: q.name,
              confidence: "MEDIUM"
            });
          }
        }

        return patterns;
      }

      // Separate component for Quadrant Progression to properly use hooks
      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = React.useState([]);
        const [loading, setLoading] = React.useState(false); // Start as false
        const [hasLoaded, setHasLoaded] = React.useState(false);
        
        React.useEffect(() => {
          // Defer trail loading to not block initial render
          // Only load if component is mounted and ticker is valid
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const controller = new AbortController();
                const timeoutId2 = setTimeout(() => controller.abort(), 3000); // 3s timeout (reduced from 5s)
                
                const response = await fetch(
                  `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(ticker.ticker)}`,
                  { signal: controller.signal }
                );
                
                clearTimeout(timeoutId2);
                
                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                if (data.ok && Array.isArray(data.trail)) {
                  setTrail(data.trail);
                } else {
                  setTrail([]); // Set empty if no trail data
                }
              } catch (e) {
                if (e.name !== 'AbortError') {
                  console.error("Failed to load trail:", e);
                }
                // Set empty trail on error to prevent infinite retries
                setTrail([]);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300); // Slightly longer delay to ensure overlay is rendered first
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);

        const patterns = detectPatterns(trail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = trail.map(p => getQuadrantFromState(p.state)).filter(Boolean);

        return (
          <div className="mb-4 p-4 bg-[#0f1630] rounded-lg border border-[#26325f]">
            <div className="text-sm font-bold mb-3 text-[#93a4d6]">Quadrant Progression</div>
            
            {/* Quadrant Map */}
            <div className="grid grid-cols-2 gap-2 mb-4">
              {/* Q1 - Bull Setup */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 1 
                  ? "border-blue-400 bg-blue-500/20" 
                  : quadHistory.some(q => q && q.q === 1)
                  ? "border-blue-500/50 bg-blue-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-blue-400">Q1: Bull Setup</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BULL_LTF_PULLBACK</div>
              </div>
              
              {/* Q2 - Bull Momentum */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 2 
                  ? "border-green-400 bg-green-500/20" 
                  : quadHistory.some(q => q && q.q === 2)
                  ? "border-green-500/50 bg-green-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-green-400">Q2: Bull Momentum</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BULL_LTF_BULL</div>
              </div>
              
              {/* Q4 - Bear Setup */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 4 
                  ? "border-orange-400 bg-orange-500/20" 
                  : quadHistory.some(q => q && q.q === 4)
                  ? "border-orange-500/50 bg-orange-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-orange-400">Q4: Bear Setup</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BEAR_LTF_PULLBACK</div>
              </div>
              
              {/* Q3 - Bear Momentum */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 3 
                  ? "border-red-400 bg-red-500/20" 
                  : quadHistory.some(q => q && q.q === 3)
                  ? "border-red-500/50 bg-red-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-red-400">Q3: Bear Momentum</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BEAR_LTF_BEAR</div>
              </div>
            </div>

            {/* Path Visualization */}
            {trail.length > 0 && (
              <div className="mb-4">
                <div className="text-xs font-semibold text-[#93a4d6] mb-2">Path ({trail.length} points)</div>
                <div className="flex items-center gap-1 flex-wrap">
                  {quadHistory.map((q, idx) => {
                    if (!q) return null;
                    const isLast = idx === quadHistory.length - 1;
                    const colorClasses = {
                      blue: isLast ? "bg-blue-500/30 border-2 border-blue-400 text-blue-300" : "bg-blue-500/10 border border-blue-500/50 text-blue-400",
                      green: isLast ? "bg-green-500/30 border-2 border-green-400 text-green-300" : "bg-green-500/10 border border-green-500/50 text-green-400",
                      red: isLast ? "bg-red-500/30 border-2 border-red-400 text-red-300" : "bg-red-500/10 border border-red-500/50 text-red-400",
                      orange: isLast ? "bg-orange-500/30 border-2 border-orange-400 text-orange-300" : "bg-orange-500/10 border border-orange-500/50 text-orange-400"
                    };
                    return (
                      <React.Fragment key={idx}>
                        <div className={`px-2 py-1 rounded text-[10px] font-bold ${colorClasses[q.color] || colorClasses.blue}`}>
                          {q.name}
                        </div>
                        {idx < quadHistory.length - 1 && (
                          <span className="text-[#93a4d6] text-xs">â†’</span>
                        )}
                      </React.Fragment>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Pattern Detection */}
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs font-bold text-yellow-400 mb-2">ðŸŽ¯ Detected Patterns</div>
                <div className="space-y-2">
                  {patterns.map((pattern, idx) => (
                    <div 
                      key={idx}
                      className={`p-2 rounded border ${
                        pattern.confidence === "HIGH"
                          ? "bg-yellow-500/20 border-yellow-400/50"
                          : "bg-blue-500/10 border-blue-500/30"
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="text-xs font-bold text-white">{pattern.description}</div>
                          {pattern.quadrant && (
                            <div className="text-[10px] text-[#93a4d6] mt-0.5">{pattern.quadrant}</div>
                          )}
                        </div>
                        <span className={`text-[10px] px-1.5 py-0.5 rounded ${
                          pattern.confidence === "HIGH"
                            ? "bg-yellow-500/30 text-yellow-300"
                            : "bg-blue-500/30 text-blue-300"
                        }`}>
                          {pattern.confidence}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {loading && (
              <div className="text-xs text-[#93a4d6] text-center py-2">Loading history...</div>
            )}
          </div>
        );
      }

      function TickerDetails({ ticker, onClose, allTickers = [], allLoadedData = null }) {
        if (!ticker) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);
        
        // Convert allLoadedData (object) to array if provided, otherwise use allTickers
        // allLoadedData contains ALL loaded tickers (unfiltered), while allTickers is filtered
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === 'object') {
            if (Array.isArray(allLoadedData)) {
              return allLoadedData;
            } else {
              // Convert object to array: { "GOOGL": {...}, "MSFT": {...} } -> [...]
              return Object.values(allLoadedData).filter(t => t && typeof t === 'object' && t.ticker);
            }
          }
          // Fallback to allTickers if allLoadedData not provided
          return allTickers || [];
        })();

        return (
          <div className="w-full h-full">
            {/* Detail Card - slides in from right, positioned in hero layout */}
            <div 
              className="bg-[#121a33] border-2 border-[#26325f] rounded-xl p-6 w-full h-full overflow-y-auto slide-in-right shadow-2xl"
              onClick={(e) => e.stopPropagation()}
              style={{ minHeight: '900px' }}
            >
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold">{ticker.ticker}</h3>
              <button
                onClick={onClose}
                className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
              >
                âœ•
              </button>
            </div>

            {flags.momentum_elite && (
              <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                <div className="text-center font-bold text-purple-300 mb-2">
                  ðŸš€ MOMENTUM ELITE ðŸš€
                </div>
                <div className="text-xs text-purple-200/80 font-normal mb-2">
                  High-quality momentum stock with strong fundamentals
                </div>
                {ticker.momentum_pct && (
                  <div className="mt-2 pt-2 border-t border-purple-400/30">
                    <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">Momentum Performance:</div>
                    <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                      {ticker.momentum_pct.week != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">1W:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.week) >= 10 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.week).toFixed(1)}%
                          </span>
                        </div>
                      )}
                      {ticker.momentum_pct.month != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">1M:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.month) >= 25 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.month).toFixed(1)}%
                          </span>
                        </div>
                      )}
                      {ticker.momentum_pct.three_months != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">3M:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.three_months) >= 50 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.three_months).toFixed(1)}%
                          </span>
                        </div>
                      )}
                      {ticker.momentum_pct.six_months != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">6M:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.six_months) >= 100 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.six_months).toFixed(1)}%
                          </span>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}

            {prime && (
              <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                â­ PRIME SETUP â­
              </div>
            )}

            {/* Bias/Direction - Prominent */}
            {(() => {
              const dir = getDirection(ticker);
              return (
                <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                  <div className="text-sm text-[#93a4d6] mb-2">Bias / Direction</div>
                  <div className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}>
                    {dir.text === "LONG" ? "ðŸ“ˆ LONG" : dir.text === "SHORT" ? "ðŸ“‰ SHORT" : dir.text}
                  </div>
                </div>
              );
            })()}

            {/* Action Description */}
            <div className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}>
              <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                {actionInfo.action}
              </div>
              <div className="text-sm text-[#93a4d6]">
                {actionInfo.description}
              </div>
            </div>

            {/* Quadrant Progression Visualization */}
            <QuadrantProgression ticker={ticker} flags={flags} />

            {/* Phase indicator */}
            <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm text-[#93a4d6]">Phase</span>
                <span className="text-sm font-semibold" style={{ color: phaseColor }}>
                  {Math.round(phase * 100)}%
                  {ticker.phase_zone && ` (${ticker.phase_zone})`}
                </span>
              </div>
              <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                <div 
                  className="h-full rounded-full transition-all duration-500"
                  style={{ 
                    width: `${phase * 100}%`,
                    backgroundColor: phaseColor,
                    boxShadow: `0 0 8px ${phaseColor}40`
                  }}
                />
              </div>
            </div>

            <div className="space-y-2.5 text-sm">
              {(() => {
                const baseScore = Number(ticker.rank) || 0; // Base Score from worker
                const dynamicRank = computeDynamicRank(ticker);
                // Use allLoadedTickersArray (ALL loaded tickers) for absolute ranking, not filtered list
                const allTickersWithRank = allLoadedTickersArray.map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }));
                const sortedByDynamic = [...allTickersWithRank].sort((a, b) => b.dynamicRank - a.dynamicRank);
                const rankPosition = sortedByDynamic.findIndex(t => {
                  if (!t || !t.ticker) return false;
                  return String(t.ticker).toUpperCase() === String(ticker.ticker).toUpperCase();
                }) + 1;
                const totalTickers = allLoadedTickersArray.length;
                const isInTop40 = rankPosition > 0 && rankPosition <= 40;
                
                return (
                  <>
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Base Score</span>
                      <span className="font-semibold text-blue-400">
                        {baseScore}
                      </span>
                    </div>
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Rank</span>
                      <span className="font-semibold">
                        {rankPosition > 0 ? `#${rankPosition} of ${totalTickers}` : "â€”"}
                      </span>
                    </div>
                    {dynamicRank !== baseScore && (
                      <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                        <span className="text-[#93a4d6]">Dynamic Score</span>
                        <span className="font-semibold text-green-400">
                          {dynamicRank}
                        </span>
                      </div>
                    )}
                    {isInTop40 && (
                      <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                        <span className="text-[#93a4d6]">Top 40 Position</span>
                        <span className="font-semibold text-yellow-400">
                          #{rankPosition} of 40
                        </span>
                      </div>
                    )}
                  </>
                );
              })()}
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">RR</span>
                <span className="font-semibold">{ticker.rr ? Number(ticker.rr).toFixed(2) : "â€”"}</span>
              </div>
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">State</span>
                <span className="font-semibold">{ticker.state || "â€”"}</span>
              </div>
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">Completion</span>
                <span className="font-semibold">{Math.round(completionForSize(ticker) * 100)}%</span>
              </div>
              {ent.corridor && (
                <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                  <span className="text-[#93a4d6]">Corridor</span>
                  <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                    {ent.side}
                  </span>
                </div>
              )}
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">Current Price</span>
                <span className="font-semibold text-lg">
                  {ticker.price ? `$${Number(ticker.price).toFixed(2)}` : "â€”"}
                </span>
              </div>
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">TP (Primary)</span>
                <span className="font-semibold">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "â€”"}
                  {ticker.tp_levels && Array.isArray(ticker.tp_levels) && ticker.tp_levels.length > 0 && (() => {
                    const firstTp = ticker.tp_levels[0];
                    const tpInfo = typeof firstTp === 'object' && firstTp !== null ? firstTp : { price: firstTp };
                    if (tpInfo.label) {
                      const refParts = [];
                      if (tpInfo.timeframe) refParts.push(tpInfo.timeframe);
                      if (tpInfo.multiplier != null && !isNaN(tpInfo.multiplier)) {
                        refParts.push(`${Number(tpInfo.multiplier).toFixed(3)}x ATR`);
                      }
                      const refStr = refParts.length > 0 ? ` (${tpInfo.label} - ${refParts.join(', ')})` : ` (${tpInfo.label})`;
                      return refStr;
                    }
                    return '';
                  })()}
                </span>
              </div>
              {ticker.tp_levels && Array.isArray(ticker.tp_levels) && ticker.tp_levels.length > 1 && (() => {
                // Calculate max TP
                const tpPrices = ticker.tp_levels
                  .map(tpItem => {
                    if (typeof tpItem === 'object' && tpItem !== null && tpItem.price != null) {
                      return Number(tpItem.price);
                    }
                    return typeof tpItem === 'number' ? tpItem : Number(tpItem);
                  })
                  .filter(p => Number.isFinite(p));
                
                if (tpPrices.length > 0) {
                  const maxTP = Math.max(...tpPrices);
                  const primaryTP = Number(ticker.tp) || tpPrices[0];
                  
                  if (maxTP > primaryTP) {
                    return (
                      <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                        <span className="text-[#93a4d6]">TP (Max)</span>
                        <span className="font-semibold text-green-400">
                          ${maxTP.toFixed(2)}
                        </span>
                      </div>
                    );
                  }
                }
                return null;
              })()}
              {ticker.tp_levels && Array.isArray(ticker.tp_levels) && ticker.tp_levels.length > 0 && (
                <div className="py-1 border-b border-[#26325f]/50">
                  <div className="text-[#93a4d6] text-xs mb-2 font-semibold">TP Levels</div>
                  <div className="space-y-1.5 max-h-48 overflow-y-auto">
                    {ticker.tp_levels.map((tp, idx) => {
                      // Handle both old format (just price) and new format (object with metadata)
                      const tpInfo = typeof tp === 'object' && tp !== null 
                        ? tp 
                        : { price: tp, label: `TP${idx + 1}` };
                      const price = Number(tpInfo.price || tp);
                      const label = tpInfo.label || `TP${idx + 1}`;
                      const source = tpInfo.source || '';
                      const type = tpInfo.type || '';
                      const confidence = tpInfo.confidence || null;
                      
                      // Build reference string from all available metadata
                      const referenceParts = [];
                      if (tpInfo.timeframe) referenceParts.push(tpInfo.timeframe);
                      if (tpInfo.multiplier != null && !isNaN(tpInfo.multiplier)) {
                        referenceParts.push(`${Number(tpInfo.multiplier).toFixed(3)}x ATR`);
                      }
                      if (tpInfo.source) referenceParts.push(tpInfo.source);
                      if (tpInfo.type) referenceParts.push(tpInfo.type);
                      const referenceStr = referenceParts.length > 0 ? referenceParts.join(' â€¢ ') : null;
                      
                      return (
                        <div key={idx} className="flex items-start justify-between p-1.5 rounded bg-[#0f1630] border border-[#26325f]/50 hover:border-[#3a4aa0] transition-colors">
                          <div className="flex-1">
                            <div className="flex items-center gap-2 flex-wrap">
                              <span className="text-xs font-semibold text-green-400">{label}</span>
                              <span className="text-xs font-mono text-white font-bold">${price.toFixed(2)}</span>
                              {confidence !== null && (
                                <span className={`text-[10px] px-1 py-0.5 rounded ${
                                  confidence >= 0.8 ? 'bg-green-500/20 text-green-400' :
                                  confidence >= 0.6 ? 'bg-yellow-500/20 text-yellow-400' :
                                  'bg-orange-500/20 text-orange-400'
                                }`}>
                                  {Math.round(confidence * 100)}%
                                </span>
                              )}
                            </div>
                            {referenceStr && (
                              <div className="text-[10px] text-[#93a4d6] mt-1 italic">
                                {referenceStr}
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              <div className="flex justify-between items-center py-1">
                <span className="text-[#93a4d6]">SL</span>
                <span className="font-semibold">{ticker.sl ? Number(ticker.sl).toFixed(2) : "â€”"}</span>
              </div>
            </div>

            {/* Flags */}
            {(flags.sq30_on || flags.sq30_release || flags.phase_dot || flags.phase_zone_change) && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs text-[#93a4d6] mb-2">Flags:</div>
                <div className="flex flex-wrap gap-2">
                  {flags.sq30_on && (
                    <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                      ðŸ§¨ Squeeze ON
                    </span>
                  )}
                  {flags.sq30_release && (
                    <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                      âš¡ Squeeze Release
                    </span>
                  )}
                  {flags.phase_dot && (
                    <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                      Phase Dot
                    </span>
                  )}
                  {flags.phase_zone_change && (
                    <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                      Zone Change
                    </span>
                  )}
                </div>
              </div>
            )}

            <div className="mt-4 pt-4 border-t border-[#26325f]">
              <a
                href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(ticker.ticker)}`}
                target="_blank"
                rel="noopener noreferrer"
                className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
              >
                ðŸ“Š Open in TradingView
              </a>
            </div>
            </div>
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // AI Chat Interface Component
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const AIChatInterface = ({ isOpen, onClose, tickerData }) => {
        const [messages, setMessages] = useState([
          {
            role: 'assistant',
            content: 'ðŸ‘‹ Hi! I\'m your AI trading assistant. I can help you analyze tickers, understand setups, and provide insights. What would you like to know?',
            timestamp: new Date()
          }
        ]);
        const [input, setInput] = useState('');
        const [loading, setLoading] = useState(false);
        const messagesEndRef = useRef(null);
        const inputRef = useRef(null);

        const scrollToBottom = () => {
          if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
          }
        };

        useEffect(() => {
          scrollToBottom();
        }, [messages]);

        useEffect(() => {
          if (isOpen && inputRef.current) {
            inputRef.current.focus();
          }
        }, [isOpen]);

        const handleSend = async (e) => {
          e.preventDefault();
          if (!input.trim() || loading) return;

          const userMessage = {
            role: 'user',
            content: input.trim(),
            timestamp: new Date()
          };

          setMessages(prev => [...prev, userMessage]);
          setInput('');
          setLoading(true);

          try {
            // Fetch recent activity for context
            let activityData = [];
            try {
              const activityRes = await fetch(`${API_BASE}/timed/activity?limit=20`);
              if (activityRes.ok) {
                const activityJson = await activityRes.json();
                if (activityJson.ok && Array.isArray(activityJson.events)) {
                  activityData = activityJson.events;
                }
              }
            } catch (e) {
              console.warn('Failed to fetch activity for chat:', e);
            }

            const response = await fetch(`${API_BASE}/timed/ai/chat`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                message: userMessage.content,
                conversationHistory: messages.slice(-10).map(m => ({
                  role: m.role,
                  content: m.content
                })),
                tickerData: tickerData ? Object.keys(tickerData).slice(0, 50) : [],
                activityData: activityData
              })
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            
            if (!data.ok) {
              throw new Error(data.error || 'AI service error');
            }

            const assistantMessage = {
              role: 'assistant',
              content: data.response || 'Sorry, I couldn\'t process that request.',
              timestamp: new Date(),
              sources: data.sources || []
            };

            setMessages(prev => [...prev, assistantMessage]);
          } catch (error) {
            console.error('Chat error:', error);
            const errorMessage = {
              role: 'assistant',
              content: error.message.includes('not configured') 
                ? 'âš ï¸ AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets.'
                : `âŒ Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true
            };
            setMessages(prev => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const formatMessage = (content) => {
          // Simple markdown-like formatting
          const lines = content.split('\n');
          return lines.map((line, i) => {
            let formatted = line;
            // Bold
            formatted = formatted.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold">$1</strong>');
            // Code blocks
            formatted = formatted.replace(/`(.+?)`/g, '<code class="bg-[#26325f] px-1 py-0.5 rounded text-xs">$1</code>');
            // Links
            formatted = formatted.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank" class="text-blue-400 hover:underline">$1</a>');
            // Use React.createElement instead of JSX for better Babel compatibility
            return React.createElement('p', { 
              key: i, 
              dangerouslySetInnerHTML: { __html: formatted } 
            });
          });
        };

        if (!isOpen) return null;

        return (
          <div className="fixed right-0 top-0 h-full w-96 bg-[#0f1630] border-l border-[#26325f] flex flex-col shadow-2xl z-50 slide-in-right">
            {/* Header */}
            <div className="flex items-center justify-between p-4 border-b border-[#26325f] bg-[#121a33]">
              <div className="flex items-center gap-2">
                <div className="w-8 h-8 rounded-full bg-gradient-to-br from-blue-500 to-purple-500 flex items-center justify-center text-white font-bold text-sm">
                  AI
                </div>
                <div>
                  <h3 className="text-sm font-semibold text-white">Trading Assistant</h3>
                  <p className="text-xs text-[#93a4d6]">Powered by OpenAI</p>
                </div>
              </div>
              <button
                onClick={onClose}
                className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
              >
                âœ•
              </button>
            </div>

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
              {messages.map((msg, idx) => (
                <div
                  key={idx}
                  className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
                >
                  <div
                    className={`max-w-[80%] rounded-lg p-3 ${
                      msg.role === 'user'
                        ? 'bg-blue-500/20 border border-blue-500/30 text-white'
                        : msg.error
                        ? 'bg-red-500/20 border border-red-500/30 text-red-300'
                        : 'bg-[#121a33] border border-[#26325f] text-[#e7ecff]'
                    }`}
                  >
                    <div className="text-sm whitespace-pre-wrap">
                      {formatMessage(msg.content)}
                    </div>
                    {msg.sources && msg.sources.length > 0 && (
                      <div className="mt-2 pt-2 border-t border-[#26325f]">
                        <p className="text-xs text-[#93a4d6] mb-1">Sources:</p>
                        <ul className="text-xs text-[#93a4d6] space-y-1">
                          {msg.sources.map((source, i) => (
                            <li key={i}>â€¢ {source}</li>
                          ))}
                        </ul>
                      </div>
                    )}
                    <div className="text-xs text-[#6b7a9f] mt-1">
                      {new Date(msg.timestamp).toLocaleTimeString()}
                    </div>
                  </div>
                </div>
              ))}
              {loading && (
                <div className="flex justify-start">
                  <div className="bg-[#121a33] border border-[#26325f] rounded-lg p-3">
                    <div className="flex items-center gap-2 text-[#93a4d6] text-sm">
                      <div className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"></div>
                      <div className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse" style={{ animationDelay: '0.2s' }}></div>
                      <div className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse" style={{ animationDelay: '0.4s' }}></div>
                      <span>Thinking...</span>
                    </div>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <form onSubmit={handleSend} className="p-4 border-t border-[#26325f] bg-[#121a33]">
              <div className="flex gap-2">
                <input
                  ref={inputRef}
                  type="text"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="Ask about tickers, setups, or market conditions..."
                  className="flex-1 px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6] focus:outline-none focus:border-[#3a4aa0]"
                  disabled={loading}
                />
                <button
                  type="submit"
                  disabled={loading || !input.trim()}
                  className="px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-[#26325f] disabled:text-[#6b7a9f] rounded-lg text-white font-semibold transition-colors disabled:cursor-not-allowed"
                >
                  Send
                </button>
              </div>
              <p className="text-xs text-[#6b7a9f] mt-2">
                ðŸ’¡ Try: "What's the status of AAPL?" or "Show me prime setups"
              </p>
            </form>
          </div>
        );
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Main App
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function App() {
        const { data, loading, error, lastUpdate, refetch } = useTickerData();
        const [filters, setFilters] = useState({
          search: "",
          quadrants: [
            "HTF_BULL_LTF_PULLBACK",
            "HTF_BULL_LTF_BULL",
            "HTF_BEAR_LTF_BEAR",
            "HTF_BEAR_LTF_PULLBACK",
          ],
          minRank: 0,
          minRR: 0,
          maxCompletion: 1.01,
          group: "ALL",
        });
        const [selectedTicker, setSelectedTicker] = useState(null);
        const [selectedTrail, setSelectedTrail] = useState(null);
        const [hoveredTicker, setHoveredTicker] = useState(null);
        const [chatOpen, setChatOpen] = useState(false);
        
        // Fetch trail data when ticker is selected
        useEffect(() => {
          if (selectedTicker) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);
            
            fetch(
              `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(selectedTicker)}`,
              { signal: controller.signal }
            )
              .then(res => res.json())
              .then(data => {
                if (data.ok && Array.isArray(data.trail)) {
                  setSelectedTrail(data.trail);
                } else {
                  setSelectedTrail([]);
                }
              })
              .catch(err => {
                if (err.name !== 'AbortError') {
                  console.error('Failed to load trail:', err);
                }
                setSelectedTrail([]);
              })
              .finally(() => {
                clearTimeout(timeoutId);
              });
          } else {
            setSelectedTrail(null);
          }
        }, [selectedTicker]);
        
        // Safe setter for selectedTicker to prevent infinite loops
        const handleTickerSelect = useCallback((ticker) => {
          try {
            setSelectedTicker(ticker);
          } catch (error) {
            console.error('Error setting selected ticker:', error);
          }
        }, []);

        const debouncedSearch = useDebounce(filters.search, 300);
        const effectiveFilters = { ...filters, search: debouncedSearch };

        const tickers = useMemo(() => {
          return applyFilters(data, effectiveFilters);
        }, [data, effectiveFilters]);

        const primeTickers = useMemo(
          () => tickers.filter(isPrimeBubble),
          [tickers]
        );

        const handleFilterChange = useCallback((newFilters) => {
          setFilters((prev) => {
            // Create a new object to ensure React detects the change
            const updated = { ...prev };
            // Apply new filters
            Object.keys(newFilters).forEach(key => {
              if (newFilters[key] === undefined || newFilters[key] === null) {
                // Explicitly delete undefined/null values to clear filters
                delete updated[key];
              } else {
                updated[key] = newFilters[key];
              }
            });
            return updated;
          });
        }, []);

        return (
          <>
            <div className="min-h-screen p-4">
              <div className="w-full mx-auto">
              {/* Navigation */}
              <nav className="mb-4 p-3 bg-[#121a33] border border-[#26325f] rounded-lg">
                <div className="flex items-center gap-3 flex-wrap">
                  <span className="text-sm text-[#93a4d6]">Navigate:</span>
                  <a
                    href="index-react.html"
                    className="px-3 py-1.5 rounded bg-blue-500/20 border border-blue-500 text-sm text-blue-400 font-semibold"
                  >
                    Dashboard
                  </a>
                  <a
                    href="simulation-dashboard.html"
                    className="px-3 py-1.5 rounded bg-[#0f1630] border border-[#26325f] text-sm hover:bg-[#1a2550] transition-colors"
                  >
                    Simulation Dashboard
                  </a>
                </div>
              </nav>

              {/* Header */}
              <header className="mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h1 className="text-3xl font-bold">
                    Timed Trading â€” React Dashboard
                  </h1>
                  <div className="flex items-center gap-4">
                    {loading && <div className="loading-spinner"></div>}
                    {error && (
                      <div className="px-4 py-2 bg-red-500/20 border border-red-500 rounded-lg text-red-400 text-sm">
                        Error: {error}
                      </div>
                    )}
                    <button
                      onClick={() => setChatOpen(true)}
                      className="px-4 py-2 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 border border-blue-400/30 rounded-lg text-white font-semibold transition-all shadow-lg hover:shadow-xl flex items-center gap-2"
                      title="Open AI Assistant"
                    >
                      <span>ðŸ¤–</span>
                      <span>AI Assistant</span>
                    </button>
                    <button
                      onClick={refetch}
                      className="px-4 py-2 bg-[#1a2550] border border-[#26325f] rounded-lg hover:bg-[#26325f] transition-colors"
                    >
                      Refresh
                    </button>
                    {lastUpdate && (
                      <span className="text-sm text-[#93a4d6]">
                        Updated {lastUpdate.toLocaleTimeString()}
                      </span>
                    )}
                  </div>
                </div>

              {/* Quick Stats */}
              <div className="flex gap-4 text-sm items-center">
                <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                  <span className="text-[#93a4d6]">Tickers: </span>
                  <span className="font-bold text-white">{tickers.length}</span>
                </div>
                <div className="px-3 py-1.5 rounded-lg bg-green-500/10 border border-green-500/30">
                  <span className="text-green-400">Prime: </span>
                  <span className="font-bold text-green-400">{primeTickers.length}</span>
                </div>
                {tickers.length > 0 && (
                  <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                    <span className="text-[#93a4d6]">In Corridor: </span>
                    <span className="font-bold text-white">
                      {tickers.filter(t => entryType(t).corridor).length}
                    </span>
                  </div>
                )}
                {error && (
                  <div className="px-3 py-1.5 rounded-lg bg-red-500/10 border border-red-500/30">
                    <span className="text-red-400">Error: {error}</span>
                  </div>
                )}
              </div>

                {/* Filters */}
                <div className="mt-4">
                  <div className="mb-4">
                    <input
                      type="text"
                      placeholder="Search ticker(s) or use natural language... (e.g., 'AAPL, GOOGL' or 'top 40' or 'rank over 75')"
                      value={filters.search}
                      onChange={(e) =>
                        handleFilterChange({ search: e.target.value })
                      }
                      className="w-full px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6]"
                    />
                    <div className="mt-1 text-xs text-[#6b7a9f]">
                      ðŸ’¡ Examples: <span className="text-[#93a4d6]">"AAPL, GOOGL, TSLA"</span> â€¢ <span className="text-[#93a4d6]">"top 40"</span> â€¢ <span className="text-[#93a4d6]">"top long setup"</span> â€¢ <span className="text-[#93a4d6]">"rank over 75"</span> â€¢ <span className="text-[#93a4d6]">"RR above 2"</span> â€¢ <span className="text-[#93a4d6]">"prime setup and in corridor"</span>
                    </div>
                  </div>
                  <QuickFilters
                    filters={filters}
                    onFilterChange={handleFilterChange}
                  />
                </div>
              </header>

              {/* Error Display */}
              {error && (
                <div className="mb-4 p-4 bg-red-500/20 border-2 border-red-500 rounded-xl">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-lg font-bold text-red-400 mb-2">Error Loading Data</h3>
                      <p className="text-red-300">{error}</p>
                    </div>
                    <button
                      onClick={refetch}
                      className="px-4 py-2 bg-red-500 hover:bg-red-600 rounded-lg text-white font-semibold"
                    >
                      Retry
                    </button>
                  </div>
                </div>
              )}

              {/* Main Content - Hero Layout: Activity Feed (left) | Bubble Chart (center) | Detail (right) */}
              {!error && (
              <div className="space-y-4">
                {/* Hero Section: Activity Feed | Bubble Chart | Detail View */}
                <div className="flex gap-4 items-start">
                  {/* Activity Feed - Left side (complementary, fixed width) */}
                  <div className="flex-shrink-0">
                    <ActivityFeed onTickerClick={handleTickerSelect} tickerData={data} />
                  </div>
                  
                  {/* Bubble Chart - Center Hero (flexible, takes remaining space) */}
                  <div className="flex-1 min-w-0">
                    <div className="h-full min-h-[900px]">
                    {loading && tickers.length === 0 ? (
                      <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] flex items-center justify-center">
                        <div className="text-center">
                          <div className="loading-spinner mx-auto mb-4"></div>
                          <div className="text-[#93a4d6]">
                            Loading tickers...
                          </div>
                        </div>
                      </div>
                    ) : (
                      <BubbleChart
                        tickers={tickers}
                        onBubbleClick={handleTickerSelect}
                        hoveredTicker={hoveredTicker}
                        onHover={setHoveredTicker}
                        selectedTicker={selectedTicker}
                        selectedTrail={selectedTrail}
                        allData={data}
                      />
                    )}
                    </div>
                  </div>
                  
                  {/* Detail View - Right side (slides in when ticker selected, fixed width) */}
                  <div className="flex-shrink-0 w-[450px]">
                    <OverlayPortal
                      selectedTicker={selectedTicker}
                      tickers={tickers}
                      data={data}
                      onClose={() => handleTickerSelect(null)}
                    />
                  </div>
                </div>

                {/* Lists below - Top 40 Dynamic, Top Long/Short wider, others in grid */}
                <div className="space-y-4">
                  {/* Top 40 Dynamic Ranking - Full width */}
                  <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                    <h2 className="text-lg font-bold mb-4">ðŸ† Top 40 Dynamic Rankings</h2>
                    <div className="text-xs text-[#93a4d6] mb-3">
                      Rankings update dynamically based on corridor status, squeeze conditions, RR, phase, and completion
                    </div>
                    <div className="max-h-[600px] overflow-y-auto space-y-1.5">
                      {tickers
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort((a, b) => b.dynamicRank - a.dynamicRank)
                        .slice(0, 40)
                        .map((ticker, idx) => (
                          <div key={ticker.ticker} className="flex items-center gap-2">
                            <div className="w-8 text-center">
                              <span className={`text-sm font-bold ${
                                idx < 3 ? "text-yellow-400" : 
                                idx < 10 ? "text-green-400" : 
                                "text-[#93a4d6]"
                              }`}>
                                #{idx + 1}
                              </span>
                            </div>
                            <div className="flex-1">
                              <SetupCard
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => handleTickerSelect(ticker.ticker)}
                              />
                            </div>
                          </div>
                        ))}
                    </div>
                  </div>

                  {/* Top Long and Top Short - Full width, side by side */}
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    {/* Top Long */}
                    {(() => {
                      const longTickers = tickers
                        .filter(t => {
                          const dir = getDirection(t);
                          return dir.text === "LONG";
                        })
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort((a, b) => b.dynamicRank - a.dynamicRank)
                        .slice(0, 25);
                      
                      if (longTickers.length === 0) return null;
                      
                      return (
                        <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                          <h2 className="text-lg font-bold mb-4">ðŸ“ˆ Top Long</h2>
                          <div className="max-h-[700px] overflow-y-auto space-y-1.5">
                            {longTickers.map((ticker) => (
                              <SetupCard
                                key={ticker.ticker}
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => handleTickerSelect(ticker.ticker)}
                              />
                            ))}
                          </div>
                        </div>
                      );
                    })()}

                    {/* Top Short */}
                    {(() => {
                      const shortTickers = tickers
                        .filter(t => {
                          const dir = getDirection(t);
                          return dir.text === "SHORT";
                        })
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort((a, b) => b.dynamicRank - a.dynamicRank)
                        .slice(0, 25);
                      
                      if (shortTickers.length === 0) return null;
                      
                      return (
                        <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                          <h2 className="text-lg font-bold mb-4">ðŸ“‰ Top Short</h2>
                          <div className="max-h-[700px] overflow-y-auto space-y-1.5">
                            {shortTickers.map((ticker) => (
                              <SetupCard
                                key={ticker.ticker}
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => handleTickerSelect(ticker.ticker)}
                              />
                            ))}
                          </div>
                        </div>
                      );
                    })()}
                  </div>

                  {/* Other lists - Grid layout */}
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    {[
                      { title: "Prime Setups", filter: (t) => isPrimeBubble(t), sort: (a, b) => (computeDynamicRank(b) - computeDynamicRank(a)), limit: 15 },
                      { title: "In Corridor", filter: (t) => entryType(t).corridor, sort: (a, b) => (computeDynamicRank(b) - computeDynamicRank(a)), limit: 15 },
                      { title: "Squeeze Release", filter: (t) => t.flags?.sq30_release, sort: (a, b) => (computeDynamicRank(b) - computeDynamicRank(a)), limit: 15 },
                    ].map((listConfig, idx) => {
                      const listTickers = tickers
                        .filter(listConfig.filter || (() => true))
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort(listConfig.sort)
                        .slice(0, listConfig.limit);
                      
                      if (listTickers.length === 0) return null;
                      
                      return (
                        <div key={idx} className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                          <h2 className="text-lg font-bold mb-4">{listConfig.title}</h2>
                          <div className="max-h-[600px] overflow-y-auto space-y-1.5">
                            {listTickers.map((ticker) => (
                              <SetupCard
                                key={ticker.ticker}
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => handleTickerSelect(ticker.ticker)}
                              />
                            ))}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>

              </div>
              )}
            </div>
          </div>
          
          <>
            {/* AI Chat Interface */}
            {chatOpen && (
              <AIChatInterface 
                isOpen={chatOpen} 
                onClose={() => setChatOpen(false)} 
                tickerData={data}
              />
            )}
          </>
        );
      }
      
      // Render overlay outside main container using portal
      const TickerDetailsLoader = ({ tickerSymbol, onClose }) => {
        const [tickerData, setTickerData] = useState(null);
        const [allLoadedData, setAllLoadedData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        
        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              // Fetch both the ticker data and all tickers for absolute ranking
              const [tickerRes, allRes] = await Promise.all([
                fetch(`${API_BASE}/timed/latest?ticker=${encodeURIComponent(tickerSymbol)}`),
                fetch(`${API_BASE}/timed/all`)
              ]);
              
              if (!tickerRes.ok) throw new Error(`HTTP ${tickerRes.status}`);
              const tickerJson = await tickerRes.json();
              if (!tickerJson.ok || !tickerJson.latestData) {
                throw new Error(tickerJson.error || 'Ticker not found');
              }
              
              // Try to get all tickers for ranking (may fail, that's okay)
              let allData = null;
              try {
                if (allRes.ok) {
                  const allJson = await allRes.json();
                  if (allJson.ok && allJson.data) {
                    allData = allJson.data;
                  }
                }
              } catch (e) {
                console.warn('Failed to fetch all tickers for ranking:', e);
              }
              
              setTickerData(tickerJson.latestData);
              setAllLoadedData(allData);
            } catch (err) {
              console.error('Failed to fetch ticker:', err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };
          
          fetchTicker();
        }, [tickerSymbol]);
        
        if (loading) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-[#26325f] rounded-xl p-6">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[#93a4d6]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }
        
        if (error || !tickerData) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-red-500 rounded-xl p-6">
              <div className="text-center">
                <div className="text-red-400 mb-2">Failed to load {tickerSymbol}</div>
                <div className="text-[#93a4d6] text-sm mb-4">{error || 'No data available'}</div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-[#26325f] hover:bg-[#3a4aa0] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }
        
        return <TickerDetails ticker={tickerData} onClose={onClose} allTickers={[]} allLoadedData={allLoadedData} />;
      }
      
      const OverlayPortal = ({ selectedTicker, tickers, data, onClose }) => {
        if (!selectedTicker) return null;
        
        try {
          // Normalize ticker name
          const tickerUpper = String(selectedTicker).toUpperCase();
          
          // Search in filtered tickers first
          let foundTicker = tickers.find((t) => {
            if (!t || typeof t !== 'object') return false;
            const tTicker = String(t.ticker || '').toUpperCase();
            return tTicker === tickerUpper;
          });
          
          // If not found, search in original data object
          if (!foundTicker && data && typeof data === 'object') {
            if (Array.isArray(data)) {
              foundTicker = data.find((t) => {
                if (!t || typeof t !== 'object') return false;
                const tTicker = String(t.ticker || '').toUpperCase();
                return tTicker === tickerUpper;
              });
            } else {
              // Object format: check if ticker is a key (data structure: { "ETHA": {...}, ... })
              if (data[tickerUpper]) {
                foundTicker = data[tickerUpper];
              } else {
                // Search through all values in case structure is different
                const dataArray = Object.values(data);
                foundTicker = dataArray.find((t) => {
                  if (!t || typeof t !== 'object') return false;
                  const tTicker = String(t.ticker || '').toUpperCase();
                  return tTicker === tickerUpper;
                });
              }
            }
          }
          
          // If still not found, fetch from API
          if (!foundTicker) {
            console.warn('Ticker not found in local data, fetching from API:', tickerUpper);
            return <TickerDetailsLoader tickerSymbol={tickerUpper} onClose={onClose} />;
          }
          
          // TEMPORARILY DISABLE PORTAL - render inline to avoid freeze issues
          // TODO: Re-enable portal once freeze is resolved
          return (
            <TickerDetails
              ticker={foundTicker}
              onClose={onClose}
              allTickers={tickers}
              allLoadedData={data}
            />
          );
          
          /* Portal code - disabled for now
          const overlayContent = (
            <TickerDetails
              ticker={foundTicker}
              onClose={onClose}
            />
          );
          
          // Use portal to render at document body level, but only if available
          if (ReactDOM && ReactDOM.createPortal && document && document.body) {
            try {
              return ReactDOM.createPortal(overlayContent, document.body);
            } catch (portalError) {
              console.error('Portal error:', portalError);
              // Fallback to inline rendering
              return overlayContent;
            }
          }
          // Fallback if portal not available
          return overlayContent;
          */
        } catch (error) {
          console.error('OverlayPortal error:', error);
          return null;
        }
      }

      // Render with error handling
      // Wait for all scripts to load before rendering
      function initializeApp() {
        try {
          // Check if React and ReactDOM are loaded
          if (typeof React === "undefined") {
            throw new Error("React not loaded. Check CDN connection.");
          }
          if (typeof ReactDOM === "undefined") {
            throw new Error("ReactDOM not loaded. Check CDN connection.");
          }

          const rootElement = document.getElementById("root");
          if (!rootElement) {
            throw new Error("Root element not found");
          }

          // Check if React 18 createRoot is available
          if (ReactDOM.createRoot) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(<App />);
          } else {
            // Fallback for React 17
            ReactDOM.render(<App />, rootElement);
          }
          
          console.log("[App] Dashboard initialized successfully");
        } catch (error) {
          console.error("Error rendering app:", error);
          const rootElement = document.getElementById("root");
          if (rootElement) {
            rootElement.innerHTML = `
              <div style="padding: 40px; text-align: center; color: #e7ecff; max-width: 800px; margin: 0 auto;">
                <h2 style="color: #e74c3c; margin-bottom: 20px;">Error Loading Dashboard</h2>
                <p style="margin-bottom: 20px; color: #ff6b6b;">${error.message}</p>
                <div style="background: #1a2440; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left; color: #93a4d6;">
                  <h3 style="color: #e7ecff; margin-bottom: 10px;">Troubleshooting:</h3>
                  <ul style="list-style: disc; padding-left: 20px; line-height: 1.8;">
                    <li>Open browser console (F12 or Cmd+Option+I) to see detailed errors</li>
                    <li>Check your internet connection - CDN resources need to load</li>
                    <li>Try refreshing the page (Cmd+R or Ctrl+R)</li>
                    <li>Check if React is loaded: <code style="background: #26325f; padding: 2px 6px; border-radius: 4px;">typeof React !== 'undefined'</code></li>
                    <li>Check if API is reachable: <a href="https://timed-trading-ingest.shashant.workers.dev/timed/health" target="_blank" style="color: #4a9eff;">API Health Check</a></li>
                  </ul>
                </div>
                <button 
                  onclick="window.location.reload()" 
                  style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;"
                >
                  Reload Page
                </button>
              </div>
            `;
          }
        }
      }

      // Wait for DOM and scripts to be ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function() {
          // Wait a bit for Babel to process
          setTimeout(initializeApp, 100);
        });
      } else {
        // DOM already loaded
        setTimeout(initializeApp, 100);
      }

      // Fallback: If React still isn't loaded after 5 seconds, show error
      setTimeout(function() {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          const rootElement = document.getElementById("root");
          if (rootElement && rootElement.innerHTML.includes("Loading dashboard")) {
            rootElement.innerHTML = `
              <div style="padding: 40px; text-align: center; color: #e7ecff;">
                <h2 style="color: #e74c3c;">CDN Resources Not Loading</h2>
                <p style="margin: 20px 0; color: #93a4d6;">
                  React or other CDN resources failed to load. This may be due to:
                </p>
                <ul style="text-align: left; display: inline-block; color: #93a4d6; margin: 20px 0;">
                  <li>Network connectivity issues</li>
                  <li>Ad blockers blocking CDN scripts</li>
                  <li>Corporate firewall blocking unpkg.com</li>
                </ul>
                <p style="margin-top: 20px;">
                  <button onclick="window.location.reload()" style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Retry
                  </button>
                </p>
              </div>
            `;
          }
        }
      }, 5000);
    </script>
  </body>
</html>
