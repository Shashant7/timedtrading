<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Timed Trading — Bubble Quadrant</title>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    :root { --bg:#0b1020; --card:#121a33; --text:#e7ecff; --muted:#93a4d6; --line:#26325f; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    header { padding:16px 18px; border-bottom:1px solid var(--line); display:flex; gap:14px; align-items:center; flex-wrap:wrap;}
    .title { font-weight:800; letter-spacing:.2px; }
    .pill { background:var(--card); border:1px solid var(--line); border-radius:999px; padding:8px 12px; display:flex; gap:10px; align-items:center;}
    .pill label { font-size:12px; color:var(--muted); }
    select,input { background:#0f1630; color:var(--text); border:1px solid var(--line); border-radius:10px; padding:8px 10px; }
    input[type="checkbox"] { transform: scale(1.1); }
    main { padding:14px 18px; }
    #chart { width:100%; height:78vh; border:1px solid var(--line); border-radius:16px; background:var(--card); }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .muted { color:var(--muted); font-size:12px; }
    .btn { cursor:pointer; background:#1a2550; border:1px solid var(--line); color:var(--text);
           border-radius:12px; padding:9px 12px; font-weight:700; }
    .btn:active { transform: translateY(1px); }
    a { color: #a8b6ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>

<body>
  <header>
    <div class="title">Timed Trading — Bubble Quadrant</div>

    <div class="pill">
      <label>Data</label>
      <select id="endpoint">
        <option value="https://timed-trading-ingest.shashant.workers.dev/timed/all">/timed/all</option>
      </select>
    </div>

    <div class="pill">
      <label>Search</label>
      <input id="search" placeholder="Ticker (e.g., SPY, MES1!)" />
    </div>

    <div class="pill row">
      <label>Show</label>
      <label class="muted"><input type="checkbox" id="q1" checked> Q1 Prep</label>
      <label class="muted"><input type="checkbox" id="q2" checked> Q2 Bull</label>
      <label class="muted"><input type="checkbox" id="q3" checked> Q3 Bear</label>
      <label class="muted"><input type="checkbox" id="q4" checked> Q4 Pullback</label>
    </div>

    <div class="pill">
      <label>Completion ≤</label>
      <select id="compMax">
        <option value="1.01">100%</option>
        <option value="0.80">80%</option>
        <option value="0.60">60%</option>
        <option value="0.40">40%</option>
        <option value="0.25">25%</option>
      </select>
    </div>

    <div class="pill">
      <label>Auto-refresh</label>
      <select id="refreshSec">
        <option value="0">Off</option>
        <option value="15">15s</option>
        <option value="30" selected>30s</option>
        <option value="60">60s</option>
      </select>
    </div>

    <button class="btn" id="refreshBtn">Refresh</button>
    <div class="muted" id="status"></div>

    <div class="muted" style="width:100%;">
      Tip: click a bubble to open TradingView. Cyan border = squeeze release. Gold border = squeeze on.
    </div>
  </header>

  <main>
    <div id="chart"></div>
  </main>

<script>
  // Crash-proof global handler (so we never get "white page" again)
  window.addEventListener("error", (e) => {
    console.error(e);
    const msg = `[JS ERROR] ${e.message}\n${e.filename}:${e.lineno}:${e.colno}`;
    const pre = document.createElement("pre");
    pre.style.padding = "16px";
    pre.style.whiteSpace = "pre-wrap";
    pre.style.color = "#fff";
    pre.style.background = "#111";
    pre.textContent = msg;
    document.body.innerHTML = "";
    document.body.appendChild(pre);
  });

  const el = (id) => document.getElementById(id);
  const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));

  // --- CONFIG ---
  const LABEL_SIZE_THRESHOLD = 28; // show ticker label if bubble size >= this (or squeeze release)
  const STALE_WARN_MIN = 30;       // start fading after this many minutes
  const STALE_MAX_MIN  = 240;      // very stale by this many minutes
  const TV_OPEN_MODE   = "chart";  // "chart" or "search"

  function quadrantFromState(s) {
    if (s === "HTF_BULL_LTF_PULLBACK") return "Q1";
    if (s === "HTF_BULL_LTF_BULL") return "Q2";
    if (s === "HTF_BEAR_LTF_BEAR") return "Q3";
    if (s === "HTF_BEAR_LTF_PULLBACK") return "Q4";
    return "Q?";
  }

  function bubbleSize(completion) {
    const c = (typeof completion === "number") ? completion : 0;
    return 10 + c * 40; // 10..50
  }

  function stalenessOpacity(tsMs) {
    if (!tsMs || typeof tsMs !== "number") return 0.65;
    const ageMin = (Date.now() - tsMs) / 60000;
    if (ageMin <= STALE_WARN_MIN) return 0.92;
    const t = clamp((ageMin - STALE_WARN_MIN) / Math.max(1, (STALE_MAX_MIN - STALE_WARN_MIN)), 0, 1);
    return 0.92 - t * 0.74; // 0.92 -> 0.18
  }

  function fmtNum(v, d=2) {
    if (v === null || v === undefined || Number.isNaN(Number(v))) return "—";
    const n = Number(v);
    if (!Number.isFinite(n)) return "—";
    return n.toFixed(d);
  }

  function fmtPct01(v) {
    const n = Number(v);
    if (!Number.isFinite(n)) return "—";
    return `${Math.round(n * 100)}%`;
  }

  function hoverText(t, d) {
    const r = Array.isArray(d.reasons) ? d.reasons : [];
    const flags = d.flags || {};

    // Optional fields (will show once Pine sends them)
    const px  = d.price;
    const sl  = d.sl;
    const tp  = d.tp;
    const eta = d.eta_days;
    const trigPx = d.trigger_price;
    const trigTs = d.trigger_ts;

    const ageMin = (Date.now() - (d.ts || Date.now())) / 60000;
    const ageStr = (Number.isFinite(ageMin) ? `${ageMin.toFixed(1)}m` : "—");

    return [
      `<b>${t}</b>`,
      `State: ${d.state || ""} (${quadrantFromState(d.state)})`,
      `HTF: ${fmtNum(d.htf_score, 2)}`,
      `LTF: ${fmtNum(d.ltf_score, 2)}`,
      `Completion: ${fmtPct01(d.completion)}`,
      `Phase: ${fmtPct01(d.phase_pct)}`,
      `Age: ${ageStr}`,
      `Price: ${fmtNum(px, 2)}`,
      `Trigger price: ${fmtNum(trigPx, 2)}`,
      `Trigger time: ${trigTs ? new Date(Number(trigTs)).toLocaleString() : "—"}`,
      `Stop (SL): ${fmtNum(sl, 2)}`,
      `Target (TP): ${fmtNum(tp, 2)}`,
      `ETA to completion: ${Number.isFinite(Number(eta)) ? `${Number(eta).toFixed(1)}d` : "—"}`,
      `Flags: sq30_on=${!!flags.sq30_on}, sq30_release=${!!flags.sq30_release}, phase_dot=${!!flags.phase_dot}`,
      r.length ? `<br><b>Reasons</b><br>${r.map(x=>`• ${x}`).join("<br>")}` : ""
    ].join("<br>");
  }

  async function fetchAll() {
    const url = el("endpoint").value;
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Fetch failed ${res.status}`);
    const json = await res.json();
    if (!json.ok) throw new Error(`API not ok`);
    return json.data || {};
  }

  function applyFilters(dataObj) {
    const search = el("search").value.trim().toUpperCase();
    const compMax = Number(el("compMax").value);

    const allow = new Set();
    if (el("q1").checked) allow.add("HTF_BULL_LTF_PULLBACK");
    if (el("q2").checked) allow.add("HTF_BULL_LTF_BULL");
    if (el("q3").checked) allow.add("HTF_BEAR_LTF_BEAR");
    if (el("q4").checked) allow.add("HTF_BEAR_LTF_PULLBACK");

    const out = [];
    for (const [ticker, d] of Object.entries(dataObj)) {
      if (!d) continue;
      const T = String(ticker || "").toUpperCase();

      if (search && !T.includes(search)) continue;
      if (!allow.has(d.state)) continue;

      const c = (typeof d.completion === "number") ? d.completion : 0;
      if (c > compMax) continue;

      out.push({ ticker: T, ...d });
    }
    return out;
  }

  function tvUrlForTicker(ticker) {
    const q = encodeURIComponent(ticker);
    if (TV_OPEN_MODE === "chart") return `https://www.tradingview.com/chart/?symbol=${q}`;
    return `https://www.tradingview.com/symbols/?query=${q}`;
  }

  let clickHandlerBound = false;

  function render(points) {
    // Ensure Plotly exists
    if (!window.Plotly) throw new Error("Plotly failed to load (CDN blocked).");

    const x = [], y = [], hover = [], sizes = [], colors = [], opacities = [], labels = [];
    const lineWidths = [], lineColors = [], custom = [];

    for (const p of points) {
      const px = (typeof p.ltf_score === "number") ? p.ltf_score : 0;
      const py = (typeof p.htf_score === "number") ? p.htf_score : 0;

      const size = bubbleSize(p.completion);
      const phase = (typeof p.phase_pct === "number") ? p.phase_pct : 0;
      const alpha = stalenessOpacity(p.ts);

      const flags = p.flags || {};
      const sqRel = !!flags.sq30_release;
      const sqOn  = !!flags.sq30_on;

      // Stroke highlight rules
      const lw = sqRel ? 3 : (sqOn ? 2 : 1);
      const lc = sqRel ? "rgba(0, 255, 255, 0.95)"
               : (sqOn ? "rgba(255, 215, 0, 0.9)"
               : "rgba(255,255,255,0.35)");

      // Label upgrade
      const showLabel = (size >= LABEL_SIZE_THRESHOLD) || sqRel;
      const lbl = showLabel ? p.ticker : "";

      x.push(px);
      y.push(py);
      hover.push(hoverText(p.ticker, p));
      sizes.push(size);
      colors.push(phase);
      opacities.push(alpha);
      labels.push(lbl);
      lineWidths.push(lw);
      lineColors.push(lc);
      custom.push({ ticker: p.ticker, tv: tvUrlForTicker(p.ticker) });
    }

    const trace = {
      type: "scatter",
      mode: "markers+text",
      x, y,
      text: labels,
      textposition: "top center",
      textfont: { size: 12, color: "rgba(231,236,255,0.9)" },
      hoverinfo: "text",
      hovertext: hover,
      customdata: custom,
      marker: {
        size: sizes,
        color: colors,
        colorscale: "Turbo",
        cmin: 0, cmax: 1,
        showscale: true,
        colorbar: { title: "Phase %" },
        opacity: opacities,
        line: { width: lineWidths, color: lineColors }
      }
    };

    const layout = {
      paper_bgcolor: "rgba(0,0,0,0)",
      plot_bgcolor: "rgba(0,0,0,0)",
      margin: { l: 55, r: 24, t: 20, b: 55 },
      xaxis: { title: "LTF Score", range: [-50, 50], zeroline: true, zerolinecolor: "#9aa7d8", gridcolor:"#26325f" },
      yaxis: { title: "HTF Score", range: [-50, 50], zeroline: true, zerolinecolor: "#9aa7d8", gridcolor:"#26325f" },
      shapes: [
        { type:"rect", xref:"x", yref:"y", x0:-50, x1:50, y0:-50, y1:50, line:{color:"#3a4aa0", width:1} }
      ],
      annotations: [
        { x:-35, y: 42, xref:"x", yref:"y", text:"Q1: HTF Bull / LTF Bear (Prep)", showarrow:false, font:{color:"#93a4d6", size:12} },
        { x: 35, y: 42, xref:"x", yref:"y", text:"Q2: Bull Aligned (Go)", showarrow:false, font:{color:"#93a4d6", size:12} },
        { x:-35, y:-45, xref:"x", yref:"y", text:"Q3: Bear Aligned (Go)", showarrow:false, font:{color:"#93a4d6", size:12} },
        { x: 35, y:-45, xref:"x", yref:"y", text:"Q4: HTF Bear / LTF Bull (Pullback)", showarrow:false, font:{color:"#93a4d6", size:12} }
      ]
    };

    Plotly.react("chart", [trace], layout, { responsive: true, displayModeBar: true });

    if (!clickHandlerBound) {
      const chartDiv = document.getElementById("chart");
      chartDiv.on("plotly_click", (evt) => {
        const p = evt?.points?.[0];
        const cd = p?.customdata;
        if (!cd?.tv) return;
        window.open(cd.tv, "_blank", "noopener,noreferrer");
      });
      clickHandlerBound = true;
    }
  }

  let refreshTimer = null;

  async function refresh() {
    const s = el("status");
    try {
      if (s) s.textContent = "Loading…";
      const dataObj = await fetchAll();
      const points = applyFilters(dataObj);
      render(points);
      if (s) s.textContent = `Loaded ${points.length} tickers • ${new Date().toLocaleTimeString()}`;
    } catch (e) {
      console.error(e);
      if (s) s.textContent = `Error: ${e.message}`;
      // also show on-page if status exists
    }
  }

  function resetAutoRefresh() {
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = null;
    const sec = Number(el("refreshSec").value);
    if (sec > 0) refreshTimer = setInterval(refresh, sec * 1000);
  }

  // Wire UI events
  ["search","q1","q2","q3","q4","compMax"].forEach(id => el(id).addEventListener("input", refresh));
  el("refreshBtn").addEventListener("click", refresh);
  el("refreshSec").addEventListener("change", () => { resetAutoRefresh(); refresh(); });

  // Boot
  resetAutoRefresh();
  refresh();
</script>

</body>
</html>
