<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timed Trading ‚Äî React Dashboard</title>

    <!-- React & ReactDOM via CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
      onerror="console.error('Failed to load React')"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      onerror="console.error('Failed to load ReactDOM')"
    ></script>

    <!-- Babel Standalone for JSX -->
    <script
      src="https://unpkg.com/@babel/standalone/babel.min.js"
      onerror="console.error('Failed to load Babel')"
    ></script>

    <!-- Tailwind CSS -->
    <script
      src="https://cdn.tailwindcss.com"
      onerror="console.error('Failed to load Tailwind')"
    ></script>

    <!-- Recharts for lightweight charting - try multiple sources -->
    <script
      src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"
      onerror="console.error('Failed to load Recharts from unpkg, trying alternative...'); loadRechartsFallback();"
    ></script>
    <script>
      function loadRechartsFallback() {
        // Try alternative CDN
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/recharts@2.10.3/umd/Recharts.js';
        script.onerror = function() {
          console.error('Recharts failed to load from all sources');
          window.RechartsFailed = true;
        };
        script.onload = function() {
          console.log('Recharts loaded from jsdelivr');
        };
        document.head.appendChild(script);
      }
      
      // Check if Recharts loaded after a delay
      window.addEventListener('load', function() {
        setTimeout(function() {
          if (typeof Recharts === 'undefined' && !window.RechartsFailed) {
            console.warn('Recharts may not have loaded yet');
          }
        }, 2000);
      });
    </script>

    <!-- Loading indicator while scripts load -->
    <script>
      window.addEventListener("load", function () {
        // Check if all scripts loaded
        setTimeout(function () {
          const root = document.getElementById("root");
          if (root && root.innerHTML === "") {
            if (typeof React === "undefined") {
              root.innerHTML =
                '<div style="padding: 40px; text-align: center; color: #e7ecff;"><h2 style="color: #e74c3c;">Loading Error</h2><p>React failed to load. Check console (F12) for details.</p></div>';
            }
          }
        }, 2000);
      });
    </script>

    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --text: #e7ecff;
        --muted: #93a4d6;
        --line: #26325f;
        --good: #2ecc71;
        --bad: #e74c3c;
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Arial;
        background: var(--bg);
        color: var(--text);
      }

      .loading-spinner {
        border: 2px solid var(--line);
        border-top: 2px solid var(--text);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .prime-glow {
        box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        animation: pulse-glow 2s ease-in-out infinite;
      }
      
      @keyframes pulse-glow {
        0%, 100% { box-shadow: 0 0 12px rgba(46, 204, 113, 0.4); }
        50% { box-shadow: 0 0 20px rgba(46, 204, 113, 0.6); }
      }

      .momentum-elite-glow {
        box-shadow: 0 0 15px rgba(168, 85, 247, 0.5), 0 0 25px rgba(236, 72, 153, 0.3);
        animation: momentum-pulse 2.5s ease-in-out infinite;
      }
      
      @keyframes momentum-pulse {
        0%, 100% { 
          box-shadow: 0 0 15px rgba(168, 85, 247, 0.5), 0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% { 
          box-shadow: 0 0 25px rgba(168, 85, 247, 0.7), 0 0 35px rgba(236, 72, 153, 0.5);
        }
      }
      
      .bubble-transition {
        transition: all 0.2s ease-out;
      }
      
      .bubble-hover {
        transform: scale(1.15);
        filter: brightness(1.2);
      }
      
      .fade-in {
        animation: fadeIn 0.3s ease-in;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .slide-in {
        animation: slideIn 0.3s ease-out;
      }
      
      @keyframes slideIn {
        from { opacity: 0; transform: translateX(-20px); }
        to { opacity: 1; transform: translateX(0); }
      }
      
      /* Phase color gradient helper */
      .phase-gradient {
        background: linear-gradient(to right, 
          #2ecc71 0%, 
          #27ae60 20%, 
          #f39c12 40%, 
          #e67e22 60%, 
          #e74c3c 80%, 
          #c0392b 100%
        );
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div style="padding: 40px; text-align: center; color: #e7ecff">
        <div class="loading-spinner" style="margin: 0 auto 20px"></div>
        <p>Loading dashboard...</p>
      </div>
    </div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, memo } = React;
      
      // Get Recharts components with fallback
      let RechartsComponents = null;
      if (typeof Recharts !== 'undefined') {
        RechartsComponents = {
          ScatterChart: Recharts.ScatterChart,
          Scatter: Recharts.Scatter,
          XAxis: Recharts.XAxis,
          YAxis: Recharts.YAxis,
          CartesianGrid: Recharts.CartesianGrid,
          Tooltip: Recharts.Tooltip,
          ResponsiveContainer: Recharts.ResponsiveContainer,
        };
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Types & Constants
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
      const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
      const API_BASE = "https://timed-trading-ingest.shashant.workers.dev";

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Hooks
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);

        const fetchData = useCallback(async () => {
          try {
            setLoading(true);
            const res = await fetch(`${API_BASE}/timed/all`);
            const json = await res.json();
            if (json.ok) {
              setData(json.data || {});
              setLastUpdate(new Date());
              setError(null);
            } else {
              setError("Failed to fetch data");
            }
          } catch (e) {
            setError(e.message);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 30000); // 30s auto-refresh
          return () => clearInterval(interval);
        }, [fetchData]);

        return { data, loading, error, lastUpdate, refetch: fetchData };
      }

      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = useState(value);

        useEffect(() => {
          const handler = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);

          return () => {
            clearTimeout(handler);
          };
        }, [value, delay]);

        return debouncedValue;
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Groups (matching original)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const GROUPS = {
        UPTICKS: new Set([
          "APLD", "TSLA", "STX", "AU", "CCJ", "CLS", "CRS", "VST", "FSLR", "JCI",
          "ORCL", "AMZN", "BRK.B", "BABA", "WMT", "PH", "GEV", "HII", "ULTA", "SHOP",
          "CSX", "PWR", "HOOD", "SPGI", "APP", "PANW", "RDDT", "TT", "GLXY", "ETHA",
        ]),
        SuperGranny: new Set(["META", "NVDA", "AMD", "ANET", "GS"]),
        GRNI: new Set([
          "VST", "TSLA", "TJX", "SPGI", "SOFI", "PWR", "PNC", "PLTR", "PANW", "NVDA",
          "NFLX", "MSTR", "MSFT", "MNST", "META", "LRCX", "KLAC", "JPM", "HOOD", "GS",
          "GOOGL", "GEV", "GE", "EXPE", "ETN", "EMR", "DE", "CRWD", "COST", "CDNS",
          "CAT", "BK", "AXP", "AXON", "AVGO", "ANET", "AMZN", "AMD", "AAPL",
        ]),
        GRNJ: new Set([
          "RKLB", "LITE", "SN", "ALB", "RDDT", "RGLD", "MTZ", "ON", "ALLY", "DY",
          "CCJ", "EWBC", "PATH", "WFRD", "WAL", "IESC", "ENS", "TWLO", "MLI", "KTOS",
          "MDB", "TLN", "EME", "AWI", "IBP", "DCI", "WTS", "FIX", "UTHR", "NBIS",
          "SGI", "AYI", "RIOT", "NXT", "SANM", "BWXT", "PEGA", "JOBY", "IONQ", "SOFI",
          "ITT", "STRL", "QLYS", "MP", "GLXY", "HIMS", "IOT", "BE", "NEU", "AVAV",
          "PSTG", "RBLX",
        ]),
        GRNY: new Set([
          "GEV", "LRCX", "PNC", "GOOGL", "GS", "META", "MNST", "KLAC", "TJX", "GE",
          "EXPE", "CAT", "BK", "SPGI", "TSLA", "EMR", "JPM", "AXP", "ANET", "AXON",
          "AAPL", "NVDA", "AVGO", "PWR", "CDNS", "DE", "MSFT", "COST", "VST", "PLTR",
          "AMZN", "HOOD", "ETN", "SOFI", "AMD", "PANW", "CRWD", "NFLX", "MSTR",
        ]),
        Social: new Set(["CSCO", "BA", "NKE", "AAPL", "PI", "APLD"]),
        SP_Sectors: new Set([
          "XLK", "XLF", "XLY", "XLP", "XLC", "XLI", "XLB", "XLE", "XLRE", "XLU", "XLV",
        ]),
      };

      const GROUP_LABELS = {
        SP_Sectors: "S&P Sectors",
      };

      const GROUP_ORDER = [
        "SP_Sectors",
        "UPTICKS",
        "SuperGranny",
        "GRNI",
        "GRNJ",
        "GRNY",
        "Social",
      ];

      function normTicker(t) {
        const s = String(t || "").trim().toUpperCase();
        if (s === "BRK-B") return "BRK.B";
        return s;
      }

      function groupsForTicker(t) {
        const T = normTicker(t);
        const out = [];
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) out.push(g);
        return out;
      }

      // Check if ticker is in any group
      function isTickerInGroups(t) {
        const T = normTicker(t);
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) return true;
        return false;
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Utils
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      
      // Phase-based color (Turbo-like gradient: 0=green, 0.5=yellow, 1=red)
      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          // Green to light green: #2ecc71 to #27ae60
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(204 + (174 - 204) * t)}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          // Light green to yellow: #27ae60 to #f39c12
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(174 + (156 - 174) * t)}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          // Yellow to orange: #f39c12 to #e67e22
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(156 + (126 - 156) * t)}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          // Orange to red: #e67e22 to #e74c3c
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(126 + (76 - 126) * t)}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          // Red to dark red: #e74c3c to #c0392b
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(76 + (57 - 76) * t)}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }
      
      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";

        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function completionForSize(ticker) {
        // Use the completion value from Pine Script payload directly
        // Pine Script calculates: completion = abs(close - triggerPrice) / expectedMove
        // This is more accurate than recalculating from trigger to TP because:
        // 1. It accounts for expectedMove (which may differ from TP distance)
        // 2. It handles direction correctly
        // 3. It works even when price hasn't reached trigger yet
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      // Dynamic ranking that considers real-time conditions
      function computeDynamicRank(ticker) {
        const baseRank = Number(ticker.rank) || 50;
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;
        
        let dynamicScore = baseRank;
        
        // Corridor bonus (high priority - active setups)
        if (inCorridor) {
          dynamicScore += 12; // Strong bonus for being in corridor
          
          // Extra bonus if aligned AND in corridor (perfect setup)
          if (aligned) {
            dynamicScore += 8;
          }
        }
        
        // Squeeze release in corridor = very strong signal
        if (sqRel && inCorridor) {
          dynamicScore += 10;
        }
        
        // Squeeze on in corridor = building pressure
        if (sqOn && inCorridor && !sqRel) {
          dynamicScore += 5;
        }
        
        // RR bonus (scaled - better RR = higher rank)
        if (rr >= 2.0) {
          dynamicScore += 8; // Excellent RR
        } else if (rr >= 1.5) {
          dynamicScore += 5; // Good RR
        } else if (rr >= 1.0) {
          dynamicScore += 2; // Acceptable RR
        }
        
        // Phase bonus (early phase = better opportunity)
        if (phase < 0.3) {
          dynamicScore += 6; // Very early
        } else if (phase < 0.5) {
          dynamicScore += 3; // Early
        } else if (phase > 0.7) {
          dynamicScore -= 5; // Late phase penalty
        }
        
        // Completion bonus (low completion = more room to run)
        if (comp < 0.3) {
          dynamicScore += 5; // Early in move
        } else if (comp > 0.8) {
          dynamicScore -= 8; // Near completion penalty
        }
        
        // Score strength bonus (strong HTF/LTF scores)
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;
        
        // Phase zone change bonus
        if (phaseZoneChange) {
          dynamicScore += 4;
        }
        
        // Clamp to 0-100 range
        dynamicScore = Math.max(0, Math.min(100, dynamicScore));
        
        return Math.round(dynamicScore);
      }

      function applyFilters(dataObj, filters) {
        const out = [];
        for (const [tickerRaw, d] of Object.entries(dataObj)) {
          if (!d) continue;
          const ticker = String(tickerRaw).trim().toUpperCase();

          // Only show tickers that are in at least one group
          if (!isTickerInGroups(ticker)) continue;

          if (filters.search && !ticker.includes(filters.search.toUpperCase()))
            continue;
          
          // Group filter
          if (filters.group && filters.group !== "ALL") {
            const T = normTicker(ticker);
            const gs = groupsForTicker(T);
            if (filters.group === "ANY") {
              if (gs.length === 0) continue;
            } else if (filters.group === "UNGROUPED") {
              if (gs.length > 0) continue;
            } else {
              if (!gs.includes(filters.group)) continue;
            }
          }

          if (filters.quadrants && !filters.quadrants.includes(d.state))
            continue;
          if (filters.minRank && (Number(d.rank) || 0) < filters.minRank)
            continue;
          if (filters.minRR && (Number(d.rr) || 0) < filters.minRR) continue;
          if (
            filters.maxCompletion &&
            completionForSize(d) > filters.maxCompletion
          )
            continue;
          if (filters.inCorridor) {
            const ent = entryType(d);
            if (!ent.corridor) continue;
          }
          if (filters.squeezeRelease) {
            const flags = d.flags || {};
            if (!flags.sq30_release) continue;
          }

          out.push({ ticker, ...d });
        }
        return out;
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Components
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Native SVG Bubble component (works without Recharts)
      const SVGBubble = memo(({ ticker, onClick, onHover, isHovered, scaleX, scaleY, offsetX, offsetY, showLabels }) => {
        const comp = completionForSize(ticker);
        // Smaller bubbles: reduced from 10+comp*40 to 4+comp*12
        const size = 4 + comp * 12;
        const phase = Number(ticker.phase_pct) || 0;
        const prime = isPrimeBubble(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);

        // Phase-based gradient color
        const color = phaseToColor(phase);
        const opacity = isHovered ? 1 : (prime ? 0.9 : 0.7);
        const borderWidth = prime ? 3 : flags.sq30_release ? 2 : flags.sq30_on ? 2 : 1;
        const borderColor = prime 
          ? "#2ecc71" 
          : flags.sq30_release 
          ? "#00ffff" 
          : flags.sq30_on
          ? "#ffd700"
          : "#ffffff";
        
        const bubbleSize = isHovered ? size * 1.2 : size;

        const x = (Number(ticker.ltf_score) || 0) * scaleX + offsetX;
        const y = (Number(ticker.htf_score) || 0) * scaleY + offsetY;

        // Determine emoji and label position
        const hasSqueeze = flags.sq30_release || flags.sq30_on;
        const emoji = prime ? "‚≠ê" : flags.sq30_release ? "‚ö°" : flags.sq30_on ? "üß®" : "";
        const labelY = y - bubbleSize - (emoji ? 12 : 8);

        return (
          <g
            onClick={() => onClick(ticker.ticker)}
            onMouseEnter={() => onHover(ticker.ticker)}
            onMouseLeave={() => onHover(null)}
            style={{ cursor: "pointer", transition: "all 0.2s ease-out" }}
          >
            {/* Glow effect for prime */}
            {prime && (
              <circle
                cx={x}
                cy={y}
                r={bubbleSize + 2}
                fill="none"
                stroke="#2ecc71"
                strokeWidth="1"
                opacity="0.3"
              />
            )}
            <circle
              cx={x}
              cy={y}
              r={bubbleSize}
              fill={color}
              fillOpacity={opacity}
              stroke={borderColor}
              strokeWidth={borderWidth}
              style={{ transition: "all 0.2s ease-out" }}
            />
            {/* Emoji above bubble */}
            {emoji && (
              <text
                x={x}
                y={labelY}
                textAnchor="middle"
                fontSize={prime ? "14" : "12"}
                fill={prime ? "#2ecc71" : flags.sq30_release ? "#00ffff" : "#ffd700"}
                fontWeight="bold"
                style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
              >
                {emoji}
              </text>
            )}
            {/* Ticker label */}
            {(showLabels || isHovered) && (
              <text
                x={x}
                y={labelY - (emoji ? 14 : 8)}
                textAnchor="middle"
                fontSize="10"
                fill="#e7ecff"
                fontWeight="600"
                style={{ 
                  textShadow: "0 0 4px rgba(0,0,0,0.9)",
                  pointerEvents: "none"
                }}
              >
                {ticker.ticker}
              </text>
            )}
          </g>
        );
      });

      const Bubble = memo(({ ticker, onClick, onHover, isHovered, showLabels }) => {
        const comp = completionForSize(ticker);
        // Smaller bubbles: reduced from 10+comp*40 to 4+comp*12
        const size = 4 + comp * 12;
        const phase = Number(ticker.phase_pct) || 0;
        const prime = isPrimeBubble(ticker);
        const flags = ticker.flags || {};

        // Phase-based gradient color
        const color = phaseToColor(phase);
        const opacity = isHovered ? 1 : (prime ? 0.9 : 0.7);
        const borderWidth = prime ? 3 : flags.sq30_release ? 2 : flags.sq30_on ? 2 : 1;
        const borderColor = prime 
          ? "#2ecc71" 
          : flags.sq30_release 
          ? "#00ffff" 
          : flags.sq30_on
          ? "#ffd700"
          : "#ffffff";
        
        const bubbleSize = isHovered ? size * 1.2 : size;
        const x = Number(ticker.ltf_score) || 0;
        const y = Number(ticker.htf_score) || 0;

        // Determine emoji and label position
        const hasSqueeze = flags.sq30_release || flags.sq30_on;
        const emoji = prime ? "‚≠ê" : flags.sq30_release ? "‚ö°" : flags.sq30_on ? "üß®" : "";
        const labelY = y - bubbleSize - (emoji ? 12 : 8);

        return (
          <g
            onClick={() => onClick(ticker.ticker)}
            onMouseEnter={() => onHover(ticker.ticker)}
            onMouseLeave={() => onHover(null)}
            style={{ cursor: "pointer", transition: "all 0.2s ease-out" }}
          >
            {/* Glow effect for prime */}
            {prime && (
              <circle
                cx={x}
                cy={y}
                r={bubbleSize + 2}
                fill="none"
                stroke="#2ecc71"
                strokeWidth="1"
                opacity="0.3"
              />
            )}
            <circle
              cx={x}
              cy={y}
              r={bubbleSize}
              fill={color}
              fillOpacity={opacity}
              stroke={borderColor}
              strokeWidth={borderWidth}
              style={{ transition: "all 0.2s ease-out" }}
            />
            {/* Emoji above bubble */}
            {emoji && (
              <text
                x={x}
                y={labelY}
                textAnchor="middle"
                fontSize={prime ? "14" : "12"}
                fill={prime ? "#2ecc71" : flags.sq30_release ? "#00ffff" : "#ffd700"}
                fontWeight="bold"
                style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
              >
                {emoji}
              </text>
            )}
            {/* Ticker label */}
            {(showLabels || isHovered) && (
              <text
                x={x}
                y={labelY - (emoji ? 14 : 8)}
                textAnchor="middle"
                fontSize="10"
                fill="#e7ecff"
                fontWeight="600"
                style={{ 
                  textShadow: "0 0 4px rgba(0,0,0,0.9)",
                  pointerEvents: "none"
                }}
              >
                {ticker.ticker}
              </text>
            )}
          </g>
        );
      });

      function BubbleChart({ tickers, onBubbleClick, hoveredTicker, onHover }) {
        const [tooltip, setTooltip] = useState(null);
        const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
        const [showLabels, setShowLabels] = useState(true);
        
        // Fallback: Native SVG chart (works without Recharts)
        if (!RechartsComponents) {
          // Larger chart: increased from 800x600 to 1200x800
          const chartWidth = 1200;
          const chartHeight = 800;
          const margin = 80;
          const plotWidth = chartWidth - 2 * margin;
          const plotHeight = chartHeight - 2 * margin;
          
          // More precise scaling for better granularity
          const scaleX = plotWidth / 100; // -50 to 50 range
          const scaleY = plotHeight / 100;
          const offsetX = margin;
          const offsetY = margin;
          
          const handleMouseMove = (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            setTooltipPos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
          };
          
          return (
            <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-4 relative">
              {/* Label toggle */}
              <div className="absolute top-2 right-2 z-10">
                <button
                  onClick={() => setShowLabels(!showLabels)}
                  className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f] text-xs text-[#93a4d6] hover:bg-[#1a2550] transition-colors"
                >
                  {showLabels ? "Hide Labels" : "Show Labels"}
                </button>
              </div>
              <svg 
                width="100%" 
                height="100%" 
                viewBox={`0 0 ${chartWidth} ${chartHeight}`}
                onMouseMove={handleMouseMove}
                onMouseLeave={() => setTooltip(null)}
                style={{ minHeight: "800px" }}
              >
                {/* Grid with better styling */}
                <defs>
                  <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                    <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#26325f" strokeWidth="0.5" opacity="0.5"/>
                  </pattern>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                    <feMerge>
                      <feMergeNode in="coloredBlur"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />
                
                {/* Axes - Much more visible - Both center lines same style */}
                {/* Vertical center line (x=0) */}
                <line x1={offsetX + 50 * scaleX} y1={offsetY} x2={offsetX + 50 * scaleX} y2={offsetY + plotHeight} stroke="#e7ecff" strokeWidth="3" opacity="0.9" />
                <line x1={offsetX + 50 * scaleX} y1={offsetY} x2={offsetX + 50 * scaleX} y2={offsetY + plotHeight} stroke="#ffffff" strokeWidth="1" opacity="0.5" />
                {/* Horizontal center line (y=0) */}
                <line x1={offsetX} y1={offsetY + plotHeight / 2} x2={offsetX + plotWidth} y2={offsetY + plotHeight / 2} stroke="#e7ecff" strokeWidth="3" opacity="0.9" />
                <line x1={offsetX} y1={offsetY + plotHeight / 2} x2={offsetX + plotWidth} y2={offsetY + plotHeight / 2} stroke="#ffffff" strokeWidth="1" opacity="0.5" />
                {/* Vertical axis line (y-axis) */}
                <line x1={offsetX} y1={offsetY} x2={offsetX} y2={offsetY + plotHeight} stroke="#93a4d6" strokeWidth="2" opacity="0.6" />
                
                {/* Axis labels */}
                <text x={offsetX - 30} y={offsetY + plotHeight / 2} fill="#93a4d6" textAnchor="middle" fontSize="13" fontWeight="600">HTF Score</text>
                <text x={offsetX + plotWidth / 2} y={offsetY + plotHeight + 40} fill="#93a4d6" textAnchor="middle" fontSize="13" fontWeight="600">LTF Score</text>
                
                {/* Axis scale markers */}
                {[-50, -25, 0, 25, 50].map(val => {
                  const x = offsetX + (val + 50) * scaleX;
                  const y = offsetY + plotHeight / 2;
                  return (
                    <g key={`x-${val}`}>
                      <line x1={x} y1={y - 5} x2={x} y2={y + 5} stroke="#93a4d6" strokeWidth="2" />
                      <text x={x} y={y + 20} fill="#93a4d6" textAnchor="middle" fontSize="10">{val}</text>
                    </g>
                  );
                })}
                {[-50, -25, 0, 25, 50].map(val => {
                  const x = offsetX;
                  const y = offsetY + plotHeight - (val + 50) * scaleY;
                  return (
                    <g key={`y-${val}`}>
                      <line x1={x - 5} y1={y} x2={x + 5} y2={y} stroke="#93a4d6" strokeWidth="2" />
                      <text x={x - 15} y={y + 4} fill="#93a4d6" textAnchor="end" fontSize="10">{val}</text>
                    </g>
                  );
                })}
                
                {/* Quadrant labels with better styling */}
                <text x={offsetX + plotWidth * 0.25} y={offsetY + 30} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q1 Prep</text>
                <text x={offsetX + plotWidth * 0.75} y={offsetY + 30} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q2 Bull</text>
                <text x={offsetX + plotWidth * 0.25} y={offsetY + plotHeight - 10} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q3 Bear</text>
                <text x={offsetX + plotWidth * 0.75} y={offsetY + plotHeight - 10} fill="#93a4d6" fontSize="12" fontWeight="600" textAnchor="middle">Q4 Pullback</text>
                
                {/* Corridors */}
                <rect 
                  x={offsetX + (LONG_CORRIDOR.ltfMin + 50) * scaleX} 
                  y={offsetY} 
                  width={(LONG_CORRIDOR.ltfMax - LONG_CORRIDOR.ltfMin) * scaleX} 
                  height={plotHeight / 2} 
                  fill="rgba(46,204,113,0.1)" 
                />
                <rect 
                  x={offsetX + (SHORT_CORRIDOR.ltfMin + 50) * scaleX} 
                  y={offsetY + plotHeight / 2} 
                  width={(SHORT_CORRIDOR.ltfMax - SHORT_CORRIDOR.ltfMin) * scaleX} 
                  height={plotHeight / 2} 
                  fill="rgba(231,76,60,0.1)" 
                />
                
                {/* Bubbles */}
                {tickers.map(ticker => (
                  <SVGBubble
                    key={ticker.ticker}
                    ticker={ticker}
                    onClick={onBubbleClick}
                    onHover={(t) => {
                      onHover(t);
                      if (t) setTooltip(tickers.find(tt => tt.ticker === t));
                    }}
                    isHovered={hoveredTicker === ticker.ticker}
                    scaleX={scaleX}
                    scaleY={-scaleY}
                    offsetX={offsetX + 50 * scaleX}
                    offsetY={offsetY + plotHeight - 50 * scaleY}
                    showLabels={showLabels}
                  />
                ))}
              </svg>
              
                {/* Tooltip */}
              {tooltip && (
                <div 
                  className="absolute bg-[#121a33] border-2 border-[#26325f] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl fade-in"
                  style={{ 
                    left: tooltipPos.x + 10, 
                    top: tooltipPos.y - 10,
                    minWidth: "200px"
                  }}
                >
                  <div className="font-bold text-base mb-2">{tooltip.ticker}</div>
                  {isPrimeBubble(tooltip) && (
                    <div className="mb-2 px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold text-center">
                      ‚≠ê PRIME SETUP
                    </div>
                  )}
                  <div className="space-y-1">
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Rank</span>
                      <span className="font-semibold">{tooltip.rank || "‚Äî"}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">RR</span>
                      <span className="font-semibold">{tooltip.rr ? Number(tooltip.rr).toFixed(2) : "‚Äî"}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">State</span>
                      <span className="font-semibold">{tooltip.state || "‚Äî"}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Phase</span>
                      <span className="font-semibold" style={{ color: phaseToColor(Number(tooltip.phase_pct) || 0) }}>
                        {Math.round((Number(tooltip.phase_pct) || 0) * 100)}%
                        {tooltip.phase_zone && ` (${tooltip.phase_zone})`}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Completion</span>
                      <span className="font-semibold">{Math.round(completionForSize(tooltip) * 100)}%</span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }
        
        // Recharts version (if loaded)
        const { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } = RechartsComponents;
        
        const data = useMemo(
          () =>
            tickers.map((t) => ({
              x: Number(t.ltf_score) || 0,
              y: Number(t.htf_score) || 0,
              ticker: t,
            })),
          [tickers]
        );

        return (
          <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-4">
            <ResponsiveContainer width="100%" height="100%">
              <ScatterChart
                margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#26325f" />
                <XAxis
                  type="number"
                  dataKey="x"
                  name="LTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <YAxis
                  type="number"
                  dataKey="y"
                  name="HTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <Tooltip
                  content={({ active, payload }) => {
                    if (!active || !payload?.[0]) return null;
                    const t = payload[0].payload.ticker;
                    return (
                      <div className="bg-[#121a33] border border-[#26325f] rounded p-3 text-sm">
                        <div className="font-bold">{t.ticker}</div>
                        <div>Rank: {t.rank || "‚Äî"}</div>
                        <div>RR: {t.rr ? Number(t.rr).toFixed(2) : "‚Äî"}</div>
                        <div>State: {t.state || "‚Äî"}</div>
                        {isPrimeBubble(t) && (
                          <div className="text-[#2ecc71]">‚≠ê PRIME SETUP</div>
                        )}
                      </div>
                    );
                  }}
                />
                <Scatter data={data}>
                  {data.map((entry, index) => (
                    <Bubble
                      key={entry.ticker.ticker}
                      ticker={entry.ticker}
                      onClick={onBubbleClick}
                      onHover={onHover}
                      isHovered={hoveredTicker === entry.ticker.ticker}
                    />
                  ))}
                </Scatter>
              </ScatterChart>
            </ResponsiveContainer>
          </div>
        );
      }

      // Format date/time from timestamp
      function formatTriggerDateTime(ts) {
        if (!ts || typeof ts !== "number") return "‚Äî";
        const date = new Date(ts);
        return {
          date: date.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }),
          time: date.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true }),
        };
      }

      // Get "Why" reason from ticker data
      function getWhyReason(ticker) {
        const reasons = ticker.reasons || [];
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        
        if (flags.sq30_release) return "Squeeze Release";
        if (flags.phase_zone_change) return "Phase Zone Change";
        if (state.includes("BULL") && state.includes("BULL")) return "Both Timeframes Bullish";
        if (state.includes("BEAR") && state.includes("BEAR")) return "Both Timeframes Bearish";
        if (reasons.length > 0) return reasons[0];
        return "Setup Active";
      }

      // Get direction from state
      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL")) return { text: "LONG", color: "text-green-400", bg: "bg-green-500/20" };
        if (state.includes("BEAR")) return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: "‚Äî", color: "text-[#93a4d6]", bg: "bg-[#26325f]" };
      }

      function SetupCard({ ticker, isSelected, onClick }) {
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const momentumElite = !!flags.momentum_elite;
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const dir = getDirection(ticker);
        const why = getWhyReason(ticker);
        const triggerDT = formatTriggerDateTime(ticker.trigger_ts);
        const tpLevels = ticker.tp_levels || [];
        const comp = completionForSize(ticker);

        return (
          <div
            className={`p-2 rounded-lg border cursor-pointer transition-all ${
              isSelected
                ? "border-blue-500 bg-blue-500/10 shadow-lg"
                : momentumElite
                ? "border-purple-500 bg-purple-500/15 momentum-elite-glow border-2"
                : prime
                ? "border-green-500 bg-green-500/10 prime-glow"
                : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0]"
            }`}
            onClick={onClick}
          >
            {/* Header */}
            <div className="flex items-center justify-between mb-1.5">
              <div className="flex items-center gap-1.5">
                <span className="font-bold text-sm">{ticker.ticker}</span>
                {momentumElite && <span className="text-purple-400 text-xs font-bold" title="Momentum Elite">üöÄ</span>}
                {prime && <span className="text-green-500 text-xs">‚≠ê</span>}
                {flags.sq30_release && <span className="text-cyan-400 text-xs">‚ö°</span>}
                {flags.sq30_on && <span className="text-yellow-400 text-xs">üß®</span>}
              </div>
              <div className="flex items-center gap-1.5">
                {ticker.price && (
                  <span className="text-xs font-semibold text-white">
                    ${Number(ticker.price).toFixed(2)}
                  </span>
                )}
                <div className={`px-1.5 py-0.5 rounded font-bold text-[10px] ${dir.bg} ${dir.color}`}>
                  {dir.text}
                </div>
              </div>
            </div>

            {/* Why and Action - Compact */}
            <div className="mb-1.5">
              <div className="text-[9px] text-[#93a4d6] mb-0.5">Why: <span className="text-white font-semibold text-[10px]">{why}</span></div>
              {(() => {
                const actionInfo = getActionDescription(ticker);
                return (
                  <div className={`text-[9px] ${actionInfo.color} font-semibold`}>
                    {actionInfo.action}
                  </div>
                );
              })()}
            </div>

            {/* Price, SL, TP - Compact inline */}
            <div className="grid grid-cols-3 gap-1.5 mb-1.5 text-[9px]">
              {ticker.price && (
                <div>
                  <div className="text-[8px] text-[#93a4d6]">Price</div>
                  <div className="font-semibold text-white">${Number(ticker.price).toFixed(2)}</div>
                </div>
              )}
              <div>
                <div className="text-[8px] text-[#93a4d6]">SL</div>
                <div className="font-semibold text-red-400">
                  {ticker.sl ? `$${Number(ticker.sl).toFixed(2)}` : "‚Äî"}
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6]">TP</div>
                <div className="font-semibold text-green-400">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "‚Äî"}
                </div>
              </div>
            </div>

            {/* Trigger Info - Compact */}
            {ticker.trigger_price && (
              <div className="mb-1.5 text-[9px]">
                <span className="text-[#93a4d6]">Trigger: </span>
                <span className="text-white font-semibold">${Number(ticker.trigger_price).toFixed(2)}</span>
                {ticker.trigger_ts && (
                  <>
                    <span className="text-[#93a4d6] ml-2">@ </span>
                    <span className="text-white text-[8px]">{triggerDT.date} {triggerDT.time}</span>
                  </>
                )}
              </div>
            )}

            {/* Phase and Completion - Compact */}
            <div className="grid grid-cols-2 gap-1.5 mb-1.5">
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Phase</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full transition-all"
                    style={{
                      width: `${phase * 100}%`,
                      backgroundColor: phaseColor,
                    }}
                  />
                </div>
                <div className="text-[9px] mt-0.5" style={{ color: phaseColor }}>
                  {Math.round(phase * 100)}%
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Complete</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full bg-blue-500 transition-all"
                    style={{ width: `${comp * 100}%` }}
                  />
                </div>
                <div className="text-[9px] mt-0.5 text-blue-400">
                  {Math.round(comp * 100)}%
                </div>
              </div>
            </div>

            {/* TP Levels - Compact */}
            {tpLevels.length > 1 && (
              <div className="mb-1.5">
                <div className="flex flex-wrap gap-1">
                  {tpLevels.slice(0, 2).map((tp, idx) => (
                    <span
                      key={idx}
                      className="px-1 py-0.5 rounded bg-green-500/20 text-green-400 text-[8px] font-mono"
                    >
                      TP{idx + 1}: ${Number(tp).toFixed(2)}
                    </span>
                  ))}
                  {tpLevels.length > 2 && (
                    <span className="px-1 py-0.5 rounded bg-[#26325f] text-[#93a4d6] text-[8px]">
                      +{tpLevels.length - 2}
                    </span>
                  )}
                </div>
              </div>
            )}

            {/* Additional Info - Compact */}
            <div className="flex items-center justify-between text-[9px] pt-1 border-t border-[#26325f]/50">
              <div className="flex gap-1">
                <span className="px-1 py-0.5 rounded bg-[#26325f]">
                  R{ticker.rank || "‚Äî"}
                </span>
                {ticker.rr && (
                  <span className="px-1 py-0.5 rounded bg-[#26325f]">
                    RR{Number(ticker.rr).toFixed(1)}
                  </span>
                )}
              </div>
              {ent.corridor && (
                <span className={`px-1 py-0.5 rounded text-[8px] font-semibold ${dir.bg} ${dir.color}`}>
                  {ent.side}
                </span>
              )}
            </div>
          </div>
        );
      }

      // Generate plain English action description
      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const momentumPct = ticker.momentum_pct || {};
        
        const isAligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback = state === "HTF_BULL_LTF_PULLBACK" || state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        
        // High completion = near target, consider exit/trim
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(0)}% completion, indicating the move is near its target. ${momentumElite ? 'Despite Momentum Elite status, ' : ''}Consider taking profits or trimming 50-75% of position to lock in gains while allowing runners to continue. Monitor for signs of reversal or continuation beyond TP levels.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20"
          };
        }
        
        // High phase = late in cycle, be cautious
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(0)}% indicates late-cycle conditions. ${momentumElite ? 'While Momentum Elite suggests continued strength, ' : ''}Market is approaching exhaustion zone. Wait for pullback to better entry or trim existing positions by 30-50% to reduce risk. Look for phase reset or continuation signals before adding size.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20"
          };
        }
        
        // Momentum Elite + Prime setup = strongest signal
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          const momentumStr = momentumPct.month != null ? ` with ${Number(momentumPct.month).toFixed(0)}% monthly momentum` : '';
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock${momentumStr} showing Prime setup with exceptional alignment. Both HTF and LTF are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(2)}:1). This represents a high-probability setup with strong fundamentals backing the technical signal. Consider entering with full position size, using TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // Momentum Elite + Squeeze release = strong momentum signal
        if (momentumElite && sqRelease && inCorridor && isAligned) {
          const momentumStr = momentumPct.week != null ? ` (${Number(momentumPct.week).toFixed(0)}% weekly)` : '';
          return {
            action: "Initiate Position - Momentum Breakout",
            description: `Momentum Elite stock${momentumStr} experiencing squeeze release with timeframe alignment. This indicates pent-up energy being released in the direction of the trend. The combination of Momentum Elite fundamentals and technical squeeze release creates a high-probability momentum continuation setup. Enter on pullback to corridor or on break of squeeze high/low, targeting TP levels.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // Prime setup with good conditions = initiate
        if (isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - Prime Setup",
            description: `Prime setup detected with strong technical alignment. Both timeframes are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(2)}:1). ${momentumElite ? 'Momentum Elite status adds fundamental strength to this technical setup. ' : ''}Early phase (${(phase * 100).toFixed(0)}%) with low completion (${(comp * 100).toFixed(0)}%) suggests room to run. Consider entering position, using SL for risk management and TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // Momentum Elite + In corridor = quality momentum play
        if (momentumElite && inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Momentum Elite Setup",
            description: `Momentum Elite stock in favorable technical setup. Price is in entry corridor with both timeframes aligned, early phase (${(phase * 100).toFixed(0)}%), and low completion (${(comp * 100).toFixed(0)}%) indicating room for continuation. ${sqRelease ? 'Squeeze release adds momentum confirmation. ' : sqOn ? 'Squeeze building suggests potential breakout. ' : ''}The combination of strong fundamentals (Momentum Elite) and favorable technicals creates a quality setup. Enter on confirmation or pullback, targeting TP levels.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20"
          };
        }
        
        // Squeeze release in corridor = strong signal
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. This indicates pent-up energy being released in the direction of the trend. ${momentumElite ? 'Momentum Elite status adds fundamental backing to this technical signal. ' : ''}Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(comp * 100).toFixed(0)}%) suggest continuation potential. Enter on pullback or break, using SL for protection and TP levels as targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20"
          };
        }
        
        // In corridor and aligned = good setup
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(comp * 100).toFixed(0)}%) suggest room to run. ${momentumElite ? 'Momentum Elite status adds quality to this setup. ' : ''}${sqOn ? 'Squeeze building suggests potential momentum. ' : ''}Rank is ${rank >= 70 ? 'strong' : 'moderate'} (${rank}) with RR of ${rr.toFixed(2)}:1. Monitor for entry confirmation or wait for squeeze release signal before initiating position.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20"
          };
        }
        
        // Pullback setup = wait for confirmation
        if (isPullback && !inCorridor) {
          return {
            action: "Wait for Entry - Pullback Setup",
            description: `Pullback detected (${state}) but price not yet in entry corridor. ${momentumElite ? 'Momentum Elite status suggests this pullback may be shallow and could present a quality entry. ' : ''}Wait for price to enter corridor (Q1‚ÜíQ2 for LONG, Q4‚ÜíQ3 for SHORT) before considering entry. ${sqOn ? 'Squeeze building suggests potential momentum when released. ' : ''}Monitor for corridor entry and confirmation signals before initiating position.`,
            color: "text-cyan-400",
            bg: "bg-cyan-500/20"
          };
        }
        
        // Squeeze on but not released = building pressure
        if (sqOn && !sqRelease) {
          return {
            action: "Monitor Closely - Squeeze Building",
            description: `Squeeze building but not yet released, indicating pressure is accumulating. ${momentumElite ? 'Momentum Elite status suggests when released, the move could be significant. ' : ''}${inCorridor ? 'Price is in entry corridor, making this a high-probability setup when squeeze releases. ' : 'Wait for price to enter corridor and squeeze to release before entering. '}Monitor closely for squeeze release signal, which typically provides strong directional momentum.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20"
          };
        }
        
        // Default: wait
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. ${momentumElite ? 'Momentum Elite status is positive, but ' : ''}Technical conditions need improvement. ${!inCorridor ? 'Price needs to enter entry corridor. ' : ''}${!isAligned ? 'Timeframes need better alignment. ' : ''}${comp > 0.5 ? `Completion is high (${(comp * 100).toFixed(0)}%), reducing upside potential. ` : ''}Wait for better conditions, confirmation signals, or entry corridor alignment before considering position.`,
          color: "text-[#93a4d6]",
          bg: "bg-[#26325f]"
        };
      }

      function QuickFilters({ filters, onFilterChange }) {
        const presets = [
          {
            label: "Prime Only",
            filter: { minRank: 75, minRR: 1.5, maxCompletion: 0.4 },
            icon: "‚≠ê",
          },
          { 
            label: "In Corridor", 
            filter: { inCorridor: true },
            icon: "üéØ",
          },
          { 
            label: "Squeeze Release", 
            filter: { squeezeRelease: true },
            icon: "‚ö°",
          },
        ];

        const isActive = (preset) => {
          if (preset.label === "Prime Only") {
            return filters.minRank === 75 && filters.minRR === 1.5 && filters.maxCompletion === 0.4;
          }
          if (preset.label === "In Corridor") {
            return filters.inCorridor === true;
          }
          if (preset.label === "Squeeze Release") {
            return filters.squeezeRelease === true;
          }
          return false;
        };

        const handlePresetClick = (preset) => {
          const active = isActive(preset);
          if (active) {
            // Toggle off - reset to defaults
            if (preset.label === "Prime Only") {
              onFilterChange({ minRank: 0, minRR: 0, maxCompletion: 1.01 });
            } else if (preset.label === "In Corridor") {
              onFilterChange({ inCorridor: false });
            } else if (preset.label === "Squeeze Release") {
              onFilterChange({ squeezeRelease: false });
            }
          } else {
            // Toggle on - apply filter
            onFilterChange(preset.filter);
          }
        };

        // Build group options
        const groupKeys = Object.keys(GROUPS).filter(Boolean);
        const ordered = [];
        for (const k of GROUP_ORDER) if (groupKeys.includes(k)) ordered.push(k);
        const remaining = groupKeys.filter((k) => !ordered.includes(k)).sort();
        ordered.push(...remaining);

        return (
          <div className="space-y-3 mb-4">
            <div className="flex gap-2 flex-wrap">
              {presets.map((preset, i) => {
                const active = isActive(preset);
                return (
                  <button
                    key={i}
                    className={`px-4 py-2 rounded-lg border text-sm font-semibold transition-all ${
                      active
                        ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                        : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
                    }`}
                    onClick={() => handlePresetClick(preset)}
                  >
                    {preset.icon} {preset.label}
                  </button>
                );
              })}
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm text-[#93a4d6] font-semibold">Group:</label>
              <select
                value={filters.group || "ALL"}
                onChange={(e) => onFilterChange({ group: e.target.value })}
                className="px-3 py-2 rounded-lg border border-[#26325f] bg-[#0f1630] text-[#93a4d6] text-sm hover:bg-[#1a2550] focus:outline-none focus:border-[#3a4aa0]"
              >
                <option value="ALL">All Tickers</option>
                <option value="ANY">Any Group</option>
                <option value="UNGROUPED">Ungrouped</option>
                <option value="__DIVIDER__" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
                {ordered.map((key) => (
                  <option key={key} value={key}>
                    {GROUP_LABELS[key] || key}
                  </option>
                ))}
              </select>
            </div>
          </div>
        );
      }

      // Helper: Get quadrant from state
      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK") return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL") return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR") return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK") return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      // Pattern detection
      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map(p => p.state).filter(Boolean);
        const safeFlags = flags || {};
        
        // Pattern 1: Clean Q1‚ÜíQ2 or Q4‚ÜíQ3 transition (ideal entry)
        for (let i = 1; i < states.length; i++) {
          if (states[i-1] === "HTF_BULL_LTF_PULLBACK" && states[i] === "HTF_BULL_LTF_BULL") {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1‚ÜíQ2 transition (Bull Entry)",
              quadrant: "Q1‚ÜíQ2",
              timestamp: trail[i].ts,
              confidence: "HIGH"
            });
          }
          if (states[i-1] === "HTF_BEAR_LTF_PULLBACK" && states[i] === "HTF_BEAR_LTF_BEAR") {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4‚ÜíQ3 transition (Bear Entry)",
              quadrant: "Q4‚ÜíQ3",
              timestamp: trail[i].ts,
              confidence: "HIGH"
            });
          }
        }

        // Pattern 2: Momentum Elite + Setup quadrant
        const currentState = states[states.length - 1];
        if ((currentState === "HTF_BULL_LTF_PULLBACK" || currentState === "HTF_BEAR_LTF_PULLBACK") && safeFlags.momentum_elite) {
          patterns.push({
            type: "ELITE_SETUP",
            description: "Momentum Elite in Setup Quadrant",
            quadrant: getQuadrantFromState(currentState)?.name,
            confidence: "HIGH"
          });
        }

        // Pattern 3: Squeeze release in setup quadrant
        const lastPoint = trail[trail.length - 1];
        if (lastPoint && lastPoint.flags && lastPoint.flags.sq30_release) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "SQUEEZE_SETUP",
              description: "Squeeze Release in Setup Quadrant",
              quadrant: q.name,
              confidence: "HIGH"
            });
          }
        }

        // Pattern 4: Multiple quadrant visits (chop vs clean)
        const uniqueQuads = new Set(states.map(s => getQuadrantFromState(s)?.q).filter(Boolean));
        if (uniqueQuads.size > 2 && states.length > 5) {
          patterns.push({
            type: "CHOPPY",
            description: "Multiple quadrant visits (choppy action)",
            confidence: "MEDIUM"
          });
        } else if (uniqueQuads.size === 1 && states.length >= 3) {
          patterns.push({
            type: "STABLE",
            description: "Stable quadrant (consistent state)",
            quadrant: getQuadrantFromState(states[0])?.name,
            confidence: "MEDIUM"
          });
        }

        // Pattern 5: Phase zone change in setup
        if (lastPoint && lastPoint.flags && lastPoint.flags.phase_zone_change) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "PHASE_SHIFT",
              description: "Phase zone change in Setup",
              quadrant: q.name,
              confidence: "MEDIUM"
            });
          }
        }

        return patterns;
      }

      // Separate component for Quadrant Progression to properly use hooks
      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = React.useState([]);
        const [loading, setLoading] = React.useState(false); // Start as false
        const [hasLoaded, setHasLoaded] = React.useState(false);
        
        React.useEffect(() => {
          // Defer trail loading to not block initial render
          if (!hasLoaded) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const response = await fetch(`https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(ticker.ticker)}`);
                const data = await response.json();
                if (data.ok && Array.isArray(data.trail)) {
                  setTrail(data.trail);
                }
              } catch (e) {
                console.error("Failed to load trail:", e);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 200); // Small delay to not block UI
            return () => clearTimeout(timeoutId);
          }
        }, [ticker.ticker, hasLoaded]);

        const patterns = detectPatterns(trail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = trail.map(p => getQuadrantFromState(p.state)).filter(Boolean);

        return (
          <div className="mb-4 p-4 bg-[#0f1630] rounded-lg border border-[#26325f]">
            <div className="text-sm font-bold mb-3 text-[#93a4d6]">Quadrant Progression</div>
            
            {/* Quadrant Map */}
            <div className="grid grid-cols-2 gap-2 mb-4">
              {/* Q1 - Bull Setup */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 1 
                  ? "border-blue-400 bg-blue-500/20" 
                  : quadHistory.some(q => q && q.q === 1)
                  ? "border-blue-500/50 bg-blue-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-blue-400">Q1: Bull Setup</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BULL_LTF_PULLBACK</div>
              </div>
              
              {/* Q2 - Bull Momentum */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 2 
                  ? "border-green-400 bg-green-500/20" 
                  : quadHistory.some(q => q && q.q === 2)
                  ? "border-green-500/50 bg-green-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-green-400">Q2: Bull Momentum</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BULL_LTF_BULL</div>
              </div>
              
              {/* Q4 - Bear Setup */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 4 
                  ? "border-orange-400 bg-orange-500/20" 
                  : quadHistory.some(q => q && q.q === 4)
                  ? "border-orange-500/50 bg-orange-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-orange-400">Q4: Bear Setup</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BEAR_LTF_PULLBACK</div>
              </div>
              
              {/* Q3 - Bear Momentum */}
              <div className={`p-3 rounded-lg border-2 ${
                currentQuad?.q === 3 
                  ? "border-red-400 bg-red-500/20" 
                  : quadHistory.some(q => q && q.q === 3)
                  ? "border-red-500/50 bg-red-500/10"
                  : "border-[#26325f] bg-[#0a0f1f]"
              }`}>
                <div className="text-xs font-bold text-red-400">Q3: Bear Momentum</div>
                <div className="text-[10px] text-[#93a4d6] mt-1">HTF_BEAR_LTF_BEAR</div>
              </div>
            </div>

            {/* Path Visualization */}
            {trail.length > 0 && (
              <div className="mb-4">
                <div className="text-xs font-semibold text-[#93a4d6] mb-2">Path ({trail.length} points)</div>
                <div className="flex items-center gap-1 flex-wrap">
                  {quadHistory.map((q, idx) => {
                    if (!q) return null;
                    const isLast = idx === quadHistory.length - 1;
                    const colorClasses = {
                      blue: isLast ? "bg-blue-500/30 border-2 border-blue-400 text-blue-300" : "bg-blue-500/10 border border-blue-500/50 text-blue-400",
                      green: isLast ? "bg-green-500/30 border-2 border-green-400 text-green-300" : "bg-green-500/10 border border-green-500/50 text-green-400",
                      red: isLast ? "bg-red-500/30 border-2 border-red-400 text-red-300" : "bg-red-500/10 border border-red-500/50 text-red-400",
                      orange: isLast ? "bg-orange-500/30 border-2 border-orange-400 text-orange-300" : "bg-orange-500/10 border border-orange-500/50 text-orange-400"
                    };
                    return (
                      <React.Fragment key={idx}>
                        <div className={`px-2 py-1 rounded text-[10px] font-bold ${colorClasses[q.color] || colorClasses.blue}`}>
                          {q.name}
                        </div>
                        {idx < quadHistory.length - 1 && (
                          <span className="text-[#93a4d6] text-xs">‚Üí</span>
                        )}
                      </React.Fragment>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Pattern Detection */}
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs font-bold text-yellow-400 mb-2">üéØ Detected Patterns</div>
                <div className="space-y-2">
                  {patterns.map((pattern, idx) => (
                    <div 
                      key={idx}
                      className={`p-2 rounded border ${
                        pattern.confidence === "HIGH"
                          ? "bg-yellow-500/20 border-yellow-400/50"
                          : "bg-blue-500/10 border-blue-500/30"
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="text-xs font-bold text-white">{pattern.description}</div>
                          {pattern.quadrant && (
                            <div className="text-[10px] text-[#93a4d6] mt-0.5">{pattern.quadrant}</div>
                          )}
                        </div>
                        <span className={`text-[10px] px-1.5 py-0.5 rounded ${
                          pattern.confidence === "HIGH"
                            ? "bg-yellow-500/30 text-yellow-300"
                            : "bg-blue-500/30 text-blue-300"
                        }`}>
                          {pattern.confidence}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {loading && (
              <div className="text-xs text-[#93a4d6] text-center py-2">Loading history...</div>
            )}
          </div>
        );
      }

      function TickerDetails({ ticker, onClose }) {
        if (!ticker) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);

        return (
          <>
            {/* Backdrop */}
            <div 
              className="fixed inset-0 bg-black/60 z-[9998]"
              onClick={onClose}
              style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0 }}
            />
            {/* Overlay Card */}
            <div className="fixed inset-0 z-[9999] flex items-center justify-center p-4 pointer-events-none" style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0 }}>
              <div 
                className="bg-[#121a33] border-2 border-[#26325f] rounded-xl p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto slide-in pointer-events-auto shadow-2xl"
                onClick={(e) => e.stopPropagation()}
              >
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold">{ticker.ticker}</h3>
              <button
                onClick={onClose}
                className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
              >
                ‚úï
              </button>
            </div>

            {flags.momentum_elite && (
              <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                <div className="text-center font-bold text-purple-300 mb-2">
                  üöÄ MOMENTUM ELITE üöÄ
                </div>
                <div className="text-xs text-purple-200/80 font-normal mb-2">
                  High-quality momentum stock with strong fundamentals
                </div>
                {ticker.momentum_pct && (
                  <div className="mt-2 pt-2 border-t border-purple-400/30">
                    <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">Momentum Performance:</div>
                    <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                      {ticker.momentum_pct.week != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">1W:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.week) >= 10 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.week).toFixed(1)}%
                          </span>
                        </div>
                      )}
                      {ticker.momentum_pct.month != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">1M:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.month) >= 25 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.month).toFixed(1)}%
                          </span>
                        </div>
                      )}
                      {ticker.momentum_pct.three_months != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">3M:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.three_months) >= 50 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.three_months).toFixed(1)}%
                          </span>
                        </div>
                      )}
                      {ticker.momentum_pct.six_months != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-300/80">6M:</span>
                          <span className={`font-bold ${Number(ticker.momentum_pct.six_months) >= 100 ? 'text-green-400' : 'text-purple-300'}`}>
                            {Number(ticker.momentum_pct.six_months).toFixed(1)}%
                          </span>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}

            {prime && (
              <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                ‚≠ê PRIME SETUP ‚≠ê
              </div>
            )}

            {/* Bias/Direction - Prominent */}
            {(() => {
              const dir = getDirection(ticker);
              return (
                <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                  <div className="text-sm text-[#93a4d6] mb-2">Bias / Direction</div>
                  <div className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}>
                    {dir.text === "LONG" ? "üìà LONG" : dir.text === "SHORT" ? "üìâ SHORT" : dir.text}
                  </div>
                </div>
              );
            })()}

            {/* Action Description */}
            <div className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}>
              <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                {actionInfo.action}
              </div>
              <div className="text-sm text-[#93a4d6]">
                {actionInfo.description}
              </div>
            </div>

            {/* Quadrant Progression Visualization */}
            <QuadrantProgression ticker={ticker} flags={flags} />

            {/* Phase indicator */}
            <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm text-[#93a4d6]">Phase</span>
                <span className="text-sm font-semibold" style={{ color: phaseColor }}>
                  {Math.round(phase * 100)}%
                  {ticker.phase_zone && ` (${ticker.phase_zone})`}
                </span>
              </div>
              <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                <div 
                  className="h-full rounded-full transition-all duration-500"
                  style={{ 
                    width: `${phase * 100}%`,
                    backgroundColor: phaseColor,
                    boxShadow: `0 0 8px ${phaseColor}40`
                  }}
                />
              </div>
            </div>

            <div className="space-y-2.5 text-sm">
              {(() => {
                const dynamicRank = computeDynamicRank(ticker);
                const baseRank = Number(ticker.rank) || 0;
                const allTickersWithRank = tickers.map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }));
                const sortedByDynamic = [...allTickersWithRank].sort((a, b) => b.dynamicRank - a.dynamicRank);
                const top40Position = sortedByDynamic.findIndex(t => t.ticker === ticker.ticker) + 1;
                const isInTop40 = top40Position > 0 && top40Position <= 40;
                
                return (
                  <>
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Rank</span>
                    <span className="font-semibold">
                      {dynamicRank !== baseRank 
                        ? `${dynamicRank} (base score: ${baseRank})` 
                        : dynamicRank}
                    </span>
                  </div>
                  {isInTop40 && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Top 40 Position</span>
                      <span className="font-semibold text-yellow-400">
                        #{top40Position} of 40
                      </span>
                    </div>
                  )}
                  </>
                );
              })()}
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">RR</span>
                <span className="font-semibold">{ticker.rr ? Number(ticker.rr).toFixed(2) : "‚Äî"}</span>
              </div>
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">State</span>
                <span className="font-semibold">{ticker.state || "‚Äî"}</span>
              </div>
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">Completion</span>
                <span className="font-semibold">{Math.round(completionForSize(ticker) * 100)}%</span>
              </div>
              {ent.corridor && (
                <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                  <span className="text-[#93a4d6]">Corridor</span>
                  <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                    {ent.side}
                  </span>
                </div>
              )}
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">Current Price</span>
                <span className="font-semibold text-lg">
                  {ticker.price ? `$${Number(ticker.price).toFixed(2)}` : "‚Äî"}
                </span>
              </div>
              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                <span className="text-[#93a4d6]">TP (Primary)</span>
                <span className="font-semibold">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "‚Äî"}
                  {ticker.tp_levels && Array.isArray(ticker.tp_levels) && ticker.tp_levels.length > 0 && (() => {
                    const firstTp = ticker.tp_levels[0];
                    const tpInfo = typeof firstTp === 'object' && firstTp !== null ? firstTp : { price: firstTp };
                    if (tpInfo.label) {
                      const refParts = [];
                      if (tpInfo.timeframe) refParts.push(tpInfo.timeframe);
                      if (tpInfo.multiplier != null && !isNaN(tpInfo.multiplier)) {
                        refParts.push(`${Number(tpInfo.multiplier).toFixed(3)}x ATR`);
                      }
                      const refStr = refParts.length > 0 ? ` (${tpInfo.label} - ${refParts.join(', ')})` : ` (${tpInfo.label})`;
                      return refStr;
                    }
                    return '';
                  })()}
                </span>
              </div>
              {ticker.tp_levels && Array.isArray(ticker.tp_levels) && ticker.tp_levels.length > 0 && (
                <div className="py-1 border-b border-[#26325f]/50">
                  <div className="text-[#93a4d6] text-xs mb-2 font-semibold">TP Levels</div>
                  <div className="space-y-1.5 max-h-48 overflow-y-auto">
                    {ticker.tp_levels.map((tp, idx) => {
                      // Handle both old format (just price) and new format (object with metadata)
                      const tpInfo = typeof tp === 'object' && tp !== null 
                        ? tp 
                        : { price: tp, label: `TP${idx + 1}` };
                      const price = Number(tpInfo.price || tp);
                      const label = tpInfo.label || `TP${idx + 1}`;
                      const source = tpInfo.source || '';
                      const type = tpInfo.type || '';
                      const confidence = tpInfo.confidence || null;
                      
                      // Build reference string from all available metadata
                      const referenceParts = [];
                      if (tpInfo.timeframe) referenceParts.push(tpInfo.timeframe);
                      if (tpInfo.multiplier != null && !isNaN(tpInfo.multiplier)) {
                        referenceParts.push(`${Number(tpInfo.multiplier).toFixed(3)}x ATR`);
                      }
                      if (tpInfo.source) referenceParts.push(tpInfo.source);
                      if (tpInfo.type) referenceParts.push(tpInfo.type);
                      const referenceStr = referenceParts.length > 0 ? referenceParts.join(' ‚Ä¢ ') : null;
                      
                      return (
                        <div key={idx} className="flex items-start justify-between p-1.5 rounded bg-[#0f1630] border border-[#26325f]/50 hover:border-[#3a4aa0] transition-colors">
                          <div className="flex-1">
                            <div className="flex items-center gap-2 flex-wrap">
                              <span className="text-xs font-semibold text-green-400">{label}</span>
                              <span className="text-xs font-mono text-white font-bold">${price.toFixed(2)}</span>
                              {confidence !== null && (
                                <span className={`text-[10px] px-1 py-0.5 rounded ${
                                  confidence >= 0.8 ? 'bg-green-500/20 text-green-400' :
                                  confidence >= 0.6 ? 'bg-yellow-500/20 text-yellow-400' :
                                  'bg-orange-500/20 text-orange-400'
                                }`}>
                                  {Math.round(confidence * 100)}%
                                </span>
                              )}
                            </div>
                            {referenceStr && (
                              <div className="text-[10px] text-[#93a4d6] mt-1 italic">
                                {referenceStr}
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
              <div className="flex justify-between items-center py-1">
                <span className="text-[#93a4d6]">SL</span>
                <span className="font-semibold">{ticker.sl ? Number(ticker.sl).toFixed(2) : "‚Äî"}</span>
              </div>
            </div>

            {/* Flags */}
            {(flags.sq30_on || flags.sq30_release || flags.phase_dot || flags.phase_zone_change) && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs text-[#93a4d6] mb-2">Flags:</div>
                <div className="flex flex-wrap gap-2">
                  {flags.sq30_on && (
                    <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                      üß® Squeeze ON
                    </span>
                  )}
                  {flags.sq30_release && (
                    <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                      ‚ö° Squeeze Release
                    </span>
                  )}
                  {flags.phase_dot && (
                    <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                      Phase Dot
                    </span>
                  )}
                  {flags.phase_zone_change && (
                    <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                      Zone Change
                    </span>
                  )}
                </div>
              </div>
            )}

            <div className="mt-4 pt-4 border-t border-[#26325f]">
              <a
                href={`https://www.tradingview.com/chart/MgotVBUg/?symbol=${encodeURIComponent(
                  ticker.ticker
                )}`}
                target="_blank"
                rel="noopener noreferrer"
                className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
              >
                üìä Open in TradingView
              </a>
            </div>
              </div>
            </div>
          </>
        );
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Main App
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function App() {
        const { data, loading, error, lastUpdate, refetch } = useTickerData();
        const [filters, setFilters] = useState({
          search: "",
          quadrants: [
            "HTF_BULL_LTF_PULLBACK",
            "HTF_BULL_LTF_BULL",
            "HTF_BEAR_LTF_BEAR",
            "HTF_BEAR_LTF_PULLBACK",
          ],
          minRank: 0,
          minRR: 0,
          maxCompletion: 1.01,
          group: "ALL",
        });
        const [selectedTicker, setSelectedTicker] = useState(null);
        const [hoveredTicker, setHoveredTicker] = useState(null);
        
        // Debug: log when selectedTicker changes
        React.useEffect(() => {
          if (selectedTicker) {
            console.log('Selected ticker:', selectedTicker);
          }
        }, [selectedTicker]);

        const debouncedSearch = useDebounce(filters.search, 300);
        const effectiveFilters = { ...filters, search: debouncedSearch };

        const tickers = useMemo(() => {
          return applyFilters(data, effectiveFilters);
        }, [data, effectiveFilters]);

        const primeTickers = useMemo(
          () => tickers.filter(isPrimeBubble),
          [tickers]
        );

        const handleFilterChange = useCallback((newFilters) => {
          setFilters((prev) => ({ ...prev, ...newFilters }));
        }, []);

        return (
          <>
            <div className="min-h-screen p-4">
              <div className="max-w-7xl mx-auto">
              {/* Navigation */}
              <nav className="mb-4 p-3 bg-[#121a33] border border-[#26325f] rounded-lg">
                <div className="flex items-center gap-3 flex-wrap">
                  <span className="text-sm text-[#93a4d6]">Navigate:</span>
                  <a
                    href="index-react.html"
                    className="px-3 py-1.5 rounded bg-blue-500/20 border border-blue-500 text-sm text-blue-400 font-semibold"
                  >
                    Dashboard
                  </a>
                  <a
                    href="simulation-dashboard.html"
                    className="px-3 py-1.5 rounded bg-[#0f1630] border border-[#26325f] text-sm hover:bg-[#1a2550] transition-colors"
                  >
                    Simulation Dashboard
                  </a>
                </div>
              </nav>

              {/* Header */}
              <header className="mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h1 className="text-3xl font-bold">
                    Timed Trading ‚Äî React Dashboard
                  </h1>
                  <div className="flex items-center gap-4">
                    {loading && <div className="loading-spinner"></div>}
                    <button
                      onClick={refetch}
                      className="px-4 py-2 bg-[#1a2550] border border-[#26325f] rounded-lg hover:bg-[#26325f] transition-colors"
                    >
                      Refresh
                    </button>
                    {lastUpdate && (
                      <span className="text-sm text-[#93a4d6]">
                        Updated {lastUpdate.toLocaleTimeString()}
                      </span>
                    )}
                  </div>
                </div>

              {/* Quick Stats */}
              <div className="flex gap-4 text-sm items-center">
                <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                  <span className="text-[#93a4d6]">Tickers: </span>
                  <span className="font-bold text-white">{tickers.length}</span>
                </div>
                <div className="px-3 py-1.5 rounded-lg bg-green-500/10 border border-green-500/30">
                  <span className="text-green-400">Prime: </span>
                  <span className="font-bold text-green-400">{primeTickers.length}</span>
                </div>
                {tickers.length > 0 && (
                  <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                    <span className="text-[#93a4d6]">In Corridor: </span>
                    <span className="font-bold text-white">
                      {tickers.filter(t => entryType(t).corridor).length}
                    </span>
                  </div>
                )}
                {error && (
                  <div className="px-3 py-1.5 rounded-lg bg-red-500/10 border border-red-500/30">
                    <span className="text-red-400">Error: {error}</span>
                  </div>
                )}
              </div>

                {/* Filters */}
                <div className="mt-4">
                  <input
                    type="text"
                    placeholder="Search ticker..."
                    value={filters.search}
                    onChange={(e) =>
                      handleFilterChange({ search: e.target.value })
                    }
                    className="w-full px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6] mb-4"
                  />
                  <QuickFilters
                    filters={filters}
                    onFilterChange={handleFilterChange}
                  />
                </div>
              </header>

              {/* Main Content - Chart on top, full width */}
              <div className="space-y-4">
                {/* Chart - Full width, larger */}
                <div>
                  <div className="h-[800px]">
                    {loading && tickers.length === 0 ? (
                      <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] flex items-center justify-center">
                        <div className="text-center">
                          <div className="loading-spinner mx-auto mb-4"></div>
                          <div className="text-[#93a4d6]">
                            Loading tickers...
                          </div>
                        </div>
                      </div>
                    ) : (
                      <BubbleChart
                        tickers={tickers}
                        onBubbleClick={setSelectedTicker}
                        hoveredTicker={hoveredTicker}
                        onHover={setHoveredTicker}
                      />
                    )}
                  </div>
                </div>

                {/* Lists below - Top 40 Dynamic, Top Long/Short wider, others in grid */}
                <div className="space-y-4">
                  {/* Top 40 Dynamic Ranking - Full width */}
                  <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                    <h2 className="text-lg font-bold mb-4">üèÜ Top 40 Dynamic Rankings</h2>
                    <div className="text-xs text-[#93a4d6] mb-3">
                      Rankings update dynamically based on corridor status, squeeze conditions, RR, phase, and completion
                    </div>
                    <div className="max-h-[600px] overflow-y-auto space-y-1.5">
                      {tickers
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort((a, b) => b.dynamicRank - a.dynamicRank)
                        .slice(0, 40)
                        .map((ticker, idx) => (
                          <div key={ticker.ticker} className="flex items-center gap-2">
                            <div className="w-8 text-center">
                              <span className={`text-sm font-bold ${
                                idx < 3 ? "text-yellow-400" : 
                                idx < 10 ? "text-green-400" : 
                                "text-[#93a4d6]"
                              }`}>
                                #{idx + 1}
                              </span>
                            </div>
                            <div className="flex-1">
                              <SetupCard
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => setSelectedTicker(ticker.ticker)}
                              />
                            </div>
                          </div>
                        ))}
                    </div>
                  </div>

                  {/* Top Long and Top Short - Full width, side by side */}
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    {/* Top Long */}
                    {(() => {
                      const longTickers = tickers
                        .filter(t => {
                          const dir = getDirection(t);
                          return dir.text === "LONG";
                        })
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort((a, b) => b.dynamicRank - a.dynamicRank)
                        .slice(0, 25);
                      
                      if (longTickers.length === 0) return null;
                      
                      return (
                        <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                          <h2 className="text-lg font-bold mb-4">üìà Top Long</h2>
                          <div className="max-h-[700px] overflow-y-auto space-y-1.5">
                            {longTickers.map((ticker) => (
                              <SetupCard
                                key={ticker.ticker}
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => setSelectedTicker(ticker.ticker)}
                              />
                            ))}
                          </div>
                        </div>
                      );
                    })()}

                    {/* Top Short */}
                    {(() => {
                      const shortTickers = tickers
                        .filter(t => {
                          const dir = getDirection(t);
                          return dir.text === "SHORT";
                        })
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort((a, b) => b.dynamicRank - a.dynamicRank)
                        .slice(0, 25);
                      
                      if (shortTickers.length === 0) return null;
                      
                      return (
                        <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                          <h2 className="text-lg font-bold mb-4">üìâ Top Short</h2>
                          <div className="max-h-[700px] overflow-y-auto space-y-1.5">
                            {shortTickers.map((ticker) => (
                              <SetupCard
                                key={ticker.ticker}
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => setSelectedTicker(ticker.ticker)}
                              />
                            ))}
                          </div>
                        </div>
                      );
                    })()}
                  </div>

                  {/* Other lists - Grid layout */}
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    {[
                      { title: "Prime Setups", filter: (t) => isPrimeBubble(t), sort: (a, b) => (computeDynamicRank(b) - computeDynamicRank(a)), limit: 15 },
                      { title: "In Corridor", filter: (t) => entryType(t).corridor, sort: (a, b) => (computeDynamicRank(b) - computeDynamicRank(a)), limit: 15 },
                      { title: "Squeeze Release", filter: (t) => t.flags?.sq30_release, sort: (a, b) => (computeDynamicRank(b) - computeDynamicRank(a)), limit: 15 },
                    ].map((listConfig, idx) => {
                      const listTickers = tickers
                        .filter(listConfig.filter || (() => true))
                        .map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }))
                        .sort(listConfig.sort)
                        .slice(0, listConfig.limit);
                      
                      if (listTickers.length === 0) return null;
                      
                      return (
                        <div key={idx} className="bg-[#121a33] border border-[#26325f] rounded-xl p-4">
                          <h2 className="text-lg font-bold mb-4">{listConfig.title}</h2>
                          <div className="max-h-[600px] overflow-y-auto space-y-1.5">
                            {listTickers.map((ticker) => (
                              <SetupCard
                                key={ticker.ticker}
                                ticker={{ ...ticker, rank: ticker.dynamicRank }}
                                isSelected={selectedTicker === ticker.ticker}
                                onClick={() => setSelectedTicker(ticker.ticker)}
                              />
                            ))}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>

              </div>
            </div>
          </div>
          
          {/* Overlay Portal - renders outside main container */}
          <OverlayPortal
            selectedTicker={selectedTicker}
            tickers={tickers}
            data={data}
            onClose={() => setSelectedTicker(null)}
          />
        </div>
        );
      }
      
      // Render overlay outside main container using portal
      function OverlayPortal({ selectedTicker, tickers, data, onClose }) {
        if (!selectedTicker) return null;
        
        // Search in filtered tickers first, then fallback to all data
        let foundTicker = tickers.find((t) => t && t.ticker === selectedTicker);
        if (!foundTicker && data && typeof data === 'object') {
          // Fallback: search in original data object
          const dataArray = Array.isArray(data) ? data : Object.values(data);
          foundTicker = dataArray.find((t) => t && t.ticker === selectedTicker);
        }
        if (!foundTicker) {
          console.warn('Ticker not found:', selectedTicker, 'Available:', tickers.map(t => t.ticker).slice(0, 5));
          return null;
        }
        
        // Use portal to render at document body level
        if (ReactDOM.createPortal) {
          return ReactDOM.createPortal(
            <TickerDetails
              ticker={foundTicker}
              onClose={onClose}
            />,
            document.body
          );
        }
        // Fallback if portal not available
        return (
          <TickerDetails
            ticker={foundTicker}
            onClose={onClose}
          />
        );
      }

      // Render with error handling
      try {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          throw new Error("React or ReactDOM not loaded");
        }

        const rootElement = document.getElementById("root");
        if (!rootElement) {
          throw new Error("Root element not found");
        }

        // Check if React 18 createRoot is available
        if (ReactDOM.createRoot) {
          const root = ReactDOM.createRoot(rootElement);
          root.render(<App />);
        } else {
          // Fallback for React 17
          ReactDOM.render(<App />, rootElement);
        }
      } catch (error) {
        console.error("Error rendering app:", error);
        document.getElementById("root").innerHTML = `
          <div style="padding: 40px; text-align: center; color: #e7ecff;">
            <h2 style="color: #e74c3c;">Error Loading Dashboard</h2>
            <p>${error.message}</p>
            <p style="margin-top: 20px; color: #93a4d6;">
              Please check the browser console (F12) for details.
            </p>
            <p style="margin-top: 10px; color: #93a4d6;">
              Make sure you have an internet connection to load CDN resources.
            </p>
          </div>
        `;
      }
    </script>
  </body>
</html>
