<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"
    />
    <title>Timed Trading</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300c853'/%3E%3Cstop offset='50%25' stop-color='%2300e676'/%3E%3Cstop offset='100%25' stop-color='%2369f0ae'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='24' height='24' rx='5.5' fill='url(%23g)'/%3E%3Cpolyline points='22 7 13.5 15.5 8.5 10.5 2 17' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpolyline points='16 7 22 7 22 13' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />

    <!-- React & ReactDOM via CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
      onerror="console.error('Failed to load React')"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      onerror="console.error('Failed to load ReactDOM')"
    ></script>

    <!-- PropTypes for Recharts compatibility (React 18 doesn't include it) -->
    <script
      crossorigin
      src="https://unpkg.com/prop-types@15/prop-types.min.js"
      onerror="console.error('Failed to load PropTypes')"
    ></script>
    <script>
      // Make PropTypes available globally for Recharts
      if (typeof PropTypes === "undefined" && typeof window !== "undefined") {
        console.warn("PropTypes not loaded, Recharts may have issues");
      } else if (typeof PropTypes !== "undefined") {
        // Ensure React.PropTypes is available for older libraries
        if (typeof React !== "undefined" && !React.PropTypes) {
          React.PropTypes = PropTypes;
        }
      }
    </script>

    <!-- Babel Standalone for JSX -->
    <script
      src="https://unpkg.com/@babel/standalone/babel.min.js"
      onerror="console.error('Failed to load Babel')"
    ></script>

    <!-- Tailwind CSS -->
    <script
      src="https://cdn.tailwindcss.com"
      onerror="console.error('Failed to load Tailwind')"
    ></script>

    <!-- Recharts for lightweight charting - try multiple sources -->
    <script
      src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"
      onerror="
        console.error(
          'Failed to load Recharts from unpkg, trying alternative...',
        );
        loadRechartsFallback();
      "
    ></script>
    <script>
      function loadRechartsFallback() {
        // Try alternative CDN
        const script = document.createElement("script");
        script.src =
          "https://cdn.jsdelivr.net/npm/recharts@2.10.3/umd/Recharts.js";
        script.onerror = function () {
          console.error("Recharts failed to load from all sources");
          window.RechartsFailed = true;
        };
        script.onload = function () {
          console.log("Recharts loaded from jsdelivr");
        };
        document.head.appendChild(script);
      }

      // Check if Recharts loaded after a delay
      window.addEventListener("load", function () {
        setTimeout(function () {
          if (typeof Recharts === "undefined" && !window.RechartsFailed) {
            console.warn("Recharts may not have loaded yet");
          }
        }, 2000);
      });
    </script>

    <!-- Loading indicator while scripts load -->
    <script>
      window.addEventListener("load", function () {
        // Check if all scripts loaded
        setTimeout(function () {
          const root = document.getElementById("root");
          if (root && root.innerHTML === "") {
            if (typeof React === "undefined") {
              root.innerHTML =
                '<div style="padding: 40px; text-align: center; color: #f0f2f5;"><h2 style="color: #e11d48;">Loading Error</h2><p>React failed to load. Check console (F12) for details.</p></div>';
            }
          }
        }, 2000);
      });
    </script>

    <style>
      /* Trade Tracker palette — Robinhood-inspired dark (v3) */
      :root {
        --tt-bg-base: #0b0e11;
        --tt-bg-surface: rgba(255,255,255,0.02);
        --tt-bg-elevated: rgba(255,255,255,0.035);
        --tt-bg-hover: rgba(255,255,255,0.04);
        --tt-border: rgba(255,255,255,0.04);
        --tt-border-strong: rgba(255,255,255,0.08);
        --tt-text: #e5e7eb;
        --tt-text-muted: #6b7280;
        --tt-text-faint: #4b5563;
        --tt-accent: #14b8a6;
        --tt-accent-dim: rgba(20, 184, 166, 0.12);
        --tt-negative: #e11d48;
        --tt-negative-dim: rgba(225, 29, 72, 0.12);
        --tt-radius: 12px;
        --tt-radius-sm: 8px;
        --tt-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        --tt-shadow-sm: 0 1px 2px rgba(0,0,0,0.15);
        --tt-shadow-md: 0 2px 8px rgba(0,0,0,0.12);
        --tt-shadow-lg: 0 4px 16px rgba(0,0,0,0.15);
        /* Aliases for existing usage */
        --bg: var(--tt-bg-base);
        --card: var(--tt-bg-surface);
        --text: var(--tt-text);
        --muted: var(--tt-text-muted);
        --line: var(--tt-border);
        --good: var(--tt-accent);
        --bad: var(--tt-negative);
      }

      body {
        margin: 0;
        font-family: var(--tt-font);
        background: var(--bg);
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        letter-spacing: -0.01em;
      }

      /* Fix rare font ligature rendering issues (e.g., missing “r” in “tr”). */
      .no-ligatures {
        font-variant-ligatures: none;
        font-feature-settings:
          "liga" 0,
          "clig" 0,
          "calt" 0;
      }

      .slider-thumb::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--tt-accent);
        cursor: pointer;
        box-shadow: 0 0 8px var(--tt-accent-dim);
      }

      .slider-thumb::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--tt-accent);
        cursor: pointer;
        border: none;
        box-shadow: 0 0 8px var(--tt-accent-dim);
      }

      /* Investor panel stage badges */
      .stage-badge { padding: 2px 8px; border-radius: 6px; font-size: 11px; font-weight: 600; text-transform: uppercase; }
      .stage-accumulate { background: rgba(16,185,129,0.15); color: #34d399; border: 1px solid rgba(16,185,129,0.3); }
      .stage-core_hold { background: rgba(59,130,246,0.15); color: #60a5fa; border: 1px solid rgba(59,130,246,0.3); }
      .stage-watch { background: rgba(245,158,11,0.15); color: #fbbf24; border: 1px solid rgba(245,158,11,0.3); }
      .stage-reduce { background: rgba(239,68,68,0.15); color: #f87171; border: 1px solid rgba(239,68,68,0.3); }
      .stage-research { background: rgba(139,92,246,0.15); color: #a78bfa; border: 1px solid rgba(139,92,246,0.3); }
      .stage-exited { background: rgba(107,114,128,0.15); color: #9ca3af; border: 1px solid rgba(107,114,128,0.3); }
      .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
      .scrollbar-hide::-webkit-scrollbar { display: none; }
      .card { background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; }

      .loading-spinner {
        width: 28px;
        height: 28px;
        position: relative;
        display: inline-block;
        will-change: transform;
      }
      .loading-spinner::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        border: 2.5px solid rgba(0,200,83,0.12);
        border-top-color: #00c853;
        animation: tt-spin 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
      }
      .loading-spinner::after {
        content: "";
        position: absolute;
        inset: 5px;
        border-radius: 50%;
        border: 2px solid transparent;
        border-top-color: rgba(0,200,83,0.4);
        animation: tt-spin 1.4s cubic-bezier(0.4, 0, 0.2, 1) infinite reverse;
      }
      .loading-spinner-sm { width: 16px; height: 16px; }
      .loading-spinner-lg { width: 40px; height: 40px; }
      @keyframes tt-spin {
        to { transform: rotate(360deg); }
      }
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      @keyframes pulse-badge {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.15); }
      }
      @keyframes coachmark-pulse {
        0%, 100% { box-shadow: 0 0 20px rgba(56, 189, 248, 0.2), inset 0 0 20px rgba(56, 189, 248, 0.05); }
        50% { box-shadow: 0 0 30px rgba(56, 189, 248, 0.35), inset 0 0 30px rgba(56, 189, 248, 0.1); }
      }
      @keyframes coachmark-slide-in {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .prime-glow {
        box-shadow: 0 0 12px var(--tt-accent-dim);
        animation: pulse-glow 2s ease-in-out infinite;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          box-shadow: 0 0 12px var(--tt-accent-dim);
        }
        50% {
          box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
        }
      }

      .momentum-elite-glow {
        box-shadow:
          0 0 15px rgba(168, 85, 247, 0.5),
          0 0 25px rgba(236, 72, 153, 0.3);
        animation: momentum-pulse 2.5s ease-in-out infinite;
      }

      /* Subtle outline pulse for action-lane cards (ENTER NOW, TRIM, EXIT) */
      .card-pulse {
        animation: card-pulse 2s ease-in-out infinite;
      }
      @keyframes card-pulse {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.2); }
        50% { opacity: 1; box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.5); }
      }
      @keyframes stage-dot-pulse {
        0%, 100% { transform: scale(1); opacity: 0.85; }
        50% { transform: scale(1.35); opacity: 1; }
      }
      .card-pulse-short {
        animation: card-pulse-short 2s ease-in-out infinite;
      }
      @keyframes card-pulse-short {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.2); }
        50% { opacity: 1; box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.5); }
      }

      /* Extreme move intensity pulse (>15% daily change) */
      .intensity-pulse {
        animation: intensity-pulse 1.8s ease-in-out infinite;
      }
      @keyframes intensity-pulse {
        0%, 100% { opacity: 1; filter: brightness(1); }
        50% { opacity: 0.92; filter: brightness(1.15); }
      }

      /* Sparkline live dot — pulses when market is open */
      .sparkline-pulse-dot {
        animation: sparkline-dot 1.8s ease-in-out infinite;
      }
      @keyframes sparkline-dot {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.4); opacity: 0.7; }
      }
      .sparkline-pulse-ring {
        animation: sparkline-ring 1.8s ease-in-out infinite;
      }
      @keyframes sparkline-ring {
        0% { transform: translate(-50%, -50%) scale(0.6); opacity: 0.3; }
        50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0; }
        100% { transform: translate(-50%, -50%) scale(0.6); opacity: 0.3; }
      }

      /* Skeleton shimmer for card placeholders */
      @keyframes skeleton-shimmer {
        0% { background-position: -200% 0; }
        100% { background-position: 200% 0; }
      }
      .skeleton-card {
        background: linear-gradient(90deg, rgba(255,255,255,0.03) 25%, rgba(255,255,255,0.06) 50%, rgba(255,255,255,0.03) 75%);
        background-size: 200% 100%;
        animation: skeleton-shimmer 1.5s ease-in-out infinite;
        border-radius: 0.5rem;
        border: 1px solid rgba(255,255,255,0.04);
      }

      /* Prime + Entry Zone: amber glow card highlight */
      .prime-entry-card {
        animation: prime-entry-glow 2.5s ease-in-out infinite;
        border-color: rgba(251,191,36,0.5) !important;
      }
      @keyframes prime-entry-glow {
        0%, 100% { box-shadow: 0 0 8px rgba(251,191,36,0.15), 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.04); }
        50% { box-shadow: 0 0 16px rgba(251,191,36,0.35), 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.04); }
      }

      @keyframes momentum-pulse {
        0%,
        100% {
          box-shadow:
            0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow:
            0 0 25px rgba(168, 85, 247, 0.8),
            0 0 45px rgba(236, 72, 153, 0.6);
        }
      }

      /* Slide-in overlay from right */
      .slide-in-right {
        animation: slideInRight 0.3s ease-out;
      }
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      /* Comet trail effect */
      .comet-trail {
        stroke-dasharray: 5, 5;
        animation: cometMove 2s linear infinite;
      }
      @keyframes cometMove {
        from {
          stroke-dashoffset: 0;
        }
        to {
          stroke-dashoffset: 20;
        }
      }

      /* Bubble Trail path (prefer readability over animation) */
      .trail-path {
        stroke-linecap: round;
        stroke-linejoin: round;
        filter: drop-shadow(0 0 4px rgba(0, 255, 255, 0.25));
      }

      @keyframes momentum-pulse-old {
        0%,
        100% {
          box-shadow:
            0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow:
            0 0 25px rgba(168, 85, 247, 0.7),
            0 0 35px rgba(236, 72, 153, 0.5);
        }
      }

      .bubble-transition {
        transition: all 0.2s ease-out;
      }

      .bubble-hover {
        transform: scale(1.15);
        filter: brightness(1.2);
      }

      .fade-in {
        animation: fadeIn 0.3s ease-in;
      }

      /* Performance: isolate card/lane layout to prevent cascade reflows */
      .kanban-card { contain: layout style paint; }
      .kanban-lane { contain: layout style; }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slide-in {
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Phase color gradient helper — Trade Tracker palette */
      .phase-gradient {
        background: linear-gradient(
          to right,
          #14b8a6 0%,
          #0d9488 20%,
          #eab308 40%,
          #f97316 60%,
          #e11d48 80%,
          #9f1239 100%
        );
      }

      /* Hide scrollbars while keeping scroll functionality */
      .scrollbar-hide {
        -ms-overflow-style: none; /* IE and Edge */
        scrollbar-width: none; /* Firefox */
      }
      .scrollbar-hide::-webkit-scrollbar {
        display: none; /* Chrome, Safari, Opera */
      }

      /* Admin-only nav links: hidden for non-admin users */
      body:not([data-user-role="admin"]) a[data-admin-only] {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100vh; gap:16px; background:#0d1117">
        <div class="loading-spinner loading-spinner-lg"></div>
        <p style="font-family:Inter,sans-serif; font-size:13px; color:#6b7280; letter-spacing:0.02em">Loading dashboard...</p>
      </div>
    </div>

    <script src="auth-gate.js?v=20260219a"></script>
    <script src="shared-price-utils.js?v=20260211a"></script>
    <script src="investor-panel.js?v=20260226a"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="shared-right-rail.compiled.js?v=20260226k" type="text/babel"></script>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef, memo } = React;

      // Currency formatters — must be defined first (used by TickerDetailRightRailFactory and inline)
      const USD_FMT = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        maximumFractionDigits: 2,
      });
      function fmtUsd(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return "—";
        return USD_FMT.format(n);
      }
      function fmtUsdAbs(n) {
        const x = Number(n);
        if (!Number.isFinite(x)) return "—";
        return `$${Math.abs(x).toFixed(2)}`;
      }

      // Get Recharts components with fallback
      let RechartsComponents = null;
      if (typeof Recharts !== "undefined") {
        RechartsComponents = {
          ScatterChart: Recharts.ScatterChart,
          Scatter: Recharts.Scatter,
          XAxis: Recharts.XAxis,
          YAxis: Recharts.YAxis,
          CartesianGrid: Recharts.CartesianGrid,
          Tooltip: Recharts.Tooltip,
          ResponsiveContainer: Recharts.ResponsiveContainer,
          ReferenceLine: Recharts.ReferenceLine,
          ReferenceArea: Recharts.ReferenceArea,
        };
      }

      // ─────────────────────────────────────────────────────────────
      // Types & Constants
      // ─────────────────────────────────────────────────────────────
      const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
      const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
      const API_BASE = "";
      const TRADE_SIZE = 1000; // $1000 per trade (used by Right Rail)
      const FUTURES_SPECS = {
        "ES1!": { pointValue: 50, name: "E-mini S&P 500" },
        "NQ1!": { pointValue: 20, name: "E-mini Nasdaq-100" },
        "YM1!": { pointValue: 5, name: "E-mini Dow" },
        "RTY1!": { pointValue: 50, name: "E-mini Russell 2000" },
        "CL1!": { pointValue: 1000, name: "Crude Oil" },
        "GC1!": { pointValue: 100, name: "Gold" },
        "SI1!": { pointValue: 5000, name: "Silver" },
        "ZB1!": { pointValue: 1000, name: "30-Year Treasury Bond" },
        "ZN1!": { pointValue: 1000, name: "10-Year Treasury Note" },
        "6E1!": { pointValue: 125000, name: "Euro FX" },
        "6J1!": { pointValue: 12500000, name: "Japanese Yen" },
      };

      // ─────────────────────────────────────────────────────────────
      // Hooks
      // ─────────────────────────────────────────────────────────────
      // Normalize trail point keys so chart rendering doesn't collapse to 0,0
      // Supports older / alternate API formats (x/y, ltf/htf, etc.)
      function normalizeTrailPoints(trail) {
        if (!Array.isArray(trail)) return [];
        return trail
          .map((p) => {
            if (!p || typeof p !== "object") return null;

            const ltf =
              p.ltf_score ??
              p.ltfScore ??
              p.ltf ??
              p.x ??
              p.ltf_value ??
              p.ltfValue ??
              p.ltf_score_value;
            const htf =
              p.htf_score ??
              p.htfScore ??
              p.htf ??
              p.y ??
              p.htf_value ??
              p.htfValue ??
              p.htf_score_value;

            const phase =
              p.phase_pct ??
              p.phasePct ??
              p.phase ??
              p.phase_completion ??
              p.phaseCompletion;
            const completion =
              p.completion ?? p.comp ?? p.completion_pct ?? p.completionPct;

            return {
              ...p,
              ltf_score: Number.isFinite(Number(ltf)) ? Number(ltf) : 0,
              htf_score: Number.isFinite(Number(htf)) ? Number(htf) : 0,
              phase_pct: Number.isFinite(Number(phase))
                ? Math.max(0, Math.min(1, Number(phase)))
                : Number.isFinite(Number(p.phase_pct))
                  ? Number(p.phase_pct)
                  : 0,
              completion: Number.isFinite(Number(completion))
                ? Math.max(0, Math.min(1, Number(completion)))
                : Number.isFinite(Number(p.completion))
                  ? Number(p.completion)
                  : 0,
            };
          })
          .filter(Boolean);
      }

      function useTickerData() {
        const [data, setData] = useState({});
        const [socialAdditions, setSocialAdditions] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);
        const [versionInfo, setVersionInfo] = useState(null);
        const [tickersWithoutScores, setTickersWithoutScores] = useState([]);
        // Local fallback for Kanban prev-lane tracking (covers cases where the backend doesn't stamp prev_kanban_stage).
        const kanbanPrevLocalRef = React.useRef({});

        const fetchData = useCallback(async () => {
          try {
            setLoading(true);
            setError(null); // Clear any previous errors
            // Add timeout to prevent hanging - 60s for cold start + D1 + rank computation
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s timeout

            // Fetch ticker data, ticker index, AND live prices in parallel
            // so the initial render never shows stale scoring-snapshot prices.
            const timestamp = Date.now();
            const [dataRes, tickersRes, pricesRes] = await Promise.all([
              fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
                signal: controller.signal,
                cache: "no-store",
                headers: {
                  Accept: "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `data-${timestamp}`,
                },
              }),
              fetch(`${API_BASE}/timed/tickers?_t=${timestamp}`, {
                signal: controller.signal,
                cache: "no-store",
                headers: {
                  Accept: "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `tickers-${timestamp}`,
                },
              }),
              fetch(`${API_BASE}/timed/prices?_t=${timestamp}`, {
                signal: controller.signal,
                cache: "no-store",
              }).catch(() => null),
            ]);

            clearTimeout(timeoutId);

            if (!dataRes.ok) {
              const errorText = await dataRes.text();
              throw new Error(
                `HTTP ${dataRes.status}: ${errorText || "Unknown error"}`,
              );
            }

            const dataJson = await dataRes.json();
            const tickersJson = await tickersRes.json();

            if (dataJson.ok) {
              setSocialAdditions(Array.isArray(dataJson.socialAdditions) ? dataJson.socialAdditions : []);
              const tickerData = dataJson.data || {};
              const allTickers =
                tickersJson.ok && tickersJson.tickers
                  ? tickersJson.tickers
                  : [];

              // Local prev-lane fallback (so transition marker/glow always works).
              // Only stamps when backend didn't provide prev_kanban_stage.
              try {
                const prevMap =
                  kanbanPrevLocalRef.current &&
                  typeof kanbanPrevLocalRef.current === "object"
                    ? kanbanPrevLocalRef.current
                    : {};
                for (const [symRaw, objRaw] of Object.entries(tickerData)) {
                  const sym = String(symRaw || "").toUpperCase();
                  const obj = objRaw && typeof objRaw === "object" ? objRaw : null;
                  if (!sym || !obj) continue;
                  const stage = obj.kanban_stage != null ? String(obj.kanban_stage) : "";
                  if (!stage) continue;
                  const prev = prevMap[sym] != null ? String(prevMap[sym]) : "";
                  if (prev && prev !== stage && (obj.prev_kanban_stage == null || String(obj.prev_kanban_stage).trim() === "")) {
                    obj.prev_kanban_stage = prev;
                    obj.prev_kanban_stage_ts = Date.now();
                  }
                  prevMap[sym] = stage;
                }
                kanbanPrevLocalRef.current = prevMap;
              } catch {
                // ignore
              }

              // Log version information for debugging
              const dataVersion = dataJson.dataVersion || "unknown";
              const versionsSeen = dataJson.versionsSeen || [];
              const versionFiltered = dataJson.versionFiltered || 0;
              const versionBreakdown = dataJson.versionBreakdown || {};
              const acceptedVersions = dataJson.acceptedVersions || [];
              const currentDataVersion =
                dataJson.currentDataVersion || "unknown";

              // Store version info for UI display
              setVersionInfo({
                storedVersion: dataVersion,
                versionsSeen: versionsSeen,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                acceptedVersions: acceptedVersions,
                currentDataVersion: currentDataVersion,
              });

              console.log(`[UI] Data Version Info:`, {
                storedVersion: dataVersion,
                currentDataVersion: currentDataVersion,
                versionsSeen: versionsSeen,
                acceptedVersions: acceptedVersions,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                tickersReturned: Object.keys(tickerData).length,
                totalTickersInIndex: allTickers.length,
              });

              // Normalize ticker keys: BRK.B -> BRK-B
              const normalizedData = {};
              Object.keys(tickerData).forEach((key) => {
                const normalizedKey = normTicker(key);
                normalizedData[normalizedKey] = tickerData[key];
                // If we normalized, ensure ticker field matches
                if (normalizedKey !== key && normalizedData[normalizedKey]) {
                  normalizedData[normalizedKey].ticker = normalizedKey;
                }
              });

              // Merge: ensure all tickers from index are present, even if no recent data
              // This maintains the full 133 ticker baseline
              const mergedData = { ...normalizedData };
              allTickers.forEach((ticker) => {
                const normalizedTicker = normTicker(ticker);
                if (!mergedData[normalizedTicker]) {
                  // Add placeholder for tickers without recent data
                  // They'll appear on the chart with their last known position (if available)
                  // or won't render until data comes in
                  mergedData[normalizedTicker] = {
                    ticker: normalizedTicker,
                    // Note: Without data, these tickers won't render bubbles
                    // but they'll be available when data arrives
                  };
                }
              });

              // Merge fresh prices from the parallel /timed/prices fetch so even
              // the very first setData (when prev is empty) has live prices.
              try {
                if (pricesRes && pricesRes.ok) {
                  const pj = await pricesRes.json();
                  if (pj.ok && pj.prices) {
                    const pts = pj.updated_at || Date.now();
                    for (const [sym, pf] of Object.entries(pj.prices)) {
                      const ns = normTicker(sym);
                      const obj = mergedData[ns];
                      if (!obj || !(Number(pf.p) > 0)) continue;
                      const curTs = obj._price_updated_at || 0;
                      if (pts >= curTs) {
                        obj.price = pf.p;
                        obj._live_price = pf.p;
                        obj._price_updated_at = pts;
                        if (pf.dh) obj._live_daily_high = pf.dh;
                        if (pf.dl) obj._live_daily_low = pf.dl;
                        if (pf.dv) obj._live_daily_volume = pf.dv;
                        const dp = Number(pf.dp);
                        const dc = Number(pf.dc);
                        if (Number.isFinite(dp)) { obj.day_change_pct = dp; obj.change_pct = dp; }
                        if (Number.isFinite(dc)) { obj.day_change = dc; obj.change = dc; }
                        const feedPc = Number(pf.pc);
                        if (Number.isFinite(feedPc) && feedPc > 0) { obj._live_prev_close = feedPc; if (!obj.prev_close) obj.prev_close = feedPc; }
                        if (Number.isFinite(Number(pf.ahp)) && pf.ahp > 0) obj._ah_price = pf.ahp;
                        if (Number.isFinite(Number(pf.ahdc))) obj._ah_change = pf.ahdc;
                        if (Number.isFinite(Number(pf.ahdp))) obj._ah_change_pct = pf.ahdp;
                      }
                    }
                  }
                }
              } catch (_) { /* prices fetch failed — continue with /timed/all data */ }

              // Preserve live price fields from current data so the 3-min
              // full refresh doesn't cause a price flicker back to candle close.
              // Key rule: if prev has a _live_price that's significantly different
              // from the incoming price, keep prev's price (the incoming snapshot
              // may contain a stale candle close due to KV eventual consistency).
              setData(prev => {
                if (!prev || typeof prev !== "object" || Object.keys(prev).length === 0) return mergedData;
                const LIVE_KEYS = ["_live_price", "_live_prev_close", "_live_daily_high", "_live_daily_low", "_live_daily_volume", "_price_updated_at", "day_change_pct", "change_pct", "day_change", "change", "_ah_price", "_ah_change", "_ah_change_pct"];
                const result = { ...mergedData };
                for (const sym of Object.keys(result)) {
                  const old = prev[sym];
                  if (!old || !(old._live_price > 0)) continue;
                  const newPx = Number(result[sym]?.price) || 0;
                  const oldLivePx = old._live_price;
                  const divergence = newPx > 0 ? Math.abs(newPx - oldLivePx) / oldLivePx : 0;
                  // If the incoming price diverges >2% from our live price,
                  // it's likely a stale candle close — keep the live price.
                  // Also preserve if old is simply more recent.
                  const oldTs = old._price_updated_at || 0;
                  const newTs = result[sym]?._price_updated_at || 0;
                  if (divergence > 0.02 || oldTs >= newTs || !newTs) {
                    const merged = { ...result[sym] };
                    for (const k of LIVE_KEYS) {
                      if (old[k] != null) merged[k] = old[k];
                    }
                    merged.price = oldLivePx;
                    result[sym] = merged;
                  }
                }
                return result;
              });
              setLastUpdate(new Date());
              setError(null);
              sessionStorage.removeItem("fetchData_abortRetry");

              // Log ticker counts for debugging
              const tickersWithData = Object.keys(mergedData).filter((t) => {
                const d = mergedData[t];
                return (
                  d && d.htf_score !== undefined && d.ltf_score !== undefined
                );
              });
              // Log detailed breakdown
              const tickersByVersion = {};
              const tickersWithoutScores = [];
              Object.keys(mergedData).forEach((t) => {
                const d = mergedData[t];
                if (d) {
                  const version = d.script_version || "unknown";
                  if (!tickersByVersion[version]) {
                    tickersByVersion[version] = [];
                  }
                  tickersByVersion[version].push(t);

                  if (d.htf_score === undefined && d.ltf_score === undefined) {
                    tickersWithoutScores.push({
                      ticker: t,
                      version: version,
                      hasPrice: !!d.price,
                    });
                  }
                }
              });

              console.log(
                `[UI] Loaded ${tickersWithData.length} tickers with scores, ${allTickers.length} total in index`,
              );
              console.log(`[UI] Tickers by version:`, tickersByVersion);
              if (tickersWithoutScores.length > 0) {
                console.warn(
                  `[UI] ⚠️ ${tickersWithoutScores.length} tickers without scores:`,
                  tickersWithoutScores.slice(0, 10),
                );
                // Store in state for UI display
                setTickersWithoutScores(tickersWithoutScores);
              } else {
                setTickersWithoutScores([]);
              }

              if (versionFiltered > 0) {
                console.warn(
                  `[UI] ⚠️ ${versionFiltered} tickers filtered out due to version mismatch.`,
                  {
                    storedVersion: dataVersion,
                    currentDataVersion: currentDataVersion,
                    versionsSeen: versionsSeen,
                    acceptedVersions: acceptedVersions,
                    versionBreakdown: versionBreakdown,
                  },
                );
              }

              // Log sample tickers to see what we're getting
              const sampleTickers = Object.keys(tickerData).slice(0, 10);
              console.log(
                `[UI] Sample tickers:`,
                sampleTickers.map((t) => ({
                  ticker: t,
                  version: tickerData[t]?.script_version || "unknown",
                  hasScores: !!(
                    tickerData[t]?.htf_score !== undefined &&
                    tickerData[t]?.ltf_score !== undefined
                  ),
                  htf_score: tickerData[t]?.htf_score,
                  ltf_score: tickerData[t]?.ltf_score,
                  dynamicScore: tickerData[t]?.dynamicScore, // Check if API provides this
                  rank: tickerData[t]?.rank,
                })),
              );

              // Check if dynamicScore is coming from API
              const hasDynamicScore = Object.values(tickerData).some(
                (t) => t?.dynamicScore !== undefined,
              );
              console.log(
                `[UI] API provides dynamicScore: ${
                  hasDynamicScore
                    ? "YES ✅"
                    : "NO ❌ (will use fallback calculation)"
                }`,
              );

              // Check order of tickers from API
              const apiTickerOrder = Object.keys(tickerData).slice(0, 10);
              console.log(
                `[UI] First 10 tickers from API (order):`,
                apiTickerOrder,
              );
            } else {
              setError(
                `API Error: ${dataJson.error || "Failed to fetch data"}`,
              );
            }
          } catch (e) {
            if (e.name === "AbortError") {
              setError("Request timeout - please try again");
              // Retry once after 2s (helps with worker cold start)
              const retryKey = "fetchData_abortRetry";
              if (!sessionStorage.getItem(retryKey)) {
                sessionStorage.setItem(retryKey, "1");
                setTimeout(() => fetchData(), 2000);
              }
            } else if (
              e.message.includes("Failed to fetch") ||
              e.message.includes("Load failed")
            ) {
              setError(
                "Network error - check console for details. API may be temporarily unavailable.",
              );
            } else {
              setError(e.message);
            }
            console.error("Fetch error:", e);
            console.error("Error details:", {
              name: e.name,
              message: e.message,
              stack: e.stack,
            });
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 180000); // 3 minutes auto-refresh
          return () => clearInterval(interval);
        }, [fetchData]);

        return {
          data,
          setData,
          socialAdditions,
          loading,
          error,
          lastUpdate,
          versionInfo,
          tickersWithoutScores,
          refetch: fetchData,
        };
      }

      // ── Real-time price feed hook ──
      // Polls /timed/prices every 30 seconds for near-real-time Current Price and Daily Change.
      // Merges price data into the main tickerData object without replacing scoring data.
      function usePriceFeed(tickerData, setTickerData) {
        const priceUpdateRef = useRef(0);
        const [priceLastUpdated, setPriceLastUpdated] = useState(0);

        // Use a ref for tickerData to avoid re-creating fetchPrices on every data change
        const tickerDataRef = useRef(tickerData);
        tickerDataRef.current = tickerData;
        const setTickerDataRef = useRef(setTickerData);
        setTickerDataRef.current = setTickerData;
        const [priceReady, setPriceReady] = useState(false);

        // Mark ready when tickerData first loads
        useEffect(() => {
          if (tickerData && Object.keys(tickerData).length > 0 && !priceReady) {
            setPriceReady(true);
          }
        }, [tickerData, priceReady]);

        const fetchPrices = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/prices?_t=${Date.now()}`, {
              cache: "no-store",
            });
            if (!res.ok) return;
            const json = await res.json();
            if (!json.ok || !json.prices) return;

            const feedTs = json.updated_at || Date.now();
            setPriceLastUpdated(feedTs);

            const setter = setTickerDataRef.current;
            if (!setter) return;

            setter(prev => {
              if (!prev || typeof prev !== "object" || Object.keys(prev).length === 0) return prev;
              const updatedData = { ...prev };
              let changed = false;
              for (const [sym, priceInfo] of Object.entries(json.prices)) {
                const normalizedSym = normTicker(sym);
                const existing = updatedData[normalizedSym];
                if (!existing || !(priceInfo.p > 0)) continue;
                if (existing._live_price === priceInfo.p) continue;
                // Don't overwrite a more recent WS price with an older HTTP poll
                if (existing._price_updated_at && existing._price_updated_at > feedTs) continue;
                const feedPc = Number(priceInfo.pc);
                const feedP = Number(priceInfo.p);
                const feedPcUsable = Number.isFinite(feedPc) && feedPc > 0 && feedP > 0
                  && (Math.abs(feedPc - feedP) / feedP * 100) > 0.05;
                const bestPc = feedPcUsable
                  ? feedPc
                  : (existing._live_prev_close || existing.prev_close || undefined);
                const feedDc = Number(priceInfo.dc);
                const feedDp = Number(priceInfo.dp);
                updatedData[normalizedSym] = {
                  ...existing,
                  price: priceInfo.p,
                  _live_price: priceInfo.p,
                  ...(bestPc > 0 ? { _live_prev_close: bestPc } : {}),
                  _live_daily_high: priceInfo.dh,
                  _live_daily_low: priceInfo.dl,
                  _live_daily_volume: priceInfo.dv,
                  _price_updated_at: feedTs,
                  ...(Number.isFinite(feedDp) ? { day_change_pct: feedDp, change_pct: feedDp } : {}),
                  ...(Number.isFinite(feedDc) ? { day_change: feedDc, change: feedDc } : {}),
                  ...(Number.isFinite(Number(priceInfo.ahp)) && priceInfo.ahp > 0 ? { _ah_price: priceInfo.ahp } : {}),
                  ...(Number.isFinite(Number(priceInfo.ahdc)) ? { _ah_change: priceInfo.ahdc } : {}),
                  ...(Number.isFinite(Number(priceInfo.ahdp)) ? { _ah_change_pct: priceInfo.ahdp } : {}),
                };
                changed = true;
              }
              if (changed) priceUpdateRef.current++;
              return changed ? updatedData : prev;
            });
          } catch (e) {
            console.warn("[PRICE FEED] Error:", e);
          }
        }, []); // stable callback — reads from refs

        useEffect(() => {
          if (!priceReady) return;
          // Fetch immediately, then poll every 30 seconds
          fetchPrices();
          const interval = setInterval(fetchPrices, 30000);
          return () => clearInterval(interval);
        }, [priceReady, fetchPrices]);

        return { priceLastUpdated, priceUpdateCount: priceUpdateRef.current };
      }

      // ─────────────────────────────────────────────────────────────────────
      // useWebSocket — real-time price + scoring push via Durable Object
      // Falls back to usePriceFeed polling if WS connection fails.
      // ─────────────────────────────────────────────────────────────────────
      function useWebSocket(tickerData, setTickerData) {
        const wsRef = useRef(null);
        const reconnectTimer = useRef(null);
        const reconnectDelay = useRef(1000);
        const [wsConnected, setWsConnected] = useState(false);
        const [wsLastMessage, setWsLastMessage] = useState(0);
        const tickerDataRef = useRef(tickerData);
        tickerDataRef.current = tickerData;
        const setTickerDataRef = useRef(setTickerData);
        setTickerDataRef.current = setTickerData;

        // Throttle WS updates: accumulate changes, flush at most every 2s
        const wsPendingRef = useRef({});
        const wsFlushTimerRef = useRef(null);
        const WS_THROTTLE_MS = 2000;
        const flushWsPending = useCallback(() => {
          const pending = wsPendingRef.current;
          if (!pending || Object.keys(pending).length === 0) return;
          wsPendingRef.current = {};
          const setter = setTickerDataRef.current;
          if (!setter) return;
          setter(prev => {
            if (!prev || typeof prev !== "object" || Object.keys(prev).length === 0) return prev;
            const result = { ...prev };
            let changed = false;
            for (const [sym, updates] of Object.entries(pending)) {
              const existing = result[sym];
              if (!existing) continue;
              result[sym] = { ...existing, ...updates };
              changed = true;
            }
            return changed ? result : prev;
          });
        }, []);
        const queueWsUpdate = useCallback((sym, updates) => {
          wsPendingRef.current[sym] = { ...(wsPendingRef.current[sym] || {}), ...updates };
          if (!wsFlushTimerRef.current) {
            wsFlushTimerRef.current = setTimeout(() => {
              wsFlushTimerRef.current = null;
              flushWsPending();
            }, WS_THROTTLE_MS);
          }
        }, [flushWsPending]);

        const connect = useCallback(() => {
          // Don't connect if already connected or during SSR
          if (wsRef.current && wsRef.current.readyState <= 1) return;

          try {
            // Connect to workers.dev subdomain to bypass Cloudflare Access
            // (Access blocks WebSocket upgrades on the custom domain)
            const wsUrl = `wss://timed-trading-ingest.shashant.workers.dev/timed/ws`;
            const ws = new WebSocket(wsUrl);
            wsRef.current = ws;

            ws.onopen = () => {
              console.log("[WS] Connected");
              setWsConnected(true);
              reconnectDelay.current = 1000; // reset backoff
            };

            ws.onmessage = (event) => {
              try {
                const msg = JSON.parse(event.data);
                setWsLastMessage(Date.now());

                if (msg.type === "prices" && msg.data) {
                  const wsTs = msg.updated_at || Date.now();
                  const MIN_PRICE_CHANGE_PCT = 0.05;
                  const curData = tickerDataRef.current;
                  if (!curData || typeof curData !== "object") return;

                  for (const [sym, priceInfo] of Object.entries(msg.data)) {
                    const normalizedSym = normTicker(sym);
                    const existing = curData[normalizedSym];
                    if (!existing || !(priceInfo.p > 0)) continue;
                    if (existing._live_price === priceInfo.p) continue;
                    const curPrice = Number(existing._live_price || existing.price || 0);
                    if (curPrice > 0 && Math.abs(priceInfo.p - curPrice) / curPrice * 100 < MIN_PRICE_CHANGE_PCT) continue;
                    const feedPc = Number(priceInfo.pc);
                    const feedP = Number(priceInfo.p);
                    const feedPcUsable = Number.isFinite(feedPc) && feedPc > 0 && feedP > 0
                      && (Math.abs(feedPc - feedP) / feedP * 100) > 0.05;
                    const bestPc = feedPcUsable
                      ? feedPc
                      : (existing._live_prev_close || existing.prev_close || undefined);
                    const feedDc = Number(priceInfo.dc);
                    const feedDp = Number(priceInfo.dp);
                    queueWsUpdate(normalizedSym, {
                      price: priceInfo.p,
                      _live_price: priceInfo.p,
                      ...(bestPc > 0 ? { _live_prev_close: bestPc } : {}),
                      _live_daily_high: priceInfo.dh,
                      _live_daily_low: priceInfo.dl,
                      _live_daily_volume: priceInfo.dv,
                      _price_updated_at: wsTs,
                      ...(Number.isFinite(feedDp) ? { day_change_pct: feedDp, change_pct: feedDp } : {}),
                      ...(Number.isFinite(feedDc) ? { day_change: feedDc, change: feedDc } : {}),
                      ...(Number.isFinite(Number(priceInfo.ahp)) && priceInfo.ahp > 0 ? { _ah_price: priceInfo.ahp } : {}),
                      ...(Number.isFinite(Number(priceInfo.ahdc)) ? { _ah_change: priceInfo.ahdc } : {}),
                      ...(Number.isFinite(Number(priceInfo.ahdp)) ? { _ah_change_pct: priceInfo.ahdp } : {}),
                    });
                  }
                }

                if (msg.type === "tick_batch" && Array.isArray(msg.updates)) {
                  const batchTs = msg.ts || Date.now();
                  const MIN_PRICE_CHANGE_PCT = 0.05;
                  const curData = tickerDataRef.current;
                  if (!curData || typeof curData !== "object") return;

                  for (const u of msg.updates) {
                    const normalizedSym = normTicker(u.s);
                    const existing = curData[normalizedSym];
                    if (!existing || !(u.last > 0)) continue;
                    if (existing._live_price === u.last) continue;
                    const curPrice = Number(existing._live_price || existing.price || 0);
                    if (curPrice > 0 && Math.abs(u.last - curPrice) / curPrice * 100 < MIN_PRICE_CHANGE_PCT) continue;
                    queueWsUpdate(normalizedSym, {
                      price: u.last,
                      _live_price: u.last,
                      _price_updated_at: u.lastTs || batchTs,
                      _session: u.session,
                      ...(Number.isFinite(u.dayChgPct) ? { day_change_pct: u.dayChgPct, change_pct: u.dayChgPct } : {}),
                      ...(Number.isFinite(u.dayChg) ? { day_change: u.dayChg, change: u.dayChg } : {}),
                      ...(Number.isFinite(u.ahChg) ? { _ah_change: u.ahChg } : {}),
                      ...(Number.isFinite(u.ahChgPct) ? { _ah_change_pct: u.ahChgPct } : {}),
                    });
                  }
                }

                if (msg.type === "scoring" && msg.data) {
                  const curData = tickerDataRef.current;
                  if (!curData || typeof curData !== "object") return;
                  for (const [sym, update] of Object.entries(msg.data)) {
                    const normalizedSym = normTicker(sym);
                    const existing = curData[normalizedSym];
                    if (!existing) continue;
                    const hasLivePrice = existing._live_price > 0;
                    queueWsUpdate(normalizedSym, {
                      ...(update.score != null ? { eqScore: update.score, eq_score: update.score } : {}),
                      ...(update.stage ? { kanban_stage: update.stage } : {}),
                      ...(update.dir ? { bias_direction: update.dir } : {}),
                      ...(!hasLivePrice && update.price > 0 ? { price: update.price } : {}),
                      ...(update.blockReason !== undefined ? {
                        __entry_block_reason: update.blockReason || undefined,
                        __execution_block_reason: update.blockReason || undefined,
                      } : {}),
                      _scoring_updated_at: update.ts || Date.now(),
                    });
                  }
                }

              } catch (e) {
                // Ignore malformed messages
              }
            };

            ws.onclose = (event) => {
              console.log(`[WS] Disconnected (code=${event.code})`);
              setWsConnected(false);
              wsRef.current = null;
              // Reconnect with exponential backoff
              const delay = reconnectDelay.current;
              reconnectDelay.current = Math.min(delay * 2, 30000);
              reconnectTimer.current = setTimeout(connect, delay);
            };

            ws.onerror = (error) => {
              console.warn("[WS] Error:", error);
              // onclose will fire after onerror, triggering reconnect
            };
          } catch (e) {
            console.warn("[WS] Connection failed:", e);
            // Schedule reconnect
            const delay = reconnectDelay.current;
            reconnectDelay.current = Math.min(delay * 2, 30000);
            reconnectTimer.current = setTimeout(connect, delay);
          }
        }, []);

        useEffect(() => {
          connect();
          return () => {
            clearTimeout(reconnectTimer.current);
            clearTimeout(wsFlushTimerRef.current);
            flushWsPending();
            if (wsRef.current) {
              wsRef.current.onclose = null;
              wsRef.current.close();
              wsRef.current = null;
            }
          };
        }, [connect, flushWsPending]);

        // Ping every 30s to keep the connection alive
        useEffect(() => {
          const pingInterval = setInterval(() => {
            if (wsRef.current && wsRef.current.readyState === 1) {
              wsRef.current.send(JSON.stringify({ type: "ping" }));
            }
          }, 30000);
          return () => clearInterval(pingInterval);
        }, []);

        return { wsConnected, wsLastMessage };
      }

      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = useState(value);

        useEffect(() => {
          const handler = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);

          return () => {
            clearTimeout(handler);
          };
        }, [value, delay]);

        return debouncedValue;
      }

      function useTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchTrades = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/trades?source=d1`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.trades)) {
              setTrades(json.trades);
            } else {
              setTrades([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch trades:", err);
            setTrades([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchTrades();
          const interval = setInterval(fetchTrades, 180000); // Refresh every 3 minutes
          return () => clearInterval(interval);
        }, [fetchTrades]);

        return { trades, loading, error, refetch: fetchTrades };
      }

      // Queued Actions hook (pending + recently resolved)
      function useQueuedActions() {
        const [actions, setActions] = useState([]);
        const [pendingCount, setPendingCount] = useState(0);
        const fetchActions = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/queued-actions?_t=${Date.now()}`, { cache: "no-store" });
            if (!res.ok) return;
            const json = await res.json();
            if (json.ok && Array.isArray(json.actions)) setActions(json.actions);
            if (json.ok && Number.isFinite(json.pendingCount)) setPendingCount(json.pendingCount);
          } catch { /* best-effort */ }
        }, []);
        useEffect(() => {
          fetchActions();
          const iv = setInterval(fetchActions, 60000);
          return () => clearInterval(iv);
        }, [fetchActions]);
        const pending = actions.filter(a => a.status === "PENDING");
        return { actions, pending, pendingCount, refetch: fetchActions };
      }

      // User-Added Tickers hook (Phase 5)
      function useUserTickers() {
        const [slots, setSlots] = useState([]);
        const [slotsUsed, setSlotsUsed] = useState(0);
        const [slotsMax, setSlotsMax] = useState(3);
        const [tier, setTier] = useState("free");
        const [adding, setAdding] = useState(false);
        const [addingTicker, setAddingTicker] = useState(null);
        const [error, setError] = useState(null);

        const fetchSlots = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/user-tickers?_t=${Date.now()}`, { cache: "no-store" });
            if (!res.ok) return;
            const json = await res.json();
            if (json.ok) {
              setSlots(json.tickers || []);
              setSlotsUsed(json.slots_used || 0);
              setSlotsMax(json.slots_max || 3);
              setTier(json.tier || "free");
            }
          } catch { /* best-effort */ }
        }, []);

        useEffect(() => {
          fetchSlots();
          const iv = setInterval(fetchSlots, 120000);
          return () => clearInterval(iv);
        }, [fetchSlots]);

        const addTicker = useCallback(async (ticker) => {
          setError(null);
          setAdding(true);
          setAddingTicker(ticker.toUpperCase().trim());
          try {
            const res = await fetch(`${API_BASE}/timed/user-tickers`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ ticker: ticker.toUpperCase().trim() }),
            });
            const json = await res.json();
            if (!json.ok) {
              setError(json.detail || json.error || "Failed to add ticker");
              return null;
            }
            await fetchSlots();
            return json;
          } catch (e) {
            setError(String(e?.message || e));
            return null;
          } finally {
            setAdding(false);
            setAddingTicker(null);
          }
        }, [fetchSlots]);

        const removeTicker = useCallback(async (ticker) => {
          setError(null);
          try {
            const res = await fetch(`${API_BASE}/timed/user-tickers/${encodeURIComponent(ticker.toUpperCase())}`, {
              method: "DELETE",
            });
            const json = await res.json();
            if (!json.ok) {
              setError(json.detail || json.error || "Failed to remove ticker");
              return false;
            }
            await fetchSlots();
            return true;
          } catch (e) {
            setError(String(e?.message || e));
            return false;
          }
        }, [fetchSlots]);

        return { slots, slotsUsed, slotsMax, tier, adding, addingTicker, error, addTicker, removeTicker, refetch: fetchSlots, setError };
      }

      // Account Summary hook — single source of truth from account_ledger (GET /timed/account-summary)
      function useAccountSummary(mode = "trader") {
        const [summary, setSummary] = useState(null);
        const [loading, setLoading] = useState(true);

        const fetchSummary = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/account-summary?mode=${mode}&_t=${Date.now()}`, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok) setSummary(json);
          } catch { /* best-effort */ }
          finally { setLoading(false); }
        }, [mode]);

        useEffect(() => {
          fetchSummary();
          const interval = setInterval(fetchSummary, 60000);
          return () => clearInterval(interval);
        }, [fetchSummary]);

        return { summary, loading, refetch: fetchSummary };
      }

      // Hook to fetch sector ratings
      function useSectors() {
        const [sectors, setSectors] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSectors = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/sectors`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.sectors)) {
              setSectors(json.sectors);
            } else {
              setSectors([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch sectors:", err);
            setSectors([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchSectors();
          // Refresh sectors every 5 minutes
          const interval = setInterval(fetchSectors, 300000);
          return () => clearInterval(interval);
        }, [fetchSectors]);

        return { sectors, loading, error, refetch: fetchSectors };
      }

      function useEarningsEvents() {
        const [events, setEvents] = useState([]);
        const [updatedAt, setUpdatedAt] = useState(0);

        const fetchEvents = useCallback(async () => {
          try {
            const res = await fetch(`${API_BASE}/timed/earnings/upcoming`);
            if (!res.ok) return;
            const json = await res.json();
            if (json.ok && Array.isArray(json.events)) {
              const now = Date.now();
              const sixteenHoursMs = 16 * 3600000;
              const filtered = json.events.filter(e => {
                const eventDate = new Date(e.date + "T00:00:00");
                const eventEndMs = eventDate.getTime() + 86400000;
                return eventEndMs + sixteenHoursMs > now;
              });
              // Sort: past events (last 16h) first, most recent left; then upcoming, soonest left
              const hourOffset = (h) => {
                const hl = String(h || "").toLowerCase();
                if (hl === "bmo" || hl === "before market open") return 9.5 * 3600000;
                if (hl === "amc" || hl === "after market close") return 16 * 3600000;
                return 12 * 3600000;
              };
              const eventTs = (e) => new Date(e.date + "T00:00:00").getTime() + hourOffset(e.hour);
              const past = filtered.filter(e => eventTs(e) < now).sort((a, b) => eventTs(b) - eventTs(a));
              const future = filtered.filter(e => eventTs(e) >= now).sort((a, b) => eventTs(a) - eventTs(b));
              setEvents([...past, ...future]);
              setUpdatedAt(json.updated_at || 0);
            }
          } catch (err) {
            console.warn("[EARNINGS] Fetch failed:", err);
          }
        }, []);

        useEffect(() => {
          fetchEvents();
          const interval = setInterval(fetchEvents, 300000);
          return () => clearInterval(interval);
        }, [fetchEvents]);

        return { events, updatedAt };
      }

      // ─────────────────────────────────────────────────────────────
      // Sector Mapping (matching worker sector-mapping.js)
      // ─────────────────────────────────────────────────────────────
      // Sector mapping function - matches worker/sector-mapping.js
      function getTickerSector(ticker) {
        const T = normTicker(ticker).toUpperCase();
        // This mapping should match worker/sector-mapping.js
        // For now, we'll fetch from API, but provide a fallback lookup
        const SECTOR_MAP = {
          // S&P Sector ETFs (SPDR) - map ETF ticker -> underlying sector
          XLK: "Information Technology",
          XLF: "Financials",
          XLY: "Consumer Discretionary",
          XLP: "Consumer Staples",
          XLC: "Communication Services",
          XLI: "Industrials",
          XLB: "Basic Materials",
          XLE: "Energy",
          XLRE: "Real Estate",
          XLU: "Utilities",
          XLV: "Healthcare",
          // Consumer Discretionary
          AMZN: "Consumer Discretionary",
          TSLA: "Consumer Discretionary",
          NKE: "Consumer Discretionary",
          TJX: "Consumer Discretionary",
          HD: "Consumer Discretionary",
          MCD: "Consumer Discretionary",
          SBUX: "Consumer Discretionary",
          LOW: "Consumer Discretionary",
          NFLX: "Consumer Discretionary",
          BKNG: "Consumer Discretionary",
          CMG: "Consumer Discretionary",
          ABNB: "Consumer Discretionary",
          EXPE: "Consumer Discretionary",
          RBLX: "Consumer Discretionary",
          ULTA: "Consumer Discretionary",
          SHOP: "Consumer Discretionary",
          // Industrials
          CAT: "Industrials",
          GE: "Industrials",
          BA: "Industrials",
          HON: "Industrials",
          RTX: "Industrials",
          EMR: "Industrials",
          ETN: "Industrials",
          DE: "Industrials",
          PH: "Industrials",
          CSX: "Industrials",
          UNP: "Industrials",
          UPS: "Industrials",
          FDX: "Industrials",
          LMT: "Industrials",
          NOC: "Industrials",
          GD: "Industrials",
          TT: "Industrials",
          PWR: "Industrials",
          AWI: "Industrials",
          WTS: "Industrials",
          DY: "Industrials",
          FIX: "Industrials",
          ITT: "Industrials",
          STRL: "Industrials",
          // Information Technology
          AAPL: "Information Technology",
          MSFT: "Information Technology",
          NVDA: "Information Technology",
          AVGO: "Information Technology",
          AMD: "Information Technology",
          ORCL: "Information Technology",
          CRM: "Information Technology",
          ADBE: "Information Technology",
          INTC: "Information Technology",
          CSCO: "Information Technology",
          TXN: "Information Technology",
          AMAT: "Information Technology",
          LRCX: "Information Technology",
          KLAC: "Information Technology",
          ANET: "Information Technology",
          CDNS: "Information Technology",
          CRWD: "Information Technology",
          PANW: "Information Technology",
          PLTR: "Information Technology",
          MDB: "Information Technology",
          PATH: "Information Technology",
          QLYS: "Information Technology",
          PEGA: "Information Technology",
          IOT: "Information Technology",
          PSTG: "Information Technology",
          MU: "Information Technology",
          APLD: "Information Technology",
          // Communication Services
          META: "Communication Services",
          GOOGL: "Communication Services",
          NFLX: "Communication Services",
          DIS: "Communication Services",
          CMCSA: "Communication Services",
          VZ: "Communication Services",
          T: "Communication Services",
          TWLO: "Communication Services",
          RDDT: "Communication Services",
          // Basic Materials
          LIN: "Basic Materials",
          APD: "Basic Materials",
          ECL: "Basic Materials",
          SHW: "Basic Materials",
          PPG: "Basic Materials",
          FCX: "Basic Materials",
          NEM: "Basic Materials",
          ALB: "Basic Materials",
          MP: "Basic Materials",
          NEU: "Basic Materials",
          AU: "Basic Materials",
          CCJ: "Basic Materials",
          RGLD: "Basic Materials",
          SN: "Basic Materials",
          // Energy
          XOM: "Energy",
          CVX: "Energy",
          SLB: "Energy",
          EOG: "Energy",
          COP: "Energy",
          MPC: "Energy",
          PSX: "Energy",
          VST: "Energy",
          FSLR: "Energy",
          // Financials
          JPM: "Financials",
          BAC: "Financials",
          WFC: "Financials",
          GS: "Financials",
          MS: "Financials",
          C: "Financials",
          AXP: "Financials",
          COF: "Financials",
          SPGI: "Financials",
          MCO: "Financials",
          BLK: "Financials",
          SCHW: "Financials",
          PNC: "Financials",
          BK: "Financials",
          TFC: "Financials",
          USB: "Financials",
          ALLY: "Financials",
          EWBC: "Financials",
          WAL: "Financials",
          SOFI: "Financials",
          HOOD: "Financials",
          // Real Estate
          AMT: "Real Estate",
          PLD: "Real Estate",
          EQIX: "Real Estate",
          PSA: "Real Estate",
          WELL: "Real Estate",
          SPG: "Real Estate",
          O: "Real Estate",
          DLR: "Real Estate",
          VICI: "Real Estate",
          EXPI: "Real Estate",
          // Healthcare
          UNH: "Healthcare",
          JNJ: "Healthcare",
          LLY: "Healthcare",
          ABBV: "Healthcare",
          MRK: "Healthcare",
          TMO: "Healthcare",
          ABT: "Healthcare",
          DHR: "Healthcare",
          BMY: "Healthcare",
          AMGN: "Healthcare",
          GILD: "Healthcare",
          REGN: "Healthcare",
          VRTX: "Healthcare",
          BIIB: "Healthcare",
          UTHR: "Healthcare",
          HIMS: "Healthcare",
          NBIS: "Healthcare",
          // Utilities
          NEE: "Utilities",
          DUK: "Utilities",
          SO: "Utilities",
          D: "Utilities",
          AEP: "Utilities",
          SRE: "Utilities",
          EXC: "Utilities",
          XEL: "Utilities",
          WEC: "Utilities",
          ES: "Utilities",
          PEG: "Utilities",
          ETR: "Utilities",
          FE: "Utilities",
          AEE: "Utilities",
        };
        const sector = SECTOR_MAP[T] || null;
        // Return empty string instead of null for easier filtering
        return sector || "";
      }

      // Normalize sector names to match worker sector ratings.
      // TradingView sector/industry labels can differ ("Health Care" vs "Healthcare", "Materials" vs "Basic Materials", etc).
      function normalizeSectorKey(sectorName) {
        const raw = String(sectorName || "")
          .trim()
          .toLowerCase()
          .replace(/[-_/]+/g, " ")
          .replace(/&/g, "and")
          .replace(/\s+/g, " ");
        if (!raw) return "";
        const ALIASES = {
          "health care": "healthcare",
          healthcare: "healthcare",
          materials: "basic materials",
          "basic materials": "basic materials",
          "non energy minerals": "basic materials",
          "consumer durables": "consumer discretionary",
          "consumer non durables": "consumer staples",
          "consumer cyclical": "consumer discretionary",
          "consumer discretionary": "consumer discretionary",
          "consumer defensive": "consumer staples",
          "consumer staples": "consumer staples",
          "financial services": "financials",
          finance: "financials",
          financials: "financials",
          technology: "information technology",
          "technology services": "information technology",
          "electronic technology": "information technology",
          "information technology": "information technology",
          communications: "communication services",
          "communication services": "communication services",
          "energy minerals": "energy",
          energy: "energy",
          industrials: "industrials",
          utilities: "utilities",
          "real estate": "real estate",
        };
        return ALIASES[raw] || raw;
      }

      function sectorKeyToCanonicalName(key) {
        const K = String(key || "")
          .trim()
          .toLowerCase();
        const CANON = {
          "consumer discretionary": "Consumer Discretionary",
          industrials: "Industrials",
          "information technology": "Information Technology",
          "communication services": "Communication Services",
          "basic materials": "Basic Materials",
          energy: "Energy",
          financials: "Financials",
          "real estate": "Real Estate",
          "consumer staples": "Consumer Staples",
          healthcare: "Healthcare",
          utilities: "Utilities",
        };
        return CANON[K] || key;
      }

      // ─────────────────────────────────────────────────────────────
      // Groups (GRNY/GRNI/GRNJ loaded dynamically from ETF sync)
      // ─────────────────────────────────────────────────────────────
      const GROUPS = {
        UPTICKS: new Set([
          "RDDT", "AMZN", "BABA", "TSLA", "KO", "WMT", "ETHA", "BRK-B", "GLXY", "MTB",
          "SPGI", "AMGN", "GILD", "CSX", "GEV", "HII", "JCI", "PH", "PWR", "TT",
          "APP", "CLS", "FSLR", "PANW", "CRS", "VST",
        ]),
        GRNI: new Set(),
        GRNJ: new Set(),
        GRNY: new Set(),
        SP_Sectors: new Set([
          "XLK", "XLF", "XLY", "XLP", "XLC", "XLI", "XLB",
          "XLE", "XLRE", "XLU", "XLV",
        ]),
        Futures: new Set(["ES1!", "NQ1!", "RTY1!", "YM1!", "GC1!", "SI1!", "CL1!", "BTCUSD", "ETHUSD", "VX1!"]),
      };

      // Load GRNY/GRNI/GRNJ dynamically from backend ETF sync
      let _etfGroupsLoaded = false;
      async function loadETFGroups() {
        if (_etfGroupsLoaded) return;
        try {
          const resp = await fetch("/timed/etf/groups");
          const data = await resp.json();
          if (data.ok && data.groups) {
            for (const [etf, tickers] of Object.entries(data.groups)) {
              if (GROUPS[etf] !== undefined) {
                GROUPS[etf] = new Set(tickers.map(t => String(t).toUpperCase()));
              }
            }
            _etfGroupsLoaded = true;
          }
        } catch (e) {
          console.warn("[ETF GROUPS] Failed to load:", e);
        }
      }
      // Fire immediately (non-blocking)
      loadETFGroups();

      const GROUP_LABELS = {
        SP_Sectors: "S&P Sectors",
        Futures: "Futures",
        Other: "Other",
        UPTICKS: "TT Selected",
        GRNI: "TT Selected",
        GRNJ: "TT Selected",
        GRNY: "TT Selected",
      };

      const GROUP_ORDER = [
        "SP_Sectors",
        "Futures",
        "UPTICKS",
        "GRNI",
        "GRNJ",
        "GRNY",
        "Other",
      ];

      function normTicker(t) {
        let s = String(t || "")
          .trim()
          .toUpperCase();
        // Normalize BRK.B to BRK-B (TradingView sends BRK.B, but we use BRK-B for US market)
        if (s === "BRK.B" || s === "BRK-B") {
          s = "BRK-B";
        }
        return s;
      }

      function groupsForTicker(t) {
        const T = normTicker(t);
        const out = [];
        for (const [g, set] of Object.entries(GROUPS)) {
          if (set.has(T)) out.push(g);
        }
        if (out.length === 0) out.push("Other");
        return out;
      }

      function isTickerTTSelected(t) {
        const T = normTicker(t);
        return (GROUPS.UPTICKS?.has(T) || GROUPS.GRNI?.has(T) || GROUPS.GRNJ?.has(T) || GROUPS.GRNY?.has(T));
      }

      function isTickerInGroups(t) {
        const T = normTicker(t);
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) return true;
        return true;
      }

      // ─────────────────────────────────────────────────────────────
      // Utils
      // ─────────────────────────────────────────────────────────────

      // Phase-based color (Turbo-like gradient: 0=green, 0.5=yellow, 1=red)
      // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
      function phaseCompletionToColor(phasePct) {
        const p = Math.max(0, Math.min(1, phasePct));
        if (p < 0.3) {
          // Green: #14b8a6 (under 30%)
          return "#14b8a6";
        } else if (p < 0.6) {
          // Yellow: #eab308 (30-60%)
          return "#eab308";
        } else {
          // Red: #e11d48 (60-100%)
          return "#e11d48";
        }
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          // Teal to darker teal: #14b8a6 (20,184,166) → #0d9488 (13,148,136)
          const t = p / 0.2;
          return `rgb(${Math.round(20 + (13 - 20) * t)}, ${Math.round(
            184 + (148 - 184) * t,
          )}, ${Math.round(166 + (136 - 166) * t)})`;
        } else if (p < 0.4) {
          // Darker teal to yellow: #0d9488 (13,148,136) → #eab308 (234,179,8)
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(13 + (234 - 13) * t)}, ${Math.round(
            148 + (179 - 148) * t,
          )}, ${Math.round(136 + (8 - 136) * t)})`;
        } else if (p < 0.6) {
          // Yellow to orange: #eab308 (234,179,8) → #f97316 (249,115,22)
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(234 + (249 - 234) * t)}, ${Math.round(
            179 + (115 - 179) * t,
          )}, ${Math.round(8 + (22 - 8) * t)})`;
        } else if (p < 0.8) {
          // Orange to cherry: #f97316 (249,115,22) → #e11d48 (225,29,72)
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(249 + (225 - 249) * t)}, ${Math.round(
            115 + (29 - 115) * t,
          )}, ${Math.round(22 + (72 - 22) * t)})`;
        } else {
          // Cherry to dark cherry: #e11d48 (225,29,72) → #9f1239 (159,18,57)
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(225 + (159 - 225) * t)}, ${Math.round(
            29 + (18 - 29) * t,
          )}, ${Math.round(72 + (57 - 72) * t)})`;
        }
      }

      // Move status helpers (Active / Invalidated / Completed)
      function prettyMoveReason(r) {
        const key = String(r || "").trim();
        const map = {
          sl_breached: "SL breached",
          tp_reached: "TP reached",
          daily_ema_regime_break: "Daily EMA regime break",
          ichimoku_regime_break: "Ichimoku regime break",
          late_cycle: "Late-cycle",
          overextended: "Overextended",
          left_entry_corridor: "Left entry corridor",
        };
        return map[key] || key.replace(/_/g, " ");
      }

      function getMoveStatusInfo(ticker) {
        const ms =
          ticker?.move_status && typeof ticker.move_status === "object"
            ? ticker.move_status
            : null;
        const hasMoveStatus = !!(ms && ms.status);
        const statusRaw = ms?.status ? String(ms.status) : "";
        const status = statusRaw ? statusRaw.trim().toUpperCase() : "ACTIVE";
        const sideRaw = ms?.side ? String(ms.side) : "";
        const side = sideRaw ? sideRaw.trim().toUpperCase() : null;
        const severityRaw = ms?.severity ? String(ms.severity) : "";
        const severity = severityRaw
          ? severityRaw.trim().toUpperCase()
          : "NONE";
        const reasons = Array.isArray(ms?.reasons)
          ? ms.reasons
              .filter((x) => x != null)
              .map((x) => String(x))
              .map((x) => x.trim())
              .filter(Boolean)
          : [];
        const headlineReason = reasons.length
          ? prettyMoveReason(reasons[0])
          : null;

        if (status === "INVALIDATED") {
          return {
            hasMoveStatus,
            status,
            side,
            severity,
            reasons,
            icon: "⛔",
            pillCls: "bg-rose-500/15 text-rose-300 border-rose-500/40",
            stroke: "#e11d48",
            dash: "4 3",
            headlineReason,
          };
        }
        if (status === "COMPLETED") {
          return {
            hasMoveStatus,
            status,
            side,
            severity,
            reasons,
            icon: "✅",
            pillCls: "bg-purple-500/15 text-purple-300 border-purple-500/40",
            stroke: "#a855f7",
            dash: "2 3",
            headlineReason,
          };
        }
        return {
          hasMoveStatus,
          status: "ACTIVE",
          side,
          severity,
          reasons,
          icon: "🟢",
          pillCls: "bg-teal-500/10 text-teal-300 border-teal-500/30",
          stroke: "#14b8a6",
          dash: null,
          headlineReason,
        };
      }

      function computeMoveProgressPct(ticker) {
        const mv = getMoveStatusInfo(ticker);
        const side = mv?.side;
        const price = Number(ticker?.price);
        const triggerPrice = Number(ticker?.trigger_price);
        const tp = Number(ticker?.tp);
        if (
          !side ||
          !Number.isFinite(price) ||
          !Number.isFinite(triggerPrice) ||
          !Number.isFinite(tp)
        )
          return null;
        if (side === "LONG") {
          const den = tp - triggerPrice;
          if (!Number.isFinite(den) || Math.abs(den) < 1e-9) return null;
          return Math.max(0, Math.min(1.2, (price - triggerPrice) / den));
        }
        if (side === "SHORT") {
          const den = triggerPrice - tp;
          if (!Number.isFinite(den) || Math.abs(den) < 1e-9) return null;
          return Math.max(0, Math.min(1.2, (triggerPrice - price) / den));
        }
        return null;
      }

      function formatAgeFromTs(tsLike) {
        const ts = Number(tsLike);
        if (!Number.isFinite(ts) || ts <= 0) return null;
        const ms = ts < 1e12 ? ts * 1000 : ts;
        const ageMs = Date.now() - ms;
        if (!Number.isFinite(ageMs) || ageMs < 0) return null;
        const mins = Math.floor(ageMs / 60000);
        if (mins < 60) return `${mins}m`;
        const hrs = Math.floor(mins / 60);
        if (hrs < 24) return `${hrs}h`;
        const days = Math.floor(hrs / 24);
        return `${days}d`;
      }

      // Trail/Bubble-journey derived intent classifier (entry-focused, but can recommend HOLD/EXIT).
      function classifyEntryIntent(ticker) {
        const t = ticker && typeof ticker === "object" ? ticker : {};
        const flags = t.flags && typeof t.flags === "object" ? t.flags : {};
        const move = getMoveStatusInfo(t);
        const ent = entryType(t);
        const inCorridor = !!ent?.corridor;

        const rr = Number(t.rr);
        const rank = Number(t.rank);
        const comp = completionForSize(t);
        const phase = Number(t.phase_pct);
        const zone = String(t.phase_zone || "").toUpperCase();

        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const inSqueeze = sqOn && !sqRel;
        const momentumElite = !!flags.momentum_elite;
        const thesis = flags.thesis_match === true;

        const deltas = t.deltas && typeof t.deltas === "object" ? t.deltas : {};
        const seq = t.seq && typeof t.seq === "object" ? t.seq : {};
        const patt =
          seq.pattern && typeof seq.pattern === "object" ? seq.pattern : {};

        const htf4h = Number(deltas.htf_4h);
        const ltf4h = Number(deltas.ltf_4h);
        const htfImproving4h = !!flags.htf_improving_4h;
        const htfMove4h = Number.isFinite(htf4h) ? Math.abs(htf4h) : 0;

        // Exit conditions (even if move_status still says ACTIVE)
        const lateCycle =
          zone === "HIGH" ||
          zone === "EXTREME" ||
          (Number.isFinite(phase) && phase >= 0.75);
        const overextended = Number.isFinite(comp) && comp >= 0.9;
        if (
          move.hasMoveStatus &&
          (move.status === "INVALIDATED" || move.status === "COMPLETED")
        ) {
          return {
            group:
              move.status === "COMPLETED"
                ? "Completed moves"
                : "Invalidated moves",
            action: "EXIT",
            confidence: 0.95,
            why: [move.headlineReason || move.status],
          };
        }
        if (overextended || lateCycle) {
          return {
            group: "Late-cycle / Overextended",
            action: "EXIT",
            confidence: overextended ? 0.9 : 0.75,
            why: [
              overextended ? "Completion very high" : null,
              lateCycle ? `Phase zone ${zone || "HIGH"}` : null,
            ].filter(Boolean),
          };
        }

        // Entry archetypes (grouping)
        const squeezeToMomentum = patt.squeezeReleaseToMomentum_6h === true;
        const corridorReclaim = seq.corridorEntry_60m === true;
        const squeezeOnToRelease = patt.squeezeOnToRelease_24h === true;

        if (squeezeToMomentum) {
          return {
            group: "Squeeze → Momentum",
            action: inCorridor ? "ENTRY" : "WAIT",
            confidence: inCorridor ? 0.82 : 0.7,
            why: [
              "Squeeze release → momentum transition",
              htfImproving4h ? "HTF improving (4h)" : null,
              Number.isFinite(rr) ? `RR ${rr.toFixed(2)}` : null,
            ].filter(Boolean),
          };
        }

        if (momentumElite && (sqRel || htfImproving4h || htfMove4h >= 5)) {
          return {
            group: "Momentum Elite",
            action: inCorridor ? "ENTRY" : "HOLD",
            confidence: inCorridor ? 0.8 : 0.68,
            why: [
              "Momentum Elite",
              sqRel ? "Squeeze release" : null,
              htfImproving4h ? "HTF improving (4h)" : null,
            ].filter(Boolean),
          };
        }

        if (corridorReclaim && htfImproving4h) {
          return {
            group: "Corridor reclaim",
            action: inCorridor ? "ENTRY" : "HOLD",
            confidence: inCorridor ? 0.78 : 0.62,
            why: ["Recent corridor entry", "HTF improving (4h)"],
          };
        }

        if (inSqueeze && (inCorridor || squeezeOnToRelease)) {
          return {
            group: "Squeeze pressure build",
            action: inCorridor ? "WAIT" : "HOLD",
            confidence: 0.62,
            why: ["Squeeze ON", "Waiting for release"],
          };
        }

        // Default: make a sensible ENTRY vs HOLD/WAI
        const baseGood =
          Number.isFinite(rank) &&
          rank >= 70 &&
          Number.isFinite(rr) &&
          rr >= 1.3 &&
          comp <= 0.7;
        const momentumGood =
          (Number.isFinite(htf4h) &&
            Number.isFinite(ltf4h) &&
            (htfMove4h >= 5 || Math.abs(ltf4h) >= 5)) ||
          htfImproving4h ||
          thesis;

        if (baseGood && momentumGood) {
          return {
            group: "Trend continuation",
            action: inCorridor ? "ENTRY" : "HOLD",
            confidence: inCorridor ? 0.68 : 0.55,
            why: [
              thesis ? "Thesis match" : null,
              htfImproving4h ? "HTF improving (4h)" : null,
              Number.isFinite(htf4h) ? `ΔHTF(4h) ${htf4h.toFixed(1)}` : null,
            ].filter(Boolean),
          };
        }

        return {
          group: "Unclear / Chop",
          action: inCorridor ? "WAIT" : "HOLD",
          confidence: 0.45,
          why: [
            inCorridor
              ? "In corridor but weak confirmation"
              : "Out of corridor",
            thesis ? "Thesis match (weak)" : null,
          ].filter(Boolean),
        };
      }

      // ── Unified Prime Badge ──────────────────────────────────────
      // Merges the old Prime, Thesis, and Winner badges into one clear
      // quality signal.  Returns false | { reason: string } so the UI
      // can show a tooltip explaining WHY it qualified.
      //
      // A ticker is Prime when it passes a quality gate AND at least one
      // confirmation signal fires:
      //   Quality:  rank ≥ 70, RR ≥ 1.5, completion < 0.5, phase < 0.65
      //   Confirm:  aligned state, thesis match, winner pattern,
      //             squeeze release, phase zone change, momentum elite
      function isPrimeBubble(ticker) {
        if (!ticker) return false;
        // rank and score are the same 0-100 composite; use either as fallback
        const rank = Number(ticker.rank ?? ticker.score ?? 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        // ── Quality gate (all must pass) ──
        if (!(rank >= 70 && rr >= 1.5 && comp < 0.5 && phase < 0.65)) return false;

        // ── Confirmation signals (at least one) ──
        const aligned = state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const thesisMatch = flags.thesis_match === true;
        const momentumElite = !!flags.momentum_elite;

        // Winner pattern: pullback + corridor + very early
        const ent = entryType(ticker);
        const inPullback = state.includes("PULLBACK");
        const inCorridor = !!ent?.corridor;
        const veryEarly = comp < 0.15 && phase < 0.6;
        const inSqueeze = !!flags.sq30_on && !flags.sq30_release;
        const winnerPattern = inPullback && inCorridor && veryEarly;

        if (aligned) return { reason: "aligned" };
        if (thesisMatch) return { reason: "thesis" };
        if (winnerPattern) return { reason: "winner" };
        if (sqRel) return { reason: "squeeze_release" };
        if (momentumElite) return { reason: "momentum" };
        if (phaseZoneChange) return { reason: "phase_change" };

        return false;
      }

      // Keep winnerSignatureScore for ranking/sorting (returns 0-5 count)
      function winnerSignatureScore(ticker) {
        if (!ticker) return 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");
        const ent = entryType(ticker);
        const comp = completionForSize(ticker);
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : NaN;
        const isSetup = state.includes("PULLBACK");
        const inCorridor = !!ent?.corridor;
        const lowCompletion = Number.isFinite(comp) && comp < 0.15;
        const earlyPhase = Number.isFinite(phase) && phase < 0.6;
        const inSqueeze = !!flags.sq30_on && !flags.sq30_release;
        return [isSetup, inCorridor, lowCompletion, earlyPhase, inSqueeze].filter(Boolean).length;
      }

      // Kept for backward compat (filters, sorting) but UI no longer shows separate badge
      function isWinnerSignature(ticker) {
        const p = isPrimeBubble(ticker);
        return p && p.reason === "winner";
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function completionForSize(ticker) {
        // Use the completion value from Pine Script payload directly
        // Pine Script calculates: completion = abs(close - triggerPrice) / expectedMove
        // This is more accurate than recalculating from trigger to TP because:
        // 1. It accounts for expectedMove (which may differ from TP distance)
        // 2. It handles direction correctly
        // 3. It works even when price hasn't reached trigger yet
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      function getDirectionFromState(ticker) {
        const state = String(ticker?.state || "");
        // Use HTF (higher timeframe) direction — the primary trend.
        // state.includes("BULL") is wrong: it matches LTF_BULL in HTF_BEAR_LTF_BULL.
        if (state.startsWith("HTF_BULL")) return "LONG";
        if (state.startsWith("HTF_BEAR")) return "SHORT";
        // Fallback for non-standard states
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        return null;
      }

      function computeEntryRef(ticker) {
        const entryRef = numFromAny(ticker?.entry_ref);
        if (Number.isFinite(entryRef) && entryRef > 0) return entryRef;
        const trigger = numFromAny(ticker?.trigger_price);
        if (Number.isFinite(trigger) && trigger > 0) return trigger;
        const price = numFromAny(
          ticker?.price ?? ticker?.close ?? ticker?.c ?? ticker?.last,
        );
        return Number.isFinite(price) && price > 0 ? price : null;
      }

      function computeTpMaxPrice(ticker) {
        const entry = computeEntryRef(ticker);
        if (!Number.isFinite(entry)) return null;
        const directMax = numFromAny(ticker?.tp_max_price ?? ticker?.tp_max);
        if (Number.isFinite(directMax) && directMax > 0) return directMax;
        const dir = getDirectionFromState(ticker);
        const tpLevels = Array.isArray(ticker?.tp_levels)
          ? ticker.tp_levels
          : [];
        const candidates = tpLevels
          .map((tp) => {
            const px =
              tp && typeof tp === "object" && tp.price != null ? tp.price : tp;
            const price = numFromAny(px);
            return Number.isFinite(price) ? price : null;
          })
          .filter((p) => Number.isFinite(p));

        if (ticker?.tp != null) {
          const tp = numFromAny(ticker.tp);
          if (Number.isFinite(tp)) candidates.push(tp);
        }

        if (candidates.length === 0) return null;

        if (dir === "LONG") {
          const valid = candidates.filter((p) => p > entry);
          return valid.length > 0 ? Math.max(...valid) : null;
        }
        if (dir === "SHORT") {
          const valid = candidates.filter((p) => p < entry);
          return valid.length > 0 ? Math.min(...valid) : null;
        }

        return null;
      }

      function computeTpTargetPrice(ticker) {
        const directTarget = numFromAny(
          ticker?.tp_target_price ?? ticker?.tp_target,
        );
        if (Number.isFinite(directTarget) && directTarget > 0)
          return directTarget;
        const primary = numFromAny(ticker?.tp);
        if (Number.isFinite(primary) && primary > 0) return primary;
        return null;
      }

      function numFromAny(v) {
        if (v == null) return null;
        if (typeof v === "number") return Number.isFinite(v) ? v : null;
        if (typeof v === "string") {
          const s = v.trim();
          if (!s) return null;
          // Accept things like "$77.16", "77.16 USD", "1,234.50"
          const m = s.replace(/,/g, "").match(/-?\d+(\.\d+)?/);
          if (!m) return null;
          const n = Number(m[0]);
          return Number.isFinite(n) ? n : null;
        }
        // Common object formats: { price }, etc.
        if (typeof v === "object" && v.price != null)
          return numFromAny(v.price);
        return null;
      }

      function formatBlockReason(raw) {
        return String(raw).split("+").map(r => {
          const m = r.match(/^sector_full:(\d+)\/(\d+)\s*(.*)/);
          if (m) return `Max ${m[3] || "sector"} positions reached (${m[1]}/${m[2]})`;
          const d = r.match(/^direction_full:(\d+)\/(\d+)\s*(LONG|SHORT)/i);
          if (d) return `Max ${d[3].toLowerCase()} positions reached (${d[1]}/${d[2]})`;
          const c = r.match(/^correlated:(\d+)\s+in\s+(.*)/);
          if (c) return `Too many correlated positions in ${c[2]} (${c[1]})`;
          const dl = r.match(/^daily_limit:(\d+)\/(\d+)/);
          if (dl) return `Daily entry limit reached (${dl[1]}/${dl[2]})`;
          if (r === "cooldown") return "Entry cooldown active";
          if (r === "smart_gate") return "Risk management gate";
          if (r === "outside_RTH") return "Outside regular trading hours";
          if (r === "weekend") return "Market closed (weekend)";
          if (r === "same_cycle") return "Already attempted this cycle";
          if (r === "existing_position") return "Position already open";
          if (r === "recent_trade") return "Recent trade on this ticker";
          return r.replace(/_/g, " ");
        }).join(", ");
      }

      // ── Shared price utilities (from shared-price-utils.js) ──
      // Single source of truth for daily change, staleness, and market-hours logic.
      const getIngestMs = window.TimedPriceUtils.getIngestMs;
      const getNyClock = window.TimedPriceUtils.getNyClock;
      const isNyRegularMarketOpen = window.TimedPriceUtils.isNyRegularMarketOpen;
      const ageLabelFromMinutes = window.TimedPriceUtils.ageLabelFromMinutes;
      const getStaleInfo = window.TimedPriceUtils.getStaleInfo;
      const getDailyChange = window.TimedPriceUtils.getDailyChange;

      // Market Pulse tickers: indices + S&P sector ETFs + crypto
      const MARKET_PULSE_TICKERS = [
        // Indices / futures / commodities
        "SPX", "US500", "ES1!", "NQ1!", "RTY1!", "YM1!", "SPY", "QQQ", "IWM", "CL1!", "GC1!", "SI1!", "VX1!",
        // Crypto
        "BTCUSD", "ETHUSD",
        // S&P 500 sector ETFs
        "XLK", "XLF", "XLY", "XLP", "XLC", "XLI", "XLB", "XLE", "XLRE", "XLU", "XLV",
      ];

      // Shared card skin (used by Kanban + Viewport cards)
      // - background tint by daily % change (blue/orange)
      // - completion fill overlay (left->right)
      // - subtle edge glow by direction of daily change
      function getCardSkin(t) {
        const pickNum = (obj, keys) => {
          for (const k of keys) {
            const v = Number(obj?.[k]);
            if (Number.isFinite(v)) return v;
          }
          return null;
        };

        const priceNum = Number(t?.price ?? t?.close);
        const prevCloseNum = pickNum(t, [
          "prev_close",
          "previous_close",
          "prior_close",
          "yclose",
          "close_prev",
        ]);

        const baseDaily = getDailyChange(t) || {};
        let dayPct = Number(baseDaily?.dayPct);
        let dayChg = Number(baseDaily?.dayChg);

        if (!Number.isFinite(dayPct)) {
          dayPct = pickNum(t, [
            "day_change_pct",
            "daily_change_pct",
            "session_change_pct",
            "change_pct",
            "pct_change",
            "chp",
          ]);
        }
        if (!Number.isFinite(dayChg)) {
          dayChg = pickNum(t, [
            "day_change",
            "daily_change",
            "session_change",
            "change",
            "chg",
            "ch",
          ]);
        }
        if (
          (!Number.isFinite(dayChg) || !Number.isFinite(dayPct)) &&
          Number.isFinite(priceNum) &&
          priceNum > 0 &&
          Number.isFinite(prevCloseNum) &&
          prevCloseNum > 0
        ) {
          const chg = priceNum - prevCloseNum;
          const pct = (chg / prevCloseNum) * 100;
          if (!Number.isFinite(dayChg)) dayChg = chg;
          if (!Number.isFinite(dayPct)) dayPct = pct;
        }

        // Card background intensity: use daily change during market hours
        // (intraday moves matter most) with weekly as fallback off-hours.
        const weeklyPct = pickNum(t, ["weekly_change_pct"]);
        const intensityPct = Number.isFinite(dayPct) && Math.abs(dayPct) > 0.1
          ? dayPct
          : Number.isFinite(weeklyPct) ? weeklyPct : dayPct;
        const intensityAbs = Number.isFinite(intensityPct) ? Math.abs(intensityPct) : 0;

        let tintAlpha = 0;
        let edgePx = 0;
        let edgeAlpha = 0;
        let intensityPulse = "";
        if (intensityAbs > 0.1) {
          if (intensityAbs <= 1)       { tintAlpha = 0.10 + (intensityAbs) * 0.10; edgePx = 1; edgeAlpha = 0.25; }
          else if (intensityAbs <= 3)  { tintAlpha = 0.20 + ((intensityAbs - 1) / 2) * 0.20; edgePx = 1.5; edgeAlpha = 0.40; }
          else if (intensityAbs <= 6)  { tintAlpha = 0.40 + ((intensityAbs - 3) / 3) * 0.20; edgePx = 2; edgeAlpha = 0.55; }
          else if (intensityAbs <= 12) { tintAlpha = 0.60 + ((intensityAbs - 6) / 6) * 0.15; edgePx = 2.5; edgeAlpha = 0.70; }
          else                         { tintAlpha = 0.75; edgePx = 3; edgeAlpha = 0.85; intensityPulse = "intensity-pulse"; }
        }
        const isUp = Number.isFinite(intensityPct) && intensityPct > 0;
        const isDown = Number.isFinite(intensityPct) && intensityPct < 0;
        const greenRgb = "34,197,94";
        const redRgb = "239,68,68";
        const rgb = isUp ? greenRgb : isDown ? redRgb : "0,0,0";
        const tint = (isUp || isDown) ? `rgba(${rgb},${tintAlpha.toFixed(3)})` : "rgba(0,0,0,0)";

        const bgTint = `linear-gradient(0deg, ${tint}, ${tint})`;
        const bgImage = bgTint;

        const dayEdgeClass = (isUp || isDown)
          ? `shadow-[0_0_0_${edgePx}px_rgba(${rgb},${edgeAlpha.toFixed(2)})]`
          : "";

        return {
          dayChg: Number.isFinite(dayChg) ? dayChg : null,
          dayPct: Number.isFinite(dayPct) ? dayPct : null,
          weeklyPct: Number.isFinite(weeklyPct) ? weeklyPct : null,
          bgImage,
          dayEdgeClass,
          intensityPulse,
        };
      }

      let _sparkIdCounter = 0;
      function Sparkline({ data: rawData, width = 200, height = 48, color, bgMode = false }) {
        const gradIdRef = React.useRef(`spg${++_sparkIdCounter}`);
        if (!Array.isArray(rawData) || rawData.length < 2) return null;
        // Filter outliers: if any value is >5x or <0.2x the median, drop it
        const sorted = [...rawData].filter(v => Number.isFinite(v) && v > 0).sort((a, b) => a - b);
        const median = sorted.length > 0 ? sorted[Math.floor(sorted.length / 2)] : 0;
        const data = median > 0 ? rawData.filter(v => Number.isFinite(v) && v > 0 && v < median * 5 && v > median * 0.2) : rawData;
        if (data.length < 2) return null;
        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min || 1;
        const padL = 0;
        const padR = bgMode ? 14 : 8;
        const padTop = bgMode ? 10 : 1;
        const padBot = bgMode ? 6 : 4;
        const w = width - padL - padR;
        const h = height - padTop - padBot;
        const points = data.map((v, i) => {
          const x = padL + (i / (data.length - 1)) * w;
          const y = padTop + h - ((v - min) / range) * h;
          return `${x.toFixed(1)},${y.toFixed(1)}`;
        }).join(" ");
        const last = data[data.length - 1];
        const first = data[0];
        const lineColor = color || (last >= first ? "#4ade80" : "#f87171");
        const dotXPct = (padL + w) / width * 100;
        const dotYPct = (padTop + h - ((last - min) / range) * h) / height * 100;
        const gradId = gradIdRef.current;
        const lineOpacity = bgMode ? 0.5 : 0.9;
        const fillTopOpacity = bgMode ? 0.14 : 0.15;
        const sw = bgMode ? "2" : "1.8";
        const mktOpen = isNyRegularMarketOpen();
        return (
          <div className="relative w-full h-full">
            <svg width="100%" height="100%" viewBox={`0 0 ${width} ${height}`} preserveAspectRatio="none" className="block" style={{ overflow: "visible" }}>
              <defs>
                <linearGradient id={gradId} x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0%" stopColor={lineColor} stopOpacity={fillTopOpacity} />
                  <stop offset="100%" stopColor={lineColor} stopOpacity="0" />
                </linearGradient>
              </defs>
              <polygon
                points={`${points} ${(padL + w).toFixed(1)},${height} ${padL},${height}`}
                fill={`url(#${gradId})`}
              />
              <polyline points={points} fill="none" stroke={lineColor} strokeWidth={sw} strokeLinecap="round" strokeLinejoin="round" opacity={lineOpacity} vectorEffect="non-scaling-stroke" />
            </svg>
            {/* Dot rendered as HTML so it stays circular despite SVG stretching */}
            <div className="absolute pointer-events-none" style={{
              left: `${dotXPct.toFixed(2)}%`,
              top: `${dotYPct.toFixed(2)}%`,
              transform: "translate(-50%, -50%)",
            }}>
              {mktOpen && (
                <div className="absolute rounded-full sparkline-pulse-ring" style={{
                  width: 20, height: 20,
                  left: "50%", top: "50%",
                  transform: "translate(-50%, -50%)",
                  border: `1.5px solid ${lineColor}`,
                  opacity: 0.25,
                }} />
              )}
              <div className={`rounded-full ${mktOpen ? "sparkline-pulse-dot" : ""}`} style={{
                width: 7, height: 7,
                background: lineColor,
                boxShadow: `0 0 6px ${lineColor}, 0 0 12px ${lineColor}40`,
                opacity: mktOpen ? 1 : 0.7,
              }} />
            </div>
          </div>
        );
      }
      window.TimedSparkline = Sparkline;

      function computeReturnPct(ticker) {
        const direct =
          numFromAny(ticker?.expected_return_pct) ||
          numFromAny(ticker?.tp_target_pct) ||
          numFromAny(ticker?.tp_max_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(ticker);
        // Use server-provided TP directly
        const tpTarget = numFromAny(ticker?.tp ?? ticker?.tp_trim);
        if (!Number.isFinite(entry) || !Number.isFinite(tpTarget)) return null;
        return (Math.abs(tpTarget - entry) / entry) * 100;
      }

      function computeRiskPct(ticker) {
        const direct = numFromAny(ticker?.risk_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(ticker);
        const sl = numFromAny(
          ticker?.sl ??
            ticker?.sl_price ??
            ticker?.stop_loss ??
            ticker?.stop ??
            ticker?.trade?.sl ??
            ticker?.trade?.sl_price,
        );
        if (!Number.isFinite(entry) || !Number.isFinite(sl)) return null;
        return (Math.abs(entry - sl) / entry) * 100;
      }

      function computeEtaDays(ticker) {
        const staleness = String(ticker?.staleness || "").toUpperCase();
        if (staleness && staleness !== "FRESH") return null;
        const baseEta = numFromAny(ticker?.eta_days_v2 ?? ticker?.eta_days);
        if (!Number.isFinite(baseEta) || baseEta <= 0) return null;
        const dir = getDirectionFromState(ticker);
        const entry = computeEntryRef(ticker);
        // Use server-provided TP directly
        const target = numFromAny(ticker?.tp ?? ticker?.tp_trim);
        const current = numFromAny(
          ticker?.price ?? ticker?.close ?? ticker?.c ?? ticker?.last,
        );
        if (
          !Number.isFinite(entry) ||
          !Number.isFinite(target) ||
          !Number.isFinite(current) ||
          !dir
        ) {
          return baseEta;
        }
        const totalDist = Math.abs(target - entry);
        if (!Number.isFinite(totalDist) || totalDist <= 0) return baseEta;
        const progress =
          dir === "LONG"
            ? (current - entry) / (target - entry)
            : (entry - current) / (entry - target);
        if (!Number.isFinite(progress)) return baseEta;
        const clamped = Math.max(0, Math.min(1, progress));
        const remaining = baseEta * (1 - clamped);
        return Math.max(0.1, Math.round(remaining * 100) / 100);
      }

      function computeHorizonBucket(src) {
        const bucket = String(src?.horizon_bucket || "")
          .trim()
          .toUpperCase();
        if (bucket) return bucket.replace("_", " ");
        const eta = computeEtaDays(src);
        if (!Number.isFinite(eta)) return "—";
        if (eta <= 7) return "SHORT TERM";
        if (eta <= 30) return "SWING";
        return "POSITIONAL";
      }

      function formatEntryZone(ticker) {
        const entry = computeEntryRef(ticker);
        const price = numFromAny(
          ticker?.price ?? ticker?.close ?? ticker?.c ?? ticker?.last,
        );
        if (!Number.isFinite(entry) || !Number.isFinite(price)) return "—";
        const low = Math.min(entry, price);
        const high = Math.max(entry, price);
        if (Math.abs(high - low) < 0.01) return `$${entry.toFixed(2)}`;
        return `$${low.toFixed(2)}–$${high.toFixed(2)}`;
      }

      function formatIngestTime(ticker) {
        const raw = ticker?.ingest_time ?? ticker?.ingest_ts ?? ticker?.ts;
        if (raw == null) return "—";
        const ms =
          typeof raw === "number" ? raw : new Date(String(raw)).getTime();
        if (!Number.isFinite(ms)) return "—";
        try {
          return new Date(ms).toLocaleString();
        } catch (e) {
          return new Date(ms).toISOString();
        }
      }

      // Compute bubble visuals (radius + color) for historical trail points.
      // NOTE: Trail points from KV/D1 may not include `rr`, so we fall back to `rank`
      // (similar to the main bubble renderers) to preserve meaningful size variation.
      // We also scale trail bubble radii down for readability while preserving relative size.
      function bubbleVisualForTrailPoint(point, tickerSymbol) {
        const comp =
          point && point.completion != null ? Number(point.completion) : 0;
        const validComp = Number.isFinite(comp)
          ? Math.max(0, Math.min(1, comp))
          : 0;

        // Prefer explicit phase_pct; otherwise fall back to completion as a proxy
        const phasePctRaw =
          point && point.phase_pct != null ? Number(point.phase_pct) : null;
        const phasePct =
          phasePctRaw != null && Number.isFinite(phasePctRaw)
            ? Math.max(0, Math.min(1, phasePctRaw))
            : validComp > 0
              ? validComp
              : 0.1;

        const rrRaw = point && point.rr != null ? Number(point.rr) : null;
        const rankRaw = point && point.rank != null ? Number(point.rank) : null;
        const fallbackRR =
          rankRaw != null && Number.isFinite(rankRaw)
            ? Math.max(0.5, Math.min(5, rankRaw / 50))
            : 0.5;
        const validRR =
          rrRaw != null && Number.isFinite(rrRaw) && rrRaw > 0
            ? rrRaw
            : fallbackRR;

        const cappedRR = Math.min(validRR, 5);
        const baseSize = 4;
        const rrMultiplier = 2;
        const size = baseSize + cappedRR * rrMultiplier * (1 - validComp);

        const sym = String(tickerSymbol || point?.ticker || "")
          .trim()
          .toUpperCase();
        const tickerHash = sym
          .split("")
          .reduce((acc, char) => acc + char.charCodeAt(0), 0);
        const sizeVariation = (tickerHash % 5) * 0.8;
        const finalSize = Math.max(baseSize, size + sizeVariation);

        // Trail bubbles should reflect their true size-at-the-time.
        const TRAIL_SIZE_SCALE = 1.0;
        const radius = Math.max(
          2.5,
          Math.min(50, finalSize * TRAIL_SIZE_SCALE),
        );
        const color = phaseCompletionToColor(phasePct);
        return { radius, color, phasePct, validComp, validRR };
      }

      // Split a trail into segments when there are big timestamp gaps.
      // This prevents confusing “teleport” lines (e.g., overnight / missing samples).
      function splitTrailByGaps(trail, gapMs = 30 * 60 * 1000) {
        if (!Array.isArray(trail) || trail.length === 0) return [];
        const segments = [];
        let cur = [];
        for (let i = 0; i < trail.length; i++) {
          const p = trail[i];
          const prev = i > 0 ? trail[i - 1] : null;
          const ts = Number(p?.ts);
          const prevTs = Number(prev?.ts);
          const hasGap =
            prev &&
            Number.isFinite(ts) &&
            Number.isFinite(prevTs) &&
            ts - prevTs > gapMs;
          if (hasGap && cur.length > 0) {
            segments.push(cur);
            cur = [];
          }
          cur.push(p);
        }
        if (cur.length > 0) segments.push(cur);
        return segments;
      }

      // Smooth path through points using Catmull-Rom → cubic Bezier conversion.
      function catmullRomPath(points) {
        if (!Array.isArray(points) || points.length < 2) return "";
        const pts = points.map((p) => ({
          x: Number(p?.x) || 0,
          y: Number(p?.y) || 0,
        }));
        let d = `M ${pts[0].x} ${pts[0].y}`;
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = i > 0 ? pts[i - 1] : pts[i];
          const p1 = pts[i];
          const p2 = pts[i + 1];
          const p3 = i + 2 < pts.length ? pts[i + 2] : p2;
          const c1x = p1.x + (p2.x - p0.x) / 6;
          const c1y = p1.y + (p2.y - p0.y) / 6;
          const c2x = p2.x - (p3.x - p1.x) / 6;
          const c2y = p2.y - (p3.y - p1.y) / 6;
          d += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
        }
        return d;
      }

      // Calculate score breakdown (mirrors computeDynamicScore / backend-style scoring)
      function calculateScoreBreakdown(ticker) {
        const htf = Number(ticker?.htf_score) || 0;
        const ltf = Number(ticker?.ltf_score) || 0;
        const phase = Number(ticker?.phase_pct) || 0;
        const rr = Number(ticker?.rr) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker?.flags || {};
        const state = String(ticker?.state || "");
        const ent = entryType(ticker || {});
        const inCorridor = !!ent?.corridor;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;

        const breakdown = {
          base: Number(ticker?.rank) || 50, // worker base score
          corridor: inCorridor ? 12 : 0,
          corridorAligned: inCorridor && aligned ? 8 : 0,
          squeezeRelease: sqRel && inCorridor ? 10 : 0,
          squeezeOn: sqOn && inCorridor && !sqRel ? 5 : 0,
          rr: rr >= 2.0 ? 8 : rr >= 1.5 ? 5 : rr >= 1.0 ? 2 : 0,
          phase: phase < 0.3 ? 6 : phase < 0.5 ? 3 : phase > 0.7 ? -5 : 0,
          completion: comp < 0.3 ? 5 : comp > 0.8 ? -8 : 0,
          htfStrength: Math.min(8, Math.abs(htf) * 0.15),
          ltfStrength: Math.min(6, Math.abs(ltf) * 0.12),
          phaseZoneChange: phaseZoneChange ? 4 : 0,
        };

        breakdown.total = Math.max(
          0,
          breakdown.base +
            breakdown.corridor +
            breakdown.corridorAligned +
            breakdown.squeezeRelease +
            breakdown.squeezeOn +
            breakdown.rr +
            breakdown.phase +
            breakdown.completion +
            breakdown.htfStrength +
            breakdown.ltfStrength +
            breakdown.phaseZoneChange,
        );

        return breakdown;
      }

      // Dynamic SCORE calculation that considers real-time conditions
      // NOTE: This returns a SCORE (0-200+), not a RANK (position 1-135)
      // RANK is determined by sorting all tickers by this score
      function computeDynamicScore(ticker) {
        const baseScore = Number(ticker.rank) || 50; // Base score from worker (0-100)
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;

        let dynamicScore = baseScore;

        // Corridor bonus (high priority - active setups)
        if (inCorridor) {
          dynamicScore += 12; // Strong bonus for being in corridor

          // Extra bonus if aligned AND in corridor (perfect setup)
          if (aligned) {
            dynamicScore += 8;
          }
        }

        // Squeeze release in corridor = very strong signal
        if (sqRel && inCorridor) {
          dynamicScore += 10;
        }

        // Squeeze on in corridor = building pressure
        if (sqOn && inCorridor && !sqRel) {
          dynamicScore += 5;
        }

        // RR bonus (scaled - better RR = higher score)
        if (rr >= 2.0) {
          dynamicScore += 8; // Excellent RR
        } else if (rr >= 1.5) {
          dynamicScore += 5; // Good RR
        } else if (rr >= 1.0) {
          dynamicScore += 2; // Acceptable RR
        }

        // Phase bonus (early phase = better opportunity)
        if (phase < 0.3) {
          dynamicScore += 6; // Very early
        } else if (phase < 0.5) {
          dynamicScore += 3; // Early
        } else if (phase > 0.7) {
          dynamicScore -= 5; // Late phase penalty
        }

        // Completion bonus (low completion = more room to run)
        if (comp < 0.3) {
          dynamicScore += 5; // Early in move
        } else if (comp > 0.8) {
          dynamicScore -= 8; // Near completion penalty
        }

        // Score strength bonus (strong HTF/LTF scores)
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;

        // Phase zone change bonus
        if (phaseZoneChange) {
          dynamicScore += 4;
        }

        // NO CAP - let scores go above 100 to avoid ties
        // Minimum is 0, but no maximum cap
        dynamicScore = Math.max(0, dynamicScore);

        return Math.round(dynamicScore * 100) / 100; // Round to 2 decimals for precision
      }

      // Alias for backward compatibility (but rename internally)
      const computeDynamicRank = computeDynamicScore;

      function toTickerArray(source) {
        if (!source) return [];
        if (Array.isArray(source)) {
          return source.filter((t) => t && typeof t === "object" && t.ticker);
        }
        if (typeof source === "object") {
          return Object.values(source).filter(
            (t) => t && typeof t === "object" && t.ticker,
          );
        }
        return [];
      }

      function rankScoreForTicker(ticker) {
        const rankScore = Number(ticker?.rank_score);
        if (Number.isFinite(rankScore)) return rankScore;
        const dynamicRank = Number(ticker?.dynamicRank);
        if (Number.isFinite(dynamicRank)) return dynamicRank;
        const dynamicScore = Number(ticker?.dynamicScore);
        if (Number.isFinite(dynamicScore)) return dynamicScore;
        return Number(computeDynamicRank(ticker)) || 0;
      }

      function getRankedTickers(source) {
        const list = toTickerArray(source);
        const withScores = list.map((t) => ({
          ...t,
          __rankPos: Number(t?.rank_position),
          __rankScore: rankScoreForTicker(t),
        }));
        withScores.sort((a, b) => {
          const rankA = Number(a.__rankPos);
          const rankB = Number(b.__rankPos);
          const hasRankA = Number.isFinite(rankA) && rankA > 0;
          const hasRankB = Number.isFinite(rankB) && rankB > 0;
          if (hasRankA && hasRankB) return rankA - rankB;
          if (hasRankA) return -1;
          if (hasRankB) return 1;
          const scoreA = Number(a.__rankScore) || 0;
          const scoreB = Number(b.__rankScore) || 0;
          return scoreB - scoreA;
        });
        return withScores;
      }

      function getRankPosition(sortedTickers, tickerSymbol) {
        const sym = String(tickerSymbol || "")
          .trim()
          .toUpperCase();
        if (!sym) return null;
        const index = sortedTickers.findIndex(
          (t) =>
            String(t.ticker || "")
              .trim()
              .toUpperCase() === sym,
        );
        return index >= 0 ? index + 1 : null;
      }

      function getRankPositionFromMap(rankPositions, tickerSymbol) {
        if (!rankPositions) return null;
        const sym = String(tickerSymbol || "")
          .trim()
          .toUpperCase();
        if (!sym) return null;
        const pos = Number(rankPositions[sym]);
        return Number.isFinite(pos) && pos > 0 ? pos : null;
      }

      function downsampleByInterval(points, intervalMs) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const buckets = new Map();
        points.forEach((p) => {
          const tsRaw = p.__ts_ms ?? p.ts ?? p.ingest_ts ?? p.ingest_time;
          const ts =
            typeof tsRaw === "string"
              ? new Date(tsRaw).getTime()
              : Number(tsRaw);
          if (!Number.isFinite(ts)) return;
          const bucket = Math.floor(ts / intervalMs) * intervalMs;
          const prev = buckets.get(bucket);
          if (!prev || ts > prev.__ts_ms) {
            buckets.set(bucket, { ...p, __ts_ms: ts, __bucket: bucket });
          }
        });
        return Array.from(buckets.values()).sort(
          (a, b) => a.__ts_ms - b.__ts_ms,
        );
      }

      // Debug: Verify function is loaded correctly
      console.log(
        "🔍 [RANKING SYSTEM] computeDynamicScore function loaded (no 100 cap)",
      );
      console.log(
        "🔍 [RANKING SYSTEM] Function signature:",
        typeof computeDynamicScore,
      );

      // Parse natural language query into filter conditions
      function parseNaturalLanguageQuery(query) {
        if (!query || typeof query !== "string") return null;

        const queryLower = query.toLowerCase().trim();
        const conditions = {};

        // Multi-ticker search: "AAPL, GOOGL, TSLA"
        // Also check if it's a simple ticker list (comma-separated, no filter keywords)
        if (
          query.includes(",") &&
          !query.match(
            /rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup|above|over|below|under/,
          )
        ) {
          return {
            type: "multi-ticker",
            tickers: query.split(",").map((t) => t.trim().toUpperCase()),
          };
        }

        // Ranked filter (all tickers sorted by rank)
        if (
          queryLower.match(/\btop\s*40\b|\btop40\b|\branked\b|\ball\s+ranked\b/)
        ) {
          conditions.top40 = true;
        }

        // Top N (rank-position) shortcuts:
        // - "top 2" / "top2" → topN=2
        // - "rank less than 3" / "rank under 3" / "rank < 3" → topN=2 (i.e., #1 and #2)
        // - "rank at most 3" / "rank <= 3" → topN=3
        const topNMatch = queryLower.match(/\btop\s*(\d+)\b/);
        if (topNMatch) {
          const n = parseInt(topNMatch[1], 10);
          if (Number.isFinite(n) && n > 0) {
            conditions.topN = n;
          }
        }
        const rankPosStrictMatch = queryLower.match(
          /\brank(?:ed)?\s*(?:<|less\s+than|under|below)\s*(\d+)\b/i,
        );
        if (rankPosStrictMatch) {
          const raw = parseInt(rankPosStrictMatch[1], 10);
          const n = Number.isFinite(raw) ? raw - 1 : NaN;
          if (Number.isFinite(n) && n > 0) {
            conditions.topN = n;
          }
        }
        const rankPosLteMatch = queryLower.match(
          /\brank(?:ed)?\s*(?:<=|at\s+most)\s*(\d+)\b/i,
        );
        if (rankPosLteMatch) {
          const n = parseInt(rankPosLteMatch[1], 10);
          if (Number.isFinite(n) && n > 0) {
            conditions.topN = n;
          }
        }

        // Top Long Setup
        if (queryLower.match(/\btop\s*long\s*setup\b|\btop\s*long\b/)) {
          conditions.topLongSetup = true;
        }

        // Top Short Setup
        if (queryLower.match(/\btop\s*short\s*setup\b|\btop\s*short\b/)) {
          conditions.topShortSetup = true;
        }

        // Prime setup
        if (queryLower.match(/\bprime\b|\bprime setup\b/)) {
          conditions.prime = true;
        }

        // Momentum Elite
        if (queryLower.match(/\bmomentum elite\b|\belite\b/)) {
          conditions.momentumElite = true;
        }

        // In corridor
        if (queryLower.match(/\bin corridor\b|\bcorridor\b/)) {
          conditions.inCorridor = true;
        }

        // Squeeze release
        if (queryLower.match(/\bsqueeze release\b|\bsqueeze released\b/)) {
          conditions.squeezeRelease = true;
        }

        // Helper function to extract numeric value with various operators
        const extractNumericCondition = (
          pattern,
          fieldName,
          isPercentage = false,
        ) => {
          // Match operators: >, >=, <, <=, above, below, over, under, greater than, less than, at least, at most
          const operators = {
            ">": "min",
            ">=": "min",
            above: "min",
            over: "min",
            "greater than": "min",
            "at least": "min",
            "<": "max",
            "<=": "max",
            below: "max",
            under: "max",
            "less than": "max",
            "at most": "max",
          };

          for (const [op, type] of Object.entries(operators)) {
            const regex = new RegExp(
              `\\b${pattern}\\s*(?:${op.replace(
                /[.*+?^${}()|[\]\\]/g,
                "\\$&",
              )})\\s*([\\d.]+)\\s*%?`,
              "i",
            );
            const match = queryLower.match(regex);
            if (match) {
              const value = isPercentage
                ? parseFloat(match[1]) / 100
                : parseFloat(match[1]);
              return { type, value };
            }
          }
          return null;
        };

        // Rank conditions (score threshold): "rank > 75", "rank above 75", "rank over 75"
        // NOTE: rank-position queries (e.g. "rank < 3") are handled above via `topN`.
        const rankCondition = extractNumericCondition("rank", "rank");
        if (rankCondition) {
          if (rankCondition.type === "min") {
            conditions.minRank = rankCondition.value;
          } else {
            // For max rank, we'd need a maxRank filter - skip for now
          }
        }

        // RR/Risk-Reward conditions: "RR > 2", "risk reward over 2", "RR above 1.5"
        const rrCondition = extractNumericCondition(
          "(?:rr|risk[\\s-]?reward)",
          "rr",
        );
        if (rrCondition && rrCondition.type === "min") {
          conditions.minRR = rrCondition.value;
        }

        // Phase conditions: "phase > 50%", "phase over 50%", "phase above 50", "phase under 30%"
        const phaseMinCondition = extractNumericCondition(
          "phase",
          "phase",
          true,
        );
        if (phaseMinCondition && phaseMinCondition.type === "min") {
          conditions.minPhase = phaseMinCondition.value;
        }
        const phaseMaxCondition = extractNumericCondition(
          "phase",
          "phase",
          true,
        );
        if (phaseMaxCondition && phaseMaxCondition.type === "max") {
          conditions.maxPhase = phaseMaxCondition.value;
        }

        // Completion conditions: "completion < 30%", "completion under 30%", "completion below 50%"
        const compCondition = extractNumericCondition(
          "completion",
          "completion",
          true,
        );
        if (compCondition && compCondition.type === "max") {
          conditions.maxCompletion = compCondition.value;
        }

        // Price change: "moved 5 points", "moved $5", "price change > 5", "price change over 5"
        const priceChangeMatch = queryLower.match(
          /\b(?:moved|price\s*change)\s+(?:over|above|greater\s*than|>|>=|at\s*least)\s*(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/,
        );
        if (priceChangeMatch) {
          conditions.minPriceChange = parseFloat(priceChangeMatch[1]);
        } else {
          // Also support "moved 5 points" without operator
          const simplePriceChangeMatch = queryLower.match(
            /\bmoved\s+(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/,
          );
          if (simplePriceChangeMatch) {
            conditions.minPriceChange = parseFloat(simplePriceChangeMatch[1]);
          }
        }

        // If we found any conditions, return them
        if (Object.keys(conditions).length > 0) {
          return { type: "query", conditions };
        }

        return null;
      }

      function applyFilters(dataObj, filters, trades = [], socialAdditions = [], savedTickerSet = null) {
        const out = [];

        const deriveHorizonBucket = (t) => {
          const etaRaw = t?.eta_days_v2 ?? t?.eta_days;
          const eta = Number(etaRaw);
          if (!Number.isFinite(eta) || eta <= 0) return null;
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        // Opportunity classification used by Viewport + Bubble Chart filtering
        const isEligibleOpportunity = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = Number(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);

          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < 1.5) return false;
          if (Number.isFinite(completion) && completion > 0.6) return false;
          if (Number.isFinite(ret) && ret < 5) return false;
          if (Number.isFinite(risk) && risk < 0.5) return false;
          if (Number.isFinite(etaConf) && etaConf < 0.55) return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > 0.75) return false;
          if (Number.isFinite(diversity) && diversity < 25) return false;
          return true;
        };

        const guidanceCategoryForAction = (action) => {
          const a = String(action || "").toLowerCase();
          if (!a) return "OTHER";
          if (a.includes("exit") || a.includes("trim")) return "EXIT_TRIM";
          if (a.startsWith("monitor") || a.includes("monitor closely"))
            return "MONITOR";
          if (a.startsWith("initiate")) return "INITIATE";
          if (a.startsWith("consider")) return "CONSIDER";
          if (a.startsWith("wait")) return "WAIT";
          if (a.includes("blocked")) return "BLOCKED";
          return "OTHER";
        };

        // Create a set of tickers that have trades (normalize ticker names)
        const tickersWithTrades = new Set();
        if (Array.isArray(trades)) {
          trades.forEach((trade) => {
            if (trade && trade.ticker) {
              tickersWithTrades.add(normTicker(trade.ticker));
            }
          });
        }

        // Parse natural language query if search field looks like a query
        const queryResult = parseNaturalLanguageQuery(filters.search);
        let effectiveFilters = { ...filters };
        let multiTickerList = null;

        if (queryResult) {
          if (queryResult.type === "multi-ticker") {
            multiTickerList = queryResult.tickers;
            // Clear search filter since we're handling it manually
            effectiveFilters = { ...effectiveFilters, search: "" };
          } else if (queryResult.type === "query") {
            // Merge query conditions into filters
            effectiveFilters = {
              ...effectiveFilters,
              ...queryResult.conditions,
              search: "",
            };
          }
        }

        // Parse ticker filter (comma-separated ticker symbols)
        const tickerFilterSet = new Set();
        // Support tickerFilter from dedicated field OR from search query if it's a multi-ticker query
        if (
          effectiveFilters.tickerFilter &&
          typeof effectiveFilters.tickerFilter === "string"
        ) {
          effectiveFilters.tickerFilter
            .split(",")
            .map((t) => t.trim().toUpperCase())
            .filter(Boolean)
            .forEach((t) => tickerFilterSet.add(t));
        }
        // Also check if search query is a multi-ticker list
        if (queryResult && queryResult.type === "multi-ticker") {
          queryResult.tickers.forEach((t) => tickerFilterSet.add(t));
        }

        for (const [tickerRaw, d] of Object.entries(dataObj)) {
          // Skip completely empty entries, but allow entries with just ticker name
          if (!d || typeof d !== "object") continue;
          const ticker = String(tickerRaw || d.ticker || "")
            .trim()
            .toUpperCase();
          if (!ticker) continue;

          // Apply ticker filter if specified
          if (tickerFilterSet.size > 0 && !tickerFilterSet.has(ticker)) {
            continue;
          }

          // Horizon bucket filter (SHORT_TERM / SWING / POSITIONAL)
          if (
            effectiveFilters.horizonBucket &&
            typeof effectiveFilters.horizonBucket === "string"
          ) {
            const rawBucket = d?.horizon_bucket || deriveHorizonBucket(d) || "";
            const hb = String(rawBucket).trim().toUpperCase();
            if (hb !== String(effectiveFilters.horizonBucket).toUpperCase()) {
              continue;
            }
          }

          // Show all tickers - they will be in a group (including "Other" if unmapped)
          const isSPSector =
            GROUPS.SP_Sectors && GROUPS.SP_Sectors.has(normTicker(ticker));
          const isFuture =
            GROUPS.Futures && GROUPS.Futures.has(normTicker(ticker));
          const inGroups = isTickerInGroups(ticker);

          // All tickers shown (either in a group or in "Other")
          // This check is now redundant but kept for clarity
          if (!inGroups) {
            console.log(
              `[FILTER] ${ticker} skipped: unexpected - should be in a group`,
            );
            continue;
          }

          // Include tickers even if they don't have scores yet - they'll show at center (0,0) with default values
          // This allows bubbles to appear immediately when tickers are added to watchlist
          // They'll update once TradingView sends data (within 5 minutes)
          const hasScores =
            d.htf_score !== undefined || d.ltf_score !== undefined;
          if (!hasScores) {
            // Provide default values so bubble can render
            d.htf_score = d.htf_score !== undefined ? d.htf_score : 0;
            d.ltf_score = d.ltf_score !== undefined ? d.ltf_score : 0;
            d.waitingForData = true; // Flag to indicate waiting for TradingView data
          }

          // Multi-ticker search
          if (multiTickerList && multiTickerList.length > 0) {
            if (!multiTickerList.includes(ticker)) continue;
          } else if (
            effectiveFilters.search &&
            !ticker.includes(effectiveFilters.search.toUpperCase())
          ) {
            // Regular search (if not multi-ticker)
            continue;
          }

          // Group filter
          if (effectiveFilters.group && effectiveFilters.group !== "ALL") {
            if (effectiveFilters.group === "SAVED") {
              if (!savedTickerSet || !savedTickerSet.has(normTicker(ticker))) continue;
            } else if (effectiveFilters.group === "TT_SELECTED") {
              const T = normTicker(ticker);
              if (!isTickerTTSelected(T)) continue;
            } else {
              const T = normTicker(ticker);
              const gs = groupsForTicker(T);
              if (effectiveFilters.group === "ANY") {
                if (gs.length === 0) continue;
              } else if (effectiveFilters.group === "UNGROUPED") {
                const actualGroups = gs.filter((g) => g !== "Other");
                if (actualGroups.length > 0) continue;
              } else {
                if (!gs.includes(effectiveFilters.group)) continue;
              }
            }
          }

          // Handle Top Long Setup and Top Short Setup from natural language
          if (effectiveFilters.topLongSetup === true) {
            if (d.state !== "HTF_BULL_LTF_PULLBACK") continue;
          }
          if (effectiveFilters.topShortSetup === true) {
            if (d.state !== "HTF_BEAR_LTF_PULLBACK") continue;
          }

          const isUnscored = d.ingest_kind === "user_ticker_seed" || d.ingest_kind === "admin_seed" || (d.state === "NEUTRAL" && Number(d.rank) === 0 && Number(d.htf_score) === 0 && Number(d.ltf_score) === 0);
          if (
            effectiveFilters.quadrants &&
            !effectiveFilters.quadrants.includes(d.state) &&
            !isUnscored
          )
            continue;
          if (
            effectiveFilters.minRank &&
            (Number(d.rank) || 0) < effectiveFilters.minRank
          )
            continue;
          if (
            effectiveFilters.minRR &&
            (Number(d.rr) || 0) < effectiveFilters.minRR
          )
            continue;
          if (
            effectiveFilters.maxCompletion &&
            completionForSize(d) > effectiveFilters.maxCompletion
          )
            continue;
          // Thesis preset gate: base thresholds (preset) + requires richer winner patterns from Worker
          // (still one pill; Worker computes `flags.thesis_match`)
          if (isThesisModeActive(effectiveFilters)) {
            const flags = d.flags || {};
            if (flags.thesis_match !== true) continue;
          }
          if (effectiveFilters.inCorridor === true) {
            const ent = entryType(d);
            if (!ent.corridor) continue;
          }
          if (effectiveFilters.squeezeRelease === true) {
            const flags = d.flags || {};
            if (!flags.sq30_release) continue;
          }
          if (effectiveFilters.inSqueeze === true) {
            const flags = d.flags || {};
            // In Squeeze: sq30_on is true but sq30_release is false
            if (!flags.sq30_on || flags.sq30_release) continue;
          }
          if (effectiveFilters.momentumElite === true) {
            const flags = d.flags || {};
            if (!flags.momentum_elite) continue;
          }
          if (effectiveFilters.prime === true) {
            if (!isPrimeBubble(d)) continue;
          }
          if (effectiveFilters.winnerSignature === true) {
            if (!isWinnerSignature(d)) continue;
          }
          if (effectiveFilters.flipWatch === true) {
            const flags = d.flags || {};
            if (!flags.flip_watch) continue;
          }

          // Kanban Stage filter (6 lanes)
          if (
            effectiveFilters.kanbanStage &&
            typeof effectiveFilters.kanbanStage === "string"
          ) {
            const stage = String(d.kanban_stage || "");
            const wantStage = String(effectiveFilters.kanbanStage).trim();
            const matches =
              wantStage === "setup"
                ? stage === "setup" || stage === "setup_watch" || stage === "flip_watch"
                : wantStage === "enter"
                  ? stage === "enter" || stage === "enter_now" || stage === "just_flipped"
                  : wantStage === "new"
                    ? stage === "just_entered"
                    : wantStage === "hold"
                      ? stage === "active" || stage === "hold"
                      : wantStage === "defend"
                        ? stage === "defend"
                        : stage === wantStage;
            if (!matches) continue;
          }

          // Pattern Group filter (Action Moves groups)
          if (
            effectiveFilters.patternGroup &&
            typeof effectiveFilters.patternGroup === "string"
          ) {
            const intent = classifyEntryIntent(d);
            const wantGroup = String(effectiveFilters.patternGroup).trim();
            if (intent.group !== wantGroup) continue;
          }

          // Opportunities filter (Viewport row 3)
          if (
            effectiveFilters.opportunities &&
            typeof effectiveFilters.opportunities === "string"
          ) {
            const mode = String(effectiveFilters.opportunities).toUpperCase();
            const prime = isPrimeBubble(d);
            const eligible = isEligibleOpportunity(d);
            if (mode === "PRIME") {
              if (!prime) continue;
            } else if (mode === "ELIGIBLE") {
              if (!eligible) continue;
            } else if (mode === "WATCH") {
              if (prime || eligible) continue;
            }
          }

          // Guidance filter (based on natural-language decision)
          if (
            effectiveFilters.guidanceCategory &&
            typeof effectiveFilters.guidanceCategory === "string"
          ) {
            const actionInfo = getActionDescription(d);
            const cat = guidanceCategoryForAction(actionInfo?.action);
            const want = String(
              effectiveFilters.guidanceCategory,
            ).toUpperCase();
            if (cat !== want) continue;
          }
          if (effectiveFilters.minPriceChange !== undefined) {
            // Calculate price change from trigger price to current price
            const currentPrice = Number(d.price) || 0;
            const triggerPrice = Number(d.trigger_price) || 0;
            if (triggerPrice > 0) {
              const priceChange = Math.abs(currentPrice - triggerPrice);
              if (priceChange < effectiveFilters.minPriceChange) continue;
            } else {
              // No trigger price, skip this filter
              continue;
            }
          }
          if (effectiveFilters.minPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase < effectiveFilters.minPhase) continue;
          }
          if (effectiveFilters.maxPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase > effectiveFilters.maxPhase) continue;
          }

          // Trades filter - only show tickers that have trades
          if (effectiveFilters.hasTrades === true) {
            if (!tickersWithTrades.has(normTicker(ticker))) continue;
          }

          // Sector filter - only show tickers in the selected sector
          if (effectiveFilters.sector) {
            // PRIORITIZE SECTOR_MAP lookup over TradingView sector data
            // TradingView uses industry classifications (e.g., "Electronic Technology", "Retail Trade")
            // but we use GICS sectors (e.g., "Information Technology", "Consumer Discretionary")
            // So we always check SECTOR_MAP first, then fall back to TradingView data
            const tickerSector =
              getTickerSector(ticker) ||
              d.sector ||
              d.fundamentals?.sector ||
              "";
            // Normalize for resilient comparison (handles aliases like Health Care vs Healthcare)
            const normalizedTickerSector = normalizeSectorKey(tickerSector);
            const normalizedFilterSector = normalizeSectorKey(
              effectiveFilters.sector,
            );
            const matches =
              normalizedTickerSector &&
              normalizedTickerSector === normalizedFilterSector;

            // Debug logging for first few tickers when sector filter is active
            if (out.length < 3 && normalizedTickerSector) {
              console.log(
                `[SECTOR FILTER] ${ticker}: tickerSector="${normalizedTickerSector}", filterSector="${normalizedFilterSector}", matches=${matches}, fromMap=${!!getTickerSector(
                  ticker,
                )}`,
              );
            }

            if (!matches) {
              continue;
            }
          }

          // TD9 Setup filter - only show tickers with TD9 signals
          if (effectiveFilters.td9Setup === "any") {
            const tdSeq = d.td_sequential || {};
            const hasTD9Bullish =
              tdSeq.td9_bullish === true || tdSeq.td9_bullish === "true";
            const hasTD9Bearish =
              tdSeq.td9_bearish === true || tdSeq.td9_bearish === "true";
            if (!hasTD9Bullish && !hasTD9Bearish) continue;
          }

          out.push({ ticker, ...d });
        }

        // Apply Ranked / Top-N filter (rank position).
        // - `top40` shows ALL ranked tickers sorted by score (misnamed historically).
        // - `topN` limits that ranked list to the top N.
        const topN = Math.floor(Number(effectiveFilters.topN));
        const hasTopN = Number.isFinite(topN) && topN > 0;
        if (effectiveFilters.top40 === true || hasTopN) {
          // Get ALL tickers from dataObj (not filtered 'out' array)
          const allTickersWithRank = Object.values(dataObj).filter(
            (t) =>
              t &&
              typeof t === "object" &&
              t.ticker &&
              t.rank !== undefined &&
              t.rank !== null,
          );

          // Sort by dynamicScore from API (backend calculation) - pure score sorting, no alphabetical tiebreaker
          allTickersWithRank.sort((a, b) => {
            const scoreA = Number(a.dynamicScore || a.rank) || 0; // Use dynamicScore from API, fallback to rank
            const scoreB = Number(b.dynamicScore || b.rank) || 0;
            // Descending order: higher score = better position
            return scoreB - scoreA;
          });

          // Ranked order lookup (ticker -> index) based on the sorted list above.
          const rankedSymbols = allTickersWithRank
            .map((t) =>
              String(t.ticker || "")
                .trim()
                .toUpperCase(),
            )
            .filter(Boolean);
          const rankIndex = {};
          rankedSymbols.forEach((sym, idx) => {
            if (rankIndex[sym] == null) rankIndex[sym] = idx;
          });

          // Filter 'out' to only include tickers that have ranks, maintaining rank order
          const rankedOut = out
            .filter((t) => {
              const tickerUpper = String(t.ticker || "")
                .trim()
                .toUpperCase();
              return rankIndex[tickerUpper] != null;
            })
            .sort((a, b) => {
              // Maintain the same ranked order as `allTickersWithRank`
              const aSym = String(a.ticker || "")
                .trim()
                .toUpperCase();
              const bSym = String(b.ticker || "")
                .trim()
                .toUpperCase();
              const ia = rankIndex[aSym];
              const ib = rankIndex[bSym];
              if (ia != null && ib != null) return ia - ib; // lower index = better rank
              if (ia != null) return -1;
              if (ib != null) return 1;
              return 0;
            });
          return hasTopN ? rankedOut.slice(0, topN) : rankedOut;
        }

        return out;
      }

      // Thesis preset (used by filter pill + auto-apply + UI badges)
      // Derived from latest best-setups analysis + self-learning.
      const THESIS_PRESET = {
        minRank: 74,
        minRR: 1.5,
        maxCompletion: 0.6,
        maxPhase: 0.6,
      };

      function isThesisModeActive(filters) {
        const f = filters || {};
        const maxCompletion = Number(f.maxCompletion);
        const minRR = Number(f.minRR);
        const minRank = Number(f.minRank);
        const maxPhase = Number(f.maxPhase);
        return (
          Number.isFinite(minRank) &&
          minRank >= THESIS_PRESET.minRank &&
          Number.isFinite(minRR) &&
          minRR >= THESIS_PRESET.minRR &&
          Number.isFinite(maxCompletion) &&
          maxCompletion <= THESIS_PRESET.maxCompletion + 1e-9 &&
          (f.maxPhase === undefined ||
            (Number.isFinite(maxPhase) &&
              maxPhase <= THESIS_PRESET.maxPhase + 1e-9))
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Components
      // ─────────────────────────────────────────────────────────────
      // Native SVG Bubble component (works without Recharts)
      const SVGBubble = memo(
        ({
          ticker,
          onClick,
          onHover,
          isHovered,
          scaleX,
          scaleY,
          offsetX,
          offsetY,
          layoutX = null,
          layoutY = null,
          showLabels,
          isTopRanked = false,
          thesisMode = false,
        }) => {
          // CRITICAL DEBUG: Log EVERY bubble call immediately
          if (!window._svgBubbleCallCount) {
            window._svgBubbleCallCount = 0;
          }
          window._svgBubbleCallCount++;

          // Always log first 10 to see what's happening
          if (window._svgBubbleCallCount <= 10) {
            console.log(
              `[SVGBUBBLE CALLED] #${window._svgBubbleCallCount} - ${
                ticker?.ticker || "NO TICKER"
              }`,
              {
                ticker: ticker?.ticker,
                hasTicker: !!ticker,
                tickerKeys: ticker ? Object.keys(ticker).slice(0, 20) : [],
                hasPhasePct: ticker ? "phase_pct" in ticker : false,
                phasePct: ticker ? ticker.phase_pct : undefined,
              },
            );
          }

          // CRITICAL: If no ticker, return null immediately
          if (!ticker || !ticker.ticker) {
            console.error(`[SVGBUBBLE ERROR] No ticker provided!`, { ticker });
            return null;
          }

          // Ensure we have valid numeric values - check for null/undefined explicitly
          // Try multiple property names in case data structure varies
          const comp =
            ticker.completion != null
              ? Number(ticker.completion)
              : ticker.completion_pct != null
                ? Number(ticker.completion_pct)
                : 0;
          const phasePct =
            ticker.phase_pct != null
              ? Number(ticker.phase_pct)
              : ticker.phase != null
                ? Number(ticker.phase)
                : 0;
          const rr =
            ticker.rr != null
              ? Number(ticker.rr)
              : ticker.risk_reward != null
                ? Number(ticker.risk_reward)
                : 0;
          const waitingForData = ticker.waitingForData === true;

          // Validate values are finite numbers and clamp to valid ranges
          const validComp = Number.isFinite(comp)
            ? Math.max(0, Math.min(1, comp))
            : 0;

          // If phase_pct is missing, try to estimate from completion or use a default based on state
          let validPhasePct = Number.isFinite(phasePct)
            ? Math.max(0, Math.min(1, phasePct))
            : null;

          // Fallback: if phase_pct is missing, use completion as proxy or estimate from state
          if (validPhasePct === null) {
            if (validComp > 0) {
              validPhasePct = validComp; // Use completion as phase estimate
            } else if (ticker.state) {
              // Estimate phase based on state (early states = lower phase)
              const state = String(ticker.state).toUpperCase();
              if (state.includes("PREP") || state.includes("PULLBACK")) {
                validPhasePct = 0.2; // Early phase
              } else if (state.includes("BULL") || state.includes("BEAR")) {
                validPhasePct = 0.5; // Mid phase
              } else {
                validPhasePct = 0.1; // Default to early phase
              }
            } else {
              validPhasePct = 0.1; // Default to early phase (green)
            }
          }

          // Default RR to a small value if missing to ensure size variation
          // Use dynamicRank or rank as fallback for size if RR is missing
          const fallbackRR = ticker.dynamicRank
            ? Math.max(0.5, Math.min(5, (Number(ticker.dynamicRank) || 0) / 50))
            : ticker.rank
              ? Math.max(0.5, Math.min(5, (Number(ticker.rank) || 0) / 50))
              : 0.5;
          const validRR = Number.isFinite(rr) && rr > 0 ? rr : fallbackRR;

          // Bubble size based on RR, adjusted for completion (lower completion = larger size)
          // RR is the opportunity, but we want to reduce size as completion increases
          // Formula: baseSize + (RR * multiplier) * (1 - completion)
          // This makes high RR + low completion = largest bubbles
          // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
          const cappedRR = Math.min(validRR, 5); // Cap RR at 5 for size calculation
          const completionPenalty = 1 - validComp; // 1.0 when completion is 0, 0.0 when completion is 1
          const baseSize = 4; // Further reduced for less overlap
          const rrMultiplier = 2; // Further reduced for smaller bubbles
          // Smaller size for tickers waiting for data
          const size = waitingForData
            ? baseSize * 0.7
            : baseSize + cappedRR * rrMultiplier * completionPenalty;

          // Force minimum size variation - if all sizes are the same, add variation based on ticker
          // Use multiple factors for better variation
          const tickerHash = (ticker.ticker || "")
            .split("")
            .reduce((acc, char) => acc + char.charCodeAt(0), 0);
          const sizeVariation = (tickerHash % 5) * 0.8; // Add 0-3.2px variation based on ticker name
          const finalSize = Math.max(baseSize, size + sizeVariation); // Add variation, ensure minimum baseSize

          const prime = isPrimeBubble(ticker);
          const winnerSig = isWinnerSignature(ticker);
          const flags = ticker.flags || {};
          const ent = entryType(ticker);
          const move = getMoveStatusInfo(ticker);

          // ── Bubble color: direction-aware (matches kanban cards) ──
          // LONG = cyan tones, SHORT = red tones, neutral = phase-based
          const flipWatch = !!flags.flip_watch;
          const dir = getDirectionFromState(ticker);
          let color;

          if (waitingForData) {
            color = "#5c6475";
          } else if (dir === "LONG") {
            // Cyan-to-green gradient anchor based on phase
            const p = Number.isFinite(validPhasePct) ? Math.max(0, Math.min(1, validPhasePct)) : 0.1;
            color = p < 0.3 ? "#22d3ee" : p < 0.6 ? "#06b6d4" : "#0891b2"; // Cyan spectrum
          } else if (dir === "SHORT") {
            const p = Number.isFinite(validPhasePct) ? Math.max(0, Math.min(1, validPhasePct)) : 0.1;
            color = p < 0.3 ? "#fb7185" : p < 0.6 ? "#e11d48" : "#be123c"; // Red spectrum
          } else {
            // Neutral: phase-based (green → yellow → red)
            const p = Number.isFinite(validPhasePct) ? Math.max(0, Math.min(1, validPhasePct)) : 0.1;
            color = p < 0.3 ? "#14b8a6" : p < 0.6 ? "#eab308" : "#e11d48";
          }

          if (!color || typeof color !== "string" || !color.startsWith("#")) {
            color = "#14b8a6";
          }

          // Opacity: direction bubbles stay vivid, invalidated/completed fade
          const baseOpacity = waitingForData ? 0.55 : isHovered ? 1 : dir ? 0.92 : prime || winnerSig ? 0.9 : 0.8;
          const moveOpacityMult = waitingForData || isHovered ? 1
            : move.status === "INVALIDATED" ? 0.25
            : move.status === "COMPLETED" ? 0.6
            : 1;
          const opacity = Math.max(0.12, baseOpacity * moveOpacityMult);

          // Border: direction accent color (matches card left-border accent)
          const borderWidth = waitingForData ? 1.5
            : dir ? 2.5
            : flipWatch ? 3.5
            : prime ? 3
            : winnerSig ? 3
            : flags.sq30_release ? 2
            : flags.sq30_on ? 2
            : 1.5;

          let borderColor = waitingForData ? "#8b92a0"
            : dir === "LONG" ? "#22d3ee"
            : dir === "SHORT" ? "#e11d48"
            : flipWatch ? "#fbbf24"
            : prime ? "#14b8a6"
            : winnerSig ? "#a855f7"
            : flags.sq30_release ? "#00ffff"
            : flags.sq30_on ? "#ffd700"
            : "rgba(255,255,255,0.25)";
          if (!waitingForData && move.status !== "ACTIVE" && !dir) {
            borderColor = move.stroke;
          }

          let finalBorderColor = borderColor;
          const bRegime = String(ticker.regime_class || "");
          const regimeDash = bRegime === "CHOPPY" ? "3,2" : bRegime === "TRANSITIONAL" ? "6,3" : undefined;

          const bubbleSize = isHovered ? finalSize * 1.2 : finalSize;

          // Calculate position correctly:
          // BubbleChart passes pre-adjusted offsets:
          // - offsetX already includes +50*scaleX (centers at x=0)
          // - offsetY already includes plotHeight - 50*scaleY (centers at y=0)
          // - scaleY is negative for y-axis inversion
          // So we just multiply scores by scales and add offsets
          const ltfScore = Number(ticker.ltf_score) || 0;
          const htfScore = Number(ticker.htf_score) || 0;

          // X: LTF score * scaleX + offsetX (offsetX already centered)
          const x = Number.isFinite(Number(layoutX))
            ? Number(layoutX)
            : ltfScore * scaleX + offsetX;

          // Y: HTF score * scaleY + offsetY (scaleY is negative, offsetY already centered)
          const y = Number.isFinite(Number(layoutY))
            ? Number(layoutY)
            : htfScore * scaleY + offsetY;

          // Determine emojis — 5 distinct badges:
          //   💎 Prime (quality)  🎯 Entry Zone (timing)
          //   🔥 MoElite          🧨 Squeeze  ⚡ Release
          const isInSqueeze = !!flags.sq30_on && !flags.sq30_release;
          const emojis = [];
          if (isTopRanked) emojis.push("👑");
          if (waitingForData) emojis.push("⏳");
          if (!waitingForData) {
            if (prime) emojis.push("💎");
            if (flipWatch) emojis.push("🎯");
            if (!!flags.momentum_elite) emojis.push("🔥");
            if (flags.sq30_release) emojis.push("⚡");
            if (isInSqueeze) emojis.push("🧨");
          }
          const emojiText = emojis.join("");
          // For #1 ranked, position emoji higher (reduced from 50 to 20 for smaller crown)
          const labelY =
            y - bubbleSize - (emojiText ? (isTopRanked ? 20 : 12) : 8);

          const finalColor = color && typeof color === "string" && color.startsWith("#") ? color : "#14b8a6";
          const finalOpacity = typeof opacity === "number" && opacity >= 0 && opacity <= 1 ? opacity : 0.85;
          const renderedSize = Math.max(3, Math.min(50, bubbleSize));
          const finalBorderWidth = typeof borderWidth === "number" && borderWidth > 0 ? borderWidth : 1.5;
          const decisionSummary = summarizeEntryDecision(ticker);
          const decisionTooltip = decisionSummary ? `System ${decisionSummary.status}: ${decisionSummary.detail}` : null;

          // Unique gradient ID per bubble
          const gradId = `bg-${ticker.ticker}`;

          return (
            <g
              onClick={() => onClick(ticker.ticker)}
              onMouseEnter={() => onHover(ticker.ticker)}
              onMouseLeave={() => onHover(null)}
              onTouchStart={(e) => { e.preventDefault(); onHover(ticker.ticker); onClick(ticker.ticker); }}
              onTouchEnd={(e) => { e.preventDefault(); onHover(null); }}
              style={{ cursor: "pointer", transition: "all 0.2s ease-out", touchAction: "manipulation" }}
            >
              {decisionTooltip && <title>{decisionTooltip}</title>}
              {/* Radial gradient fill for glassmorphic depth */}
              <defs>
                <radialGradient id={gradId} cx="35%" cy="35%">
                  <stop offset="0%" stopColor="#ffffff" stopOpacity="0.18" />
                  <stop offset="50%" stopColor={finalColor} stopOpacity={finalOpacity} />
                  <stop offset="100%" stopColor={finalColor} stopOpacity={finalOpacity * 0.7} />
                </radialGradient>
              </defs>
              {/* Earnings ring — orange dashed ring for upcoming/recent earnings */}
              {(() => {
                const eEvt = window._ttEarningsMap?.[ticker.ticker];
                if (!eEvt) return null;
                const isToday = eEvt._daysAway === 0 || eEvt._daysAway === 1;
                return (
                  <circle
                    cx={x} cy={y}
                    r={renderedSize + (isToday ? 6 : 4)}
                    fill="none"
                    stroke="#f59e0b"
                    strokeWidth={isToday ? 2 : 1.5}
                    strokeDasharray={isToday ? "none" : "4 3"}
                    opacity={isToday ? 0.8 : 0.55}
                    style={{ pointerEvents: "none" }}
                  >
                    {isToday && (
                      <animate attributeName="opacity" values="0.5;0.9;0.5" dur="2s" repeatCount="indefinite" />
                    )}
                  </circle>
                );
              })()}
              {/* Outer glow ring for direction / special states */}
              {(dir || flipWatch || prime || winnerSig) && (
                <circle
                  cx={x} cy={y}
                  r={renderedSize + 3}
                  fill="none"
                  stroke={finalBorderColor}
                  strokeWidth={flipWatch ? 2 : 1}
                  opacity={flipWatch ? 0.5 : 0.2}
                >
                  {flipWatch && (
                    <>
                      <animate attributeName="r" values={`${renderedSize + 3};${renderedSize + 6};${renderedSize + 3}`} dur="2s" repeatCount="indefinite" />
                      <animate attributeName="opacity" values="0.3;0.7;0.3" dur="2s" repeatCount="indefinite" />
                    </>
                  )}
                </circle>
              )}
              {/* Actionable glow: Enter and beyond stages */}
              {!waitingForData && (() => {
                const ks = String(ticker.kanban_stage || "").toLowerCase();
                const actionable = ["enter", "enter_now", "just_entered", "just_flipped", "hold", "defend", "trim", "exit"].includes(ks);
                if (!actionable) return null;
                const glowColor = dir === "SHORT" ? "#f43f5e" : "#22d3ee";
                return (
                  <circle
                    cx={x} cy={y}
                    r={renderedSize + 5}
                    fill="none"
                    stroke={glowColor}
                    strokeWidth="1.5"
                    opacity="0.5"
                  >
                    <animate attributeName="r" values={`${renderedSize + 4};${renderedSize + 8};${renderedSize + 4}`} dur="2.5s" repeatCount="indefinite" />
                    <animate attributeName="opacity" values="0.3;0.65;0.3" dur="2.5s" repeatCount="indefinite" />
                  </circle>
                );
              })()}
              {/* Main bubble — radial gradient for depth */}
              <circle
                cx={x} cy={y}
                r={renderedSize}
                fill={`url(#${gradId})`}
                stroke={finalBorderColor}
                strokeWidth={finalBorderWidth}
                strokeDasharray={regimeDash}
              />
              {/* Subtle highlight arc (top-left) for glassy look */}
              {renderedSize > 5 && (
                <circle
                  cx={x - renderedSize * 0.2}
                  cy={y - renderedSize * 0.2}
                  r={renderedSize * 0.45}
                  fill="#ffffff"
                  fillOpacity="0.08"
                  style={{ pointerEvents: "none" }}
                />
              )}
              {/* Emoji above bubble - show multiple when applicable */}
              {emojiText && (
                <g style={{ pointerEvents: "none" }}>
                  {/* Background circle for #1 ranked - reduced size */}
                  {isTopRanked && (
                    <circle
                      cx={x}
                      cy={labelY - 5}
                      r="18"
                      fill="#ffd700"
                      fillOpacity="0.3"
                    >
                      <animate
                        attributeName="fillOpacity"
                        values="0.2;0.5;0.2"
                        dur="1.5s"
                        repeatCount="indefinite"
                      />
                    </circle>
                  )}
                  {/* Outer glow ring for #1 - reduced size */}
                  {isTopRanked && (
                    <>
                      <circle
                        cx={x}
                        cy={labelY - 5}
                        r="22"
                        fill="none"
                        stroke="#ffd700"
                        strokeWidth="2"
                        opacity="0.6"
                      >
                        <animate
                          attributeName="r"
                          values="20;24;20"
                          dur="2s"
                          repeatCount="indefinite"
                        />
                        <animate
                          attributeName="opacity"
                          values="0.4;0.8;0.4"
                          dur="2s"
                          repeatCount="indefinite"
                        />
                      </circle>
                    </>
                  )}
                  {/* Main emoji text */}
                  <text
                    x={x}
                    y={labelY}
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fontSize={
                      isTopRanked
                        ? "24"
                        : waitingForData
                          ? "10"
                          : prime
                            ? "14"
                            : "12"
                    }
                    fill={
                      isTopRanked
                        ? "#ffd700"
                        : waitingForData
                          ? "#8b92a0"
                          : prime
                            ? "#14b8a6"
                            : winnerSig
                              ? "#a855f7"
                              : flags.sq30_release
                                ? "#00ffff"
                                : flags.momentum_elite
                                  ? "#a855f7"
                                  : "#ffd700"
                    }
                    fontWeight="bold"
                    style={{
                      textShadow: isTopRanked
                        ? "0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.6)"
                        : "0 0 3px rgba(0,0,0,0.8)",
                      filter: isTopRanked
                        ? "drop-shadow(0 0 15px rgba(255, 215, 0, 1)) drop-shadow(0 0 30px rgba(255, 215, 0, 0.9)) drop-shadow(0 0 45px rgba(255, 215, 0, 0.7))"
                        : "none",
                      pointerEvents: "none",
                    }}
                  >
                    {emojiText}
                  </text>
                  {/* Additional sparkle effects for #1 - reduced size */}
                  {isTopRanked && (
                    <>
                      <text
                        x={x - 15}
                        y={labelY - 10}
                        textAnchor="middle"
                        dominantBaseline="middle"
                        fontSize="12"
                        fill="#ffd700"
                        opacity="0.9"
                        style={{ pointerEvents: "none" }}
                      >
                        ✨
                      </text>
                      <text
                        x={x + 15}
                        y={labelY - 10}
                        textAnchor="middle"
                        dominantBaseline="middle"
                        fontSize="12"
                        fill="#ffd700"
                        opacity="0.9"
                        style={{ pointerEvents: "none" }}
                      >
                        ✨
                      </text>
                    </>
                  )}
                </g>
              )}
              {/* Additional glow effect for #1 ranked - reduced size */}
              {isTopRanked && (
                <>
                  <circle
                    cx={x}
                    cy={y}
                    r={bubbleSize + 4}
                    fill="none"
                    stroke="#ffd700"
                    strokeWidth="2"
                    opacity="0.6"
                  >
                    <animate
                      attributeName="opacity"
                      values="0.3;0.9;0.3"
                      dur="2s"
                      repeatCount="indefinite"
                    />
                    <animate
                      attributeName="r"
                      values={`${bubbleSize + 3};${bubbleSize + 6};${
                        bubbleSize + 3
                      }`}
                      dur="2s"
                      repeatCount="indefinite"
                    />
                  </circle>
                  {/* Outer glow ring */}
                  <circle
                    cx={x}
                    cy={y}
                    r={bubbleSize + 6}
                    fill="none"
                    stroke="#ffd700"
                    strokeWidth="1.5"
                    opacity="0.3"
                  >
                    <animate
                      attributeName="opacity"
                      values="0.1;0.5;0.1"
                      dur="2s"
                      repeatCount="indefinite"
                    />
                  </circle>
                </>
              )}
              {/* Ticker label */}
              {(showLabels || isHovered) && (
                <text
                  x={x}
                  y={labelY - (emojiText ? 14 : 8)}
                  textAnchor="middle"
                  fontSize="10"
                  fill={waitingForData ? "#8b92a0" : "#f0f2f5"}
                  fontWeight="600"
                  style={{
                    textShadow: "0 0 4px rgba(0,0,0,0.9)",
                    pointerEvents: "none",
                  }}
                >
                  {ticker.ticker}
                </text>
              )}
            </g>
          );
        },
      );

      // Hook to fetch trail data for all tickers
      // NOTE: This is intentionally "best effort" and must not hammer the API.
      function useAllTrails(tickers, enabled = true) {
        const [allTrails, setAllTrails] = useState({});
        const [loadingTrails, setLoadingTrails] = useState(false);
        const trailsFetchedRef = React.useRef(new Set());
        const trailsAttemptedAtRef = React.useRef(new Map()); // ticker -> lastAttemptMs

        React.useEffect(() => {
          // If disabled (e.g., a ticker is selected), do NOT continue background trail fetching.
          // This avoids starving the selected ticker's own /trail request and prevents 429 loops.
          if (!enabled) {
            setLoadingTrails(false);
            return;
          }

          if (!tickers || tickers.length === 0) {
            setAllTrails({});
            return;
          }

          // Only fetch trails for tickers we haven't fetched yet
          const tickersToFetch = tickers
            .map((t) => String(t?.ticker || "").toUpperCase())
            .filter((t) => {
              if (!t) return false;
              if (trailsFetchedRef.current.has(t)) return false;
              // Cooldown for failed attempts (especially 429)
              const lastAttempt = trailsAttemptedAtRef.current.get(t) || 0;
              const cooldownMs = 60_000; // 60s cooldown between attempts
              if (Date.now() - lastAttempt < cooldownMs) return false;
              return true;
            });

          if (tickersToFetch.length === 0) return;

          // Limit concurrent fetches to avoid overwhelming the API
          // Reduced batch size to avoid rate limiting and server errors
          const MAX_CONCURRENT = 5;
          const batches = [];
          for (let i = 0; i < tickersToFetch.length; i += MAX_CONCURRENT) {
            batches.push(tickersToFetch.slice(i, i + MAX_CONCURRENT));
          }

          setLoadingTrails(true);

          const fetchBatch = async (batch) => {
            const promises = batch.map(async (ticker) => {
              trailsAttemptedAtRef.current.set(ticker, Date.now());
              // Retry logic with exponential backoff
              let lastError = null;
              for (let attempt = 0; attempt < 3; attempt++) {
                try {
                  const res = await fetch(
                    `/timed/trail?ticker=${encodeURIComponent(
                      ticker,
                    )}`,
                    {
                      signal: AbortSignal.timeout(5000), // 5 second timeout
                    },
                  );

                  if (res.ok) {
                    const json = await res.json();
                    if (
                      json.ok &&
                      Array.isArray(json.trail) &&
                      json.trail.length > 0
                    ) {
                      return {
                        ticker,
                        trail: normalizeTrailPoints(json.trail),
                      };
                    }
                    // If ok but empty trail, return empty (not an error)
                    return { ticker, trail: [] };
                  } else if (res.status === 429) {
                    // Rate limited - wait longer before retry
                    await new Promise((resolve) =>
                      setTimeout(resolve, 1000 * (attempt + 1)),
                    );
                    continue;
                  } else if (res.status >= 500) {
                    // Server error - retry with backoff
                    if (attempt < 2) {
                      await new Promise((resolve) =>
                        setTimeout(resolve, 500 * Math.pow(2, attempt)),
                      );
                      continue;
                    }
                  }
                  // For other errors (400, 404, etc.), don't retry
                  return { ticker, trail: [] };
                } catch (err) {
                  lastError = err;
                  // Only retry on network errors or timeouts, not on abort
                  if (
                    err.name !== "AbortError" &&
                    err.name !== "TimeoutError" &&
                    attempt < 2
                  ) {
                    await new Promise((resolve) =>
                      setTimeout(resolve, 500 * Math.pow(2, attempt)),
                    );
                    continue;
                  }
                  // If it's an abort/timeout or last attempt, return empty
                  if (attempt === 2 || err.name === "AbortError") {
                    break;
                  }
                }
              }
              // If we get here, all retries failed
              if (lastError && lastError.name !== "AbortError") {
                // Only log if it's not a timeout/abort (those are expected)
                console.warn(
                  `Failed to fetch trail for ${ticker} after 3 attempts:`,
                  lastError.message,
                );
              }
              return { ticker, trail: [] };
            });

            const results = await Promise.all(promises);
            return results;
          };

          // Fetch all batches sequentially to avoid overwhelming the API
          const fetchAllBatches = async () => {
            const allResults = [];
            for (const batch of batches) {
              const results = await fetchBatch(batch);
              allResults.push(...results);

              // Update state incrementally for better UX
              setAllTrails((prev) => {
                const updated = { ...prev };
                results.forEach(({ ticker, trail }) => {
                  // IMPORTANT: Mark as fetched on ANY successful fetch attempt result (even empty)
                  // so we don't hammer the API in a tight loop when trails are missing or rate-limited.
                  trailsFetchedRef.current.add(ticker);
                  updated[ticker] = Array.isArray(trail) ? trail : [];

                  // Debug: Log when trails are loaded (or confirmed empty) for a small sample
                  if (
                    Object.keys(updated).length <= 10 ||
                    ticker === "AAPL" ||
                    ticker === "MSFT"
                  ) {
                    console.log(
                      `[TRAILS] Loaded ${
                        Array.isArray(trail) ? trail.length : 0
                      } points for ${ticker}`,
                    );
                  }
                });
                return updated;
              });

              // Longer delay between batches to avoid overwhelming the API
              await new Promise((resolve) => setTimeout(resolve, 500));
            }
            setLoadingTrails(false);
          };

          fetchAllBatches();
        }, [tickers, enabled]);

        return { allTrails, loadingTrails };
      }

      function BubbleChart({
        tickers,
        onBubbleClick,
        hoveredTicker,
        onHover,
        selectedTicker,
        selectedTrail,
        isTimeTravelActive = false,
        highlightTrailPoint = null,
        allData,
        rankedTickers,
        rankedTickerPositions,
        thesisMode = false,
      }) {
        // Debug: Log props received
        React.useEffect(() => {
          console.log(`[BUBBLE CHART] Props received:`, {
            selectedTicker,
            hasSelectedTrail: !!selectedTrail,
            selectedTrailLength: Array.isArray(selectedTrail)
              ? selectedTrail.length
              : 0,
            tickersCount: tickers ? tickers.length : 0,
          });
        }, [selectedTicker, selectedTrail, tickers]);

        // When a ticker is selected, "solo" it (show only that bubble + journey).
        // IMPORTANT: chart zoom should remain stable (domain is computed from the full loaded universe, not this filtered list).
        const displayTickers = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          if (!selectedTicker) return list;
          const sym = String(selectedTicker).toUpperCase();
          const solo = list.filter(
            (t) => String(t?.ticker || "").toUpperCase() === sym,
          );
          // If selection is no longer in the filtered universe, fall back to showing the current universe.
          return solo.length > 0 ? solo : list;
        }, [tickers, selectedTicker]);

        // Time Travel mode is snapshot-only: BubbleChart does NOT render trails for all bubbles.
        // The only trail we render is `selectedTrail` (Selected Ticker mode).
        // Debug: Log what BubbleChart receives
        React.useEffect(() => {
          if (!window._bubbleChartPropsLogged) {
            window._bubbleChartPropsLogged = true;
            console.log(`[BUBBLE CHART PROPS] Received:`, {
              tickersCount: tickers ? tickers.length : 0,
              hasTickers: !!tickers,
              isArray: Array.isArray(tickers),
              firstTicker:
                tickers && tickers.length > 0
                  ? {
                      ticker: tickers[0].ticker,
                      hasPhasePct: "phase_pct" in (tickers[0] || {}),
                      hasCompletion: "completion" in (tickers[0] || {}),
                      hasRR: "rr" in (tickers[0] || {}),
                      keys: Object.keys(tickers[0] || {}).slice(0, 15),
                    }
                  : null,
              hasAllData: !!allData,
              allDataKeys: allData ? Object.keys(allData).slice(0, 10) : [],
            });
          }
        }, [tickers, allData]);

        const [tooltip, setTooltip] = useState(null);
        const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
        const [showLabels, setShowLabels] = useState(true);
        const [crosshairPos, setCrosshairPos] = useState(null); // { x, y, ltfValue, htfValue }
        const containerRef = React.useRef(null);

        // Calculate #1 ranked ticker using SAME data source as Ranked List
        const topRankedTicker = React.useMemo(() => {
          if (rankedTickers && rankedTickers.length > 0) {
            return rankedTickers[0].ticker;
          }
          if (!allData || typeof allData !== "object") return null;
          const sorted = getRankedTickers(allData);
          return sorted.length > 0 ? sorted[0].ticker : null;
        }, [rankedTickers, allData]);
        const [dimensions, setDimensions] = React.useState({
          width: 900,
          height: 800,
        });

        // Update dimensions on mount and resize to use full container space
        React.useEffect(() => {
          const updateDimensions = () => {
            if (containerRef.current) {
              const rect = containerRef.current.getBoundingClientRect();
              // Use actual container size (padding already handled by CSS p-2 = 8px each side)
              setDimensions({
                width: Math.max(rect.width - 16, 400),
                height: Math.max(rect.height - 16, 400),
              });
            }
          };
          // Use ResizeObserver for responsive tracking of actual container size
          updateDimensions(); // immediate first measurement
          let ro;
          if (typeof ResizeObserver !== "undefined" && containerRef.current) {
            ro = new ResizeObserver(() => updateDimensions());
            ro.observe(containerRef.current);
          }
          window.addEventListener("resize", updateDimensions);
          return () => {
            if (ro) ro.disconnect();
            window.removeEventListener("resize", updateDimensions);
          };
        }, []);

        // Check Recharts availability (may load later)
        // Re-check inside component in case Recharts loaded after initial script execution
        let currentRechartsComponents = RechartsComponents;
        if (!currentRechartsComponents && typeof Recharts !== "undefined") {
          currentRechartsComponents = {
            ScatterChart: Recharts.ScatterChart,
            Scatter: Recharts.Scatter,
            XAxis: Recharts.XAxis,
            YAxis: Recharts.YAxis,
            CartesianGrid: Recharts.CartesianGrid,
            Tooltip: Recharts.Tooltip,
            ResponsiveContainer: Recharts.ResponsiveContainer,
            ReferenceLine: Recharts.ReferenceLine,
            ReferenceArea: Recharts.ReferenceArea,
          };
        }

        // TEMP: force Native SVG rendering (selection + trail lives here)
        const FORCE_NATIVE_SVG = true;
        if (FORCE_NATIVE_SVG) currentRechartsComponents = null;

        // Debug: Log which path we're taking
        console.log(
          `[BUBBLE CHART RENDER] Using ${
            currentRechartsComponents ? "Recharts" : "Native SVG"
          } mode`,
          {
            selectedTicker,
            hasSelectedTrail: !!selectedTrail,
            selectedTrailLength: Array.isArray(selectedTrail)
              ? selectedTrail.length
              : 0,
          },
        );

        // Fallback: Native SVG chart (works without Recharts)
        if (!currentRechartsComponents) {
          const chartWidth = dimensions.width;
          const chartHeight = dimensions.height;
          const margin = 70; // Extra margin so axis labels don't clip
          const plotWidth = chartWidth - 2 * margin;
          const plotHeight = chartHeight - 2 * margin;

          // Auto-zoom: set domains based on active tickers (symmetric around 0)
          const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
          const axisDomain = (arr, key, fallback = 50) => {
            let min = Infinity;
            let max = -Infinity;
            for (const t of arr) {
              const v = Number(t?.[key]);
              if (!Number.isFinite(v)) continue;
              if (v < min) min = v;
              if (v > max) max = v;
            }
            if (!Number.isFinite(min) || !Number.isFinite(max)) return fallback;
            const maxAbs = Math.max(Math.abs(min), Math.abs(max), 5);
            // Pad a bit, but keep within canonical -50..50 score space
            return clamp(maxAbs * 1.15, 10, 50);
          };
          // Domain base: full loaded universe (stable across filter clicks), fallback to current tickers list.
          const domainBase = (() => {
            if (allData && typeof allData === "object") {
              return Object.values(allData).filter(
                (t) => t && typeof t === "object",
              );
            }
            return Array.isArray(tickers) ? tickers : [];
          })();
          const domainXMax = axisDomain(domainBase, "ltf_score", 50);
          const domainYMax = axisDomain(domainBase, "htf_score", 50);

          // Scaling based on dynamic domains
          const scaleX = plotWidth / (2 * domainXMax);
          const scaleY = plotHeight / (2 * domainYMax);
          const offsetX = margin;
          const offsetY = margin;

          const handlePointerMove = (clientX, clientY, targetEl) => {
            const rect = targetEl.getBoundingClientRect();

            // CSS pixels within the rendered SVG element (used for HTML tooltip positioning)
            const cssX = clientX - rect.left;
            const cssY = clientY - rect.top;
            setTooltipPos({ x: cssX, y: cssY });

            // Convert screen coords → SVG viewBox units using the SVG's actual transform.
            // This accounts for preserveAspectRatio letterboxing and any scaling caused by layout changes.
            let svgX;
            let svgY;
            try {
              if (targetEl && typeof targetEl.createSVGPoint === "function") {
                const pt = targetEl.createSVGPoint();
                pt.x = clientX;
                pt.y = clientY;
                const ctm = targetEl.getScreenCTM && targetEl.getScreenCTM();
                if (ctm && typeof ctm.inverse === "function") {
                  const p = pt.matrixTransform(ctm.inverse());
                  svgX = p.x;
                  svgY = p.y;
                }
              }
            } catch {}

            // Fallback if CTM isn't available
            if (!Number.isFinite(svgX) || !Number.isFinite(svgY)) {
              const sx = rect.width ? chartWidth / rect.width : 1;
              const sy = rect.height ? chartHeight / rect.height : 1;
              svgX = cssX * sx;
              svgY = cssY * sy;
            }

            // Convert SVG position to plot-area coordinates
            const chartX = svgX - offsetX;
            const chartY = svgY - offsetY;

            // Check if mouse is within plot area
            if (
              chartX >= 0 &&
              chartX <= plotWidth &&
              chartY >= 0 &&
              chartY <= plotHeight
            ) {
              // Convert to LTF/HTF scores
              const ltfValue = chartX / scaleX - domainXMax; // -domainXMax..domainXMax
              const htfValue = domainYMax - chartY / scaleY; // Inverted: top is +domainYMax

              setCrosshairPos({
                x: svgX,
                y: svgY,
                ltfValue: ltfValue,
                htfValue: htfValue,
                chartX: chartX,
                chartY: chartY,
              });
            } else {
              setCrosshairPos(null);
            }
          };

          const handleMouseMove = (e) => {
            handlePointerMove(e.clientX, e.clientY, e.currentTarget);
          };

          const handleMouseLeave = () => {
            setTooltip(null);
            setCrosshairPos(null);
          };

          // Collision avoidance: lightly repel overlapping bubbles while anchoring to true score position
          const layoutPositions = (() => {
            const list = Array.isArray(displayTickers) ? displayTickers : [];
            if (list.length === 0) return {};

            const hash = (s) =>
              String(s || "")
                .split("")
                .reduce((acc, ch) => acc + ch.charCodeAt(0), 0);

            const bubbleRadius = (t) => {
              const waiting = t?.waitingForData === true;
              const compRaw = t?.completion != null ? Number(t.completion) : 0;
              const comp = Number.isFinite(compRaw) ? clamp(compRaw, 0, 1) : 0;
              const rrRaw = t?.rr != null ? Number(t.rr) : 0.5;
              const rr = Number.isFinite(rrRaw) && rrRaw > 0 ? rrRaw : 0.5;
              const cappedRR = Math.min(rr, 5);
              const baseSize = 4;
              const rrMultiplier = 2;
              const size = waiting
                ? baseSize * 0.7
                : baseSize + cappedRR * rrMultiplier * (1 - comp);
              const v = (hash(t?.ticker) % 5) * 0.8;
              const finalSize = Math.max(baseSize, size + v);
              return clamp(finalSize, 3, 30);
            };

            const nodes = list.map((t) => {
              const ltf = Number(t?.ltf_score) || 0;
              const htf = Number(t?.htf_score) || 0;
              const x0 = offsetX + (ltf + domainXMax) * scaleX;
              const y0 = offsetY + (domainYMax - htf) * scaleY;
              const r = bubbleRadius(t);
              const j = (hash(t?.ticker) % 7) - 3; // deterministic tiny offset
              return {
                ticker: String(t?.ticker || ""),
                x0,
                y0,
                x: x0 + j * 0.15,
                y: y0 + j * 0.15,
                r,
              };
            });

            const PAD = 1.0;
            const ITER = 12;
            const ANCHOR = 0.18;
            const REPULSE = 0.6;
            const minX = offsetX + 2;
            const maxX = offsetX + plotWidth - 2;
            const minY = offsetY + 2;
            const maxY = offsetY + plotHeight - 2;

            for (let it = 0; it < ITER; it++) {
              for (let i = 0; i < nodes.length; i++) {
                const a = nodes[i];
                for (let j = i + 1; j < nodes.length; j++) {
                  const b = nodes[j];
                  let dx = b.x - a.x;
                  let dy = b.y - a.y;
                  let dist = Math.hypot(dx, dy);
                  const minDist = a.r + b.r + PAD;
                  if (!Number.isFinite(dist) || dist === 0) {
                    const n = ((hash(a.ticker + b.ticker) % 10) - 5) * 0.02;
                    dx = n;
                    dy = -n;
                    dist = Math.hypot(dx, dy) || 1;
                  }
                  if (dist < minDist) {
                    const push = ((minDist - dist) / dist) * 0.5 * REPULSE;
                    a.x -= dx * push;
                    a.y -= dy * push;
                    b.x += dx * push;
                    b.y += dy * push;
                  }
                }
              }
              for (const n of nodes) {
                n.x += (n.x0 - n.x) * ANCHOR;
                n.y += (n.y0 - n.y) * ANCHOR;
                n.x = clamp(n.x, minX + n.r, maxX - n.r);
                n.y = clamp(n.y, minY + n.r, maxY - n.r);
              }
            }

            const out = {};
            for (const n of nodes) {
              if (!n.ticker) continue;
              out[n.ticker] = { x: n.x, y: n.y };
            }
            return out;
          })();

          return (
            <div
              ref={containerRef}
              className="w-full h-full bg-white/[0.02] rounded-xl border border-white/[0.06] p-2 relative"
            >
              {/* Label toggle */}
              <div className="absolute top-2 right-2 z-10">
                <button
                  onClick={() => setShowLabels(!showLabels)}
                  className="px-3 py-1.5 rounded-lg bg-white/[0.03] border border-white/[0.06] text-xs text-[#6b7280] hover:bg-white/5 transition-colors"
                >
                  {showLabels ? "Hide Labels" : "Show Labels"}
                </button>
              </div>
              <svg
                width="100%"
                height="100%"
                viewBox={`0 0 ${chartWidth} ${chartHeight}`}
                preserveAspectRatio="xMidYMid meet"
                onMouseMove={handleMouseMove}
                onMouseLeave={handleMouseLeave}
                onTouchMove={(e) => {
                  // Convert touch event to mouse-like coordinates for mobile
                  const touch = e.touches[0];
                  if (touch) {
                    handlePointerMove(
                      touch.clientX,
                      touch.clientY,
                      e.currentTarget,
                    );
                  }
                }}
                onTouchEnd={handleMouseLeave}
                className="w-full h-full touch-none"
              >
                {/* Grid with better styling */}
                <defs>
                  <pattern
                    id="grid"
                    width="50"
                    height="50"
                    patternUnits="userSpaceOnUse"
                  >
                    <path
                      d="M 50 0 L 0 0 0 50"
                      fill="none"
                      stroke="#252b36"
                      strokeWidth="0.5"
                      opacity="0.5"
                    />
                  </pattern>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                      <feMergeNode in="coloredBlur" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>

                  {/* Arrowhead marker for the Bubble Trail path */}
                  <marker
                    id="trailArrow"
                    viewBox="0 0 10 10"
                    refX="9"
                    refY="5"
                    markerWidth="6"
                    markerHeight="6"
                    orient="auto"
                  >
                    <path
                      d="M 0 0 L 10 5 L 0 10 z"
                      fill="#00ffff"
                      opacity="0.8"
                    />
                  </marker>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />

                {/* Axes - Zero lines (X=0 and Y=0) - Make them very visible */}
                {/* Vertical center line (X=0) */}
                <line
                  x1={offsetX + domainXMax * scaleX}
                  y1={offsetY}
                  x2={offsetX + domainXMax * scaleX}
                  y2={offsetY + plotHeight}
                  stroke="#ffffff"
                  strokeWidth="2"
                  opacity="1"
                />
                {/* Horizontal center line (Y=0) */}
                <line
                  x1={offsetX}
                  y1={offsetY + plotHeight / 2}
                  x2={offsetX + plotWidth}
                  y2={offsetY + plotHeight / 2}
                  stroke="#ffffff"
                  strokeWidth="2"
                  opacity="1"
                />
                {/* Vertical axis line (y-axis) */}
                <line
                  x1={offsetX}
                  y1={offsetY}
                  x2={offsetX}
                  y2={offsetY + plotHeight}
                  stroke="#8b92a0"
                  strokeWidth="2"
                  opacity="0.6"
                />

                {/* Axis labels */}
                <text
                  x={offsetX - 50}
                  y={offsetY + plotHeight / 2}
                  fill="#8b92a0"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                  transform={`rotate(-90 ${offsetX - 50} ${
                    offsetY + plotHeight / 2
                  })`}
                >
                  HTF Score
                </text>
                <text
                  x={offsetX + plotWidth / 2}
                  y={offsetY + plotHeight + 40}
                  fill="#8b92a0"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                >
                  LTF Score
                </text>

                {/* Axis scale markers */}
                {[
                  -domainXMax,
                  -domainXMax / 2,
                  0,
                  domainXMax / 2,
                  domainXMax,
                ].map((val) => {
                  const x = offsetX + (val + domainXMax) * scaleX;
                  const y = offsetY + plotHeight / 2;
                  return (
                    <g key={`x-${val}`}>
                      <line
                        x1={x}
                        y1={y - 5}
                        x2={x}
                        y2={y + 5}
                        stroke="#8b92a0"
                        strokeWidth="2"
                      />
                      <text
                        x={x}
                        y={y + 20}
                        fill="#8b92a0"
                        textAnchor="middle"
                        fontSize="10"
                      >
                        {Math.round(val)}
                      </text>
                    </g>
                  );
                })}
                {[
                  -domainYMax,
                  -domainYMax / 2,
                  0,
                  domainYMax / 2,
                  domainYMax,
                ].map((val) => {
                  const x = offsetX;
                  const y = offsetY + plotHeight - (val + domainYMax) * scaleY;
                  return (
                    <g key={`y-${val}`}>
                      <line
                        x1={x - 5}
                        y1={y}
                        x2={x + 5}
                        y2={y}
                        stroke="#8b92a0"
                        strokeWidth="2"
                      />
                      <text
                        x={x - 15}
                        y={y + 4}
                        fill="#8b92a0"
                        textAnchor="end"
                        fontSize="10"
                      >
                        {Math.round(val)}
                      </text>
                    </g>
                  );
                })}

                {/* Quadrant labels - moved further from center for more bubble space */}
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + 20}
                  fill="#8b92a0"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q1 Prep
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + 20}
                  fill="#8b92a0"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q2 Bull
                </text>
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + plotHeight - 5}
                  fill="#8b92a0"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q3 Bear
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + plotHeight - 5}
                  fill="#8b92a0"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q4 Pullback
                </text>

                {/* Corridors - More pronounced */}
                <rect
                  x={offsetX + (LONG_CORRIDOR.ltfMin + domainXMax) * scaleX}
                  y={offsetY}
                  width={(LONG_CORRIDOR.ltfMax - LONG_CORRIDOR.ltfMin) * scaleX}
                  height={plotHeight / 2}
                  fill="rgba(46,204,113,0.25)"
                  stroke="rgba(46,204,113,0.6)"
                  strokeWidth="2"
                  strokeDasharray="4 4"
                />
                <rect
                  x={offsetX + (SHORT_CORRIDOR.ltfMin + domainXMax) * scaleX}
                  y={offsetY + plotHeight / 2}
                  width={
                    (SHORT_CORRIDOR.ltfMax - SHORT_CORRIDOR.ltfMin) * scaleX
                  }
                  height={plotHeight / 2}
                  fill="rgba(231,76,60,0.25)"
                  stroke="rgba(231,76,60,0.6)"
                  strokeWidth="2"
                  strokeDasharray="4 4"
                />

                {/* Crosshair - Vertical line */}
                {crosshairPos &&
                  crosshairPos.chartX >= 0 &&
                  crosshairPos.chartX <= plotWidth && (
                    <line
                      x1={offsetX + crosshairPos.chartX}
                      y1={offsetY}
                      x2={offsetX + crosshairPos.chartX}
                      y2={offsetY + plotHeight}
                      stroke="#00ffff"
                      strokeWidth="1"
                      strokeDasharray="4 4"
                      opacity="0.7"
                      pointerEvents="none"
                    />
                  )}

                {/* Crosshair - Horizontal line */}
                {crosshairPos &&
                  crosshairPos.chartY >= 0 &&
                  crosshairPos.chartY <= plotHeight && (
                    <line
                      x1={offsetX}
                      y1={offsetY + crosshairPos.chartY}
                      x2={offsetX + plotWidth}
                      y2={offsetY + crosshairPos.chartY}
                      stroke="#00ffff"
                      strokeWidth="1"
                      strokeDasharray="4 4"
                      opacity="0.7"
                      pointerEvents="none"
                    />
                  )}

                {/* Crosshair value labels - Always show when crosshair is active */}
                {crosshairPos && (
                  <>
                    {/* LTF value at bottom - show if crosshair is in plot area */}
                    {crosshairPos.chartX >= 0 &&
                      crosshairPos.chartX <= plotWidth && (
                        <g>
                          <rect
                            x={offsetX + crosshairPos.chartX - 30}
                            y={offsetY + plotHeight + 5}
                            width="60"
                            height="20"
                            fill="#0c0f14"
                            stroke="#00ffff"
                            strokeWidth="1.5"
                            opacity="0.95"
                            rx="3"
                          />
                          <text
                            x={offsetX + crosshairPos.chartX}
                            y={offsetY + plotHeight + 18}
                            fill="#00ffff"
                            textAnchor="middle"
                            fontSize="12"
                            fontWeight="700"
                          >
                            LTF: {crosshairPos.ltfValue.toFixed(1)}
                          </text>
                        </g>
                      )}

                    {/* HTF value on left - show if crosshair is in plot area */}
                    {crosshairPos.chartY >= 0 &&
                      crosshairPos.chartY <= plotHeight && (
                        <g>
                          <rect
                            x={offsetX - 55}
                            y={offsetY + crosshairPos.chartY - 10}
                            width="50"
                            height="20"
                            fill="#0c0f14"
                            stroke="#00ffff"
                            strokeWidth="1.5"
                            opacity="0.95"
                            rx="3"
                          />
                          <text
                            x={offsetX - 30}
                            y={offsetY + crosshairPos.chartY + 5}
                            fill="#00ffff"
                            textAnchor="middle"
                            fontSize="12"
                            fontWeight="700"
                          >
                            HTF: {crosshairPos.htfValue.toFixed(1)}
                          </text>
                        </g>
                      )}
                  </>
                )}

                {/* Bubble Journey overlay */}
                {selectedTicker &&
                  selectedTrail &&
                  selectedTrail.length > 1 && (
                    <>
                      {/* Trail path */}
                      {(() => {
                        const GAP_MS = 30 * 60 * 1000; // break across big gaps (e.g., overnight)
                        const segments = splitTrailByGaps(
                          selectedTrail,
                          GAP_MS,
                        );
                        return segments
                          .filter((seg) => Array.isArray(seg) && seg.length > 1)
                          .map((seg, segIdx) => {
                            const pts = seg.map((p) => ({
                              x:
                                (Number(p?.ltf_score) || 0) * scaleX +
                                offsetX +
                                domainXMax * scaleX,
                              y:
                                (Number(p?.htf_score) || 0) * -scaleY +
                                offsetY +
                                plotHeight -
                                domainYMax * scaleY,
                            }));
                            const d = catmullRomPath(pts);
                            if (!d) return null;
                            const isLast = segIdx === segments.length - 1;
                            const opacity =
                              0.35 +
                              (segIdx / Math.max(1, segments.length - 1)) *
                                0.25;
                            return (
                              <path
                                key={`trail-path-${segIdx}`}
                                d={d}
                                fill="none"
                                stroke="#00ffff"
                                strokeWidth="2.25"
                                opacity={opacity}
                                className="trail-path"
                                markerEnd={
                                  isLast ? "url(#trailArrow)" : undefined
                                }
                                pointerEvents="none"
                              />
                            );
                          });
                      })()}

                      {/* Trail points */}
                      {selectedTrail.slice(0, -1).map((point, idx) => {
                        const x =
                          (Number(point?.ltf_score) || 0) * scaleX +
                          offsetX +
                          domainXMax * scaleX;
                        const y =
                          (Number(point?.htf_score) || 0) * -scaleY +
                          offsetY +
                          plotHeight -
                          domainYMax * scaleY;
                        const visual = bubbleVisualForTrailPoint(
                          point,
                          selectedTicker,
                        );
                        const size = visual.radius;
                        const opacity =
                          0.3 + (idx / selectedTrail.length) * 0.4;
                        return (
                          <circle
                            key={`trail-point-${idx}`}
                            cx={x}
                            cy={y}
                            r={size}
                            fill={visual.color}
                            fillOpacity={opacity}
                            stroke={visual.color}
                            strokeWidth="1"
                            strokeOpacity={opacity * 0.5}
                          />
                        );
                      })}

                      {/* Highlight a specific historical point */}
                      {highlightTrailPoint &&
                        Number.isFinite(
                          Number(highlightTrailPoint?.ltf_score),
                        ) &&
                        Number.isFinite(
                          Number(highlightTrailPoint?.htf_score),
                        ) &&
                        (() => {
                          const hx =
                            (Number(highlightTrailPoint.ltf_score) || 0) *
                              scaleX +
                            offsetX +
                            domainXMax * scaleX;
                          const hy =
                            (Number(highlightTrailPoint.htf_score) || 0) *
                              -scaleY +
                            offsetY +
                            plotHeight -
                            domainYMax * scaleY;
                          const visual = bubbleVisualForTrailPoint(
                            highlightTrailPoint,
                            selectedTicker,
                          );
                          const r = Math.max(3, Number(visual?.radius) || 6);
                          return (
                            <g
                              key={`trail-highlight-${String(
                                highlightTrailPoint?.ts ?? "",
                              )}`}
                              pointerEvents="none"
                            >
                              <circle
                                cx={hx}
                                cy={hy}
                                r={r + 3}
                                fill="none"
                                stroke="#00ffff"
                                strokeWidth="2.25"
                                opacity="0.9"
                              >
                                <animate
                                  attributeName="r"
                                  values={`${r + 2};${r + 10};${r + 2}`}
                                  dur="1.4s"
                                  repeatCount="indefinite"
                                />
                                <animate
                                  attributeName="opacity"
                                  values="0.95;0.25;0.95"
                                  dur="1.4s"
                                  repeatCount="indefinite"
                                />
                              </circle>
                              <circle
                                cx={hx}
                                cy={hy}
                                r={r + 1}
                                fill="none"
                                stroke={visual?.color || "#00ffff"}
                                strokeWidth="1.5"
                                opacity="0.8"
                              />
                            </g>
                          );
                        })()}
                    </>
                  )}

                {/* Current bubbles */}
                {displayTickers.map((ticker) => (
                  <SVGBubble
                    key={ticker.ticker}
                    ticker={ticker}
                    onClick={onBubbleClick}
                    onHover={(t) => {
                      onHover(t);
                      if (t) setTooltip(tickers.find((tt) => tt.ticker === t));
                    }}
                    isHovered={
                      hoveredTicker === ticker.ticker ||
                      (selectedTicker &&
                        String(selectedTicker).toUpperCase() ===
                          String(ticker.ticker || "").toUpperCase())
                    }
                    scaleX={scaleX}
                    scaleY={-scaleY}
                    offsetX={offsetX + domainXMax * scaleX}
                    offsetY={offsetY + plotHeight - domainYMax * scaleY}
                    layoutX={layoutPositions?.[ticker.ticker]?.x}
                    layoutY={layoutPositions?.[ticker.ticker]?.y}
                    showLabels={showLabels}
                    isTopRanked={topRankedTicker === ticker.ticker}
                    thesisMode={thesisMode}
                  />
                ))}

                {/* Time Travel floating label near the selected bubble */}
                {isTimeTravelActive &&
                  selectedTicker &&
                  (() => {
                    const sym = String(selectedTicker || "")
                      .trim()
                      .toUpperCase();
                    if (!sym) return null;
                    const selectedObj = (
                      Array.isArray(tickers) ? tickers : []
                    ).find(
                      (t) =>
                        t &&
                        String(t.ticker || "")
                          .trim()
                          .toUpperCase() === sym,
                    );
                    if (!selectedObj) return null;

                    const ltf = Number(selectedObj?.ltf_score) || 0;
                    const htf = Number(selectedObj?.htf_score) || 0;
                    const lx = layoutPositions?.[selectedObj.ticker]?.x;
                    const ly = layoutPositions?.[selectedObj.ticker]?.y;

                    const ox = offsetX + domainXMax * scaleX;
                    const oy = offsetY + plotHeight - domainYMax * scaleY;
                    const sx = scaleX;
                    const sy = -scaleY;

                    const x = Number.isFinite(Number(lx))
                      ? Number(lx)
                      : ltf * sx + ox;
                    const y = Number.isFinite(Number(ly))
                      ? Number(ly)
                      : htf * sy + oy;

                    const toMs = (v) => {
                      if (v == null) return NaN;
                      if (typeof v === "number") {
                        const n = v;
                        // Heuristic: if seconds, convert to ms
                        return n > 0 && n < 1e12 ? n * 1000 : n;
                      }
                      const n = Number(v);
                      if (Number.isFinite(n))
                        return n > 0 && n < 1e12 ? n * 1000 : n;
                      const d = new Date(String(v));
                      const ms = d.getTime();
                      return Number.isFinite(ms) ? ms : NaN;
                    };

                    const tsMs = toMs(
                      selectedObj.ts ??
                        selectedObj.ingest_ts ??
                        selectedObj.ingest_time,
                    );
                    const price = Number(selectedObj.price);

                    const tsText = Number.isFinite(tsMs)
                      ? new Date(tsMs).toLocaleString("en-US", {
                          month: "short",
                          day: "numeric",
                          hour: "numeric",
                          minute: "2-digit",
                        })
                      : "—";
                    const pxText = Number.isFinite(price)
                      ? `$${price.toFixed(2)}`
                      : "—";
                    const labelText = `${tsText} • ${pxText}`;

                    // Position the label near the bubble; clamp inside the SVG viewport.
                    const pad = 8;
                    const approxW = Math.min(
                      260,
                      Math.max(140, labelText.length * 6.2),
                    );
                    const w = approxW;
                    const h = 22;
                    let lx0 = x + 14;
                    let ly0 = y - 34;
                    lx0 = Math.max(pad, Math.min(chartWidth - w - pad, lx0));
                    ly0 = Math.max(pad, Math.min(chartHeight - h - pad, ly0));

                    return (
                      <g pointerEvents="none" opacity="0.98">
                        <rect
                          x={lx0}
                          y={ly0}
                          width={w}
                          height={h}
                          rx="6"
                          fill="#0c0f14"
                          stroke="#00ffff"
                          strokeWidth="1"
                          fillOpacity="0.85"
                        />
                        <text
                          x={lx0 + w / 2}
                          y={ly0 + 15}
                          fill="#f0f2f5"
                          textAnchor="middle"
                          fontSize="11"
                          fontWeight="700"
                        >
                          {labelText}
                        </text>
                      </g>
                    );
                  })()}
              </svg>

              {/* Tooltip */}
              {tooltip &&
                (() => {
                  // Calculate rank position using worker's rank field (stored at worker level)
                  // This matches the ranking system used throughout the platform
                  let rankPosition = null;
                  let totalTickers = 0;
                  const sortedByRank =
                    rankedTickers && rankedTickers.length > 0
                      ? rankedTickers
                      : getRankedTickers(allData);
                  totalTickers = sortedByRank.length;
                  rankPosition =
                    getRankPositionFromMap(
                      rankedTickerPositions,
                      tooltip.ticker,
                    ) ?? getRankPosition(sortedByRank, tooltip.ticker);
                  const rankTotal =
                    Number.isFinite(Number(tooltip.rank_total)) &&
                    Number(tooltip.rank_total) > 0
                      ? Number(tooltip.rank_total)
                      : totalTickers;
                  totalTickers = rankTotal;
                  return (
                    <div
                      className="absolute rounded-2xl p-3 text-sm pointer-events-none z-10 shadow-2xl fade-in border border-white/[0.10]"
                      style={{
                        left: tooltipPos.x > dimensions.width * 0.65 ? tooltipPos.x - 240 : tooltipPos.x + 10,
                        top: tooltipPos.y > dimensions.height * 0.55 ? tooltipPos.y - 280 : tooltipPos.y - 10,
                        minWidth: "220px",
                        background: "rgba(255,255,255,0.06)",
                        backdropFilter: "blur(24px) saturate(1.4)",
                        WebkitBackdropFilter: "blur(24px) saturate(1.4)",
                        boxShadow: "0 8px 32px rgba(0,0,0,0.45), inset 0 0.5px 0 rgba(255,255,255,0.08)",
                      }}
                    >
                      <div className="font-bold text-base mb-2">
                        {tooltip.ticker}
                        {tooltip.price && (
                          <span className="ml-2 text-sm font-normal text-white">
                            ${Number(tooltip.price).toFixed(2)}
                          </span>
                        )}
                      </div>
                      {(() => {
                        // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                        const ingestTime =
                          tooltip.ingest_ts ||
                          tooltip.ingest_time ||
                          tooltip.ts;
                        if (ingestTime) {
                          try {
                            let timeValue;
                            if (typeof ingestTime === "string") {
                              timeValue = new Date(ingestTime);
                            } else {
                              const n = Number(ingestTime);
                              const ms = n > 0 && n < 1e12 ? n * 1000 : n;
                              timeValue = new Date(ms);
                            }
                            if (!isNaN(timeValue.getTime())) {
                              const ageMs = Date.now() - timeValue.getTime();
                              const ageMinutes = Math.floor(ageMs / 60000);
                              const ageHours = Math.floor(ageMinutes / 60);

                              // Warn if data is stale (older than 30 minutes)
                              const isStale = ageMinutes > 30;
                              const etOpt = { timeZone: "America/New_York" };

                              const displayTime = timeValue.toLocaleTimeString(
                                "en-US",
                                { hour: "numeric", minute: "2-digit", hour12: true, ...etOpt },
                              );
                              const displayDate = timeValue.toLocaleDateString(
                                "en-US",
                                { month: "short", day: "numeric", ...etOpt },
                              );
                              return (
                                <div
                                  className={`text-[10px] mb-2 ${
                                    isStale
                                      ? "text-yellow-400"
                                      : "text-[#6b7280]"
                                  }`}
                                >
                                  {displayDate} {displayTime}
                                  {isStale && (
                                    <span
                                      className="ml-1"
                                      title={`Data is ${
                                        ageHours > 0 ? `${ageHours}h ` : ""
                                      }${ageMinutes % 60}m old`}
                                    >
                                      ⚠️
                                    </span>
                                  )}
                                </div>
                              );
                            }
                          } catch (e) {}
                        }
                        return null;
                      })()}
                      {(() => {
                        const p = isPrimeBubble(tooltip);
                        if (!p) return null;
                        const labels = { aligned: "Aligned", thesis: "Thesis Confirmed", winner: "Early Pattern", squeeze_release: "Squeeze Release", momentum: "Momentum", phase_change: "Phase Shift" };
                        return (
                          <div className="mb-2 px-2 py-1 rounded bg-teal-500/20 text-teal-400 text-xs font-semibold text-center">
                            💎 PRIME — {labels[p.reason] || "Quality Setup"}
                          </div>
                        );
                      })()}
                      {(() => {
                        const mv = getMoveStatusInfo(tooltip);
                        return (
                          <div className="mb-2 flex items-center justify-between gap-2">
                            <span className="text-[11px] text-[#6b7280]">
                              Move
                            </span>
                            <span
                              className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${mv.pillCls}`}
                            >
                              {mv.icon} {mv.status}
                            </span>
                          </div>
                        );
                      })()}
                      {(() => {
                        const mv = getMoveStatusInfo(tooltip);
                        if (mv.status === "ACTIVE" || !mv.headlineReason)
                          return null;
                        return (
                          <div className="mb-2 text-[10px] text-[#4b5563]">
                            <span className="text-[#6b7280]">
                              {mv.status === "INVALIDATED"
                                ? "Invalidated"
                                : "Completed"}
                              :
                            </span>{" "}
                            <span className="text-[#d1d5db]">
                              {mv.headlineReason}
                            </span>
                          </div>
                        );
                      })()}
                      <div className="space-y-1">
                        <div className="flex justify-between">
                          <span className="text-[#6b7280]">Score</span>
                          <span className="font-semibold">
                            {(() => {
                              const s = rankScoreForTicker(tooltip);
                              return Number.isFinite(s) ? s.toFixed(1) : "—";
                            })()}
                          </span>
                        </div>
                        {rankPosition !== null && totalTickers > 0 && (
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Rank</span>
                            <span className="font-semibold">
                              {rankPosition} / {totalTickers}
                            </span>
                          </div>
                        )}
                        <div className="flex justify-between">
                          <span className="text-[#6b7280]">RR</span>
                          <span className="font-semibold">
                            {window._ttIsPro
                              ? (tooltip.rr ? Number(tooltip.rr).toFixed(2) : "—")
                              : <span className="text-amber-400" title="Upgrade to Pro for R:R">Go Pro</span>}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-[#6b7280]">State</span>
                          <span className="font-semibold">
                            {tooltip.state || "—"}
                          </span>
                        </div>
                        {window._ttIsPro ? (
                          <>
                            <div className="flex justify-between">
                              <span className="text-[#6b7280]">Phase</span>
                              <span
                                className="font-semibold"
                                style={{
                                  color: phaseToColor(
                                    Number(tooltip.phase_pct) || 0,
                                  ),
                                }}
                              >
                                {Math.round((Number(tooltip.phase_pct) || 0) * 100)}
                                %{tooltip.phase_zone && ` (${tooltip.phase_zone})`}
                              </span>
                            </div>
                            <div className="flex justify-between">
                              <span className="text-[#6b7280]">Completion</span>
                              <span className="font-semibold">
                                {Math.round(completionForSize(tooltip) * 100)}%
                              </span>
                            </div>
                          </>
                        ) : (
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Progress</span>
                            <span className="font-semibold text-amber-400" title="Upgrade to Pro for Phase & Completion">Go Pro</span>
                          </div>
                        )}
                        {tooltip.regime_class && (
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Regime</span>
                            <span className={`font-semibold ${tooltip.regime_class === "TRENDING" ? "text-emerald-400" : tooltip.regime_class === "CHOPPY" ? "text-rose-400" : "text-amber-400"}`}>
                              {tooltip.regime_class}
                            </span>
                          </div>
                        )}
                        {(() => {
                          const rm = tooltip.rvol_map || {};
                          const rv = Math.max(Number(rm?.["30"]?.vr) || 0, Number(rm?.["60"]?.vr) || 0);
                          if (rv <= 0) return null;
                          return (
                            <div className="flex justify-between">
                              <span className="text-[#6b7280]">RVOL</span>
                              <span className={`font-semibold ${rv >= 1.5 ? "text-emerald-400" : rv >= 0.8 ? "text-white" : "text-rose-400"}`}>
                                {rv.toFixed(2)}x
                              </span>
                            </div>
                          );
                        })()}
                      </div>
                    </div>
                  );
                })()}
            </div>
          );
        }

        // Recharts version (if loaded) - use currentRechartsComponents
        const {
          ScatterChart,
          Scatter,
          XAxis,
          YAxis,
          CartesianGrid,
          Tooltip,
          ResponsiveContainer,
          ReferenceLine,
          ReferenceArea,
        } = currentRechartsComponents;

        const [rechartsCrosshair, setRechartsCrosshair] = useState(null);
        const chartContainerRef = React.useRef(null);

        // Store ranked tickers for tooltip access
        const allTickersForRanking = rankedTickers;

        // Filter data based on selectedTicker - if selected, only show that ticker
        const data = useMemo(() => {
          const tickersToUse = selectedTicker
            ? tickers.filter((t) => {
                if (!t || typeof t !== "object") return false;
                const tTicker = String(t.ticker || "").toUpperCase();
                return tTicker === String(selectedTicker).toUpperCase();
              })
            : tickers;

          console.log(
            `[RECHARTS DATA] selectedTicker=${selectedTicker}, using ${tickersToUse.length} of ${tickers.length} tickers`,
          );

          return tickersToUse.map((t) => ({
            x: Number(t.ltf_score) || 0,
            y: Number(t.htf_score) || 0,
            ticker: t,
          }));
        }, [tickers, selectedTicker]);

        // Recharts shape renderer - receives cx, cy, payload from Recharts
        const BubbleShape = React.useCallback(
          (props) => {
            const { cx, cy, payload } = props;
            const ticker = payload?.ticker;
            if (!ticker) return null;

            const comp =
              ticker.completion != null ? Number(ticker.completion) : 0;
            const phasePct =
              ticker.phase_pct != null ? Number(ticker.phase_pct) : 0;
            const rr = ticker.rr != null ? Number(ticker.rr) : 0;
            const waitingForData = ticker.waitingForData === true;

            const validComp = Number.isFinite(comp)
              ? Math.max(0, Math.min(1, comp))
              : 0;
            const validPhase = Number.isFinite(phasePct)
              ? Math.max(0, Math.min(1, phasePct))
              : 0.1;
            const validRR = Number.isFinite(rr) && rr > 0 ? rr : 0.5;

            const cappedRR = Math.min(validRR, 5);
            const baseSize = 4; // Further reduced for less overlap
            const rrMultiplier = 2; // Further reduced for smaller bubbles
            const size = waitingForData
              ? baseSize * 0.7
              : baseSize + cappedRR * rrMultiplier * (1 - validComp);

            // Add size variation for better visual distinction
            const tickerHash = (ticker.ticker || "")
              .split("")
              .reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const sizeVariation = (tickerHash % 5) * 0.8;
            const finalSize = Math.max(baseSize, size + sizeVariation);

            // Direction-aware color (matches kanban card accents)
            const flags = ticker.flags || {};
            const prime = isPrimeBubble(ticker);
            const winnerSig = isWinnerSignature(ticker);
            const move = getMoveStatusInfo(ticker);
            const dir = getDirectionFromState(ticker);
            const flipWatch = !!flags.flip_watch;
            const isTopRanked = topRankedTicker === ticker.ticker;
            const isBubbleHovered = hoveredTicker === ticker.ticker;
            const isInSqueeze = !!flags.sq30_on && !flags.sq30_release;

            let color;
            if (waitingForData) {
              color = "#5c6475";
            } else if (dir === "LONG") {
              color = validPhase < 0.3 ? "#22d3ee" : validPhase < 0.6 ? "#06b6d4" : "#0891b2";
            } else if (dir === "SHORT") {
              color = validPhase < 0.3 ? "#fb7185" : validPhase < 0.6 ? "#e11d48" : "#be123c";
            } else {
              color = validPhase < 0.3 ? "#14b8a6" : validPhase < 0.6 ? "#eab308" : "#e11d48";
            }

            const emojis = [];
            if (isTopRanked) emojis.push("👑");
            if (waitingForData) emojis.push("⏳");
            if (!waitingForData) {
              if (prime) emojis.push("💎");
              if (flipWatch) emojis.push("🎯");
              if (!!flags.momentum_elite) emojis.push("🔥");
              if (flags.sq30_release) emojis.push("⚡");
              if (isInSqueeze) emojis.push("🧨");
            }
            const emojiText = emojis.join("");

            let borderColor = waitingForData ? "#8b92a0"
              : dir === "LONG" ? "#22d3ee"
              : dir === "SHORT" ? "#e11d48"
              : flipWatch ? "#fbbf24"
              : prime ? "#14b8a6"
              : winnerSig ? "#a855f7"
              : flags.sq30_release ? "#00ffff"
              : flags.sq30_on ? "#ffd700"
              : "rgba(255,255,255,0.25)";

            const baseOpacity = waitingForData ? 0.55
              : isBubbleHovered ? 1
              : dir ? 0.92
              : prime || winnerSig ? 0.9
              : 0.8;
            const moveOpacityMult = waitingForData || isBubbleHovered ? 1
              : move.status === "INVALIDATED" ? 0.25
              : move.status === "COMPLETED" ? 0.6
              : 1;
            const opacity = Math.max(0.12, baseOpacity * moveOpacityMult);

            if (!waitingForData && move.status !== "ACTIVE" && !dir) {
              borderColor = move.stroke;
            }
            const borderWidth = waitingForData ? 1.5
              : dir ? 2.5
              : flipWatch ? 3.5
              : prime || winnerSig ? 3
              : flags.sq30_release || flags.sq30_on ? 2
              : 1.5;
            const bubbleSize = isBubbleHovered ? finalSize * 1.2 : finalSize;
            const labelY =
              cy - bubbleSize - (emojiText ? (isTopRanked ? 20 : 12) : 8);

            const rcGradId = `rc-bg-${ticker.ticker}`;
            const rcRenderedSize = Math.max(3, bubbleSize);

            return (
              <g
                onClick={() => onBubbleClick(ticker.ticker)}
                onMouseEnter={() => onHover(ticker.ticker)}
                onMouseLeave={() => onHover(null)}
                onTouchStart={(e) => { e.preventDefault(); onHover(ticker.ticker); onBubbleClick(ticker.ticker); }}
                onTouchEnd={(e) => { e.preventDefault(); onHover(null); }}
                style={{ cursor: "pointer", transition: "all 0.2s ease-out", touchAction: "manipulation" }}
              >
                <defs>
                  <radialGradient id={rcGradId} cx="35%" cy="35%">
                    <stop offset="0%" stopColor="#ffffff" stopOpacity="0.18" />
                    <stop offset="50%" stopColor={color} stopOpacity={opacity} />
                    <stop offset="100%" stopColor={color} stopOpacity={opacity * 0.7} />
                  </radialGradient>
                </defs>
                {/* Outer glow ring for direction / special states */}
                {(dir || flipWatch || prime || winnerSig) && (
                  <circle
                    cx={cx} cy={cy}
                    r={rcRenderedSize + 3}
                    fill="none"
                    stroke={borderColor}
                    strokeWidth={flipWatch ? 2 : 1}
                    opacity={flipWatch ? 0.5 : 0.2}
                  >
                    {flipWatch && (
                      <>
                        <animate attributeName="r" values={`${rcRenderedSize + 3};${rcRenderedSize + 6};${rcRenderedSize + 3}`} dur="2s" repeatCount="indefinite" />
                        <animate attributeName="opacity" values="0.3;0.7;0.3" dur="2s" repeatCount="indefinite" />
                      </>
                    )}
                  </circle>
                )}
                {/* #1 ranked glow */}
                {isTopRanked && (
                  <>
                    <circle cx={cx} cy={cy} r={rcRenderedSize + 5} fill="none" stroke="#ffd700" strokeWidth="2" opacity="0.6">
                      <animate attributeName="opacity" values="0.3;0.9;0.3" dur="2s" repeatCount="indefinite" />
                      <animate attributeName="r" values={`${rcRenderedSize + 4};${rcRenderedSize + 7};${rcRenderedSize + 4}`} dur="2s" repeatCount="indefinite" />
                    </circle>
                  </>
                )}
                {/* Main bubble — gradient fill */}
                <circle
                  cx={cx} cy={cy}
                  r={rcRenderedSize}
                  fill={`url(#${rcGradId})`}
                  stroke={borderColor}
                  strokeWidth={borderWidth}
                  strokeDasharray={!waitingForData && move.dash ? move.dash : undefined}
                />
                {/* Highlight arc for glassy look */}
                {rcRenderedSize > 5 && (
                  <circle
                    cx={cx - rcRenderedSize * 0.2}
                    cy={cy - rcRenderedSize * 0.2}
                    r={rcRenderedSize * 0.45}
                    fill="#ffffff"
                    fillOpacity="0.08"
                    style={{ pointerEvents: "none" }}
                  />
                )}
                {/* Move status badge (Completed / Invalidated) */}
                {!waitingForData && move.status !== "ACTIVE" && (
                  <g style={{ pointerEvents: "none" }}>
                    <text
                      x={cx + bubbleSize * 0.55}
                      y={cy - bubbleSize * 0.55}
                      textAnchor="middle"
                      dominantBaseline="middle"
                      fontSize="12"
                      fontWeight="800"
                      style={{ textShadow: "0 0 4px rgba(0,0,0,0.9)" }}
                    >
                      {move.icon}
                    </text>
                  </g>
                )}
                {/* Emoji above bubble */}
                {emojiText && (
                  <g style={{ pointerEvents: "none" }}>
                    {/* Background circle for #1 ranked - reduced size */}
                    {isTopRanked && (
                      <circle
                        cx={cx}
                        cy={labelY - 5}
                        r="18"
                        fill="#ffd700"
                        fillOpacity="0.3"
                      >
                        <animate
                          attributeName="fillOpacity"
                          values="0.2;0.5;0.2"
                          dur="1.5s"
                          repeatCount="indefinite"
                        />
                      </circle>
                    )}
                    {/* Outer glow ring for #1 - reduced size */}
                    {isTopRanked && (
                      <>
                        <circle
                          cx={cx}
                          cy={labelY - 5}
                          r="22"
                          fill="none"
                          stroke="#ffd700"
                          strokeWidth="2"
                          opacity="0.6"
                        >
                          <animate
                            attributeName="r"
                            values="20;24;20"
                            dur="2s"
                            repeatCount="indefinite"
                          />
                          <animate
                            attributeName="opacity"
                            values="0.4;0.8;0.4"
                            dur="2s"
                            repeatCount="indefinite"
                          />
                        </circle>
                      </>
                    )}
                    {/* Main emoji text */}
                    <text
                      x={cx}
                      y={labelY}
                      textAnchor="middle"
                      dominantBaseline="middle"
                      fontSize={
                        isTopRanked
                          ? "24"
                          : waitingForData
                            ? "10"
                            : prime
                              ? "14"
                              : "12"
                      }
                      fill={
                        isTopRanked
                          ? "#ffd700"
                          : waitingForData
                            ? "#8b92a0"
                            : prime
                              ? "#14b8a6"
                              : winnerSig
                                ? "#a855f7"
                                : flags.sq30_release
                                  ? "#00ffff"
                                  : flags.momentum_elite
                                    ? "#a855f7"
                                    : "#ffd700"
                      }
                      fontWeight="bold"
                      style={{
                        textShadow: isTopRanked
                          ? "0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.8)"
                          : "0 0 3px rgba(0,0,0,0.8)",
                        filter: isTopRanked
                          ? "drop-shadow(0 0 15px rgba(255, 215, 0, 1))"
                          : "none",
                        pointerEvents: "none",
                      }}
                    >
                      {emojiText}
                    </text>
                    {/* Sparkle effects for #1 - reduced size */}
                    {isTopRanked && (
                      <>
                        <text
                          x={cx - 15}
                          y={labelY - 10}
                          textAnchor="middle"
                          dominantBaseline="middle"
                          fontSize="12"
                          fill="#ffd700"
                          opacity="0.9"
                          style={{ pointerEvents: "none" }}
                        >
                          ✨
                        </text>
                        <text
                          x={cx + 15}
                          y={labelY - 10}
                          textAnchor="middle"
                          dominantBaseline="middle"
                          fontSize="12"
                          fill="#ffd700"
                          opacity="0.9"
                          style={{ pointerEvents: "none" }}
                        >
                          ✨
                        </text>
                      </>
                    )}
                  </g>
                )}
                {/* Ticker label */}
                {(showLabels || isBubbleHovered) && (
                  <text
                    x={cx}
                    y={labelY - (emojiText ? 14 : 8)}
                    textAnchor="middle"
                    fontSize="10"
                    fill={waitingForData ? "#8b92a0" : "#f0f2f5"}
                    fontWeight="600"
                    style={{
                      textShadow: "0 0 4px rgba(0,0,0,0.9)",
                      pointerEvents: "none",
                    }}
                  >
                    {ticker.ticker}
                  </text>
                )}
              </g>
            );
          },
          [onBubbleClick, onHover, hoveredTicker, topRankedTicker, showLabels],
        );

        const handleRechartsMouseMove = (e) => {
          if (
            e &&
            e.activeCoordinate &&
            e.chartX !== undefined &&
            e.chartY !== undefined
          ) {
            // Calculate values from chart coordinates
            // Domain is [-50, 50] for both axes
            // activeCoordinate gives us pixel position, we need to convert to data values
            const chart = e.chart;
            if (chart && chartContainerRef.current) {
              const rect = chartContainerRef.current.getBoundingClientRect();
              const margin = { top: 20, right: 20, bottom: 20, left: 20 };
              const plotWidth = rect.width - margin.left - margin.right;
              const plotHeight = rect.height - margin.top - margin.bottom;

              // Convert pixel coordinates to data values
              const ltfValue =
                ((e.chartX - margin.left) / plotWidth) * 100 - 50;
              const htfValue =
                50 - ((e.chartY - margin.top) / plotHeight) * 100;

              setRechartsCrosshair({
                x: e.chartX,
                y: e.chartY,
                ltfValue: ltfValue,
                htfValue: htfValue,
              });
            } else if (e.activePayload && e.activePayload[0]) {
              // Fallback: use payload data if available
              const payload = e.activePayload[0].payload;
              setRechartsCrosshair({
                x: e.activeCoordinate.x,
                y: e.activeCoordinate.y,
                ltfValue: payload.x,
                htfValue: payload.y,
              });
            }
          }
        };

        const handleRechartsMouseLeave = () => {
          setRechartsCrosshair(null);
        };

        return (
          <div
            ref={chartContainerRef}
            className="w-full h-full bg-white/[0.02] rounded-xl border border-white/[0.06] p-4 relative"
          >
            <ResponsiveContainer width="100%" height="100%">
              <ScatterChart
                margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
                onMouseMove={handleRechartsMouseMove}
                onMouseLeave={handleRechartsMouseLeave}
                onTouchMove={(e) => {
                  // Recharts handles touch events, but we need to ensure they work
                  if (e.activeCoordinate) {
                    handleRechartsMouseMove(e);
                  }
                }}
                onTouchEnd={handleRechartsMouseLeave}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#252b36" />
                <XAxis
                  type="number"
                  dataKey="x"
                  name="LTF Score"
                  domain={[-50, 50]}
                  stroke="#8b92a0"
                />
                <YAxis
                  type="number"
                  dataKey="y"
                  name="HTF Score"
                  domain={[-50, 50]}
                  stroke="#8b92a0"
                />
                {/* Corridors - Long corridor (top half, LTF: -8 to +12) - More pronounced */}
                <ReferenceArea
                  x1={LONG_CORRIDOR.ltfMin}
                  x2={LONG_CORRIDOR.ltfMax}
                  y1={0}
                  y2={50}
                  fill="rgba(46,204,113,0.25)"
                  stroke="rgba(46,204,113,0.6)"
                  strokeWidth={2}
                  strokeDasharray="4 4"
                />
                {/* Corridors - Short corridor (bottom half, LTF: -12 to +8) - More pronounced */}
                <ReferenceArea
                  x1={SHORT_CORRIDOR.ltfMin}
                  x2={SHORT_CORRIDOR.ltfMax}
                  y1={-50}
                  y2={0}
                  fill="rgba(231,76,60,0.25)"
                  stroke="rgba(231,76,60,0.6)"
                  strokeWidth={2}
                  strokeDasharray="4 4"
                />
                {/* Zero lines - X=0 and Y=0 */}
                <ReferenceLine
                  x={0}
                  stroke="#ffffff"
                  strokeWidth={2}
                  opacity={1}
                />
                <ReferenceLine
                  y={0}
                  stroke="#ffffff"
                  strokeWidth={2}
                  opacity={1}
                />
                {/* Crosshair - Vertical line */}
                {rechartsCrosshair && rechartsCrosshair.ltfValue !== null && (
                  <ReferenceLine
                    x={rechartsCrosshair.ltfValue}
                    stroke="#00ffff"
                    strokeWidth={1}
                    strokeDasharray="4 4"
                    opacity={0.7}
                  />
                )}
                {/* Crosshair - Horizontal line */}
                {rechartsCrosshair && rechartsCrosshair.htfValue !== null && (
                  <ReferenceLine
                    y={rechartsCrosshair.htfValue}
                    stroke="#00ffff"
                    strokeWidth={1}
                    strokeDasharray="4 4"
                    opacity={0.7}
                  />
                )}
                <Tooltip
                  content={({ active, payload }) => {
                    if (!active || !payload?.[0]) return null;
                    const t = payload[0].payload.ticker;

                    // Calculate rank position (same logic as native SVG tooltip)
                    let rankPosition = null;
                    let totalTickers = 0;
                    const sortedByRank =
                      allTickersForRanking &&
                      Array.isArray(allTickersForRanking)
                        ? allTickersForRanking
                        : getRankedTickers(allData);
                    totalTickers = sortedByRank.length;
                    rankPosition =
                      getRankPositionFromMap(rankedTickerPositions, t.ticker) ??
                      getRankPosition(sortedByRank, t.ticker);
                    const rankTotal =
                      Number.isFinite(Number(t.rank_total)) &&
                      Number(t.rank_total) > 0
                        ? Number(t.rank_total)
                        : totalTickers;
                    totalTickers = rankTotal;

                    return (
                      <div className="bg-white/[0.02] border-2 border-white/[0.06] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl">
                        <div className="font-bold text-base mb-2">
                          {t.ticker}
                          {t.price && (
                            <span className="ml-2 text-sm font-normal text-white">
                              ${Number(t.price).toFixed(2)}
                            </span>
                          )}
                        </div>
                        {(() => {
                          // Show ingest time (same logic as native SVG tooltip)
                          const ingestTime =
                            t.ingest_ts || t.ingest_time || t.ts;
                          if (ingestTime) {
                            try {
                              const timeValue =
                                typeof ingestTime === "string"
                                  ? new Date(ingestTime)
                                  : new Date(Number(ingestTime));
                              if (!isNaN(timeValue.getTime())) {
                                const ageMs = Date.now() - timeValue.getTime();
                                const ageMinutes = Math.floor(ageMs / 60000);
                                const ageHours = Math.floor(ageMinutes / 60);
                                const isStale = ageMinutes > 30;

                                const displayTime =
                                  timeValue.toLocaleTimeString("en-US", {
                                    hour: "numeric",
                                    minute: "2-digit",
                                    hour12: true,
                                  });
                                const displayDate =
                                  timeValue.toLocaleDateString("en-US", {
                                    month: "short",
                                    day: "numeric",
                                  });
                                return (
                                  <div
                                    className={`text-[10px] mb-2 ${
                                      isStale
                                        ? "text-yellow-400"
                                        : "text-[#6b7280]"
                                    }`}
                                  >
                                    {displayDate} {displayTime}
                                    {isStale && (
                                      <span
                                        className="ml-1"
                                        title={`Data is ${
                                          ageHours > 0 ? `${ageHours}h ` : ""
                                        }${ageMinutes % 60}m old`}
                                      >
                                        ⚠️
                                      </span>
                                    )}
                                  </div>
                                );
                              }
                            } catch (e) {}
                          }
                          return null;
                        })()}
                        {(() => {
                          const p = isPrimeBubble(t);
                          if (!p) return null;
                          const labels = { aligned: "Aligned", thesis: "Thesis Confirmed", winner: "Early Pattern", squeeze_release: "Squeeze Release", momentum: "Momentum", phase_change: "Phase Shift" };
                          return (
                            <div className="mb-2 px-2 py-1 rounded bg-teal-500/20 text-teal-400 text-xs font-semibold text-center">
                              💎 PRIME — {labels[p.reason] || "Quality Setup"}
                            </div>
                          );
                        })()}
                        {(() => {
                          const mv = getMoveStatusInfo(t);
                          return (
                            <div className="mb-2 flex items-center justify-between gap-2">
                              <span className="text-[11px] text-[#6b7280]">
                                Move
                              </span>
                              <span
                                className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${mv.pillCls}`}
                              >
                                {mv.icon} {mv.status}
                              </span>
                            </div>
                          );
                        })()}
                        {(() => {
                          const mv = getMoveStatusInfo(t);
                          if (mv.status === "ACTIVE" || !mv.headlineReason)
                            return null;
                          return (
                            <div className="mb-2 text-[10px] text-[#4b5563]">
                              <span className="text-[#6b7280]">
                                {mv.status === "INVALIDATED"
                                  ? "Invalidated"
                                  : "Completed"}
                                :
                              </span>{" "}
                              <span className="text-[#d1d5db]">
                                {mv.headlineReason}
                              </span>
                            </div>
                          );
                        })()}
                        <div className="space-y-1">
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Score</span>
                            <span className="font-semibold">
                              {(() => {
                                const s = rankScoreForTicker(t);
                                return Number.isFinite(s) ? s.toFixed(1) : "—";
                              })()}
                            </span>
                          </div>
                          {rankPosition !== null && totalTickers > 0 && (
                            <div className="flex justify-between">
                              <span className="text-[#6b7280]">Rank</span>
                              <span className="font-semibold">
                                {rankPosition} / {totalTickers}
                              </span>
                            </div>
                          )}
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">RR</span>
                            <span className="font-semibold">
                              {t.rr ? Number(t.rr).toFixed(2) : "—"}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">State</span>
                            <span className="font-semibold">
                              {t.state || "—"}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Phase</span>
                            <span
                              className="font-semibold"
                              style={{
                                color: phaseToColor(Number(t.phase_pct) || 0),
                              }}
                            >
                              {Math.round((Number(t.phase_pct) || 0) * 100)}%
                              {t.phase_zone && ` (${t.phase_zone})`}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Completion</span>
                            <span className="font-semibold">
                              {Math.round(completionForSize(t) * 100)}%
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Horizon</span>
                            <span className="font-semibold">
                              {(() => {
                                const eta = computeEtaDays(t);
                                const bucket = String(t.horizon_bucket || "")
                                  .trim()
                                  .toUpperCase();
                                if (bucket) return bucket.replace("_", " ");
                                if (!Number.isFinite(eta)) return "—";
                                if (eta <= 7) return "SHORT TERM";
                                if (eta <= 30) return "SWING";
                                return "POSITIONAL";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">ETA</span>
                            <span className="font-semibold">
                              {(() => {
                                const eta = computeEtaDays(t);
                                return Number.isFinite(eta)
                                  ? `${eta.toFixed(1)}d`
                                  : "—";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Return %</span>
                            <span className="font-semibold">
                              {(() => {
                                const ret = computeReturnPct(t);
                                return Number.isFinite(ret)
                                  ? `${ret.toFixed(1)}%`
                                  : "—";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#6b7280]">Risk %</span>
                            <span className="font-semibold">
                              {(() => {
                                const risk = computeRiskPct(t);
                                return Number.isFinite(risk)
                                  ? `${risk.toFixed(1)}%`
                                  : "—";
                              })()}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  }}
                />
                <Scatter data={data} shape={BubbleShape} />
              </ScatterChart>
            </ResponsiveContainer>

            {/* Trail rendering overlay for selected ticker (Recharts mode) */}
            {selectedTicker &&
              selectedTrail &&
              Array.isArray(selectedTrail) &&
              selectedTrail.length > 1 && (
                <svg
                  className="absolute inset-0 pointer-events-none z-10"
                  style={{ width: "100%", height: "100%" }}
                >
                  <defs>
                    <linearGradient
                      id="trailGradient"
                      x1="0%"
                      y1="0%"
                      x2="100%"
                      y2="100%"
                    >
                      <stop offset="0%" stopColor="#00ffff" stopOpacity="0.3" />
                      <stop
                        offset="100%"
                        stopColor="#00ffff"
                        stopOpacity="0.6"
                      />
                    </linearGradient>

                    {/* Arrowhead marker for the Bubble Trail path */}
                    <marker
                      id="trailArrowRecharts"
                      viewBox="0 0 10 10"
                      refX="9"
                      refY="5"
                      markerWidth="6"
                      markerHeight="6"
                      orient="auto"
                    >
                      <path
                        d="M 0 0 L 10 5 L 0 10 z"
                        fill="#00ffff"
                        opacity="0.8"
                      />
                    </marker>
                  </defs>
                  <g>
                    {/* Trail lines */}
                    {(() => {
                      const chartWidth =
                        chartContainerRef.current?.clientWidth || 1200;
                      const chartHeight =
                        chartContainerRef.current?.clientHeight || 800;
                      const margin = 20;
                      const plotWidth = chartWidth - 2 * margin;
                      const plotHeight = chartHeight - 2 * margin;

                      const GAP_MS = 30 * 60 * 1000;
                      const segments = splitTrailByGaps(selectedTrail, GAP_MS);

                      return segments
                        .filter((seg) => Array.isArray(seg) && seg.length > 1)
                        .map((seg, segIdx) => {
                          const pts = seg.map((p) => ({
                            x:
                              (((Number(p?.ltf_score) || 0) + 50) / 100) *
                                plotWidth +
                              margin,
                            y:
                              ((50 - (Number(p?.htf_score) || 0)) / 100) *
                                plotHeight +
                              margin,
                          }));
                          const d = catmullRomPath(pts);
                          if (!d) return null;
                          const isLast = segIdx === segments.length - 1;
                          const opacity =
                            0.35 +
                            (segIdx / Math.max(1, segments.length - 1)) * 0.25;
                          return (
                            <path
                              key={`trail-path-recharts-${segIdx}`}
                              d={d}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity={opacity}
                              className="trail-path"
                              markerEnd={
                                isLast ? "url(#trailArrowRecharts)" : undefined
                              }
                            />
                          );
                        });
                    })()}
                    {/* Trail points (historical bubbles) */}
                    {selectedTrail.slice(0, -1).map((point, idx) => {
                      const chartWidth =
                        chartContainerRef.current?.clientWidth || 1200;
                      const chartHeight =
                        chartContainerRef.current?.clientHeight || 800;
                      const margin = 20;
                      const plotWidth = chartWidth - 2 * margin;
                      const plotHeight = chartHeight - 2 * margin;

                      const cx =
                        (((Number(point.ltf_score) || 0) + 50) / 100) *
                          plotWidth +
                        margin;
                      const cy =
                        ((50 - (Number(point.htf_score) || 0)) / 100) *
                          plotHeight +
                        margin;
                      const visual = bubbleVisualForTrailPoint(
                        point,
                        selectedTicker,
                      );
                      const size = visual.radius;
                      const opacity = 0.3 + (idx / selectedTrail.length) * 0.4;
                      const color = visual.color;

                      return (
                        <circle
                          key={`trail-point-${idx}`}
                          cx={cx}
                          cy={cy}
                          r={size}
                          fill={color}
                          fillOpacity={opacity}
                          stroke={color}
                          strokeWidth="1"
                          strokeOpacity={opacity * 0.5}
                        />
                      );
                    })}
                    {/* Highlight a specific historical point (from Bubble Journey hover/click) */}
                    {highlightTrailPoint &&
                      Number.isFinite(Number(highlightTrailPoint?.ltf_score)) &&
                      Number.isFinite(Number(highlightTrailPoint?.htf_score)) &&
                      (() => {
                        const chartWidth =
                          chartContainerRef.current?.clientWidth || 1200;
                        const chartHeight =
                          chartContainerRef.current?.clientHeight || 800;
                        const margin = 20;
                        const plotWidth = chartWidth - 2 * margin;
                        const plotHeight = chartHeight - 2 * margin;

                        const hx =
                          (((Number(highlightTrailPoint.ltf_score) || 0) + 50) /
                            100) *
                            plotWidth +
                          margin;
                        const hy =
                          ((50 - (Number(highlightTrailPoint.htf_score) || 0)) /
                            100) *
                            plotHeight +
                          margin;

                        const visual = bubbleVisualForTrailPoint(
                          highlightTrailPoint,
                          selectedTicker,
                        );
                        const r = Math.max(3, Number(visual?.radius) || 6);

                        return (
                          <g
                            key={`trail-highlight-recharts-${String(
                              highlightTrailPoint?.ts ?? "",
                            )}`}
                            pointerEvents="none"
                          >
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 3}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity="0.9"
                            >
                              <animate
                                attributeName="r"
                                values={`${r + 2};${r + 10};${r + 2}`}
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                              <animate
                                attributeName="opacity"
                                values="0.95;0.25;0.95"
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                            </circle>
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 1}
                              fill="none"
                              stroke={visual?.color || "#00ffff"}
                              strokeWidth="1.5"
                              opacity="0.8"
                            />
                          </g>
                        );
                      })()}
                  </g>
                </svg>
              )}

            {/* Crosshair value labels for Recharts */}
            {rechartsCrosshair && (
              <>
                {rechartsCrosshair.ltfValue !== null && (
                  <div
                    className="absolute bg-[#0f1117] border border-[#00ffff] rounded px-2 py-1 text-[#00ffff] text-xs font-semibold pointer-events-none z-20"
                    style={{
                      left: `${rechartsCrosshair.x + 20}px`,
                      bottom: "20px",
                      transform: "translateX(-50%)",
                    }}
                  >
                    LTF: {rechartsCrosshair.ltfValue.toFixed(1)}
                  </div>
                )}
                {rechartsCrosshair.htfValue !== null && (
                  <div
                    className="absolute bg-[#0f1117] border border-[#00ffff] rounded px-2 py-1 text-[#00ffff] text-xs font-semibold pointer-events-none z-20"
                    style={{
                      left: "20px",
                      top: `${rechartsCrosshair.y + 20}px`,
                      transform: "translateY(-50%)",
                    }}
                  >
                    HTF: {rechartsCrosshair.htfValue.toFixed(1)}
                  </div>
                )}
              </>
            )}
          </div>
        );
      }

      // Format date/time from timestamp
      function formatTriggerDateTime(ts) {
        if (!ts || typeof ts !== "number") return "—";
        const date = new Date(ts);
        return {
          date: date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          }),
          time: date.toLocaleTimeString("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          }),
        };
      }

      // Get "Why" reason from ticker data
      function getWhyReason(ticker) {
        const reasons = ticker.reasons || [];
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        if (flags.sq30_release) return "Squeeze Release";
        if (flags.phase_zone_change) return "Phase Zone Change";
        if (state.includes("BULL") && state.includes("BULL"))
          return "Both Timeframes Bullish";
        if (state.includes("BEAR") && state.includes("BEAR"))
          return "Both Timeframes Bearish";
        if (reasons.length > 0) return reasons[0];
        return "Setup Active";
      }

      const ENTRY_DECISION_LABELS = {
        futures_disabled: "Futures excluded",
        missing_levels: "Missing price/SL/TP",
        not_in_corridor: "Not in entry corridor",
        corridor_misaligned: "Corridor misaligned",
        no_trigger: "No trigger/squeeze",
        rr_below_min: "RR below minimum",
        completion_high: "Completion too high",
        phase_high: "Phase too high",
        rank_low: "Rank too low",
        stale_data: "Data delayed",
      };

      function summarizeEntryDecision(ticker) {
        const decision = ticker?.entry_decision;
        if (!decision || typeof decision !== "object") return null;
        const blockers = Array.isArray(decision.blockers)
          ? decision.blockers
          : [];
        const warnings = Array.isArray(decision.warnings)
          ? decision.warnings
          : [];
        const label = (code) =>
          ENTRY_DECISION_LABELS[code] || String(code || "").replace(/_/g, " ");
        if (decision.ok) {
          return {
            status: "Eligible",
            detail: "All entry checks passed",
            tone: "text-teal-400",
            bg: "bg-teal-500/20",
            blockers: [],
            warnings: warnings.map(label),
          };
        }
        if (blockers.length === 0) {
          return {
            status: "Waiting",
            detail: "Setup not confirmed yet",
            tone: "text-[#6b7280]",
            bg: "bg-white/[0.04]",
            blockers: [],
            warnings: warnings.map(label),
          };
        }
        const shown = blockers.slice(0, 3).map(label);
        const extra =
          blockers.length > 3 ? ` +${blockers.length - 3} more` : "";
        return {
          status: "Blocked",
          detail: `${shown.join(", ")}${extra}`,
          tone: "text-yellow-400",
          bg: "bg-yellow-500/20",
          blockers: blockers.map(label),
          warnings: warnings.map(label),
        };
      }

      // Get direction from state — HTF (higher timeframe) is the primary direction.
      function getDirection(ticker) {
        const state = String(ticker.state || "");
        // Prioritize HTF prefix to avoid matching LTF_BULL in HTF_BEAR_LTF_BULL
        if (state.startsWith("HTF_BULL"))
          return {
            text: "LONG",
            color: "text-teal-400",
            bg: "bg-teal-500/20",
          };
        if (state.startsWith("HTF_BEAR"))
          return { text: "SHORT", color: "text-rose-400", bg: "bg-rose-500/20" };
        // Fallback for non-standard states
        if (state.includes("BULL"))
          return {
            text: "LONG",
            color: "text-teal-400",
            bg: "bg-teal-500/20",
          };
        if (state.includes("BEAR"))
          return { text: "SHORT", color: "text-rose-400", bg: "bg-rose-500/20" };
        return { text: "—", color: "text-[#6b7280]", bg: "bg-white/[0.04]" };
      }

      function SetupCard({ ticker, isSelected, onClick }) {
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const momentumElite = !!flags.momentum_elite;
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const dir = getDirection(ticker);
        const why = getWhyReason(ticker);
        const triggerDT = formatTriggerDateTime(ticker.trigger_ts);
        const tpLevels = ticker.tp_levels || [];
        const comp = completionForSize(ticker);
        const decision = summarizeEntryDecision(ticker);
        const skin = getCardSkin(ticker);

        return (
          <div
            className={`p-1.5 rounded-lg border cursor-pointer transition-all ${
              isSelected
                ? "border-blue-500 bg-blue-500/10 shadow-lg"
                : momentumElite
                  ? "border-purple-500 bg-purple-500/15 momentum-elite-glow border-2"
                  : prime
                    ? "border-teal-500 bg-teal-500/10 prime-glow"
                    : "border-white/[0.06] bg-white/[0.03] hover:brightness-[1.06] hover:border-[#3a4aa0]"
            }`}
            onClick={onClick}
            style={{
              backgroundColor: "#1a1f28",
              backgroundImage: skin?.bgImage || undefined,
            }}
          >
            {/* Header */}
            <div className="flex items-center justify-between mb-1">
              <div className="flex items-center gap-1.5">
                <span className="font-bold text-sm">{ticker.ticker}</span>
                {momentumElite && (
                  <span
                    className="text-purple-400 text-xs font-bold"
                    title="Momentum Elite"
                  >
                    🔥
                  </span>
                )}
                {prime && <span className="text-teal-500 text-xs">💎</span>}
                {flags.sq30_release && (
                  <span className="text-cyan-400 text-xs">⚡</span>
                )}
                {flags.sq30_on && (
                  <span className="text-yellow-400 text-xs">🧨</span>
                )}
              </div>
              <div className="flex items-center gap-1.5">
                {ticker.price && (
                  <div className="text-right">
                    <span className="text-xs font-semibold text-white">
                      ${Number(ticker.price).toFixed(2)}
                    </span>
                    {(() => {
                      const { dayChg, dayPct, stale, marketOpen } =
                        getDailyChange(ticker);
                      if (!Number.isFinite(dayChg) && !Number.isFinite(dayPct))
                        return null;
                      const val = Number(dayChg || dayPct || 0);
                      const sign = val >= 0 ? "+" : "-";
                      // Scale color brightness by magnitude: <0.5% muted, 1-3% normal, >3% vivid
                      const absP = Math.abs(Number(dayPct || 0));
                      const bright = Math.min(1, 0.5 + absP / 4);
                      const chgColor = val >= 0
                        ? `rgba(74,222,128,${bright.toFixed(2)})`
                        : `rgba(248,113,113,${bright.toFixed(2)})`;
                      return (
                        <div className="text-[10px]" style={{ color: chgColor }}>
                          {Number.isFinite(dayPct)
                            ? `${sign}${Math.abs(dayPct).toFixed(2)}%`
                            : "—"}{" "}
                          {Number.isFinite(dayChg)
                            ? `(${sign}${fmtUsdAbs(dayChg)})`
                            : ""}
                          {!marketOpen && (
                            <span className="ml-2 text-[10px] text-[#6b7280]">
                              AH
                              {stale?.ageLabel
                                ? ` • as of ${stale.ageLabel}`
                                : ""}
                            </span>
                          )}
                        </div>
                      );
                    })()}
                    {(() => {
                      // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                      const ingestTime =
                        ticker.ingest_ts || ticker.ingest_time || ticker.ts;
                      if (ingestTime) {
                        try {
                          const timeValue =
                            typeof ingestTime === "string"
                              ? new Date(ingestTime)
                              : new Date(Number(ingestTime));
                          if (!isNaN(timeValue.getTime())) {
                            const ageMs = Date.now() - timeValue.getTime();
                            const ageMinutes = Math.floor(ageMs / 60000);
                            const ageHours = Math.floor(ageMinutes / 60);

                            // Warn if data is stale (older than 30 minutes)
                            const isStale = ageMinutes > 30;

                            const displayTime = timeValue.toLocaleTimeString(
                              "en-US",
                              {
                                hour: "numeric",
                                minute: "2-digit",
                                hour12: true,
                              },
                            );
                            const displayDate = timeValue.toLocaleDateString(
                              "en-US",
                              {
                                month: "short",
                                day: "numeric",
                              },
                            );
                            return (
                              <div
                                className={`text-[9px] mt-0.5 ${
                                  isStale ? "text-yellow-400" : "text-[#6b7280]"
                                }`}
                              >
                                {displayDate} {displayTime}
                                {isStale && (
                                  <span
                                    className="ml-0.5"
                                    title={`Data is ${
                                      ageHours > 0 ? `${ageHours}h ` : ""
                                    }${ageMinutes % 60}m old`}
                                  >
                                    ⚠️
                                  </span>
                                )}
                              </div>
                            );
                          }
                        } catch (e) {}
                      }
                      return null;
                    })()}
                  </div>
                )}
                <div
                  className={`px-1.5 py-0.5 rounded font-bold text-[10px] ${dir.bg} ${dir.color}`}
                >
                  {dir.text}
                </div>
              </div>
            </div>

            {/* Why and Action - Compact */}
            <div className="mb-1">
              <div className="text-[8px] text-[#6b7280] mb-0.5">
                Why:{" "}
                <span className="text-white font-semibold text-[9px]">
                  {why}
                </span>
              </div>
              {(() => {
                const actionInfo = getActionDescription(ticker);
                return (
                  <div
                    className={`text-[8px] ${actionInfo.color} font-semibold`}
                  >
                    {actionInfo.action}
                  </div>
                );
              })()}
            </div>

            {/* Price, SL, TP - Compact inline */}
            <div className="grid grid-cols-3 gap-1 mb-1 text-[8px]">
              {ticker.price && (
                <div>
                  <div className="text-[8px] text-[#6b7280]">Price</div>
                  <div className="font-semibold text-white">
                    ${Number(ticker.price).toFixed(2)}
                  </div>
                </div>
              )}
              <div>
                <div className="text-[8px] text-[#6b7280]">SL</div>
                <div className="font-semibold text-rose-400">
                  {ticker.sl ? `$${Number(ticker.sl).toFixed(2)}` : "—"}
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#6b7280]">TP</div>
                <div className="font-semibold text-teal-400">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "—"}
                </div>
              </div>
            </div>

            {/* Trigger Info - Compact */}
            {ticker.trigger_price && (
              <div className="mb-1 text-[8px]">
                <span className="text-[#6b7280]">Trigger: </span>
                <span className="text-white font-semibold">
                  ${Number(ticker.trigger_price).toFixed(2)}
                </span>
                {ticker.trigger_ts && (
                  <>
                    <span className="text-[#6b7280] ml-1.5">@ </span>
                    <span className="text-white text-[7px]">
                      {triggerDT.date} {triggerDT.time}
                    </span>
                  </>
                )}
              </div>
            )}

            {/* Phase and Completion - Compact */}
            <div className="grid grid-cols-2 gap-1 mb-1">
              <div>
                <div className="text-[8px] text-[#6b7280] mb-0.5">Phase</div>
                <div className="h-1.5 bg-white/[0.04] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full transition-all"
                    style={{
                      width: `${phase * 100}%`,
                      backgroundColor: phaseColor,
                    }}
                  />
                </div>
                <div
                  className="text-[9px] mt-0.5"
                  style={{ color: phaseColor }}
                >
                  {Math.round(phase * 100)}%
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#6b7280] mb-0.5">Complete</div>
                <div className="h-1.5 bg-white/[0.04] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full bg-blue-500 transition-all"
                    style={{ width: `${comp * 100}%` }}
                  />
                </div>
                <div className="text-[9px] mt-0.5 text-blue-400">
                  {Math.round(comp * 100)}%
                </div>
              </div>
            </div>

            {/* Sparkline — daily price trend */}
            {ticker._sparkline && ticker._sparkline.length >= 3 && (
              <div className="mb-1 w-full">
                <Sparkline data={(() => {
                  const lp = Number(ticker._live_price || ticker.price);
                  const sp = ticker._sparkline;
                  if (lp > 0 && sp.length > 0 && Math.abs(lp - sp[sp.length - 1]) / sp[sp.length - 1] > 0.005) return [...sp, lp];
                  return sp;
                })()} width={200} height={36} />
              </div>
            )}

            {/* TP Levels - Compact */}
            {tpLevels.length > 1 && (
              <div className="mb-1">
                <div className="flex flex-wrap gap-0.5">
                  {tpLevels.slice(0, 2).map((tp, idx) => (
                    <span
                      key={idx}
                      className="px-0.5 py-0 rounded bg-teal-500/20 text-teal-400 text-[7px] font-mono"
                    >
                      TP{idx + 1}: ${Number(tp).toFixed(2)}
                    </span>
                  ))}
                  {tpLevels.length > 2 && (
                    <span className="px-0.5 py-0 rounded bg-white/[0.04] text-[#6b7280] text-[7px]">
                      +{tpLevels.length - 2}
                    </span>
                  )}
                </div>
              </div>
            )}

            {/* Additional Info - Compact */}
            <div className="flex items-center justify-between text-[8px] pt-0.5 border-t border-white/[0.06]/50">
              <div className="flex gap-1">
                <span className="px-1 py-0.5 rounded bg-white/[0.04]">
                  R{ticker.rank || "—"}
                </span>
                {ticker.rr && (
                  <span className="px-1 py-0.5 rounded bg-white/[0.04]">
                    RR{Number(ticker.rr).toFixed(1)}
                  </span>
                )}
              </div>
              {ent.corridor && (
                <span
                  className={`px-1 py-0.5 rounded text-[8px] font-semibold ${dir.bg} ${dir.color}`}
                >
                  {ent.side}
                </span>
              )}
            </div>
            {decision && (
              <div className="mt-1 text-[8px] text-[#6b7280]">
                <span
                  className={`px-1 py-0.5 rounded ${decision.bg} ${decision.tone}`}
                  title={
                    decision.blockers && decision.blockers.length > 0
                      ? `Blocked: ${decision.blockers.join(", ")}`
                      : decision.warnings && decision.warnings.length > 0
                        ? `Warnings: ${decision.warnings.join(", ")}`
                        : ""
                  }
                >
                  {decision.status}
                </span>
                <span className="ml-1">{decision.detail}</span>
                {decision.warnings && decision.warnings.length > 0 && (
                  <span className="ml-1 text-yellow-300">
                    • {decision.warnings[0]}
                  </span>
                )}
              </div>
            )}
          </div>
        );
      }

      // Generate plain English action description
      // trade (optional) — the most recent trade object for this ticker
      function getActionDescription(ticker, trade) {
        const stage = String(ticker?.kanban_stage || "").trim().toLowerCase();
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const momentumPct = ticker.momentum_pct || {};

        const isAligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;

        // ─── Open-trade-aware guidance ───
        // If there is an open trade, guidance must be about managing that trade.
        const tradeStatus = trade ? String(trade.status || "").toUpperCase() : "";
        const tradeIsClosed = tradeStatus === "WIN" || tradeStatus === "LOSS" || !!(trade?.exit_ts ?? trade?.exitTs);
        const tradeIsOpen = trade && !tradeIsClosed && (tradeStatus === "OPEN" || tradeStatus === "TP_HIT_TRIM" || !tradeStatus);

        if (tradeIsOpen) {
          const ep = Number(trade?.entryPrice ?? trade?.entry_price) || 0;
          const cp = Number(ticker?.price ?? ticker?.close) || 0;
          const tradeDir = String(trade?.direction || "").toUpperCase();
          const isLong = tradeDir === "LONG";
          const trimmedPct = Number(trade?.trimmed_pct ?? trade?.trimmedPct ?? 0);
          const sl = Number(ticker?.sl ?? ticker?.sl_price ?? trade?.sl ?? 0);
          const tp = numFromAny(ticker?.tp ?? ticker?.tp_trim ?? trade?.tp);
          const dirSign = isLong ? 1 : -1;
          const unrealizedPct = ep > 0 && cp > 0 ? ((cp - ep) / ep) * 100 * dirSign : 0;
          const isProfit = unrealizedPct > 0;
          const slBreached = sl > 0 && cp > 0 && ((isLong && cp <= sl) || (!isLong && cp >= sl));
          const tpReached = tp > 0 && cp > 0 && ((isLong && cp >= tp) || (!isLong && cp <= tp));
          const nearSl = sl > 0 && cp > 0 && !slBreached && (Math.abs(cp - sl) / cp) < 0.015;
          const nearTp = tp > 0 && cp > 0 && !tpReached && (Math.abs(cp - tp) / cp) < 0.015;
          const meta = ticker?.kanban_meta || {};
          const metaReason = meta?.reason || "";
          const priceSummary = `${isLong ? "Long" : "Short"} from $${ep.toFixed(2)}, current $${cp.toFixed(2)} (${unrealizedPct >= 0 ? "+" : ""}${unrealizedPct.toFixed(1)}%).`;

          // Already partially trimmed — always show runner management
          if (tradeStatus === "TP_HIT_TRIM" || trimmedPct > 0) {
            return {
              action: "✂️ Position Trimmed — Manage Runner",
              description: `${(trimmedPct * 100).toFixed(0)}% of position trimmed. ${priceSummary} Trail your TSL to protect remaining gains. ${!isAligned ? "Timeframes no longer aligned — consider closing the runner." : "Trend alignment still intact — let it ride with a trailing stop."}`,
              color: "text-yellow-300",
              bg: "bg-yellow-500/15",
            };
          }

          // ─── Kanban-stage-first guidance for open trades ───

          // EXIT stage — most urgent, close immediately
          if (stage === "exit") {
            const exitReason = metaReason || (slBreached ? "TSL breached" : "Exit indicator triggered");
            return {
              action: "🚨 EXIT — Close Position",
              description: `System says EXIT. Reason: ${exitReason}. ${priceSummary} Close the position now to ${isProfit ? "lock in remaining gains" : "limit losses"}. Do not average down or widen your stop.`,
              color: "text-rose-400",
              bg: "bg-rose-500/20",
            };
          }

          // DEFEND stage — tighten stops, warning indicators
          if (stage === "defend" || (stage === "hold" && meta?.bucket === "defend")) {
            const defendReason = metaReason || "Warning indicators detected";
            return {
              action: "🛡 DEFEND — Tighten Stop",
              description: `System says DEFEND. Reason: ${defendReason}. ${priceSummary} The system is tightening TSL to ${isProfit ? "protect gains" : "limit further downside"}. Do NOT trim yet — just defending. Monitor for recovery (back to HOLD) or further deterioration (to EXIT).`,
              color: "text-amber-400",
              bg: "bg-amber-500/15",
            };
          }

          // TRIM stage — take partial profits on extremes
          if (stage === "trim") {
            const trimReason = metaReason || (nearTp ? "Near TP target" : `${(comp * 100).toFixed(0)}% complete`);
            return {
              action: "✂️ TRIM — Take Partial Profits",
              description: `System says TRIM. Reason: ${trimReason}. ${priceSummary} Consider trimming 50–75% of the position to lock in gains. ${isAligned ? "Trend still aligned — trail the stop on the remaining runner." : "Alignment weakening — consider a larger trim."}`,
              color: "text-yellow-400",
              bg: "bg-yellow-500/20",
            };
          }

          // JUST ENTERED stage — newly opened, monitor
          if (stage === "just_entered") {
            return {
              action: "🆕 JUST ENTERED — Monitor",
              description: `Position recently opened. ${priceSummary} Watch for confirmation and initial move in your favor. The system will promote to HOLD once the position stabilizes, or to DEFEND/EXIT if adverse indicators appear.`,
              color: "text-sky-300",
              bg: "bg-sky-500/15",
            };
          }

          // HOLD stage — position is healthy, keep it
          if (stage === "hold") {
            const holdExtra = isPullback
              ? `HTF still supports the ${isLong ? "bullish" : "bearish"} case but LTF pulling back — hold above TSL.`
              : isAligned
                ? "All timeframes aligned — conditions favor holding."
                : "Monitor alignment.";
            return {
              action: isProfit ? "🔒 HOLD — Trend Intact" : "🔄 HOLD — Position Building",
              description: `System says HOLD. Position is healthy and working as expected. ${priceSummary} ${holdExtra} TSL at $${sl > 0 ? sl.toFixed(2) : "N/A"}, TP at $${tp > 0 ? tp.toFixed(2) : "N/A"}. ${comp > 0.5 ? `Completion at ${(comp * 100).toFixed(0)}% — watch for trim indicators.` : "Let the trade develop."}`,
              color: isProfit ? "text-teal-300" : "text-sky-300",
              bg: isProfit ? "bg-teal-500/15" : "bg-sky-500/15",
            };
          }

          // ─── Fallback: price-level checks when kanban stage is unset or unexpected ───

          // SL breached
          if (slBreached) {
            return {
              action: "🚨 TSL Breached — Exit Now",
              description: `Current price ($${cp.toFixed(2)}) has breached your TSL at $${sl.toFixed(2)}. ${priceSummary} Close the position to limit losses. Do not average down.`,
              color: "text-rose-400",
              bg: "bg-rose-500/20",
            };
          }

          // TP reached
          if (tpReached) {
            return {
              action: "🎯 Target Reached — Take Profit",
              description: `Price has reached the first take-profit target ($${tp.toFixed(2)}). ${priceSummary} Consider trimming 50–75% to lock in gains. ${isAligned ? "Trend still aligned — trail the stop on the remaining runner." : "Alignment weakening — consider full exit."}`,
              color: "text-[#00e676]",
              bg: "bg-[#00c853]/20",
            };
          }

          // Near SL
          if (nearSl) {
            return {
              action: "🛡 Near TSL — Defend",
              description: `Price ($${cp.toFixed(2)}) is approaching your TSL at $${sl.toFixed(2)}. ${!isAligned ? "Timeframes have lost alignment, increasing risk." : "Trend still aligned — TSL may hold."} Prepare to exit if TSL is breached. Do not widen your stop.`,
              color: "text-orange-400",
              bg: "bg-orange-500/15",
            };
          }

          // Near TP
          if (nearTp) {
            return {
              action: "📈 Approaching Target — Prepare to Trim",
              description: `Price ($${cp.toFixed(2)}) is nearing your take-profit at $${tp.toFixed(2)}. ${priceSummary} Set a limit order at TP or prepare a manual trim when target is touched.`,
              color: "text-teal-300",
              bg: "bg-teal-500/15",
            };
          }

          // Alignment lost
          if (!isAligned && !isPullback) {
            return {
              action: "⚠️ Alignment Lost — Monitor Closely",
              description: `Timeframes no longer aligned (${state.replace(/_/g, " ")}). ${priceSummary} Consider tightening TSL or trimming to reduce exposure until alignment returns.`,
              color: "text-amber-300",
              bg: "bg-amber-500/15",
            };
          }

          // Pullback while in trade
          if (isPullback) {
            return {
              action: "↩️ Pullback in Progress — Hold",
              description: `Higher timeframe still supports the ${isLong ? "bullish" : "bearish"} case, but lower timeframe is pulling back. ${priceSummary} Hold as long as price stays above TSL ($${sl > 0 ? sl.toFixed(2) : "N/A"}). Pullbacks in aligned trends can offer add-on opportunities.`,
              color: "text-cyan-300",
              bg: "bg-cyan-500/15",
            };
          }

          // Default open-trade guidance
          return {
            action: isProfit ? "🔒 Hold Position — Trend Intact" : "🔄 Position Active — Building",
            description: `${priceSummary} ${isAligned ? "All timeframes aligned — conditions favor holding." : ""} TSL at $${sl > 0 ? sl.toFixed(2) : "N/A"}, TP at $${tp > 0 ? tp.toFixed(2) : "N/A"}. ${comp > 0.5 ? `Completion at ${(comp * 100).toFixed(0)}% — consider partial trim if momentum fades.` : "Let the trade develop."}`,
            color: isProfit ? "text-teal-300" : "text-sky-300",
            bg: isProfit ? "bg-teal-500/15" : "bg-sky-500/15",
          };
        }

        // ─── Closed-trade guidance: recently exited ───
        if (trade && tradeIsClosed) {
          const pnl = Number(trade?.pnl ?? trade?.realizedPnl) || 0;
          const pnlPct = Number(trade?.pnl_pct ?? trade?.pnlPct) || 0;
          const exitPx = Number(trade?.exit_price ?? trade?.exitPrice) || 0;
          const entPx = Number(trade?.entryPrice ?? trade?.entry_price) || 0;
          const exitReason = String(trade?.exit_reason ?? trade?.exitReason ?? "").replace(/_/g, " ");
          const trDir = String(trade?.direction || "").toUpperCase();
          const pnlStr = pnlPct !== 0 ? `${pnlPct >= 0 ? "+" : ""}${pnlPct.toFixed(1)}%` : pnl !== 0 ? `$${pnl >= 0 ? "+" : ""}${pnl.toFixed(2)}` : "";
          const exitPxStr = exitPx > 0 ? ` at $${exitPx.toFixed(2)}` : "";
          const entPxStr = entPx > 0 ? `${trDir === "LONG" ? "Long" : trDir === "SHORT" ? "Short" : "Entry"} from $${entPx.toFixed(2)}, exited${exitPxStr}` : `Exited${exitPxStr}`;
          const reasonStr = exitReason ? ` Reason: ${exitReason.replace(/\b\w/g, c => c.toUpperCase())}.` : "";
          const isWin = tradeStatus === "WIN" || pnl > 0;
          return {
            action: isWin ? "✅ Trade Closed — Win" : "❌ Trade Closed — Loss",
            description: `${entPxStr}${pnlStr ? ` (${pnlStr})` : ""}.${reasonStr} ${isWin ? "Well managed." : "Review the setup and indicators for lessons."} The ticker is now back in the scoring pipeline and will re-enter stages if a new setup forms.`,
            color: isWin ? "text-[#69f0ae]" : "text-rose-300",
            bg: isWin ? "bg-[#00c853]/15" : "bg-rose-500/15",
          };
        }

        // ─── No-trade guidance (pre-trade / discovery mode) ───

        // Lane-aware guidance: when the Kanban lane is explicit, keep the headline aligned
        // with the lane so the UI doesn't contradict itself. Add phase/completion as caution.
        if (stage === "watch" || stage === "setup_watch" || stage === "flip_watch" || stage === "just_flipped" || stage === "enter_now" || stage === "enter") {
          const late =
            (Number.isFinite(phase) && phase > 0.7) ||
            (Number.isFinite(comp) && comp > 0.8);
          const cautionParts = [];
          if (Number.isFinite(phase) && phase > 0.7)
            cautionParts.push(`Phase ${(phase * 100).toFixed(0)}% (late-cycle)`);
          if (Number.isFinite(comp) && comp > 0.8)
            cautionParts.push(
              `Completion ${(comp * 100).toFixed(0)}% (near target)`,
            );
          const caution =
            cautionParts.length > 0 ? `Caution: ${cautionParts.join(" • ")}.` : "";

          if (stage === "watch") {
            return {
              action: "Watching",
              description: `Ticker has started to form a setup or pattern we like but not yet confirmed. Waiting for corridor entry or momentum flip. ${caution}`.trim(),
              color: "text-violet-300",
              bg: "bg-violet-500/15",
            };
          }
          if (stage === "setup_watch") {
            return {
              action: "Setup Watch",
              description: `Ticker is in corridor but still in setup (pullback) state. Waiting for flip to momentum (HTF_BULL_LTF_BULL or HTF_BEAR_LTF_BEAR) before entry. ${caution}`.trim(),
              color: "text-violet-300",
              bg: "bg-violet-500/15",
            };
          }
          if (stage === "flip_watch") {
            return {
              action: late ? "Flip Watch (Late-cycle)" : "Flip Watch",
              description: `Ticker is in the Flip Watch lane: momentum alignment is near and the system is watching for a flip into momentum. Wait for the flip / corridor confirmation before entering. ${caution}`.trim(),
              color: "text-amber-300",
              bg: "bg-amber-500/15",
            };
          }
          if (stage === "just_flipped") {
            return {
              action: late ? "Just Flipped (Late-cycle)" : "Just Flipped",
              description: `Ticker just flipped into momentum (recent corridor entry). Prefer waiting for the first pullback / corridor stabilization, then enter on confirmation. ${caution}`.trim(),
              color: "text-cyan-300",
              bg: "bg-cyan-500/15",
            };
          }
          // enter_now / enter
          return {
            action: late ? "Enter Now (Late-cycle)" : "Enter Now",
            description: `Ticker meets the system's entry criteria and is in the Enter lane. Review current price levels, SL/TP targets below, and consider position sizing based on your risk tolerance before executing. ${isPullback ? "Currently in pullback — this can offer a better entry if price holds above SL. " : ""}${caution}`.trim(),
            color: late ? "text-yellow-300" : "text-teal-300",
            bg: late ? "bg-yellow-500/15" : "bg-teal-500/15",
          };
        }

        // ─── Post-entry Kanban stages (no open trade in the system, but stage is set) ───

        // EXIT stage — system says close, even if no trade tracked here
        if (stage === "exit") {
          const exitMeta = ticker?.kanban_meta || {};
          const exitReason = exitMeta?.reason || "Exit indicator triggered";
          return {
            action: "🚨 EXIT — Close Position",
            description: `System says EXIT. Reason: ${exitReason}. If you have an open position, close it now. The setup has deteriorated beyond recovery thresholds.`,
            color: "text-rose-400",
            bg: "bg-rose-500/20",
          };
        }

        // DEFEND stage: Warning indicators, tighten TSL
        if (stage === "defend" || (stage === "hold" && ticker?.kanban_meta?.bucket === "defend")) {
          const defendReason = ticker?.kanban_meta?.reason || "Warning indicators detected";
          return {
            action: "🛡 DEFEND — Tighten Stop",
            description: `System says DEFEND. Reason: ${defendReason}. The system is tightening TSL to protect gains or limit losses. Do NOT trim yet — just defending. Monitor for recovery (back to HOLD) or further deterioration (to EXIT).`,
            color: "text-amber-400",
            bg: "bg-amber-500/15",
          };
        }

        // TRIM stage: take partial profits
        if (stage === "trim") {
          const trimMeta = ticker?.kanban_meta || {};
          const trimReason = trimMeta?.reason || `${(comp * 100).toFixed(0)}% complete`;
          return {
            action: "✂️ TRIM — Take Partial Profits",
            description: `System says TRIM. Reason: ${trimReason}. ${momentumElite ? "Despite Momentum Elite status, " : ""}Consider trimming 50–75% of position to lock in gains while allowing runners to continue. Monitor for signs of reversal or continuation beyond TP levels.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // HOLD stage: position is healthy
        if (stage === "hold") {
          return {
            action: "🔒 HOLD — Position Healthy",
            description: `System says HOLD. Position is working as expected. ${isAligned ? "All timeframes aligned — conditions favor holding." : isPullback ? "HTF trend intact, LTF pulling back — normal behavior." : "Monitor alignment."} ${comp > 0.5 ? `Completion at ${(comp * 100).toFixed(0)}% — watch for trim indicators.` : "Let the trade develop."}`,
            color: "text-teal-300",
            bg: "bg-teal-500/15",
          };
        }

        // JUST ENTERED stage: recently entered position
        if (stage === "just_entered") {
          return {
            action: "🆕 JUST ENTERED — Monitor",
            description: "Position recently opened. Watch for confirmation and initial move in your favor. The system will promote to HOLD once the position stabilizes, or to DEFEND/EXIT if adverse indicators appear.",
            color: "text-sky-300",
            bg: "bg-sky-500/15",
          };
        }

        // ─── Generic fallback conditions (stage not set or unrecognized) ───

        // High completion = near target, consider exit/trim
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(
              0,
            )}% completion, indicating the move is near its target. ${
              momentumElite ? "Despite Momentum Elite status, " : ""
            }Consider taking profits or trimming 50-75% of position to lock in gains while allowing runners to continue. Monitor for signs of reversal or continuation beyond TP levels.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // High phase = late in cycle, be cautious
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(
              0,
            )}% indicates late-cycle conditions. ${
              momentumElite
                ? "While Momentum Elite suggests continued strength, "
                : ""
            }Market is approaching exhaustion zone. Wait for pullback to better entry or trim existing positions by 30-50% to reduce risk. Look for phase reset or continuation patterns before adding size.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20",
          };
        }

        // Momentum Elite + Prime setup = strongest pattern
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          const momentumStr =
            momentumPct.month != null
              ? ` with ${Number(momentumPct.month).toFixed(
                  0,
                )}% monthly momentum`
              : "";
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock${momentumStr} showing Prime setup with exceptional alignment. Both HTF and LTF are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2,
            )}:1). This represents a high-probability setup with strong fundamentals backing the technical pattern. Review TP levels as potential profit targets and size according to your risk tolerance.`,
            color: "text-teal-400",
            bg: "bg-teal-500/20",
          };
        }

        // Momentum Elite + Squeeze release = strong momentum pattern
        if (momentumElite && sqRelease && inCorridor && isAligned) {
          const momentumStr =
            momentumPct.week != null
              ? ` (${Number(momentumPct.week).toFixed(0)}% weekly)`
              : "";
          return {
            action: "Initiate Position - Momentum Breakout",
            description: `Momentum Elite stock${momentumStr} experiencing squeeze release with timeframe alignment. This indicates pent-up energy being released in the direction of the trend. The combination of Momentum Elite fundamentals and technical squeeze release creates a high-probability momentum continuation setup. Enter on pullback to corridor or on break of squeeze high/low, targeting TP levels.`,
            color: "text-teal-400",
            bg: "bg-teal-500/20",
          };
        }

        // Prime setup with good conditions = initiate
        if (isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - Prime Setup",
            description: `Prime setup detected with strong technical alignment. Both timeframes are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2,
            )}:1). ${
              momentumElite
                ? "Momentum Elite status adds fundamental strength to this technical setup. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) with low completion (${(
              comp * 100
            ).toFixed(
              0,
            )}%) suggests room to run. Consider entering position, using SL for risk management and TP levels as profit targets.`,
            color: "text-teal-400",
            bg: "bg-teal-500/20",
          };
        }

        // Momentum Elite + In corridor = quality momentum play
        if (
          momentumElite &&
          inCorridor &&
          isAligned &&
          comp < 0.5 &&
          phase < 0.6
        ) {
          return {
            action: "Consider Entry - Momentum Elite Setup",
            description: `Momentum Elite stock in favorable technical setup. Price is in entry corridor with both timeframes aligned, early phase (${(
              phase * 100
            ).toFixed(0)}%), and low completion (${(comp * 100).toFixed(
              0,
            )}%) indicating room for continuation. ${
              sqRelease
                ? "Squeeze release adds momentum confirmation. "
                : sqOn
                  ? "Squeeze building suggests potential breakout. "
                  : ""
            }The combination of strong fundamentals (Momentum Elite) and favorable technicals creates a quality setup. Enter on confirmation or pullback, targeting TP levels.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Squeeze release in corridor = strong pattern
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. This indicates pent-up energy being released in the direction of the trend. ${
              momentumElite
                ? "Momentum Elite status adds fundamental backing to this technical pattern. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(
              comp * 100
            ).toFixed(
              0,
            )}%) suggest continuation potential. Enter on pullback or break, using SL for protection and TP levels as targets.`,
            color: "text-teal-400",
            bg: "bg-teal-500/20",
          };
        }

        // In corridor and aligned = good setup
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase (${(
              phase * 100
            ).toFixed(0)}%) and low completion (${(comp * 100).toFixed(
              0,
            )}%) suggest room to run. ${
              momentumElite
                ? "Momentum Elite status adds quality to this setup. "
                : ""
            }${
              sqOn ? "Squeeze building suggests potential momentum. " : ""
            }Rank is ${
              rank >= 70 ? "strong" : "moderate"
            } (${rank}) with RR of ${rr.toFixed(
              2,
            )}:1. Monitor for entry confirmation or wait for squeeze release pattern before initiating position.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Pullback setup = wait for confirmation
        if (isPullback && !inCorridor) {
          return {
            action: "Wait for Entry - Pullback Setup",
            description: `Pullback detected (${state}) but price not yet in entry corridor. ${
              momentumElite
                ? "Momentum Elite status suggests this pullback may be shallow and could present a quality entry. "
                : ""
            }Wait for price to enter corridor (Q1→Q2 for LONG, Q4→Q3 for SHORT) before considering entry. ${
              sqOn
                ? "Squeeze building suggests potential momentum when released. "
                : ""
            }Monitor for corridor entry and confirmation patterns before initiating position.`,
            color: "text-cyan-400",
            bg: "bg-cyan-500/20",
          };
        }

        // Squeeze on but not released = building pressure
        if (sqOn && !sqRelease) {
          return {
            action: "Monitor Closely - Squeeze Building",
            description: `Squeeze building but not yet released, indicating pressure is accumulating. ${
              momentumElite
                ? "Momentum Elite status suggests when released, the move could be significant. "
                : ""
            }${
              inCorridor
                ? "Price is in entry corridor, making this a high-probability setup when squeeze releases. "
                : "Wait for price to enter corridor and squeeze to release before entering. "
            }Monitor closely for squeeze release pattern, which typically provides strong directional momentum.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // Default: wait (avoid "Setup Not Optimal" when Prime — use entry-timing wording instead)
        if (isPrime) {
          return {
            action: "Wait for Entry - Prime Setup",
            description: `This is a Prime (high-quality) setup, but entry conditions are not yet aligned. ${
              momentumElite ? "Momentum Elite status is positive. " : ""
            }${
              !inCorridor ? "Price needs to enter entry corridor. " : ""
            }${!isAligned ? "Timeframes need better alignment. " : ""}${
              comp > 0.5
                ? `Completion is high (${(comp * 100).toFixed(0)}%), reducing upside potential. `
                : ""
            }Wait for corridor alignment, confirmation patterns, or better timing before entering.`,
            color: "text-[#6b7280]",
            bg: "bg-white/[0.04]",
          };
        }
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. ${
            momentumElite ? "Momentum Elite status is positive, but " : ""
          }Technical conditions need improvement. ${
            !inCorridor ? "Price needs to enter entry corridor. " : ""
          }${!isAligned ? "Timeframes need better alignment. " : ""}${
            comp > 0.5
              ? `Completion is high (${(comp * 100).toFixed(
                  0,
                )}%), reducing upside potential. `
              : ""
          }Wait for better conditions, confirmation patterns, or entry corridor alignment before considering position.`,
          color: "text-[#6b7280]",
          bg: "bg-white/[0.04]",
        };
      }

      // ─────────────────────────────────────────────────────────────
      // Activity Feed Component
      // ─────────────────────────────────────────────────────────────
      function ActivityFeed({ onTickerClick, tickerData }) {
        const [events, setEvents] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [searchQuery, setSearchQuery] = useState("");
        const [activeFilter, setActiveFilter] = React.useState(null);
        const feedRef = React.useRef(null);

        // Helper to get latest ticker data and merge with event
        // IMPORTANT: Always use latest RR from tickerData to match Bubble Chart (which recomputes RR)
        // This ensures Activity Feed RR matches Bubble Chart RR (both use recomputed values from /timed/all)
        const getEventWithTickerData = useCallback(
          (event) => {
            const latestData = tickerData?.[event.ticker] || {};
            // Merge event data with latest ticker data, preferring latest data for RR (matches Bubble Chart computation)
            // Use event data for historical snapshots (price, sl, tp at event time) but latest RR for consistency
            return {
              ...event,
              price: event.price || latestData.price,
              sl: event.sl !== undefined ? event.sl : latestData.sl,
              tp: event.tp !== undefined ? event.tp : latestData.tp,
              tp_levels: event.tp_levels || latestData.tp_levels,
              // Always use latest RR to match Bubble Chart (which uses recomputed RR from /timed/all)
              // This ensures consistency since worker recomputes RR using fused SL levels
              rr: latestData.rr !== undefined ? latestData.rr : event.rr,
              phase_pct:
                event.phase_pct !== undefined
                  ? event.phase_pct
                  : latestData.phase_pct,
              completion:
                event.completion !== undefined
                  ? event.completion
                  : latestData.completion,
              // Include momentum_pct from latest data if available
              momentum_pct: latestData.momentum_pct || event.momentum_pct,
            };
          },
          [tickerData],
        );

        const fetchActivity = React.useCallback(async (isRetry = false) => {
          try {
            setLoading(true);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // Increased timeout to 10s

            // Add timestamp to URL to prevent caching on hard refresh
            const timestamp = Date.now();
            const res = await fetch(
              `/timed/activity?limit=50&_t=${timestamp}`,
              {
                signal: controller.signal,
                cache: "no-store", // Prevent caching issues on hard refresh
                headers: {
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `activity-${timestamp}`, // Additional cache busting header
                },
              },
            );
            clearTimeout(timeoutId);

            if (!res.ok) {
              throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }

            const data = await res.json();

            if (data.ok && Array.isArray(data.events)) {
              setEvents(data.events);
              setError(null); // Clear any previous errors
            } else {
              // Log error for debugging
              console.warn("Activity feed response:", {
                status: res.status,
                ok: res.ok,
                dataOk: data.ok,
                error: data.error,
                eventsCount: data.events?.length || 0,
              });

              // Handle rate limit error
              if (res.status === 429) {
                setError(
                  "Rate limit exceeded. Please wait a moment and refresh.",
                );
              } else if (data.error) {
                setError(data.error);
              } else {
                setError(null);
              }

              // Still set events if it's an empty array (no error, just no data)
              if (Array.isArray(data.events)) {
                setEvents(data.events);
              }
            }
          } catch (err) {
            if (err.name !== "AbortError") {
              console.error("Activity feed fetch error:", err);
              setError("Failed to load activity feed");
              // Retry after a short delay on first load failure (only once)
              if (!isRetry) {
                setTimeout(() => {
                  fetchActivity(true);
                }, 2000);
              }
            }
          } finally {
            setLoading(false);
          }
        }, []);

        // Initial fetch and periodic refresh - ensure it runs on mount
        React.useEffect(() => {
          // Use a small delay to ensure component is fully mounted
          const initialTimeout = setTimeout(() => {
            fetchActivity();
          }, 100);

          const interval = setInterval(fetchActivity, 5 * 60 * 1000); // Refresh every 5 minutes to align with data updates

          return () => {
            clearTimeout(initialTimeout);
            clearInterval(interval);
          };
        }, [fetchActivity]);

        // Auto-scroll to top when new events arrive
        React.useEffect(() => {
          if (feedRef.current && events.length > 0) {
            feedRef.current.scrollTop = 0;
          }
        }, [events.length]);

        const formatTime = (ts) => {
          const date = new Date(ts);
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / 60000);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);

          if (diffMins < 1) return "just now";
          if (diffMins < 60) return `${diffMins}m ago`;
          if (diffHours < 24) return `${diffHours}h ago`;
          if (diffDays < 7) return `${diffDays}d ago`;
          return date.toLocaleDateString();
        };

        const getEventIcon = (type) => {
          switch (type) {
            case "corridor_entry":
              return "🚪";
            case "squeeze_start":
              return "⚡";
            case "squeeze_release":
              return "💥";
            case "state_aligned":
              return "🎯";
            case "momentum_elite":
              return "🔥";
            case "td9_exit":
              return "🔢";
            case "td9_entry":
              return "🔢";
            case "discord_alert":
              return "📢";
            case "trade_entry":
              return "✅";
            case "ingest_missing":
              return "⏱️";
            default:
              return "📊";
          }
        };

        const getEventColor = (type) => {
          switch (type) {
            case "corridor_entry":
              return "text-blue-400";
            case "squeeze_start":
              return "text-yellow-400";
            case "squeeze_release":
              return "text-teal-400";
            case "state_aligned":
              return "text-purple-400";
            case "momentum_elite":
              return "text-pink-400";
            case "td9_exit":
              return "text-orange-400";
            case "td9_entry":
              return "text-cyan-400";
            case "discord_alert":
              return "text-indigo-400";
            case "trade_entry":
              return "text-teal-400";
            case "ingest_missing":
              return "text-rose-400";
            default:
              return "text-gray-400";
          }
        };

        const getEventLabel = (event) => {
          switch (event.type) {
            case "corridor_entry":
              return `${event.ticker} entered ${event.side || "corridor"}`;
            case "squeeze_start":
              return `${event.ticker} squeeze started`;
            case "squeeze_release":
              return `${event.ticker} squeeze released${
                event.side ? ` (${event.side})` : ""
              }`;
            case "state_aligned":
              return `${event.ticker} aligned ${event.side || ""}`;
            case "momentum_elite":
              return `${event.ticker} Momentum Elite`;
            case "td9_exit":
              return `${event.ticker} TD9 Exit ${event.direction || ""}`;
            case "td9_entry":
              return `${event.ticker} TD9 Entry ${event.direction || ""}`;
            case "discord_alert":
              return `📢 Alert Fired: ${event.ticker} ${
                event.direction || event.action || ""
              } ${event.action === "entry" ? "Entry" : ""}`;
            case "trade_entry":
              return `✅ Trade Entered: ${event.ticker} ${
                event.direction || ""
              }`;
            case "ingest_missing":
              return `⏱️ Missing ingest: ${event.ticker} ${
                event.age_min != null ? `(${event.age_min}m)` : ""
              }`;
            default:
              return `${event.ticker} event`;
          }
        };

        // Filter events by search query and active filter
        const filteredEvents = useMemo(() => {
          let filtered = events;

          // Apply type filter
          if (activeFilter) {
            filtered = filtered.filter((event) => event.type === activeFilter);
          }

          // Apply search query
          if (searchQuery.trim()) {
            const query = searchQuery.toLowerCase();
            filtered = filtered.filter((event) => {
              const ticker = (event.ticker || "").toLowerCase();
              const type = (event.type || "").toLowerCase();
              const direction = (event.direction || "").toLowerCase();
              const side = (event.side || "").toLowerCase();
              return (
                ticker.includes(query) ||
                type.includes(query) ||
                direction.includes(query) ||
                side.includes(query)
              );
            });
          }

          return filtered;
        }, [events, searchQuery, activeFilter]);

        return (
          <div className="w-80 bg-white/[0.03] border border-white/[0.06] rounded-xl p-4 flex flex-col">
            <div className="flex items-center justify-between mb-3 pb-2 border-b border-white/[0.06]">
              <h3 className="text-lg font-semibold text-white">
                Activity Feed
              </h3>
              <button
                onClick={fetchActivity}
                className="text-xs text-[#6b7280] hover:text-white transition-colors"
                title="Refresh"
              >
                ↻
              </button>
            </div>

            {/* Search Bar and Filter Tags */}
            <div className="mb-3 space-y-2">
              <input
                type="text"
                placeholder="Search events..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full px-3 py-1.5 text-xs bg-white/[0.02] border border-white/[0.06] rounded text-white placeholder-[#5c6475] focus:outline-none focus:border-[#3a4a7a]"
              />
              {/* Filter Tags */}
              <div className="flex flex-wrap gap-1.5">
                {[
                  { label: "All", type: null },
                  { label: "Trade Entered", type: "trade_entry" },
                  { label: "Alerts", type: "discord_alert" },
                  { label: "Squeeze", type: "squeeze_release" },
                  { label: "Ingest Missing", type: "ingest_missing" },
                ].map((filter) => (
                  <button
                    key={filter.label}
                    onClick={() =>
                      setActiveFilter(
                        activeFilter === filter.type ? null : filter.type,
                      )
                    }
                    className={`px-2 py-0.5 text-[10px] rounded border transition-colors ${
                      activeFilter === filter.type
                        ? "bg-blue-500/20 border-blue-500 text-blue-400"
                        : "bg-white/[0.02] border-white/[0.06] text-[#6b7280] hover:border-[#3a4a7a]"
                    }`}
                  >
                    {filter.label}
                  </button>
                ))}
              </div>
            </div>

            <div
              ref={feedRef}
              className="flex-1 overflow-y-auto space-y-2 pr-2"
              style={{ maxHeight: "760px" }}
            >
              {loading && events.length === 0 ? (
                <div className="text-center text-[#6b7280] py-8">
                  <div className="loading-spinner mx-auto mb-2"></div>
                  Loading events...
                </div>
              ) : error ? (
                <div className="text-center text-yellow-400 py-8 px-2">
                  <div className="text-sm mb-2">{error}</div>
                  <button
                    onClick={fetchActivity}
                    className="text-xs text-[#6b7280] hover:text-white underline"
                  >
                    Retry
                  </button>
                </div>
              ) : filteredEvents.length === 0 ? (
                <div className="text-center text-[#6b7280] py-8">
                  {searchQuery.trim()
                    ? "No events match your search"
                    : "No recent activity"}
                </div>
              ) : (
                filteredEvents.map((event) => {
                  const eventData = getEventWithTickerData(event);
                  // Calculate Max TP from tp_levels array
                  let maxTP = eventData.tp;
                  if (
                    eventData.tp_levels &&
                    Array.isArray(eventData.tp_levels) &&
                    eventData.tp_levels.length > 0
                  ) {
                    const tpPrices = eventData.tp_levels
                      .map((tpItem) => {
                        if (
                          typeof tpItem === "object" &&
                          tpItem !== null &&
                          tpItem.price != null
                        ) {
                          return Number(tpItem.price);
                        }
                        return typeof tpItem === "number"
                          ? tpItem
                          : Number(tpItem);
                      })
                      .filter((p) => Number.isFinite(p));
                    if (tpPrices.length > 0) {
                      maxTP = Math.max(...tpPrices);
                    }
                  }

                  return (
                    <div
                      key={event.id || `${event.ticker}-${event.ts}`}
                      onClick={() =>
                        onTickerClick && onTickerClick(event.ticker)
                      }
                      className="bg-white/[0.02] border border-white/[0.06] rounded p-2 text-xs hover:border-[#3a4a7a] hover:bg-[#1a2440] transition-colors cursor-pointer"
                    >
                      <div className="flex items-start justify-between gap-2 mb-1.5">
                        <div className="flex items-center gap-1.5 flex-1 min-w-0">
                          <span className="text-base">
                            {getEventIcon(event.type)}
                          </span>
                          <div className="flex-1 min-w-0">
                            <span
                              className={`font-semibold ${getEventColor(
                                event.type,
                              )} truncate block`}
                            >
                              {getEventLabel(event)}
                            </span>
                            {eventData.price && (
                              <div className="text-[10px] text-white mt-0.5">
                                ${Number(eventData.price).toFixed(2)}
                                {(() => {
                                  // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                                  const ingestTime =
                                    eventData.ingest_ts ||
                                    eventData.ingest_time ||
                                    eventData.ts ||
                                    event.ts;
                                  if (ingestTime) {
                                    try {
                                      const timeValue =
                                        typeof ingestTime === "string"
                                          ? new Date(ingestTime)
                                          : new Date(Number(ingestTime));
                                      if (!isNaN(timeValue.getTime())) {
                                        const ageMs =
                                          Date.now() - timeValue.getTime();
                                        const ageMinutes = Math.floor(
                                          ageMs / 60000,
                                        );
                                        const ageHours = Math.floor(
                                          ageMinutes / 60,
                                        );

                                        // Warn if data is stale (older than 30 minutes)
                                        const isStale = ageMinutes > 30;

                                        const displayTime =
                                          timeValue.toLocaleTimeString(
                                            "en-US",
                                            {
                                              hour: "numeric",
                                              minute: "2-digit",
                                              hour12: true,
                                            },
                                          );
                                        const displayDate =
                                          timeValue.toLocaleDateString(
                                            "en-US",
                                            {
                                              month: "short",
                                              day: "numeric",
                                            },
                                          );
                                        return (
                                          <span
                                            className={`ml-1.5 ${
                                              isStale
                                                ? "text-yellow-400"
                                                : "text-[#6b7280]"
                                            }`}
                                          >
                                            {displayDate} {displayTime}
                                            {isStale && (
                                              <span
                                                className="ml-0.5"
                                                title={`Data is ${
                                                  ageHours > 0
                                                    ? `${ageHours}h `
                                                    : ""
                                                }${ageMinutes % 60}m old`}
                                              >
                                                ⚠️
                                              </span>
                                            )}
                                          </span>
                                        );
                                      }
                                    } catch (e) {}
                                  }
                                  return null;
                                })()}
                              </div>
                            )}
                          </div>
                        </div>
                        <span className="text-[#4b5563] text-[10px] whitespace-nowrap">
                          {formatTime(event.ts)}
                        </span>
                      </div>

                      {/* Standardized Fields - Always Show */}
                      <div className="space-y-1.5 border-t border-white/[0.06]/50 pt-1.5 mt-1.5">
                        {/* SL Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#4b5563] text-[10px]">
                            SL:
                          </span>
                          <span className="text-rose-400 font-mono text-[10px]">
                            {eventData.sl != null
                              ? `$${Number(eventData.sl).toFixed(2)}`
                              : "—"}
                          </span>
                        </div>

                        {/* Max TP Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#4b5563] text-[10px]">
                            Max TP:
                          </span>
                          <span className="text-teal-400 font-mono text-[10px]">
                            {maxTP != null
                              ? `$${Number(maxTP).toFixed(2)}`
                              : "—"}
                          </span>
                        </div>

                        {/* RR Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#4b5563] text-[10px]">
                            RR:
                          </span>
                          <span className="text-blue-400 font-mono text-[10px]">
                            {eventData.rr != null
                              ? Number(eventData.rr).toFixed(2)
                              : "—"}
                          </span>
                        </div>

                        {/* Phase Complete Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#4b5563] text-[10px]">
                            Phase:
                          </span>
                          <div className="flex items-center gap-1.5">
                            <div className="w-16 h-1 bg-white/[0.04] rounded-full overflow-hidden">
                              <div
                                className="h-full rounded-full transition-all"
                                style={{
                                  width: `${
                                    (Number(eventData.phase_pct) || 0) * 100
                                  }%`,
                                  backgroundColor: (() => {
                                    const phase =
                                      Number(eventData.phase_pct) || 0;
                                    if (phase < 0.3) return "#14b8a6";
                                    if (phase < 0.6) return "#eab308";
                                    return "#e11d48";
                                  })(),
                                }}
                              />
                            </div>
                            <span className="text-white font-mono text-[10px] min-w-[2.5rem]">
                              {eventData.phase_pct != null
                                ? `${Math.round(
                                    Number(eventData.phase_pct) * 100,
                                  )}%`
                                : "—"}
                            </span>
                          </div>
                        </div>
                      </div>

                      {/* Additional Info - Compact */}
                      {(event.rank || event.state || event.trigger_dir) && (
                        <div className="flex items-center gap-2 text-[#4b5563] text-[10px] mt-1.5 pt-1.5 border-t border-white/[0.06]/30">
                          {event.rank && <span>Rank {event.rank}</span>}
                          {event.state && (
                            <span className="truncate" title={event.state}>
                              {event.state.split("_").pop()}
                            </span>
                          )}
                          {event.trigger_dir && (
                            <span>Dir: {event.trigger_dir}</span>
                          )}
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      // Welcome Modal Component - Dashboard Guide (focused: dashboard, save tickers, universe list, confirm)
      function DashboardWelcomeModal({ onClose, tickers = [], savedTickers = new Set(), toggleSavedTicker = null }) {
        const [currentStep, setCurrentStep] = useState(0);
        const universeList = Array.isArray(tickers) ? [...tickers].sort((a, b) => String(a?.ticker || a).localeCompare(String(b?.ticker || b))) : [];

        const allSteps = [
          {
            title: "Welcome to the Active Trader Dashboard",
            content: (
              <div className="space-y-4">
                <p className="text-[#d1d5db] leading-relaxed">
                  This platform takes a systematic approach to picking and managing stocks. The system continuously scores every stock across multiple timeframes, then places them in <strong className="text-white">action lanes</strong> based on where each stock is in its trend cycle.
                </p>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  <div className="bg-white/[0.03] border border-teal-500/20 rounded-lg p-4 ring-1 ring-teal-500/10">
                    <h3 className="text-teal-400 font-semibold mb-1.5 text-sm">Active Trader (this page)</h3>
                    <p className="text-xs text-[#9ca3af] leading-relaxed">
                      Shorter-horizon swing trades. The system moves stocks through lanes: Setup → Enter → Hold → Defend → Trim → Exit. Each lane signals what action the system recommends right now.
                    </p>
                  </div>
                  <div className="bg-white/[0.03] border border-white/[0.06] rounded-lg p-4">
                    <h3 className="text-blue-400 font-semibold mb-1.5 text-sm">Investor</h3>
                    <p className="text-xs text-[#9ca3af] leading-relaxed">
                      Longer-horizon portfolio management. The system accumulates strong setups, holds through strength, and reduces when conditions weaken. Switch to it from the navigation bar.
                    </p>
                  </div>
                </div>
                <div className="bg-white/[0.03] border border-white/[0.06] rounded-lg p-4">
                  <h3 className="text-teal-400 font-semibold mb-1.5 text-sm">Simulation Portfolio</h3>
                  <p className="text-xs text-[#9ca3af] leading-relaxed">
                    The system runs a simulation portfolio that executes trades automatically based on scores and signals. Visit the <strong className="text-white">Trades</strong> page to review every entry, trim, exit, and P&L the system has generated.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Save tickers to follow their progress",
            content: (
              <div className="space-y-4">
                <p className="text-[#d1d5db] leading-relaxed">
                  Any ticker can be saved to a personal list for quick filtering. Use the <strong className="text-white">Saved</strong> button to show only saved tickers. Toggle the star on any card to add or remove it.
                </p>
                <p className="text-sm text-[#6b7280]">
                  Saving a ticker does not affect the system's scoring or lane placement — it simply bookmarks the ticker for faster access.
                </p>
              </div>
            ),
          },
          {
            title: "Browse our ticker universe",
            content: (
              <div className="space-y-4">
                <p className="text-[#d1d5db]">
                  Scroll the list below. Tap the star next to any ticker to add it to your saved list.
                </p>
                <div className="max-h-64 overflow-y-auto border border-white/[0.08] rounded-lg p-2 space-y-0.5 bg-white/[0.02]">
                  {universeList.length === 0 ? (
                    <p className="text-sm text-[#6b7280] py-4 text-center">No tickers loaded yet. Close and refresh the dashboard.</p>
                  ) : (
                    universeList.map((t) => {
                      const sym = t && (t.ticker != null) ? t.ticker : String(t);
                      const name = t && typeof t === "object" ? (t?.context?.name || t.name || t.description || "") : "";
                      const saved = savedTickers && savedTickers.has ? savedTickers.has(sym) : false;
                      return (
                        <div key={sym} className="flex items-center justify-between py-2 px-2 rounded hover:bg-white/[0.06]">
                          <span className="text-sm text-white font-mono shrink-0" style={{ minWidth: "48px" }}>{sym}</span>
                          <span className="text-xs text-[#6b7280] truncate flex-1 mx-2">{name || "—"}</span>
                          {toggleSavedTicker ? (
                            <button
                              type="button"
                              onClick={() => toggleSavedTicker(sym)}
                              className={"shrink-0 text-[14px] transition-colors " + (saved ? "text-amber-400" : "text-[#4b5563] hover:text-amber-300")}
                              title={saved ? "Remove from Saved" : "Add to Saved"}
                            >
                              {saved ? "★" : "☆"}
                            </button>
                          ) : (
                            <span className="text-[#4b5563] text-sm">☆</span>
                          )}
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
            ),
          },
          {
            title: "Ready to Explore",
            content: (
              <div className="space-y-4">
                <p className="text-[#d1d5db] leading-relaxed">
                  The <strong className="text-white">Dashboard</strong> shows real-time lane placements. The <strong className="text-white">Trades</strong> page shows every trade the simulation portfolio has taken. The <strong className="text-white">Investor</strong> page offers a longer-horizon view of the same universe.
                </p>
                <div className="bg-white/[0.03] border border-white/[0.06] rounded-lg p-4">
                  <div className="flex items-start gap-2">
                    <span className="text-blue-400 text-sm mt-0.5">ℹ</span>
                    <p className="text-xs text-[#9ca3af] leading-relaxed">
                      Reopen this guide anytime using the <strong className="text-white">Guide</strong> button. Use <strong className="text-white">Tour</strong> to walk through the interface step by step.
                    </p>
                  </div>
                </div>
              </div>
            ),
          }
        ];

        // Guide: 4 steps (dashboard, save tickers, universe list, confirm).
        const steps = allSteps.slice(0, 4);

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[#0f1117] border-2 border-white/[0.06] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-lg">
              {/* Header */}
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-white/[0.06] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-teal-400"
                              : "bg-white/[0.04]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[#6b7280] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-white/[0.04] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>

              {/* Content */}
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>

              {/* Footer */}
              <div className="border-t border-white/[0.06] p-4 flex items-center justify-between bg-white/[0.03]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-white/[0.06] text-[#6b7280] opacity-50 cursor-not-allowed"
                      : "border-white/[0.06] bg-white/5 hover:bg-white/[0.04] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[#6b7280]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Let's go
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Welcome Modal Component - Trade Tracker Guide (Simulated Trades)
      function TrackerWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const allSteps = [
          {
            title: "Trade Tracker = feedback loop",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#d1d5db]">
                  Use Trade Tracker to learn which <strong>lanes</strong> and
                  <strong> setups</strong> actually work, then compound the
                  process.
                </p>
                <div className="bg-white/[0.03] border border-white/[0.06] rounded-lg p-4">
                  <p className="text-sm text-[#6b7280]">
                    Keep it simple:
                    <br />
                    • Manage open trades in <strong className="text-white">Portfolio</strong>
                    <br />
                    • Review lane decisions in <strong className="text-white">By Day Activity</strong>
                    <br />
                    • Click any row to open the <strong className="text-white">Right Rail</strong>
                    (it shows what lane you were in and why)
                  </p>
                </div>
                <div className="bg-teal-500/10 border border-teal-500/30 rounded-lg p-4">
                  <h3 className="text-teal-400 font-semibold mb-2">
                    The compounding loop
                  </h3>
                  <ul className="text-sm text-[#6b7280] list-disc list-inside space-y-1">
                    <li>Find your best lane + trigger combinations</li>
                    <li>Repeat them (raise size slowly as confidence grows)</li>
                    <li>Kill what doesn’t work (stop feeding losing patterns)</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#6b7280]">
                    <strong className="text-yellow-400">Tip:</strong> When you
                    see a good trade, click into the Right Rail and note the
                    lane + trigger combo—then look for that same pattern in the
                    Action Center next time.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Lane-first review (Right Rail)",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#d1d5db]">
                  Trade Tracker helps you <strong>audit lane decisions</strong>{" "}
                  so we repeat winners and stop feeding losers.
                </p>

                <div className="bg-white/[0.03] border border-white/[0.06] rounded-lg p-4">
                  <h3 className="text-white font-semibold mb-2">
                    What to do daily
                  </h3>
                  <ol className="text-sm text-[#6b7280] list-decimal list-inside space-y-2">
                    <li>
                      Check <strong className="text-white">Portfolio</strong>{" "}
                      for open trades (P&L + risk).
                    </li>
                    <li>
                      Open <strong className="text-white">By Day Activity</strong>{" "}
                      to replay lane changes + entries/exits.
                    </li>
                    <li>
                      Click any row to open the{" "}
                      <strong className="text-white">Right Rail</strong> — it
                      shows the lane + why (trigger/decision).
                    </li>
                  </ol>
                </div>

                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    The only question
                  </h3>
                  <p className="text-sm text-[#6b7280]">
                    “If I followed the lane + decision exactly, did it pay?” If
                    not: which lane/trigger combo should be demoted or blocked?
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Trim & exit discipline (no AGQ disasters)",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#d1d5db]">
                  We win by being ruthless on{" "}
                  <strong>risk management</strong>: trim winners, exit losers
                  early, and don’t “hope” in HOLD.
                </p>

                <div className="bg-rose-500/10 border border-rose-500/30 rounded-lg p-4">
                  <h3 className="text-rose-400 font-semibold mb-2">
                    What to flag immediately
                  </h3>
                  <ul className="text-sm text-[#6b7280] list-disc list-inside space-y-2">
                    <li>
                      “Enter Now” when entry decision is not green-lit (should
                      never happen)
                    </li>
                    <li>Big adverse move after entry (exit/defend faster)</li>
                    <li>Lane backtracking (enter → just flipped → hold)</li>
                  </ul>
                </div>

                <div className="bg-teal-500/10 border border-teal-500/30 rounded-lg p-4">
                  <h3 className="text-teal-400 font-semibold mb-2">
                    What to record (so we compound)
                  </h3>
                  <div className="text-sm text-[#6b7280] space-y-2">
                    <div>
                      <strong className="text-white">Lane</strong> +{" "}
                      <strong className="text-white">trigger</strong> at entry
                    </div>
                    <div>
                      <strong className="text-white">Exit reason</strong>{" "}
                      (trim/defend/stop/target)
                    </div>
                    <div>
                      <strong className="text-white">Outcome</strong> (did the
                      lane rule work?)
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "How P&L is Calculated 💰",
            content: (
              <div className="space-y-4">
                <p className="text-[#d1d5db]">
                  Understanding how profit and loss is calculated helps you
                  interpret the results:
                </p>
                <div className="bg-teal-500/10 border border-teal-500/30 rounded-lg p-4">
                  <h3 className="text-teal-400 font-semibold mb-2">
                    📈 For Stocks:
                  </h3>
                  <div className="text-sm text-[#6b7280] space-y-2">
                    <div>
                      <strong className="text-white">Position Size:</strong>{" "}
                      $1,000 per trade
                    </div>
                    <div>
                      <strong className="text-white">Shares:</strong> $1,000 ÷
                      Entry Price
                    </div>
                    <div>
                      <strong className="text-white">P&L (LONG):</strong>{" "}
                      (Current Price - Entry Price) × Shares
                    </div>
                    <div>
                      <strong className="text-white">P&L (SHORT):</strong>{" "}
                      (Entry Price - Current Price) × Shares
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    📊 For Futures:
                  </h3>
                  <div className="text-sm text-[#6b7280] space-y-2">
                    <div>
                      <strong className="text-white">Contracts:</strong> Usually
                      1 contract per trade
                    </div>
                    <div>
                      <strong className="text-white">Point Value:</strong> Each
                      futures contract has a point value:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>NQ1! (Nasdaq): $20 per point</li>
                        <li>ES1! (S&P 500): $50 per point</li>
                        <li>Other futures vary</li>
                      </ul>
                    </div>
                    <div>
                      <strong className="text-white">P&L:</strong> (Price
                      Change) × Contracts × Point Value
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2">
                    🎯 Example:
                  </h3>
                  <div className="text-sm text-[#6b7280] space-y-1">
                    <div>
                      <strong className="text-white">Stock Trade:</strong> AAPL
                      at $150 entry, $155 current
                    </div>
                    <div className="ml-4">
                      Shares: $1,000 ÷ $150 = 6.67 shares
                    </div>
                    <div className="ml-4">
                      P&L: ($155 - $150) × 6.67 ={" "}
                      <span className="text-teal-400">+$33.35</span>
                    </div>
                    <div className="mt-2">
                      <strong className="text-white">Futures Trade:</strong>{" "}
                      NQ1! at 15,000 entry, 15,100 current
                    </div>
                    <div className="ml-4">
                      Price Change: 15,100 - 15,000 = 100 points
                    </div>
                    <div className="ml-4">
                      P&L: 100 × 1 × $20 ={" "}
                      <span className="text-teal-400">+$2,000</span>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Tracking & Analytics 📊",
            content: (
              <div className="space-y-4">
                <p className="text-[#d1d5db]">
                  The Trade Tracker provides powerful analytics to help you
                  learn:
                </p>
                <div className="bg-teal-500/10 border border-teal-500/30 rounded-lg p-4">
                  <h3 className="text-teal-400 font-semibold mb-2">
                    📈 Performance Metrics:
                  </h3>
                  <ul className="text-sm text-[#6b7280] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Historical Win Rate:</strong>{" "}
                      Percentage of past trades that were profitable
                    </li>
                    <li>
                      <strong className="text-white">Total P&L:</strong> Sum of
                      all profits and losses
                    </li>
                    <li>
                      <strong className="text-white">Average Win/Loss:</strong>{" "}
                      Average profit per win vs loss
                    </li>
                    <li>
                      <strong className="text-white">Best/Worst Trade:</strong>{" "}
                      Your biggest winners and losers
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🔍 Filter by Version:
                  </h3>
                  <p className="text-sm text-[#6b7280] mb-2">
                    Use the "Model Version" dropdown to compare performance
                    across different versions of the trading model. This helps
                    you see which improvements work best.
                  </p>
                  <p className="text-sm text-[#6b7280]">
                    <strong className="text-white">Tip:</strong> Newer versions
                    often include improvements, but older versions may have
                    proven track records.
                  </p>
                </div>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    📊 Daily Summary:
                  </h3>
                  <p className="text-sm text-[#6b7280]">
                    Click "View Daily Summary" to see performance breakdowns by:
                  </p>
                  <ul className="text-sm text-[#6b7280] list-disc list-inside space-y-1 mt-2">
                    <li>Rank ranges (which ranked setups perform best)</li>
                    <li>Risk/Reward ratios (which RR ratios win more)</li>
                    <li>Quadrants (which chart zones are most profitable)</li>
                    <li>Overall statistics and insights</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#6b7280]">
                    <strong className="text-yellow-400">Remember:</strong> The
                    goal is to learn which setups work best. Review your wins
                    and losses regularly to improve your trading strategy!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together 🎓",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#d1d5db]">
                  Here's your{" "}
                  <strong className="text-yellow-400">workflow</strong> for
                  using the Trade Tracker:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    📋 Daily Workflow:
                  </h3>
                  <ol className="text-sm text-[#6b7280] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Monitor Open Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check the "Open Trades" section regularly
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Watch P&L update in real-time
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Click trades to see detailed information
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Review Closed Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check "Closed Trades" to see final results
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Review trade history to understand what happened
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Learn from both wins and losses
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Analyze Performance
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Use the version filter to compare models
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Check daily summary for insights
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Look for patterns in winning vs losing trades
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Improve Your Strategy
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Focus on setups with high historical win rates
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Avoid setups that consistently lose
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Adjust filters on the main dashboard based on results
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-teal-500/10 border border-teal-500/30 rounded-lg p-4">
                  <h3 className="text-teal-400 font-semibold mb-2">
                    ⭐ Key Takeaways:
                  </h3>
                  <div className="text-sm text-[#6b7280] space-y-1">
                    <div>✅ Trades are created automatically from alerts</div>
                    <div>✅ Each trade uses $1,000 position size</div>
                    <div>✅ P&L updates in real-time for open trades</div>
                    <div>✅ Trades close automatically at SL or TP</div>
                    <div>✅ Use analytics to learn which setups work best</div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#6b7280]">
                    <strong className="text-yellow-400">
                      Ready to start tracking?
                    </strong>{" "}
                    The Trade Tracker refreshes every 30 seconds to show the
                    latest trades and updates. Click "Start Tracking!" to begin!
                  </p>
                </div>
              </div>
            ),
          },
        ];
        const steps = allSteps.slice(0, 4);

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[#0f1117] border-2 border-white/[0.06] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-lg">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-white/[0.06] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                              ? "bg-teal-400"
                              : "bg-white/[0.04]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[#6b7280] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-white/[0.04] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-white/[0.06] p-4 flex items-center justify-between bg-white/[0.03]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-white/[0.06] text-[#6b7280] opacity-50 cursor-not-allowed"
                      : "border-white/[0.06] bg-white/5 hover:bg-white/[0.04] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[#6b7280]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Tracking! 🚀
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Time Travel Slider Component
      function TimeTravelSlider({
        tickers,
        allTickers,
        data,
        onTimeChange,
        tickerFilter,
        selectedTicker,
        compact = false,
      }) {
        const [isActive, setIsActive] = useState(false);
        const [selectedTimestamp, setSelectedTimestamp] = useState(null);
        const [trailData, setTrailData] = useState({});
        const [loadingTrails, setLoadingTrails] = useState(false);
        const [trailLoadProgress, setTrailLoadProgress] = useState({
          total: 0,
          done: 0,
        });
        const [isPlaying, setIsPlaying] = useState(false);
        const [playSpeedMs, setPlaySpeedMs] = useState(600); // ms per 5-min step
        const [loopPlayback, setLoopPlayback] = useState(true);
        const [loadCancelled, setLoadCancelled] = useState(false);
        const STEP_OPTIONS = React.useMemo(
          () => [
            { label: "5m", ms: 5 * 60 * 1000 },
            { label: "15m", ms: 15 * 60 * 1000 },
            { label: "30m", ms: 30 * 60 * 1000 },
            { label: "1H", ms: 60 * 60 * 1000 },
            { label: "4H", ms: 4 * 60 * 60 * 1000 },
            { label: "1D", ms: 24 * 60 * 60 * 1000 },
            { label: "1W", ms: 7 * 24 * 60 * 60 * 1000 },
          ],
          [],
        );
        const [stepMs, setStepMs] = useState(5 * 60 * 1000);

        // Prevent render loops when parent passes unstable callbacks/arrays.
        // (This was causing "Maximum update depth exceeded" and breaking Play.)
        const onTimeChangeRef = React.useRef(onTimeChange);
        useEffect(() => {
          onTimeChangeRef.current = onTimeChange;
        }, [onTimeChange]);

        const tickersRef = React.useRef(tickers);
        tickersRef.current = tickers;

        // Bucket timestamp to selected step (stable reference for effects)
        const roundToStep = React.useCallback(
          (ts) => {
            const ms = Number(ts);
            const step = Number(stepMs);
            if (!Number.isFinite(ms) || !Number.isFinite(step) || step <= 0)
              return ms;
            return Math.floor(ms / step) * step;
          },
          [stepMs],
        );

        // Get available timestamps - prefer trail data (historical) over live ticker data
        // This ensures the slider range matches what's actually available in the trail
        const availableTimestamps = useMemo(() => {
          const timestamps = new Set();
          
          // If we have trail data loaded, use timestamps from trails (more accurate for Time Travel)
          const trailSymbols = Object.keys(trailData || {});
          if (trailSymbols.length > 0) {
            trailSymbols.forEach((sym) => {
              const trail = trailData[sym];
              if (!Array.isArray(trail)) return;
              trail.forEach((point) => {
                const pointTs = point.ts || (point.timestamp ? new Date(point.timestamp).getTime() : null);
                if (pointTs) {
                  const rounded = roundToStep(Number(pointTs));
                  timestamps.add(rounded);
                }
              });
            });
          }
          
          // Fall back to live ticker data if no trail data yet
          if (timestamps.size === 0) {
            const sourceTickers =
              allTickers && typeof allTickers === "object"
                ? Array.isArray(allTickers)
                  ? allTickers
                  : Object.values(allTickers)
                : tickers;

            sourceTickers.forEach((t) => {
              if (!t || typeof t !== "object") return;
              if (t.ts) {
                const rounded = roundToStep(Number(t.ts));
                timestamps.add(rounded);
              }
              if (t.ingest_ts) {
                const ts =
                  typeof t.ingest_ts === "string"
                    ? new Date(t.ingest_ts).getTime()
                    : Number(t.ingest_ts);
                if (ts) {
                  const rounded = roundToStep(ts);
                  timestamps.add(rounded);
                }
              }
            });
          }
          
          return Array.from(timestamps).sort((a, b) => a - b);
        }, [allTickers, tickers, trailData, roundToStep]);

        const minTimestamp =
          availableTimestamps.length > 0
            ? availableTimestamps[0]
            : roundToStep(Date.now() - 7 * 24 * 60 * 60 * 1000);
        const maxTimestamp =
          availableTimestamps.length > 0
            ? availableTimestamps[availableTimestamps.length - 1]
            : roundToStep(Date.now());

        const STEP_MS = stepMs;

        const buildSnapshotTickers = React.useCallback(
          (sourceTickers, trails, roundedTimestamp) => {
            if (!Array.isArray(sourceTickers)) return [];
            return sourceTickers
              .map((ticker) => {
                const symbol = ticker?.ticker;
                if (!symbol) return null;

                const trail = trails?.[symbol] || [];
                const pointsWithTs = Array.isArray(trail)
                  ? trail
                      .map((point) => {
                        const pointTs =
                          point.ts ||
                          (point.timestamp
                            ? new Date(point.timestamp).getTime()
                            : null);
                        if (!pointTs) return null;
                        return {
                          point,
                          pointTs,
                          roundedPointTs: roundToStep(pointTs),
                        };
                      })
                      .filter(Boolean)
                  : [];

                // Snapshot: use closest known point. If missing data, keep visible using latest values.
                if (pointsWithTs.length > 0) {
                  const closest = pointsWithTs.reduce((best, cur) => {
                    if (!best) return cur;
                    const bestDist = Math.abs(
                      best.roundedPointTs - roundedTimestamp,
                    );
                    const curDist = Math.abs(
                      cur.roundedPointTs - roundedTimestamp,
                    );
                    return curDist < bestDist ? cur : best;
                  }, null);

                  const closestPoint = closest.point;
                  return {
                    ...ticker,
                    htf_score:
                      closestPoint.htf_score !== undefined
                        ? closestPoint.htf_score
                        : ticker.htf_score,
                    ltf_score:
                      closestPoint.ltf_score !== undefined
                        ? closestPoint.ltf_score
                        : ticker.ltf_score,
                    price:
                      closestPoint.price !== undefined
                        ? closestPoint.price
                        : ticker.price,
                    state: closestPoint.state || ticker.state,
                    rank:
                      closestPoint.rank !== undefined
                        ? closestPoint.rank
                        : ticker.rank,
                    rr:
                      closestPoint.rr !== undefined
                        ? closestPoint.rr
                        : ticker.rr,
                    completion:
                      closestPoint.completion !== undefined
                        ? closestPoint.completion
                        : ticker.completion,
                    phase_pct:
                      closestPoint.phase_pct !== undefined
                        ? closestPoint.phase_pct
                        : ticker.phase_pct,
                    // Historical kanban stage from trail (for Time Travel Kanban)
                    kanban_stage:
                      closestPoint.kanban_stage !== undefined
                        ? closestPoint.kanban_stage
                        : ticker.kanban_stage,
                    entry_ts:
                      closestPoint.entry_ts !== undefined
                        ? closestPoint.entry_ts
                        : ticker.entry_ts,
                    entry_price:
                      closestPoint.entry_price !== undefined
                        ? closestPoint.entry_price
                        : ticker.entry_price,
                    ts: closest.pointTs,
                    _isTimeTravel: true,
                    _timeTravelMissing: false,
                  };
                }

                return {
                  ...ticker,
                  _isTimeTravel: true,
                  _timeTravelMissing: true,
                  ts: ticker.ts || ticker.ingest_ts || null,
                };
              })
              .filter(Boolean);
          },
          [roundToStep],
        );

        // Fetch trail data and filter by timestamp
        // Use a ref to track if we're currently fetching to prevent race conditions
        const fetchingRef = React.useRef(false);
        const lastFetchedSymbolsRef = React.useRef("");

        // Memoize ticker symbols to prevent unnecessary re-fetches
        const tickerSymbols = useMemo(() => {
          return tickers
            .map((t) => t.ticker)
            .sort()
            .join(",");
        }, [tickers]);

        // Fetch trails ONCE when activating (or when ticker set changes).
        // Snapshot updates (including animation) should NOT refetch trails.
        const cancelledRef = React.useRef(false);
        
        useEffect(() => {
          cancelledRef.current = false;

          if (!isActive) {
            setIsPlaying(false);
            setTrailData({});
            setTrailLoadProgress({ total: 0, done: 0 });
            lastFetchedSymbolsRef.current = "";
            setLoadCancelled(false);
            onTimeChangeRef.current?.(null);
            return () => {
              cancelledRef.current = true;
            };
          }

          if (tickersRef.current.length === 0) {
            onTimeChangeRef.current?.([]);
            return () => {
              cancelledRef.current = true;
            };
          }

          // Prevent concurrent fetches
          if (fetchingRef.current) return;

          // Avoid refetch if we already fetched this exact ticker set
          if (lastFetchedSymbolsRef.current === tickerSymbols) {
            return;
          }

          const fetchTrails = async () => {
            fetchingRef.current = true;
            setLoadingTrails(true);
            setLoadCancelled(false);
            lastFetchedSymbolsRef.current = tickerSymbols;
            try {
              const trails = {};
              const tickerSymbolsArray = tickersRef.current.map(
                (t) => t.ticker,
              );
              setTrailLoadProgress({
                total: tickerSymbolsArray.length,
                done: 0,
              });

              const MAX_CONCURRENT = 5;
              for (
                let i = 0;
                i < tickerSymbolsArray.length;
                i += MAX_CONCURRENT
              ) {
                // Check if cancelled
                if (cancelledRef.current) {
                  console.log('[Time Travel] Load cancelled by user');
                  break;
                }
                
                const batch = tickerSymbolsArray.slice(i, i + MAX_CONCURRENT);
                const batchResults = await Promise.all(
                  batch.map(async (ticker) => {
                    try {
                      const res = await fetch(
                        `/timed/trail?ticker=${encodeURIComponent(
                          ticker,
                        )}&include_kanban=1`,
                      );
                      if (res.ok) {
                        const json = await res.json();
                        if (
                          json.ok &&
                          json.trail &&
                          Array.isArray(json.trail)
                        ) {
                          return { ticker, trail: json.trail };
                        }
                      }
                      return { ticker, trail: [] };
                    } catch (err) {
                      return { ticker, trail: [] };
                    }
                  }),
                );

                batchResults.forEach(({ ticker, trail }) => {
                  if (Array.isArray(trail) && trail.length > 0) {
                    trails[ticker] = trail;
                  }
                });

                if (!cancelledRef.current) {
                  setTrailLoadProgress((p) => ({
                    total: p.total || tickerSymbolsArray.length,
                    done: Math.min(
                      (p.done || 0) + batch.length,
                      tickerSymbolsArray.length,
                    ),
                  }));
                }

                // Small delay between batches to avoid spikes
                await new Promise((r) => setTimeout(r, 250));
              }

              if (!cancelledRef.current) {
                setTrailData(trails);
                console.log('[Time Travel] Trails loaded:', Object.keys(trails).length, 'tickers');
              }
            } catch (err) {
              console.error("Failed to fetch trails:", err);
              if (!cancelledRef.current) setTrailData({});
            } finally {
              if (!cancelledRef.current) setLoadingTrails(false);
              fetchingRef.current = false;
            }
          };

          fetchTrails();
          return () => {
            cancelledRef.current = true;
          };
        }, [isActive, tickerSymbols]);
        
        // Cancel loading function
        const handleCancelLoad = React.useCallback(() => {
          cancelledRef.current = true;
          setLoadCancelled(true);
          setLoadingTrails(false);
          fetchingRef.current = false;
        }, []);
        
        // When trails finish loading, reset timestamp to latest available data point
        const prevTrailCountRef = React.useRef(0);
        useEffect(() => {
          const trailCount = Object.keys(trailData).length;
          // Only trigger on actual trail data load (not on reset)
          if (trailCount > 0 && trailCount !== prevTrailCountRef.current && !loadingTrails) {
            console.log('[Time Travel] Trails loaded, resetting to latest timestamp:', {
              trailCount,
              maxTimestamp: new Date(maxTimestamp).toLocaleString(),
            });
            setSelectedTimestamp(roundToStep(maxTimestamp));
          }
          prevTrailCountRef.current = trailCount;
        }, [trailData, loadingTrails, maxTimestamp, roundToStep]);

        // Compute snapshot whenever timestamp changes or new trails arrive.
        useEffect(() => {
          if (!isActive) return;
          if (!selectedTimestamp) return;
          const roundedTimestamp = roundToStep(selectedTimestamp);
          const snapshot = buildSnapshotTickers(
            tickersRef.current,
            trailData,
            roundedTimestamp,
          );
          
          // Debug: log snapshot update
          const withData = snapshot.filter(t => !t._timeTravelMissing);
          console.log('[Time Travel] Snapshot update:', {
            timestamp: new Date(roundedTimestamp).toLocaleString(),
            totalTickers: snapshot.length,
            withTrailData: withData.length,
            trailSymbols: Object.keys(trailData).length,
            sampleTicker: withData[0] ? {
              ticker: withData[0].ticker,
              htf_score: withData[0].htf_score,
              ltf_score: withData[0].ltf_score,
              kanban_stage: withData[0].kanban_stage,
            } : null,
          });
          
          onTimeChangeRef.current?.(snapshot);
        }, [
          isActive,
          selectedTimestamp,
          trailData,
          tickerSymbols,
          buildSnapshotTickers,
          roundToStep,
        ]);

        // Animation: advance by 5 minutes at a configurable speed.
        useEffect(() => {
          if (!isActive || !isPlaying) return;

          const id = setInterval(() => {
            setSelectedTimestamp((prev) => {
              const cur =
                prev !== null && prev !== undefined
                  ? roundToStep(prev)
                  : roundToStep(maxTimestamp);
              const next = cur + STEP_MS;
              if (next > maxTimestamp) {
                if (loopPlayback) {
                  return roundToStep(minTimestamp);
                }
                setIsPlaying(false);
                return cur;
              }
              return next;
            });
          }, playSpeedMs);

          return () => clearInterval(id);
        }, [
          isActive,
          isPlaying,
          playSpeedMs,
          loopPlayback,
          minTimestamp,
          maxTimestamp,
          roundToStep,
          STEP_MS,
        ]);

        const handleTimestampChange = (e) => {
          const ts = Number(e.target.value);
          // Round to selected step
          const rounded = roundToStep(ts);
          setSelectedTimestamp(rounded);
          setIsPlaying(false);
        };

        const formatTimestamp = (ts) => {
          if (!ts) return "Now";
          const date = new Date(ts);
          return date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          });
        };

        const currentValue = selectedTimestamp
          ? roundToStep(selectedTimestamp)
          : roundToStep(maxTimestamp);
        const progress =
          maxTimestamp > minTimestamp
            ? ((currentValue - minTimestamp) / (maxTimestamp - minTimestamp)) *
              100
            : 100;

        // Parse ticker filter to show which tickers are being tracked
        const trackedTickers = useMemo(() => {
          if (!tickerFilter || typeof tickerFilter !== "string") return [];
          return tickerFilter
            .split(",")
            .map((t) => t.trim().toUpperCase())
            .filter(Boolean);
        }, [tickerFilter]);

        const selectedSym = useMemo(() => {
          const s = String(selectedTicker || "")
            .trim()
            .toUpperCase();
          return s || null;
        }, [selectedTicker]);

        const selectedSnapshotInfo = useMemo(() => {
          if (!isActive) return null;
          if (!selectedSym) return null;
          if (!Number.isFinite(currentValue)) return null;
          const trail = trailData?.[selectedSym] || [];
          if (!Array.isArray(trail) || trail.length === 0) return null;

          const pointsWithTs = trail
            .map((point) => {
              const pointTs =
                point.ts ||
                (point.timestamp ? new Date(point.timestamp).getTime() : null);
              if (!pointTs) return null;
              return {
                point,
                pointTs: Number(pointTs),
                roundedPointTs: roundToStep(pointTs),
              };
            })
            .filter(Boolean);

          if (pointsWithTs.length === 0) return null;
          const closest = pointsWithTs.reduce((best, cur) => {
            if (!best) return cur;
            const bestDist = Math.abs(best.roundedPointTs - currentValue);
            const curDist = Math.abs(cur.roundedPointTs - currentValue);
            return curDist < bestDist ? cur : best;
          }, null);

          const px = Number(closest?.point?.price);
          return {
            ts: Number.isFinite(closest?.pointTs) ? closest.pointTs : null,
            price: Number.isFinite(px) ? px : null,
          };
        }, [isActive, selectedSym, currentValue, trailData, roundToStep]);

        const fmtPrice = (p) => {
          const n = Number(p);
          return Number.isFinite(n) ? `$${n.toFixed(2)}` : "—";
        };

        // Compact mode: inline controls for header bar
        if (compact) {
          return (
            <div className="flex items-center gap-2 flex-wrap">
              <label className="flex items-center gap-1.5 cursor-pointer">
                <input
                  type="checkbox"
                  checked={isActive}
                  onChange={(e) => {
                    setIsActive(e.target.checked);
                    if (!e.target.checked) {
                      setIsPlaying(false);
                      setSelectedTimestamp(null);
                      onTimeChangeRef.current?.(null);
                    } else {
                      setSelectedTimestamp(roundToStep(maxTimestamp));
                    }
                  }}
                  className="w-3.5 h-3.5"
                />
                <span className="text-xs font-semibold text-white whitespace-nowrap">
                  ⏱️ Time Travel
                </span>
              </label>
              {isActive && (
                <>
                  {/* Loading state - prominent overlay */}
                  {loadingTrails && (
                    <div className="flex items-center gap-2 px-3 py-1 bg-white/[0.03] border border-[#3a4aa0] rounded-lg">
                      <div className="w-4 h-4 border-2 border-[#00ffff] border-t-transparent rounded-full animate-spin"></div>
                      <span className="text-[11px] text-[#00ffff] font-semibold">
                        Loading {trailLoadProgress.done}/{trailLoadProgress.total || '...'}
                      </span>
                      <button
                        onClick={handleCancelLoad}
                        className="px-2 py-0.5 bg-[#3a1a1a] hover:bg-[#5a2a2a] text-[#ff6b6b] rounded text-[10px] font-medium"
                        title="Cancel loading"
                      >
                        Cancel
                      </button>
                    </div>
                  )}
                  {/* Controls - only show when not loading */}
                  {!loadingTrails && (
                    <>
                      <button
                        onClick={() => {
                          if (!isPlaying) {
                            setSelectedTimestamp((prev) =>
                              prev !== null && prev !== undefined ? prev : maxTimestamp,
                            );
                          }
                          setIsPlaying((p) => !p);
                        }}
                        className="px-2 py-1 bg-white/[0.04] hover:bg-white/[0.06] rounded text-[10px] text-white"
                        title="Play / Pause"
                      >
                        {isPlaying ? "⏸" : "▶️"}
                      </button>
                      <select
                        value={String(stepMs)}
                        onChange={(e) => {
                          const next = Number(e.target.value);
                          if (!Number.isFinite(next) || next <= 0) return;
                          setStepMs(next);
                          setIsPlaying(false);
                          setSelectedTimestamp((prev) =>
                            prev != null
                              ? Math.floor(Number(prev) / next) * next
                              : Math.floor(Number(maxTimestamp) / next) * next,
                          );
                        }}
                        className="bg-white/[0.03] border border-white/[0.06] rounded px-1.5 py-0.5 text-[10px] text-[#d1d5db]"
                        title="Time step"
                      >
                        {STEP_OPTIONS.map((opt) => (
                          <option key={opt.label} value={opt.ms}>
                            {opt.label}
                          </option>
                        ))}
                      </select>
                      <input
                        type="range"
                        min={minTimestamp}
                        max={maxTimestamp}
                        step={STEP_MS}
                        value={currentValue}
                        onChange={handleTimestampChange}
                        className="flex-1 min-w-[120px] h-1.5 bg-white/[0.03] rounded-lg appearance-none cursor-pointer"
                        style={{
                          background: `linear-gradient(to right, #00ffff 0%, #00ffff ${progress}%, #252b36 ${progress}%, #252b36 100%)`,
                        }}
                      />
                      <span className="text-[10px] text-[#00ffff] font-semibold whitespace-nowrap">
                        {formatTimestamp(currentValue)}
                      </span>
                      {loadCancelled && (
                        <span className="text-[10px] text-[#ff6b6b]">Cancelled</span>
                      )}
                    </>
                  )}
                </>
              )}
            </div>
          );
        }

        // Full mode: original panel layout
        return (
          <div className="mb-4 bg-white/[0.02] border border-white/[0.06] rounded-xl p-4">
            <div className="flex items-center justify-between mb-3 flex-wrap gap-2">
              <div className="flex items-center gap-3 flex-wrap">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={isActive}
                    onChange={(e) => {
                      setIsActive(e.target.checked);
                      if (!e.target.checked) {
                        setIsPlaying(false);
                        setSelectedTimestamp(null);
                        onTimeChangeRef.current?.(null);
                      } else {
                        // Round to 5 minutes when activating
                        setSelectedTimestamp(roundToStep(maxTimestamp));
                      }
                    }}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-semibold text-white">
                    ⏱️ Time Travel
                  </span>
                </label>
                {isActive && (
                  <div className="flex items-center gap-2">
                    {/* Loading state */}
                    {loadingTrails ? (
                      <div className="flex items-center gap-2 px-3 py-1 bg-white/[0.03] border border-[#3a4aa0] rounded-lg">
                        <div className="loading-spinner loading-spinner-sm"></div>
                        <span className="text-xs text-[#00ffff] font-semibold">
                          Loading trails... {trailLoadProgress.done}/{trailLoadProgress.total || '...'}
                        </span>
                        <button
                          onClick={handleCancelLoad}
                          className="px-2 py-1 bg-[#3a1a1a] hover:bg-[#5a2a2a] text-[#ff6b6b] rounded text-xs font-medium"
                          title="Cancel loading"
                        >
                          Cancel
                        </button>
                      </div>
                    ) : (
                      <>
                        <button
                          onClick={() => {
                            // Ensure we have a starting timestamp before playing
                            if (!isPlaying) {
                              setSelectedTimestamp((prev) =>
                                prev !== null && prev !== undefined
                                  ? prev
                                  : maxTimestamp,
                              );
                            }
                            setIsPlaying((p) => !p);
                          }}
                          className="px-2 py-1 bg-white/[0.04] hover:bg-white/[0.06] rounded text-xs text-white"
                          title="Play / Pause"
                        >
                          {isPlaying ? "⏸ Pause" : "▶️ Play"}
                        </button>
                        <select
                          value={String(stepMs)}
                          onChange={(e) => {
                            const next = Number(e.target.value);
                            if (!Number.isFinite(next) || next <= 0) return;
                            setStepMs(next);
                            setIsPlaying(false);
                            setSelectedTimestamp((prev) =>
                              prev != null
                                ? Math.floor(Number(prev) / next) * next
                                : Math.floor(Number(maxTimestamp) / next) * next,
                            );
                          }}
                          className="bg-white/[0.03] border border-white/[0.06] rounded px-2 py-1 text-xs text-[#d1d5db]"
                          title="Time step"
                        >
                          {STEP_OPTIONS.map((opt) => (
                            <option key={opt.label} value={opt.ms}>
                              {opt.label}
                            </option>
                          ))}
                        </select>
                        <select
                          value={playSpeedMs}
                          onChange={(e) => setPlaySpeedMs(Number(e.target.value))}
                          className="bg-white/[0.03] border border-white/[0.06] rounded px-2 py-1 text-xs text-[#d1d5db]"
                          title="Playback speed"
                        >
                          <option value={300}>Fast</option>
                          <option value={600}>Normal</option>
                          <option value={1200}>Slow</option>
                        </select>
                        <label className="flex items-center gap-1 text-xs text-[#6b7280]">
                          <input
                            type="checkbox"
                            checked={loopPlayback}
                            onChange={(e) => setLoopPlayback(e.target.checked)}
                          />
                          Loop
                        </label>
                        {loadCancelled && (
                          <span className="text-xs text-[#ff6b6b]">Cancelled</span>
                        )}
                      </>
                    )}
                  </div>
                )}
                {trackedTickers.length > 0 && (
                  <div className="flex items-center gap-2 text-xs text-[#6b7280]">
                    <span className="text-[#00ffff]">Tracking:</span>
                    <div className="flex flex-wrap gap-1">
                      {trackedTickers.slice(0, 5).map((ticker, idx) => (
                        <span
                          key={idx}
                          className="px-2 py-0.5 bg-white/[0.03] border border-white/[0.06] rounded text-[#00ffff]"
                        >
                          {ticker}
                        </span>
                      ))}
                      {trackedTickers.length > 5 && (
                        <span className="px-2 py-0.5 bg-white/[0.03] border border-white/[0.06] rounded text-[#6b7280]">
                          +{trackedTickers.length - 5}
                        </span>
                      )}
                    </div>
                  </div>
                )}
                {tickers.length > 0 && trackedTickers.length === 0 && (
                  <div className="text-xs text-[#6b7280]">
                    Showing {tickers.length} ticker
                    {tickers.length !== 1 ? "s" : ""}
                  </div>
                )}
              </div>
              {isActive && (
                <div className="text-xs text-[#00ffff] font-semibold text-right">
                  <div>{formatTimestamp(currentValue)}</div>
                  {selectedSym && (
                    <div className="mt-0.5 text-[11px] text-[#6b7280] font-normal">
                      {selectedSym}:{" "}
                      <span className="text-white font-semibold">
                        {fmtPrice(selectedSnapshotInfo?.price)}
                      </span>
                      {Number.isFinite(selectedSnapshotInfo?.ts) &&
                        selectedSnapshotInfo.ts !== currentValue && (
                          <span className="text-[#4b5563]">
                            {` (data @ ${formatTimestamp(selectedSnapshotInfo.ts)})`}
                          </span>
                        )}
                    </div>
                  )}
                </div>
              )}
            </div>

            {isActive && (
              <div className="space-y-2">
                <input
                  type="range"
                  min={minTimestamp}
                  max={maxTimestamp}
                  step={STEP_MS}
                  value={currentValue}
                  onChange={handleTimestampChange}
                  className="w-full h-2 bg-white/[0.03] rounded-lg appearance-none cursor-pointer slider-thumb"
                  style={{
                    background: `linear-gradient(to right, #00ffff 0%, #00ffff ${progress}%, #252b36 ${progress}%, #252b36 100%)`,
                  }}
                />
                <div className="flex justify-between text-xs text-[#6b7280]">
                  <span>{formatTimestamp(minTimestamp)}</span>
                  <span>{formatTimestamp(maxTimestamp)}</span>
                </div>
                {loadingTrails && (
                  <div className="text-xs text-[#6b7280]">
                    <div className="flex items-center justify-between mb-1">
                      <span>Loading historical data…</span>
                      <span className="tabular-nums">
                        {trailLoadProgress.done}/{trailLoadProgress.total || 0}
                      </span>
                    </div>
                    <div className="w-full h-2 bg-white/[0.03] border border-white/[0.06] rounded overflow-hidden">
                      <div
                        className="h-full bg-[#00ffff]"
                        style={{
                          width: `${
                            trailLoadProgress.total > 0
                              ? Math.round(
                                  (trailLoadProgress.done /
                                    trailLoadProgress.total) *
                                    100,
                                )
                              : 0
                          }%`,
                          transition: "width 200ms ease",
                        }}
                      />
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }

      function QuickFilters({ filters, onFilterChange, sectors = [] }) {
        // Groups (seed list) - one row
        const groupPresets = [
          {
            label: "TT Selected",
            filter: { group: "TT_SELECTED" },
            icon: "🌐",
          },
          {
            label: "SP Sectors",
            filter: { group: "SP_Sectors" },
            icon: "📈",
          },
          {
            label: "Futures",
            filter: { group: "Futures" },
            icon: "⚡",
          },
          {
            label: "Added By Me",
            filter: { group: "USER_ADDED" },
            icon: "➕",
          },
        ];

        // Filters - one row
        const filterPresets = [
          {
            label: "Short-Term",
            filter: { horizonBucket: "SHORT_TERM" },
            icon: "⏱️",
          },
          {
            label: "Swing",
            filter: { horizonBucket: "SWING" },
            icon: "🎢",
          },
          {
            label: "Positional",
            filter: { horizonBucket: "POSITIONAL" },
            icon: "🏔️",
          },
          {
            label: "Prime Only",
            filter: { minRank: 75, minRR: 1.5, maxCompletion: 0.4 },
            icon: "💎",
          },
          {
            label: "In Corridor",
            filter: { inCorridor: true },
            icon: "🎯",
          },
          {
            label: "Squeeze Release",
            filter: { squeezeRelease: true },
            icon: "⚡",
          },
          {
            label: "In Squeeze",
            filter: { inSqueeze: true },
            icon: "🧨",
          },
          {
            label: "Momentum Elite",
            filter: { momentumElite: true },
            icon: "🔥",
          },
          {
            label: "Prime",
            filter: { prime: true },
            icon: "💎",
          },
          {
            label: "Q1: Bull Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "📈",
          },
          {
            label: "Q2: Bull Momentum",
            filter: { quadrants: ["HTF_BULL_LTF_BULL"] },
            icon: "🚀",
          },
          {
            label: "Q3: Bear Momentum",
            filter: { quadrants: ["HTF_BEAR_LTF_BEAR"] },
            icon: "📉",
          },
          {
            label: "Q4: Bear Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "🔻",
          },
          {
            label: "Ranked",
            filter: { top40: true },
            icon: "📊",
          },
          {
            label: "Top Long Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "📈",
          },
          {
            label: "Top Short Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "📉",
          },
          {
            label: "Trades",
            filter: { hasTrades: true },
            icon: "💼",
          },
          {
            label: "TD9 Setup",
            filter: { td9Setup: "any" },
            icon: "🔢",
          },
        ];

        const isActive = (preset) => {
          if (preset.label === "Prime Only") {
            return (
              filters.minRank === 75 &&
              filters.minRR === 1.5 &&
              filters.maxCompletion === 0.4
            );
          }
          if (preset.label === "Short-Term") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "SHORT_TERM"
            );
          }
          if (preset.label === "Swing") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "SWING"
            );
          }
          if (preset.label === "Positional") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "POSITIONAL"
            );
          }
          if (preset.label === "In Corridor") {
            return filters.inCorridor === true;
          }
          if (preset.label === "Squeeze Release") {
            return filters.squeezeRelease === true;
          }
          if (preset.label === "In Squeeze") {
            return filters.inSqueeze === true;
          }
          if (preset.label === "Momentum Elite") {
            return filters.momentumElite === true;
          }
          // Check for "Top Long Setup" and "Top Short Setup" specifically
          if (preset.label === "Top Long Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
            );
          }
          if (preset.label === "Top Short Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
            );
          }
          // Check if quadrant filter matches (for Q1, Q2, Q3, Q4 labels)
          if (preset.label.startsWith("Q")) {
            const presetQuadrants = preset.filter.quadrants || [];
            const currentQuadrants = filters.quadrants || [];
            // Check if preset quadrants are the only ones selected
            if (presetQuadrants.length === 1 && currentQuadrants.length === 1) {
              return presetQuadrants[0] === currentQuadrants[0];
            }
            // Check if preset quadrants are subset of current (and no others)
            if (
              presetQuadrants.length === 1 &&
              currentQuadrants.includes(presetQuadrants[0])
            ) {
              return currentQuadrants.length === 1;
            }
          }
          // Check if group filter matches
          if (preset.filter.group) {
            return filters.group === preset.filter.group;
          }
          // Check if Top 40 filter matches
          if (preset.filter.top40) {
            return filters.top40 === true;
          }
          // Check if Trades filter matches
          if (preset.filter.hasTrades) {
            return filters.hasTrades === true;
          }
          // Check if TD9 Setup filter matches
          if (preset.filter.td9Setup) {
            return filters.td9Setup === "any";
          }
          return false;
        };

        const handlePresetClick = (preset) => {
          const active = isActive(preset);
          if (active) {
            // Toggle off - remove this specific filter, keep others
            const newFilters = { ...filters };

            if (preset.label === "Prime Only") {
              // Reset Prime Only filters to defaults
              newFilters.minRank = 0;
              newFilters.minRR = 0;
              newFilters.maxCompletion = 1.01;
            } else if (
              preset.label === "Short-Term" ||
              preset.label === "Swing" ||
              preset.label === "Positional"
            ) {
              delete newFilters.horizonBucket;
            } else if (preset.label === "In Corridor") {
              delete newFilters.inCorridor;
            } else if (preset.label === "Squeeze Release") {
              delete newFilters.squeezeRelease;
            } else if (preset.label === "In Squeeze") {
              delete newFilters.inSqueeze;
            } else if (preset.label === "Momentum Elite") {
              // Explicitly delete to ensure it's removed
              delete newFilters.momentumElite;
              // Set to undefined so handleFilterChange properly removes it
              newFilters.momentumElite = undefined;
            } else if (preset.label === "Top Long Setup") {
              // Restore all quadrants if Top Long Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label === "Top Short Setup") {
              // Restore all quadrants if Top Short Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label.startsWith("Q")) {
              // For Q1-Q4, restore all quadrants if this was the only one
              const presetQuadrants = preset.filter.quadrants || [];
              const currentQuadrants = filters.quadrants || [];
              if (
                presetQuadrants.length === 1 &&
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === presetQuadrants[0]
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.filter.group) {
              // Reset group filter
              newFilters.group = "ALL";
            } else if (preset.filter.top40) {
              delete newFilters.top40;
            } else if (preset.filter.hasTrades) {
              delete newFilters.hasTrades;
            } else if (preset.filter.td9Setup) {
              delete newFilters.td9Setup;
              newFilters.td9Setup = undefined; // Ensure it's cleared
            }

            // Ensure all deleted filters are explicitly set to undefined for proper cleanup
            onFilterChange(newFilters);
          } else {
            // Toggle on - apply filter, merge with existing filters
            const mergedFilters = { ...filters, ...preset.filter };

            // Special handling for quadrant filters - replace, don't merge arrays
            if (preset.filter.quadrants) {
              mergedFilters.quadrants = preset.filter.quadrants;
            }

            onFilterChange(mergedFilters);
          }
        };

        const resetAllFilters = () => {
          // Explicitly reset all filters including boolean flags
          // Use onFilterChange to ensure proper state updates
          const defaultFilters = {
            search: "",
            quadrants: [
              "HTF_BULL_LTF_PULLBACK",
              "HTF_BULL_LTF_BULL",
              "HTF_BEAR_LTF_BEAR",
              "HTF_BEAR_LTF_PULLBACK",
            ],
            minRank: 0,
            minRR: 0,
            maxCompletion: 1.01,
            group: "ALL",
          };
          // Explicitly clear all boolean filters by setting to undefined
          // handleFilterChange will delete undefined values
          onFilterChange({
            ...defaultFilters,
            horizonBucket: undefined,
            inCorridor: undefined,
            squeezeRelease: undefined,
            inSqueeze: undefined,
            momentumElite: undefined,
            winnerSignature: undefined,
            top40: undefined,
            hasTrades: undefined,
            td9Setup: undefined,
            sector: undefined,
          });
        };

        const renderPresetButton = (preset, i) => {
          const active = isActive(preset);
          return (
            <button
              key={i}
              className={`px-4 py-2 rounded-lg border text-sm font-semibold transition-all ${
                active
                  ? "border-teal-500 bg-teal-500/20 text-teal-400 shadow-lg"
                  : "border-white/[0.06] bg-white/[0.03] hover:bg-white/5 hover:border-[#3a4aa0] text-[#6b7280]"
              }`}
              onClick={() => handlePresetClick(preset)}
            >
              {preset.icon} {preset.label}
            </button>
          );
        };

        return (
          <div className="space-y-3 mb-4">
            {/* Groups Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {groupPresets.map((preset, i) => renderPresetButton(preset, i))}
            </div>
            {/* Filters Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {filterPresets.map((preset, i) => renderPresetButton(preset, i))}
              {/* Reset Filters Button */}
              <button
                onClick={resetAllFilters}
                className="px-4 py-2 rounded-lg border border-rose-500/50 bg-rose-500/10 hover:bg-rose-500/20 text-rose-400 text-sm font-semibold transition-all"
                title="Reset all filters to defaults"
              >
                🔄 Reset Filters
              </button>
            </div>
            {/* Sectors Row */}
            {sectors.length > 0 && (
              <div className="flex gap-2 flex-wrap items-center">
                <span className="text-xs text-[#6b7280] font-semibold mr-1">
                  Sectors:
                </span>
                {sectors.map((sectorData) => {
                  const sectorName = sectorData.sector || sectorData.name;
                  const rating = sectorData.rating || "neutral";
                  const emoji =
                    rating === "overweight"
                      ? "💪"
                      : rating === "underweight"
                        ? "👎"
                        : "😒";
                  const isActive = filters.sector === sectorName;
                  return (
                    <button
                      key={sectorName}
                      onClick={() => {
                        if (isActive) {
                          // Toggle off - clear sector filter
                          onFilterChange({
                            ...filters,
                            sector: undefined,
                          });
                        } else {
                          // Toggle on - set sector filter
                          onFilterChange({
                            ...filters,
                            sector: sectorName,
                          });
                        }
                      }}
                      className={`px-2 py-1 rounded-lg border text-xs font-semibold transition-all ${
                        isActive
                          ? "border-teal-500 bg-teal-500/20 text-teal-400 shadow-lg"
                          : "border-white/[0.06] bg-white/[0.03] hover:bg-white/5 hover:border-[#3a4aa0] text-[#6b7280]"
                      }`}
                      title={`${sectorName} - ${
                        rating.charAt(0).toUpperCase() + rating.slice(1)
                      }`}
                    >
                      {emoji} {sectorName}
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Viewport Filter Tags (controls Viewport + Bubble Chart)
      // ─────────────────────────────────────────────────────────────
      function ViewportFilterTags({
        filters,
        onChange,
        sectors = [],
        allData = null,
        trades = [],
        socialAdditions = [],
      }) {
        const group = String(filters.group || "ALL");
        const horizon = String(filters.horizonBucket || "ALL");
        const opp = String(filters.opportunities || "ALL");
        const quadrants = Array.isArray(filters.quadrants)
          ? filters.quadrants
          : null;
        const sector = String(filters.sector || "ALL");
        const guidance = String(filters.guidanceCategory || "ALL");

        const sectorRatingMap = React.useMemo(() => {
          const map = {};
          if (Array.isArray(sectors)) {
            sectors.forEach((s) => {
              const name = s?.sector || s?.name;
              if (!name) return;
              map[normalizeSectorKey(name)] = String(
                s?.rating || "neutral",
              ).toLowerCase();
            });
          }
          return map;
        }, [sectors]);

        const sectorEmoji = (sectorName) => {
          const rating =
            sectorRatingMap[normalizeSectorKey(sectorName)] || "neutral";
          return rating === "overweight"
            ? "💪"
            : rating === "underweight"
              ? "👎"
              : "😒";
        };

        const QUAD = {
          // Match quadrant presets used elsewhere in the UI
          // Q1: Bull Setup (pullback), Q2: Bull Momentum, Q3: Bear Momentum, Q4: Bear Setup (pullback)
          Q1: "HTF_BULL_LTF_PULLBACK",
          Q2: "HTF_BULL_LTF_BULL",
          Q3: "HTF_BEAR_LTF_BEAR",
          Q4: "HTF_BEAR_LTF_PULLBACK",
        };
        const ALL_QUADS = Object.values(QUAD);

        const isQuadActive = (qKey) => {
          const s = QUAD[qKey];
          if (!s) return false;
          if (!quadrants) return false;
          return quadrants.includes(s);
        };

        // Single-select quadrant behavior:
        // - click Qx => show only that quadrant
        // - click same Qx again => clear quadrant filter (show all)
        const toggleQuadrant = (qKey) => {
          const s = QUAD[qKey];
          if (!s) return;
          const cur = Array.isArray(quadrants) ? quadrants : null;
          const isOnlyThis = cur && cur.length === 1 && cur[0] === s;
          onChange({ quadrants: isOnlyThis ? undefined : [s] });
        };

        const PILL_TOOLTIPS = {
          "💎 Prime":
            "Top-quality setup: strong rank (≥70), good R:R (≥1.5), early phase + confirmation pattern (aligned, thesis, winner pattern, squeeze release, or momentum).",
          "🎯 Entry Zone":
            "Flip Watch active — ticker is in or near the scoring entry corridor. Actionable timing window.",
          "🧨 In Squeeze":
            "Currently in squeeze (sq30_on=true and sq30_release=false). Building pressure.",
          "⚡ Squeeze Release":
            "Squeeze release just fired (sq30_release=true). Breakout in progress.",
          "🔥 Momentum Elite":
            "Strong fundamental + price momentum overlay.",
        };

        const pillCounts = React.useMemo(() => {
          if (!allData) return null;
          const safeTrades = Array.isArray(trades) ? trades : [];
          const base = filters || {};

          const countWith = (nextFilters) => {
            try {
              const n = applyFilters(allData, nextFilters, safeTrades, socialAdditions).length;
              return Number.isFinite(n) ? n : null;
            } catch {
              return null;
            }
          };

          // Guidance
          const guidanceAll = countWith({
            ...base,
            guidanceCategory: undefined,
          });
          const guidanceInitiate = countWith({
            ...base,
            guidanceCategory: "INITIATE",
          });
          const guidanceConsider = countWith({
            ...base,
            guidanceCategory: "CONSIDER",
          });
          const guidanceMonitor = countWith({
            ...base,
            guidanceCategory: "MONITOR",
          });
          const guidanceWait = countWith({ ...base, guidanceCategory: "WAIT" });
          const guidanceExitTrim = countWith({
            ...base,
            guidanceCategory: "EXIT_TRIM",
          });
          const guidanceOther = countWith({
            ...base,
            guidanceCategory: "OTHER",
          });

          // Horizon
          const horizonAll = countWith({ ...base, horizonBucket: undefined });
          const horizonShort = countWith({
            ...base,
            horizonBucket: "SHORT_TERM",
          });
          const horizonSwing = countWith({ ...base, horizonBucket: "SWING" });
          const horizonPos = countWith({
            ...base,
            horizonBucket: "POSITIONAL",
          });

          // Opportunities
          const oppAll = countWith({ ...base, opportunities: undefined });
          const oppEligible = countWith({ ...base, opportunities: "ELIGIBLE" });
          const oppPrime = countWith({ ...base, opportunities: "PRIME" });
          const oppWatch = countWith({ ...base, opportunities: "WATCH" });
          const q1 = countWith({ ...base, quadrants: [QUAD.Q1] });
          const q2 = countWith({ ...base, quadrants: [QUAD.Q2] });
          const q3 = countWith({ ...base, quadrants: [QUAD.Q3] });
          const q4 = countWith({ ...base, quadrants: [QUAD.Q4] });

          // Specials
          const thesisFilters = isThesisModeActive(base)
            ? base
            : { ...base, ...THESIS_PRESET };
          const thesis = countWith(thesisFilters);
          const inSqueeze = countWith({ ...base, inSqueeze: true });
          const squeezeRelease = countWith({ ...base, squeezeRelease: true });
          const momentumElite = countWith({ ...base, momentumElite: true });
          const winnerSignature = countWith({ ...base, winnerSignature: true });
          const flipWatch = countWith({ ...base, flipWatch: true });

          // Kanban Stages (6 lanes - Discovery + Management)
          const kanbanSetup = countWith({ ...base, kanbanStage: "setup" }) +
            countWith({ ...base, kanbanStage: "setup_watch" }) +
            countWith({ ...base, kanbanStage: "flip_watch" });
          const kanbanEnter = countWith({ ...base, kanbanStage: "enter" }) +
            countWith({ ...base, kanbanStage: "enter_now" }) +
            countWith({ ...base, kanbanStage: "just_flipped" });
          const kanbanNew = countWith({ ...base, kanbanStage: "just_entered" });
          const kanbanHold = countWith({ ...base, kanbanStage: "active" }) +
            countWith({ ...base, kanbanStage: "hold" });
          const kanbanDefend = countWith({ ...base, kanbanStage: "defend" });
          const kanbanTrim = countWith({ ...base, kanbanStage: "trim" });
          const kanbanExit = countWith({ ...base, kanbanStage: "exit" });

          // Action Moves Pattern Groups
          const patternSqueezeMomentum = countWith({
            ...base,
            patternGroup: "Squeeze → Momentum",
          });
          const patternMomentumElite = countWith({
            ...base,
            patternGroup: "Momentum Elite",
          });
          const patternCorridorReclaim = countWith({
            ...base,
            patternGroup: "Corridor reclaim",
          });
          const patternSqueezeBuild = countWith({
            ...base,
            patternGroup: "Squeeze pressure build",
          });
          const patternTrendCont = countWith({
            ...base,
            patternGroup: "Trend continuation",
          });
          const patternLateCycle = countWith({
            ...base,
            patternGroup: "Late-cycle / Overextended",
          });
          const patternUnclear = countWith({
            ...base,
            patternGroup: "Unclear / Chop",
          });

          // Groups
          const groupAll = countWith({ ...base, group: "ALL" });
          const groupTTSelected = countWith({ ...base, group: "TT_SELECTED" });
          const groupFutures = countWith({ ...base, group: "Futures" });

          // S&P Sectors (group + sector filters)
          const sectorAll = countWith({ ...base, sector: undefined });
          const spSectors = countWith({ ...base, group: "SP_Sectors" });
          const comm = countWith({ ...base, sector: "Communication Services" });
          const consDisc = countWith({
            ...base,
            sector: "Consumer Discretionary",
          });
          const consStaples = countWith({
            ...base,
            sector: "Consumer Staples",
          });
          const energy = countWith({ ...base, sector: "Energy" });
          const financials = countWith({ ...base, sector: "Financials" });
          const healthcare = countWith({ ...base, sector: "Healthcare" });
          const industrials = countWith({ ...base, sector: "Industrials" });
          const tech = countWith({ ...base, sector: "Information Technology" });
          const materials = countWith({ ...base, sector: "Basic Materials" });
          const realEstate = countWith({ ...base, sector: "Real Estate" });
          const utilities = countWith({ ...base, sector: "Utilities" });

          return {
            guidance: {
              ALL: guidanceAll,
              INITIATE: guidanceInitiate,
              CONSIDER: guidanceConsider,
              MONITOR: guidanceMonitor,
              WAIT: guidanceWait,
              EXIT_TRIM: guidanceExitTrim,
              OTHER: guidanceOther,
            },
            horizon: {
              ALL: horizonAll,
              SHORT_TERM: horizonShort,
              SWING: horizonSwing,
              POSITIONAL: horizonPos,
            },
            opp: {
              ALL: oppAll,
              ELIGIBLE: oppEligible,
              PRIME: oppPrime,
              WATCH: oppWatch,
              Q1: q1,
              Q2: q2,
              Q3: q3,
              Q4: q4,
            },
            specials: {
              THESIS: thesis,
              IN_SQUEEZE: inSqueeze,
              SQUEEZE_RELEASE: squeezeRelease,
              MOMENTUM_ELITE: momentumElite,
              WINNER_SIGNATURE: winnerSignature,
              FLIP_WATCH: flipWatch,
            },
            patterns: {
              SQUEEZE_MOMENTUM: patternSqueezeMomentum,
              MOMENTUM_ELITE: patternMomentumElite,
              CORRIDOR_RECLAIM: patternCorridorReclaim,
              SQUEEZE_BUILD: patternSqueezeBuild,
              TREND_CONT: patternTrendCont,
              LATE_CYCLE: patternLateCycle,
              UNCLEAR: patternUnclear,
            },
            kanban: {
              SETUP: kanbanSetup,
              ENTER: kanbanEnter,
              NEW: kanbanNew,
              HOLD: kanbanHold,
              DEFEND: kanbanDefend,
              TRIM: kanbanTrim,
              EXIT: kanbanExit,
            },
            groups: {
              ALL: groupAll,
              TT_SELECTED: groupTTSelected,
              Futures: groupFutures,
            },
            sectors: {
              ALL: sectorAll,
              SP_Sectors: spSectors,
              "Communication Services": comm,
              "Consumer Discretionary": consDisc,
              "Consumer Staples": consStaples,
              Energy: energy,
              Financials: financials,
              Healthcare: healthcare,
              Industrials: industrials,
              "Information Technology": tech,
              "Basic Materials": materials,
              "Real Estate": realEstate,
              Utilities: utilities,
            },
          };
        }, [allData, trades, filters, socialAdditions]);

        const pillLabelWithCount = (baseLabel, count) => {
          if (!Number.isFinite(count)) return baseLabel;
          return `${baseLabel} (${count})`;
        };

        const pill = (label, active, onClick, variant) => {
          const labelStr = String(label);
          const m = labelStr.match(/^(.*?)(?:\s*\((\d+)\))\s*$/);
          const baseLabel = (m ? m[1] : labelStr).trim();
          const count = m ? Number(m[2]) : null;
          const tip = PILL_TOOLTIPS[baseLabel] || null;
          const isTTSelected = variant === "tt-selected-pill";
          const btnClass = isTTSelected
            ? active
              ? "border-emerald-400 bg-emerald-500/25 text-emerald-200 ring-1 ring-emerald-400/30"
              : "border-emerald-500/30 bg-emerald-500/10 text-emerald-300 hover:bg-emerald-500/20 hover:text-emerald-100"
            : active
              ? "border-blue-400 bg-blue-500/20 text-blue-200"
              : "border-white/[0.06] bg-white/[0.03] text-[#6b7280] hover:text-white";
          const countClass = isTTSelected
            ? active
              ? "border-emerald-400/40 bg-emerald-400/10 text-emerald-100"
              : "border-emerald-500/30 bg-emerald-500/10 text-emerald-200"
            : active
              ? "border-blue-400/40 bg-blue-400/10 text-blue-100"
              : "border-white/[0.06] bg-white/[0.02] text-[#c8d2ff]";
          return (
            <div className="relative group">
              <button
                onClick={onClick}
                className={`px-3 py-1.5 rounded-lg border text-xs font-semibold transition-all ${btnClass}`}
              >
                <span className="inline-flex items-center gap-2">
                  {isTTSelected ? <span style={{fontSize:"11px"}}>✦</span> : null}
                  <span>{baseLabel}</span>
                  {Number.isFinite(count) ? (
                    <span
                      className={`px-1.5 py-0.5 rounded-md text-[10px] font-bold border ${countClass}`}
                      title={`${count} tickers`}
                    >
                      {count}
                    </span>
                  ) : null}
                </span>
              </button>
              {tip ? (
                <div className="pointer-events-none absolute left-1/2 top-full z-50 mt-2 hidden -translate-x-1/2 group-hover:block">
                  <div className="max-w-[280px] rounded-lg border border-white/[0.06] bg-[#0b1024] px-3 py-2 text-[11px] leading-snug text-[#c8d2ff] shadow-lg">
                    {tip}
                  </div>
                </div>
              ) : null}
            </div>
          );
        };

        const toggleBool = (key) => {
          const cur = filters[key] === true;
          onChange({ [key]: cur ? undefined : true });
        };

        const isThesisActive = () => {
          return isThesisModeActive(filters);
        };
        const toggleThesis = () => {
          const active = isThesisActive();
          try {
            localStorage.setItem("timedTrading_thesisAuto", active ? "0" : "1");
          } catch {}
          if (active) {
            // Reset only the preset fields (leave other filters intact)
            onChange({
              minRank: 0,
              minRR: 0,
              maxCompletion: 1.01,
              maxPhase: undefined,
            });
          } else {
            onChange({ ...THESIS_PRESET });
          }
        };

        return (
          <div className="mb-2">
            {/* Kanban Stages + Groups + S&P Sectors — compact flow */}
            <div className="flex flex-wrap gap-x-6 gap-y-2">
              <div className="space-y-1">
                <div className="text-[10px] text-[#4b5563] font-semibold">
                  Kanban Stages
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  {pill(
                    pillLabelWithCount("All", null),
                    !filters.kanbanStage,
                    () => onChange({ kanbanStage: undefined }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "📋 Setup",
                      pillCounts?.kanban?.SETUP,
                    ),
                    filters.kanbanStage === "setup",
                    () => onChange({ kanbanStage: "setup" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "🎯 Enter",
                      pillCounts?.kanban?.ENTER,
                    ),
                    filters.kanbanStage === "enter",
                    () => onChange({ kanbanStage: "enter" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "🆕 New",
                      pillCounts?.kanban?.NEW,
                    ),
                    filters.kanbanStage === "new",
                    () => onChange({ kanbanStage: "new" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "🔒 Hold",
                      pillCounts?.kanban?.HOLD,
                    ),
                    filters.kanbanStage === "hold",
                    () => onChange({ kanbanStage: "hold" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "🛡 Defend",
                      pillCounts?.kanban?.DEFEND,
                    ),
                    filters.kanbanStage === "defend",
                    () => onChange({ kanbanStage: "defend" }),
                  )}
                  {pill(
                    pillLabelWithCount("✂️ Trim", pillCounts?.kanban?.TRIM),
                    filters.kanbanStage === "trim",
                    () => onChange({ kanbanStage: "trim" }),
                  )}
                  {pill(
                    pillLabelWithCount("🚪 Exit", pillCounts?.kanban?.EXIT),
                    filters.kanbanStage === "exit",
                    () => onChange({ kanbanStage: "exit" }),
                  )}
                </div>
              </div>

              {/* Groups — immediately next to Kanban Stages */}
              <div className="space-y-1">
                <div className="text-[10px] text-[#4b5563] font-semibold">
                  Groups
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  {pill(
                    pillLabelWithCount("All", pillCounts?.groups?.ALL),
                    group === "ALL",
                    () => onChange({ group: "ALL" }),
                  )}
                  {pill(
                    "⭐ Saved",
                    group === "SAVED",
                    () => onChange({ group: "SAVED" }),
                  )}
                  {pill(
                    pillLabelWithCount("TT Selected", pillCounts?.groups?.TT_SELECTED),
                    group === "TT_SELECTED",
                    () => onChange({ group: "TT_SELECTED" }),
                    "tt-selected-pill",
                  )}
                  {pill(
                    pillLabelWithCount("📈 SP Sectors", pillCounts?.sectors?.SP_Sectors),
                    group === "SP_Sectors",
                    () => onChange({ group: group === "SP_Sectors" ? "ALL" : "SP_Sectors" }),
                  )}
                  {pill(
                    pillLabelWithCount("⚡ Futures", pillCounts?.groups?.Futures),
                    group === "Futures",
                    () => onChange({ group: group === "Futures" ? "ALL" : "Futures" }),
                  )}
                  {pill(
                    "➕ Added By Me",
                    group === "USER_ADDED",
                    () => onChange({ group: group === "USER_ADDED" ? "ALL" : "USER_ADDED" }),
                  )}
                </div>
              </div>

              <div className="space-y-1">
                <div className="text-[10px] text-[#4b5563] font-semibold">
                  S&amp;P Sectors
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  {pill(
                    pillLabelWithCount("All", pillCounts?.sectors?.ALL),
                    sector === "ALL",
                    () => onChange({ sector: undefined }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      "S&P Sectors",
                      pillCounts?.sectors?.SP_Sectors,
                    ),
                    group === "SP_Sectors",
                    () => onChange({ group: group === "SP_Sectors" ? "ALL" : "SP_Sectors" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Communication Services")} Comm`,
                      pillCounts?.sectors?.["Communication Services"],
                    ),
                    sector === "Communication Services",
                    () => onChange({ sector: "Communication Services" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Consumer Discretionary")} Cons Disc`,
                      pillCounts?.sectors?.["Consumer Discretionary"],
                    ),
                    sector === "Consumer Discretionary",
                    () => onChange({ sector: "Consumer Discretionary" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Consumer Staples")} Cons Staples`,
                      pillCounts?.sectors?.["Consumer Staples"],
                    ),
                    sector === "Consumer Staples",
                    () => onChange({ sector: "Consumer Staples" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Energy")} Energy`,
                      pillCounts?.sectors?.Energy,
                    ),
                    sector === "Energy",
                    () => onChange({ sector: "Energy" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Financials")} Financials`,
                      pillCounts?.sectors?.Financials,
                    ),
                    sector === "Financials",
                    () => onChange({ sector: "Financials" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Healthcare")} Health`,
                      pillCounts?.sectors?.Healthcare,
                    ),
                    sector === "Healthcare",
                    () => onChange({ sector: "Healthcare" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Industrials")} Industrials`,
                      pillCounts?.sectors?.Industrials,
                    ),
                    sector === "Industrials",
                    () => onChange({ sector: "Industrials" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Information Technology")} Tech`,
                      pillCounts?.sectors?.["Information Technology"],
                    ),
                    sector === "Information Technology",
                    () => onChange({ sector: "Information Technology" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Basic Materials")} Materials`,
                      pillCounts?.sectors?.["Basic Materials"],
                    ),
                    sector === "Basic Materials",
                    () => onChange({ sector: "Basic Materials" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Real Estate")} Real Estate`,
                      pillCounts?.sectors?.["Real Estate"],
                    ),
                    sector === "Real Estate",
                    () => onChange({ sector: "Real Estate" }),
                  )}
                  {pill(
                    pillLabelWithCount(
                      `${sectorEmoji("Utilities")} Utilities`,
                      pillCounts?.sectors?.Utilities,
                    ),
                    sector === "Utilities",
                    () => onChange({ sector: "Utilities" }),
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      }

      function ActiveMovesSnapshotPanel({
        tickers = [],
        rankPositions = {},
        onSelectTicker = null,
        allData = null,
        defaultLimit = 12,
        storageKey = "timedTrading_activeMovesSnapshot_v1",
        title = "Active Moves (snapshot)",
      }) {
        // Hover tooltip (replaces tiny default browser "title" tooltip)
        const [hoverTip, setHoverTip] = React.useState(null);
        const [hoverTipPos, setHoverTipPos] = React.useState({ x: 0, y: 0 });

        const updateHoverTipPos = React.useCallback((e) => {
          try {
            const vw =
              typeof window !== "undefined" ? Number(window.innerWidth) : 1200;
            const vh =
              typeof window !== "undefined" ? Number(window.innerHeight) : 800;
            const MAX_W = 360;
            const MAX_H = 220; // conservative clamp (multi-line tips)
            const PAD = 12;
            const x0 = Number(e?.clientX) || 0;
            const y0 = Number(e?.clientY) || 0;
            const x = Math.max(
              PAD,
              Math.min(x0 + 12, Math.max(PAD, vw - MAX_W - PAD)),
            );
            const y = Math.max(
              PAD,
              Math.min(y0 + 12, Math.max(PAD, vh - MAX_H - PAD)),
            );
            setHoverTipPos({ x, y });
          } catch {
            // ignore
          }
        }, []);

        const showHoverTip = React.useCallback(
          (text, e) => {
            const t = String(text || "").trim();
            if (!t) return;
            updateHoverTipPos(e);
            setHoverTip(t);
          },
          [updateHoverTipPos],
        );

        const hideHoverTip = React.useCallback(() => {
          setHoverTip(null);
        }, []);

        const [snap, setSnap] = React.useState(() => {
          try {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || !Array.isArray(parsed.items)) return null;
            return parsed;
          } catch {
            return null;
          }
        });

        const buildSnapshot = React.useCallback(
          (sourceTickers) => {
            const list = Array.isArray(sourceTickers) ? sourceTickers : [];
            const items = [];
            for (const t of list) {
              if (!t?.ticker) continue;
              const mv = getMoveStatusInfo(t);
              // Do not include items without an explicit move_status (prevents snapshot/right-rail mismatch)
              if (!mv.hasMoveStatus) continue;
              if (mv.status !== "ACTIVE") continue;
              const triggerTs = Number(t?.trigger_ts);
              if (!Number.isFinite(triggerTs) || triggerTs <= 0) continue; // only "real" moves
              const sym = String(t.ticker).toUpperCase();
              const rp =
                getRankPositionFromMap(rankPositions, sym) ??
                Number(t?.rank_position);
              const inCorridor = !!entryType(t)?.corridor;
              const rr = Number(t?.rr);
              const flags =
                t?.flags && typeof t.flags === "object" ? t.flags : {};
              const momentumElite = !!flags.momentum_elite;
              const sqRelease = !!flags.sq30_release;
              const inSqueeze = !!flags.sq30_on && !flags.sq30_release;
              const thesis = flags.thesis_match === true;
              const prime = isPrimeBubble(t);
              const winnerSig = isWinnerSignature(t);
              const flipWatch = !!flags.flip_watch;
              // Use server-provided SL/TP directly (no client-side inflation)
              const sl = numFromAny(t?.sl ?? t?.sl_price ?? t?.stop_loss ?? t?.stop ?? t?.trade?.sl ?? t?.trade?.sl_price);
              const tp = numFromAny(t?.tp ?? t?.tp_trim);
              const eta = computeEtaDays(t);
              const price = Number(t?.price ?? t?.close ?? t?.c ?? t?.last);
              const intent = classifyEntryIntent(t);
              const comp = completionForSize(t);
              const progress = Number.isFinite(comp) ? comp : null;
              const phase = Number(t?.phase_pct);
              const age = formatAgeFromTs(triggerTs);
              items.push({
                sym,
                rp: Number.isFinite(rp) ? rp : null,
                inCorridor,
                rr: Number.isFinite(rr) ? rr : null,
                progress: Number.isFinite(progress) ? progress : null,
                phase: Number.isFinite(phase) ? phase : null,
                age,
                momentumElite,
                sqRelease,
                inSqueeze,
                thesis,
                prime,
                winnerSig,
                flipWatch,
                sl: Number.isFinite(sl) && sl > 0 ? sl : null,
                tp: Number.isFinite(tp) && tp > 0 ? tp : null,
                eta: Number.isFinite(eta) && eta > 0 ? eta : null,
                price: Number.isFinite(price) && price > 0 ? price : null,
                intent,
                t,
              });
            }
            items.sort((a, b) => {
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              if (a.rp != null) return -1;
              if (b.rp != null) return 1;
              return a.sym.localeCompare(b.sym);
            });
            const out = {
              createdAt: Date.now(),
              items: items.slice(0, Math.max(1, defaultLimit)),
            };
            try {
              localStorage.setItem(storageKey, JSON.stringify(out));
            } catch {}
            return out;
          },
          [defaultLimit, rankPositions, storageKey],
        );

        const MAX_SNAPSHOT_AGE_MS = 60 * 60 * 1000; // 60 minutes

        // Initialize snapshot once when we have data (but do NOT keep it in sync).
        React.useEffect(() => {
          if (snap && Array.isArray(snap.items) && snap.items.length > 0) {
            const ageOk =
              Number.isFinite(Number(snap.createdAt)) &&
              Date.now() - Number(snap.createdAt) <= MAX_SNAPSHOT_AGE_MS;
            if (ageOk) return;
          }
          if (!Array.isArray(tickers) || tickers.length === 0) return;
          setSnap(buildSnapshot(tickers));
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [tickers, buildSnapshot]);

        const onRefresh = React.useCallback(() => {
          setSnap(buildSnapshot(tickers));
        }, [buildSnapshot, tickers]);

        const onClear = React.useCallback(() => {
          setSnap(null);
          try {
            localStorage.removeItem(storageKey);
          } catch {}
        }, [storageKey]);

        const asOf = snap?.createdAt ? new Date(Number(snap.createdAt)) : null;
        const rows = Array.isArray(snap?.items) ? snap.items : [];

        const grouped = React.useMemo(() => {
          const groups = {};
          for (const r of rows) {
            const g = String(r?.intent?.group || "Unclear / Chop");
            if (!groups[g]) groups[g] = [];
            groups[g].push(r);
          }
          const order = [
            "Squeeze → Momentum",
            "Momentum Elite",
            "Corridor reclaim",
            "Trend continuation",
            "Squeeze pressure build",
            "Late-cycle / Overextended",
            "Unclear / Chop",
          ];
          const keys = Object.keys(groups);
          keys.sort((a, b) => {
            const ia = order.indexOf(a);
            const ib = order.indexOf(b);
            if (ia !== -1 && ib !== -1) return ia - ib;
            if (ia !== -1) return -1;
            if (ib !== -1) return 1;
            return a.localeCompare(b);
          });
          // Sort items within each group alphabetically by ticker
          for (const k of keys) {
            groups[k].sort((a, b) => String(a?.sym || "").localeCompare(String(b?.sym || "")));
          }
          return keys.map((k) => ({ group: k, items: groups[k] }));
        }, [rows]);

        const actionPill = (action) => {
          const a = String(action || "").toUpperCase();
          if (a === "ENTRY")
            return {
              label: "ENTRY",
              cls: "bg-teal-500/15 text-teal-300 border-teal-500/40",
            };
          if (a === "EXIT")
            return {
              label: "EXIT",
              cls: "bg-rose-500/15 text-rose-300 border-rose-500/40",
            };
          if (a === "WAIT")
            return {
              label: "WAIT",
              cls: "bg-yellow-500/10 text-yellow-200 border-yellow-500/30",
            };
          return {
            label: "HOLD",
            cls: "bg-blue-500/10 text-blue-200 border-blue-500/30",
          };
        };

        if (rows.length === 0) {
          return (
            <div className="text-xs text-[#4b5563] p-3 text-center">
              No open positions yet
            </div>
          );
        }

        return (
          <>
            <div className="space-y-2">
              {grouped.map((g) => (
                <div key={`active-group-${g.group}`}>
                  <div className="flex items-center justify-between mb-1">
                    <div className="text-[10px] font-semibold text-[#8b95a5]">
                      {g.group}
                    </div>
                    <div className="text-[10px] text-[#4b5563]">
                      {g.items.length}
                    </div>
                  </div>
                  {/* ── Compact position rows: ticker | dir | price | SL/TP | progress ── */}
                  <div className="flex flex-wrap gap-1">
                    {g.items.map((r) => {
                    const mv = getMoveStatusInfo(r.t);
                    const dir = mv.side || getDirection(r.t)?.text || "";
                    const isShort = dir === "SHORT";
                    const p = r.progress != null ? Math.max(0, Math.min(1, r.progress)) : null;
                    const pPct = p != null ? Math.round(p * 100) : null;
                    const pxText = r.price != null ? `$${r.price.toFixed(2)}` : "";
                    const slText = r.sl != null ? `$${r.sl.toFixed(2)}` : "";
                    const tpText = r.tp != null ? `$${r.tp.toFixed(2)}` : "";
                    return (
                      <button
                        key={`active-move-${r.sym}`}
                        className="flex items-center gap-1.5 px-2 py-1 rounded border border-white/[0.06] hover:border-white/[0.15] bg-white/[0.02] hover:bg-white/[0.05] transition-all text-left"
                        onClick={() => { if (typeof onSelectTicker === "function") onSelectTicker(r.sym); }}
                        title={`${r.sym} ${dir} | ${pxText} | SL ${slText} TP ${tpText} | ${pPct != null ? pPct + "%" : "—"}`}
                      >
                        <span className="text-[11px] font-bold text-white">{r.sym}</span>
                        <span className={`text-[9px] font-bold ${isShort ? "text-rose-400" : "text-cyan-400"}`}>{isShort ? "S" : "L"}</span>
                        {pxText && <span className="text-[10px] text-[#8b95a5] tabular-nums">{pxText}</span>}
                        {pPct != null && (
                          <span className="inline-block w-[24px] h-[4px] rounded-full bg-white/[0.06] overflow-hidden">
                            <span className={`block h-full rounded-full ${pPct >= 80 ? "bg-teal-400" : pPct >= 40 ? "bg-cyan-400/60" : "bg-amber-400/50"}`} style={{ width: `${pPct}%` }} />
                          </span>
                        )}
                      </button>
                    );
                    })}
                  </div>
                </div>
              ))}
            </div>

            {hoverTip && (
              <div
                className="fixed z-[9999] max-w-[360px] pointer-events-none border border-white/[0.10] rounded-2xl shadow-lg px-3 py-2 text-[12px] leading-snug text-[#d1d5db]"
                style={{ left: hoverTipPos.x, top: hoverTipPos.y, background: "rgba(255,255,255,0.06)", backdropFilter: "blur(24px) saturate(1.4)", WebkitBackdropFilter: "blur(24px) saturate(1.4)", boxShadow: "0 8px 32px rgba(0,0,0,0.45), inset 0 0.5px 0 rgba(255,255,255,0.08)" }}
                role="tooltip"
              >
                {hoverTip}
              </div>
            )}
          </>
        );
      }

      // Admin role check — reads from DOM at call time so it works
      // both before and after auth-gate sets the attribute.
      Object.defineProperty(window, '_ttIsAdmin', {
        get() { return document.body.dataset.userRole === "admin"; },
        configurable: true,
      });

      // ─────────────────────────────────────────────────────────────
      // Shared compact card renderer (used by both Kanban + Viewport)
      // ─────────────────────────────────────────────────────────────
      const CompactCard = React.memo(function CompactCard({ t, onSelectTicker, savedTickers, toggleSavedTicker, tradeByTicker, addingTicker }) {
          const state = String(t?.state || "");
          const htfBull = state.startsWith("HTF_BULL");
          const htfBear = state.startsWith("HTF_BEAR");
          const ltfPullback = state.includes("PULLBACK");
          const ltfBull = state.includes("LTF_BULL");
          const ltfBear = state.includes("LTF_BEAR");
          const isBullish = htfBull;
          const sym = String(t?.ticker || "").toUpperCase();
          const openTrade = tradeByTicker?.get?.(sym) || null;
          const statusUp = String(openTrade?.status || "").toUpperCase();
          const hasOpenTrade = openTrade && (
            ["OPEN", "TP_HIT_TRIM"].includes(statusUp) ||
            (!(openTrade.exit_ts ?? openTrade.exitTs) && statusUp !== "WIN" && statusUp !== "LOSS")
          );
          let dir = isBullish ? "LONG" : "SHORT";
          if (hasOpenTrade) {
            const d = String(openTrade.direction || "").toUpperCase();
            if (d === "LONG" || d === "SHORT") dir = d;
          }
          // Also check ticker-level position direction (from server)
          if (!hasOpenTrade && t?.has_open_position) {
            const pd = String(t?.position_direction || "").toUpperCase();
            if (pd === "LONG" || pd === "SHORT") dir = pd;
          }
          const biasLabel = (() => {
            // When there's an open trade, show the trade direction as bias
            if (hasOpenTrade || t?.has_open_position) return dir;
            if (htfBull && ltfBull) return "LONG";
            if (htfBull && ltfPullback) return "PULLBACK";
            if (htfBull && ltfBear) return "CAUTION";
            if (htfBear && ltfBear) return "SHORT";
            if (htfBear && ltfPullback) return "BOUNCE";
            if (htfBear && ltfBull) return "CAUTION";
            if (!state || state === "NEUTRAL") return "NEUTRAL";
            return dir;
          })();
          // Display label: use Bull/Bear so pills don't conflict with L/S badges
          const biasLabelDisplay = biasLabel === "LONG" ? "Bull" : biasLabel === "SHORT" ? "Bear" : biasLabel;
          const biasPillCls = (() => {
            if (biasLabel === "LONG") return "bg-cyan-400/20 text-cyan-200 border-cyan-400/50";
            if (biasLabel === "SHORT") return "bg-rose-500/20 text-rose-200 border-rose-400/50";
            if (biasLabel === "PULLBACK" || biasLabel === "BOUNCE") return "bg-amber-500/20 text-amber-200 border-amber-400/50";
            if (biasLabel === "CAUTION") return "bg-orange-500/20 text-orange-200 border-orange-400/50";
            return "bg-slate-500/20 text-slate-200 border-slate-400/50";
          })();
          const stage = String(t?.kanban_stage || "");
          const flags = t?.flags || {};
          const score = Number(rankScoreForTicker(t)) || Number(t?.score ?? t?.flip_watch_score ?? t?.weighted_score);
          const price = Number(t?.price ?? t?.close);

          // Use position SL/TP when available (correct for SHORT trades), else fall back to ticker SL/TP
          const hasPos = !!t?.has_open_position;
          const posDir = hasPos ? String(t?.position_direction || "").toUpperCase() : null;
          const slRaw = hasPos && Number.isFinite(Number(t?.position_sl)) && Number(t?.position_sl) > 0
            ? Number(t.position_sl)
            : Number(t?.sl ?? t?.sl_price ?? t?.stop_loss ?? t?.stop);
          const tpRaw = hasPos && Number.isFinite(Number(t?.position_tp)) && Number(t?.position_tp) > 0
            ? Number(t.position_tp)
            : numFromAny(t?.tp ?? t?.tp_trim);

          // Direction for SL/TP sanity: use `dir` which already accounts for
          // trade direction, position direction, and ticker bias (lines 10892-10901)
          const effectiveDir = dir;
          const slSane = (() => {
            if (!Number.isFinite(slRaw) || slRaw <= 0 || !Number.isFinite(price) || price <= 0) return null;
            if (dir === "LONG" && slRaw >= price) return null;
            if (dir === "SHORT" && slRaw <= price) return null;
            return slRaw;
          })();
          const tpSane = (() => {
            if (!Number.isFinite(tpRaw) || tpRaw <= 0 || !Number.isFinite(price) || price <= 0) return null;
            if (dir === "LONG" && tpRaw <= price) return null;
            if (dir === "SHORT" && tpRaw >= price) return null;
            return tpRaw;
          })();
          const sl = slSane;
          const tp = tpSane;

          // R:R only meaningful when both SL and TP are present
          const rrNow = (() => {
            if (sl == null || tp == null) return null; // No TP or SL → no R:R
            if (!Number.isFinite(price) || price <= 0) return null;
            const risk = Math.abs(price - sl);
            const reward = Math.abs(tp - price);
            if (risk > 0) return reward / risk;
            return null;
          })();

          const isActiveTrade =
            hasOpenTrade ||
            stage === "just_entered" || stage === "hold" || stage === "defend" ||
            stage === "trim" || stage === "exit";

          // Entry price: prefer the open trade's trail-corrected entry price (from /timed/trades)
          // over the ticker payload's entry_price (from scoring snapshot, can be stale).
          let entryPrice = null;
          if (isActiveTrade && openTrade) {
            const ep = Number(openTrade.entryPrice ?? openTrade.entry_price) || 0;
            if (ep > 0) entryPrice = ep;
          }
          // Fallback: use ticker payload's entry_price if trade object doesn't have one
          if (!entryPrice && isActiveTrade) {
            const entryPriceRaw = numFromAny(t?.entry_price);
            if (Number.isFinite(entryPriceRaw) && entryPriceRaw > 0) entryPrice = entryPriceRaw;
          }
          const entryChangePct =
            Number.isFinite(entryPrice) && entryPrice > 0 && Number.isFinite(price) && price > 0
              ? dir === "LONG"
                ? ((price - entryPrice) / entryPrice) * 100
                : ((entryPrice - price) / entryPrice) * 100
              : null;

          // Phoenix-inspired swing fields
          const eqScore = Number(t?.entry_quality?.score) || 0;
          const volTier = String(t?.volatility_tier || "");
          const swingDir = t?.swing_consensus?.direction || null;
          const swingBullCt = Number(t?.swing_consensus?.bullish_count) || 0;
          const swingBearCt = Number(t?.swing_consensus?.bearish_count) || 0;
          const freshCrossTf = t?.swing_consensus?.freshest_cross_tf || null;
          const regimeCombined = t?.regime?.combined || null;
          const regimeLabel = {
            STRONG_BULL: "Strong Bull", EARLY_BULL: "Early Bull", LATE_BULL: "Late Bull",
            COUNTER_TREND_BULL: "CT Bull", NEUTRAL: "Neutral", COUNTER_TREND_BEAR: "CT Bear",
            EARLY_BEAR: "Early Bear", LATE_BEAR: "Late Bear", STRONG_BEAR: "Strong Bear",
          }[regimeCombined] || null;

          // v3: Regime classification + RVOL + Kijun SL + Ticker Profile
          const v3Regime = String(t?.regime_class || "");
          const v3RegimeScore = Number(t?.regime_score) || 0;
          const v3BehaviorType = String(t?._ticker_profile?.behavior_type || "");
          const v3SlMult = Number(t?._ticker_profile?.sl_mult) || 0;
          const v3TpMult = Number(t?._ticker_profile?.tp_mult) || 0;
          const v3RvolMap = t?.rvol_map || {};
          const v3Rvol30 = Number(v3RvolMap?.["30"]?.vr) || 0;
          const v3Rvol1H = Number(v3RvolMap?.["60"]?.vr) || 0;
          const v3RvolBest = Math.max(v3Rvol30, v3Rvol1H) || 0;
          let v3KijunSL = dir === "LONG"
            ? Number(t?.ichimoku_d?.kijunSL_long) || null
            : Number(t?.ichimoku_d?.kijunSL_short) || null;
          // Sanity: hide Kijun when >50% away from price (avoids wrong values like K754 for $394)
          if (v3KijunSL != null && Number.isFinite(price) && price > 0) {
            const pctAway = Math.abs(v3KijunSL - price) / price;
            if (pctAway > 0.5) v3KijunSL = null;
          }
          const v3BlockReason = String(t?.__execution_block_reason || t?.__entry_block_reason || "");
          const v3BlockLabel = {
            rvol_dead_zone: "Low Volume",
            shorts_blocked_in_chop: "No Shorts (Choppy)",
            htf_below_regime_floor: "Score Too Low",
            loss_streak_cooldown: "Loss Cooldown",
            "rr_too_low": "R:R Too Low",
            move_too_advanced: "Move Advanced",
            fuel_exhausted: "Fuel Exhausted",
            entry_quality_too_low: "Quality Low",
            trigger_stale: "Signal Stale",
            rsi_1h_overbought: "RSI Overbought",
            rsi_1h_oversold: "RSI Oversold",
            price_below_sl_long: "Below SL",
            price_too_close_to_sl: "Near SL",
            st_support_weak_bull: "ST Weak",
            st_support_weak_bear: "ST Weak",
          }[v3BlockReason.split(",")[0]?.split(":")[0]] || null;

          // Emoji badges
          const badges = [];
          const _isPrime = isPrimeBubble(t);
          const _isEntryZone = !!flags.flip_watch;
          const _isPrimeEntry = _isPrime && _isEntryZone;
          if (_isPrime) badges.push("💎");
          if (_isEntryZone) badges.push("🎯");
          if (flags.momentum_elite) badges.push("🔥");
          if (flags.sq30_release) badges.push("⚡");
          if (flags.sq30_on && !flags.sq30_release) badges.push("🧨");
          const _earningsEvt = window._ttEarningsMap?.[sym];
          if (_earningsEvt) badges.push("📅");

          // Daily change — single source: getDailyChange() which prioritises
          // Alpaca live feed (_live_daily_change_pct) > scoring snapshot > raw fields.
          const dailyResult = getDailyChange(t) || {};
          const dayPct = Number.isFinite(dailyResult.dayPct) ? dailyResult.dayPct : null;
          const dayChg = Number.isFinite(dailyResult.dayChg) ? dailyResult.dayChg : null;

          const skin = getCardSkin(t);
          const badgesText = badges.length > 0 ? badges.join("") : "";
          const dirPillCls = biasPillCls;
          const dirAccentCls = dir === "LONG" ? "border-l-4 border-l-cyan-400" : "border-l-4 border-l-red-500";
          const dirOutlineCls = dir === "LONG" ? "border border-cyan-400/40" : "border border-rose-500/40";
          const isActionLane = ["enter_now", "trim", "exit"].includes(stage);
          const pulseCls = isActionLane ? (dir === "LONG" ? "card-pulse" : "card-pulse-short") : "";

          // ── Card background: deep glass (fish-tank) with daily-change tint ──
          const glassBg = "rgba(10,16,28,0.45)";
          const cardBgImage = [
            skin?.bgImage || null,
            "linear-gradient(170deg, rgba(255,255,255,0.07) 0%, rgba(255,255,255,0.02) 25%, transparent 55%)",
            "linear-gradient(to bottom, rgba(120,160,255,0.04) 0%, transparent 40%, rgba(0,0,0,0.15) 100%)",
            `linear-gradient(0deg, ${glassBg}, ${glassBg})`,
          ].filter(Boolean).join(", ");

          // ── Prime + Entry Zone highlight ──
          const primeEntryCls = _isPrimeEntry ? "prime-entry-card " : "";
          const primeEntryBorder = _isPrimeEntry
            ? "border-amber-400/60 "
            : (dir === "LONG" ? "border-cyan-400/20 " : "border-rose-400/20 ");
          const primeEntryShadow = _isPrimeEntry
            ? "0 0 12px rgba(251,191,36,0.25), 0 4px 12px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.12), inset 0 -1px 2px rgba(0,0,0,0.3)"
            : "0 4px 12px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.12), inset 0 -1px 2px rgba(0,0,0,0.3)";

          // Extended hours change (AH/Pre-market) — only show when market is closed, skip crypto (24/7)
          const _isCrypto = sym === "BTCUSD" || sym === "ETHUSD";
          const _mktOpen = isNyRegularMarketOpen();
          const ahPct = (_isCrypto || _mktOpen) ? null : Number(t?._ah_change_pct);
          const ahChg = (_isCrypto || _mktOpen) ? null : Number(t?._ah_change);
          const hasAH = Number.isFinite(ahPct) && ahPct !== 0;

          // Lane reason text
          const laneReason = (() => {
            if (openTrade) {
              const trimPct = Number(openTrade.trimmed_pct ?? openTrade.trimmedPct ?? 0);
              const trimPx = Number(openTrade.trim_price ?? openTrade.trimPrice) || 0;
              const exitPx = Number(openTrade.exit_price ?? openTrade.exitPrice) || 0;
              const pnlPct = Number(openTrade.pnl_pct ?? openTrade.pnlPct) || 0;
              const tradeStatus = String(openTrade.status || "").toUpperCase();
              const tradeClosed = tradeStatus === "WIN" || tradeStatus === "LOSS" || !!(openTrade.exit_ts ?? openTrade.exitTs);
              if (tradeClosed) {
                const exitTs = Number(openTrade.exit_ts ?? openTrade.exitTs ?? 0);
                const hoursSinceExit = exitTs > 0 ? (Date.now() - exitTs) / 3600000 : Infinity;
                if (hoursSinceExit <= 48) {
                  const pxStr = exitPx > 0 ? ` @ $${exitPx.toFixed(2)}` : "";
                  const pnlStr = Number.isFinite(pnlPct) && pnlPct !== 0 ? ` (${pnlPct >= 0 ? "+" : ""}${pnlPct.toFixed(1)}%)` : "";
                  return { text: `Exited${pxStr}${pnlStr}`, cls: tradeStatus === "WIN" ? "text-[#00e676]" : "text-rose-400" };
                }
              } else if (hasOpenTrade && trimPct > 0) {
                const pxStr = trimPx > 0 ? ` @ $${trimPx.toFixed(2)}` : "";
                return { text: `Trimmed ${(trimPct * 100).toFixed(0)}%${pxStr}`, cls: "text-yellow-400" };
              }
              if (isActiveTrade && Number.isFinite(entryPrice)) {
                const epStr = `Entry $${entryPrice.toFixed(2)}`;
                const chgStr = Number.isFinite(entryChangePct) ? ` (${entryChangePct >= 0 ? "+" : ""}${entryChangePct.toFixed(2)}%)` : "";
                return { text: `${epStr}${chgStr}`, cls: Number.isFinite(entryChangePct) && entryChangePct >= 0 ? "text-[#00e676]" : "text-rose-400" };
              }
            }
            if ((stage === "enter" || stage === "enter_now") && (t?.__execution_block_reason || t?.__entry_block_reason)) {
              return { text: formatBlockReason(t.__execution_block_reason || t.__entry_block_reason), cls: "text-amber-300/80" };
            }
            return null;
          })();

          return (
            <div
              key={`card-${t.ticker}`}
              role="button"
              tabIndex={0}
              onClick={() => {
                if (typeof onSelectTicker === "function") onSelectTicker(sym);
              }}
              onKeyDown={(e) => {
                if (e.key === "Enter" || e.key === " ") {
                  e.preventDefault();
                  if (typeof onSelectTicker === "function") onSelectTicker(sym);
                }
              }}
              className={
                "w-full text-left rounded-lg cursor-pointer hover:brightness-110 relative overflow-hidden border flex flex-col " +
                primeEntryBorder +
                primeEntryCls +
                pulseCls + " " + (skin?.dayEdgeClass || "") + " " + (skin?.intensityPulse || "")
              }
              style={{
                backgroundImage: cardBgImage,
                boxShadow: primeEntryShadow,
                height: "142px",
              }}
            >
              {/* ── Direction accent strip ── */}
              <div className="absolute left-0 top-0 bottom-0 w-[3px] rounded-l-lg" style={{
                background: dir === "LONG"
                  ? "linear-gradient(to bottom, #22d3ee, #06b6d4)"
                  : "linear-gradient(to bottom, #fb7185, #e11d48)",
                boxShadow: dir === "LONG"
                  ? "0 0 6px rgba(34,211,238,0.4)"
                  : "0 0 6px rgba(225,29,72,0.4)",
              }} />
              {/* ── Sparkline background ── */}
              {t._sparkline && t._sparkline.length >= 3 && (
                <div className="absolute inset-0 pointer-events-none" style={{ zIndex: 0 }}>
                  <Sparkline data={(() => {
                    const lp = Number(t._live_price || t.price);
                    const sp = t._sparkline;
                    if (lp > 0 && sp.length > 0 && Math.abs(lp - sp[sp.length - 1]) / sp[sp.length - 1] > 0.005) {
                      return [...sp, lp];
                    }
                    return sp;
                  })()} width={200} height={142} bgMode />
                </div>
              )}
              <div className="relative flex flex-col flex-1 min-h-0" style={{ zIndex: 1 }}>
              <div className="absolute inset-0 pointer-events-none rounded-lg" style={{
                background: "linear-gradient(to bottom, rgba(0,0,0,0.30) 0%, rgba(0,0,0,0.05) 45%, rgba(0,0,0,0.40) 100%)",
              }} />

              {/* ── Row 1: Star, Ticker, TT, LONG/SHORT | Price + Daily Chg ── */}
              <div className="relative flex items-center justify-between px-2 pt-1.5 pb-0" style={{ zIndex: 1 }}>
                <div className="flex items-center gap-1.5 min-w-0">
                  {toggleSavedTicker && (
                    <button
                      onClick={(e) => { e.preventDefault(); e.stopPropagation(); toggleSavedTicker(sym); }}
                      onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); }}
                      className={`shrink-0 text-[13px] hover:scale-110 transition-transform ${savedTickers?.has?.(sym) ? "text-amber-400" : "text-[#4b5563] hover:text-amber-300"}`}
                      title={savedTickers?.has?.(sym) ? "Remove from Saved" : "Add to Saved"}
                    >&#9733;</button>
                  )}
                  {(() => {
                    const ctx = t?.context && typeof t.context === "object" ? t.context : null;
                    const ctxName = ctx?.name || "";
                    const ctxSector = ctx?.sector || "";
                    const ctxIndustry = ctx?.industry || "";
                    const ctxMCap = ctx?.market_cap && Number.isFinite(Number(ctx.market_cap)) && Number(ctx.market_cap) > 0
                      ? (Number(ctx.market_cap) >= 1e12 ? `$${(Number(ctx.market_cap) / 1e12).toFixed(1)}T`
                        : Number(ctx.market_cap) >= 1e9 ? `$${(Number(ctx.market_cap) / 1e9).toFixed(1)}B`
                        : Number(ctx.market_cap) >= 1e6 ? `$${(Number(ctx.market_cap) / 1e6).toFixed(0)}M`
                        : `$${Number(ctx.market_cap).toLocaleString()}`)
                      : "";
                    const tipParts = [ctxName, ctxSector && ctxIndustry ? `${ctxSector} / ${ctxIndustry}` : ctxSector || ctxIndustry, ctxMCap ? `MCap: ${ctxMCap}` : ""].filter(Boolean);
                    const tip = tipParts.length > 0 ? tipParts.join("\n") : sym;
                    return <span className={`text-[13px] font-bold shrink-0 ${_isPrimeEntry ? "text-amber-300" : "text-white"}`} title={tip}>{sym}</span>;
                  })()}
                  {isTickerTTSelected(sym) && (
                    <span className="inline-flex items-center justify-center px-1.5 py-px rounded text-[9px] font-bold shrink-0 tracking-wide bg-emerald-500/35 text-emerald-200 border border-emerald-400/50" style={{ textShadow: "0 0 6px rgba(16,185,129,0.4)" }} title="TT Selected">TT</span>
                  )}
                  <span className={`inline-flex items-center justify-center px-1.5 py-px rounded text-[9px] font-black shrink-0 tracking-wide ${dir === "LONG" ? "bg-cyan-500/80 text-white ring-1 ring-cyan-300/60" : "bg-rose-600/80 text-white ring-1 ring-rose-400/60"}`}>{dir}</span>
                </div>
                {window._ttIsPro && (
                  <div className="flex flex-col items-end shrink-0 ml-1">
                    <span className="text-white font-bold text-[13px] tabular-nums leading-tight" style={{ textShadow: "0 1px 3px rgba(0,0,0,0.8)" }}>
                      {Number.isFinite(price) ? `$${price.toFixed(2)}` : "—"}
                    </span>
                    {Number.isFinite(dayPct) && (
                      <span className="text-[11px] font-bold tabular-nums leading-tight"
                        style={{
                          color: dayPct >= 0
                            ? (Math.abs(dayPct) >= 3 ? "#4ade80" : "#00e676")
                            : (Math.abs(dayPct) >= 3 ? "#fb7185" : "#f87171"),
                          textShadow: "0 1px 4px rgba(0,0,0,0.7)",
                        }}>
                        {dayPct >= 0 ? "+" : ""}{dayPct.toFixed(2)}%
                        {Number.isFinite(dayChg) ? ` (${dayChg >= 0 ? "+" : "-"}$${Math.abs(dayChg).toFixed(2)})` : ""}
                      </span>
                    )}
                  </div>
                )}
              </div>

              {/* ── Row 2: Badges, bias pill, regime, RVOL | EXT Chg% ── */}
              <div className="relative flex items-center justify-between px-2 py-0.5" style={{ zIndex: 1 }}>
                <div className="flex items-center gap-1 min-w-0">
                  {badgesText && <span className="text-[10px] shrink-0">{badgesText}</span>}
                  <span className={`px-1 py-px rounded border text-[9px] font-extrabold tracking-wide shrink-0 ${dirPillCls}`} title={state}>
                    {biasLabelDisplay}
                  </span>
                  {v3Regime && (
                    <span className={`px-1 py-px rounded text-[8px] font-bold tracking-wide shrink-0 ${
                      v3Regime === "TRENDING" ? "bg-emerald-500/20 text-emerald-300 border border-emerald-500/40"
                      : v3Regime === "CHOPPY" ? "bg-rose-500/20 text-rose-300 border border-rose-500/40"
                      : "bg-amber-500/20 text-amber-300 border border-amber-500/40"
                    }`} title={`Regime: ${v3Regime} (score ${v3RegimeScore})`}>
                      {v3Regime === "TRENDING" ? "TRD" : v3Regime === "CHOPPY" ? "CHP" : "TRN"}
                    </span>
                  )}
                  {v3RvolBest > 0 && (
                    <span className={`text-[8px] font-bold tabular-nums shrink-0 ${
                      v3RvolBest >= 1.5 ? "text-emerald-400" : v3RvolBest >= 0.8 ? "text-gray-400" : "text-rose-400"
                    }`} title={`RVOL: ${v3RvolBest.toFixed(2)}x (30m: ${v3Rvol30.toFixed(2)}, 1H: ${v3Rvol1H.toFixed(2)})`}>
                      V{v3RvolBest.toFixed(1)}
                    </span>
                  )}
                  {v3BehaviorType && (
                    <span className={`px-1 py-px rounded text-[7px] font-bold tracking-wide shrink-0 ${
                      v3BehaviorType === "MOMENTUM" ? "bg-blue-500/20 text-blue-300 border border-blue-500/30"
                      : v3BehaviorType === "MEAN_REVERT" ? "bg-purple-500/20 text-purple-300 border border-purple-500/30"
                      : "bg-gray-500/20 text-gray-400 border border-gray-500/30"
                    }`} title={`Behavior: ${v3BehaviorType}${v3SlMult ? ` | SL×${v3SlMult}` : ""}${v3TpMult ? ` TP×${v3TpMult}` : ""}`}>
                      {v3BehaviorType === "MOMENTUM" ? "MOM" : v3BehaviorType === "MEAN_REVERT" ? "MR" : "MIX"}
                    </span>
                  )}
                </div>
                {window._ttIsPro && hasAH && (
                  <span className={`text-[9px] font-medium tabular-nums leading-tight shrink-0 ml-1 ${ahPct >= 0 ? "text-[#00e676]" : "text-rose-400"}`}>
                    <span className="text-[8px] text-gray-400 mr-0.5">EXT</span>
                    {ahPct >= 0 ? "+" : ""}{ahPct.toFixed(2)}%
                  </span>
                )}
              </div>

              {/* ── Row 3: Score, R:R, Alignment | SL, TP (Pro only) ── */}
              {!window._ttIsPro ? (
                <div className="relative flex items-center justify-center px-2 py-1" style={{ zIndex: 1 }}>
                  <span className="text-[10px] text-gray-500 font-medium flex items-center gap-1">
                    <svg className="w-3 h-3 text-amber-400/70" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/></svg>
                    <span className="text-amber-400/80 font-semibold">Score, SL/TP, R:R</span>
                    <span className="text-gray-500 mx-0.5">—</span>
                    <span className="text-amber-400/60 hover:text-amber-300 cursor-pointer" onClick={(e) => { e.stopPropagation(); window.dispatchEvent(new CustomEvent("tt-go-pro")); }}>Go Pro</span>
                  </span>
                </div>
              ) : addingTicker === sym ? (
                <div className="relative flex items-center justify-center gap-2 px-2 py-1 text-[10px]" style={{ zIndex: 1 }}>
                  <span className="loading-spinner loading-spinner-sm" style={{width:"10px",height:"10px",borderWidth:"1.5px",borderColor:"rgba(6,182,212,0.25)",borderTopColor:"rgb(6,182,212)"}}></span>
                  <span className="text-cyan-400 font-medium">Adding ticker…</span>
                </div>
              ) : (!Number.isFinite(score) || score === 0) && sl == null && tp == null && Number(t?.price) > 0 ? (
                <div className="relative flex items-center justify-center gap-2 px-2 py-1 text-[10px]" style={{ zIndex: 1 }}>
                  <span className="loading-spinner loading-spinner-sm" style={{width:"10px",height:"10px",borderWidth:"1.5px",borderColor:"rgba(6,182,212,0.25)",borderTopColor:"rgb(6,182,212)"}}></span>
                  <span className="text-cyan-400 font-medium">{t?.ingest_kind === "user_ticker_seed" || t?.ingest_kind === "admin_seed" ? "Onboarding..." : "Scoring..."}</span>
                </div>
              ) : (
                <div className="relative flex items-center justify-between px-2 py-0.5 text-[10px] font-medium" style={{ zIndex: 1 }}>
                  <div className="flex items-center gap-2 text-[#8b95a5]">
                    <span>Score <span className="text-white font-bold tabular-nums">{Number.isFinite(score) ? score.toFixed(0) : "—"}</span></span>
                    <span>R:R <span className="text-white font-bold tabular-nums">{Number.isFinite(rrNow) ? rrNow.toFixed(2) : "—"}</span></span>
                    {(() => {
                      const wr = t?._alignment?.path_win_rate;
                      if (wr == null) return null;
                      const wrNum = Number(wr);
                      if (!Number.isFinite(wrNum)) return null;
                      const cls = wrNum >= 60 ? "text-emerald-400" : wrNum >= 45 ? "text-amber-400" : "text-rose-400";
                      return <span className={`${cls} font-bold tabular-nums`} title={`Entry path historical win rate: ${wrNum.toFixed(0)}%`}>{wrNum.toFixed(0)}%</span>;
                    })()}
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-rose-400">SL <span className="font-bold tabular-nums">{sl != null ? `$${sl.toFixed(2)}` : "—"}</span></span>
                    {v3KijunSL != null && <span className="text-orange-300/70" title="Kijun-Sen reference SL">K<span className="font-bold tabular-nums">{v3KijunSL.toFixed(0)}</span></span>}
                    <span className="text-teal-400">TP <span className="font-bold tabular-nums">{tp != null ? `$${tp.toFixed(2)}` : "—"}</span></span>
                  </div>
                </div>
              )}

              {/* ── Row 4: Lane reason (Pro) + earnings callout (all) ── */}
              {(((laneReason || v3BlockLabel) && window._ttIsPro) || _earningsEvt) && (
                <div className="relative flex items-center justify-between px-2 py-0.5 text-[9px] font-semibold truncate" style={{ zIndex: 1 }}>
                  <div className="flex items-center gap-1 min-w-0">
                    {window._ttIsPro && laneReason ? <span className={`truncate ${laneReason.cls}`}>{laneReason.text}</span> : null}
                    {window._ttIsPro && v3BlockLabel && stage === "setup" && (
                      <span className="px-1 py-px rounded bg-rose-500/15 text-rose-300/80 border border-rose-500/25 text-[8px]" title={v3BlockReason}>
                        {v3BlockLabel}
                      </span>
                    )}
                  </div>
                  {_earningsEvt && (
                    <span className="text-amber-400/90 shrink-0 ml-1">📅 {(() => {
                      const d = _earningsEvt._daysAway;
                      const h = _earningsEvt.hour;
                      const hStr = h ? (() => { const hl = String(h).toLowerCase(); if (hl === "bmo" || hl === "before market open") return " BMO"; if (hl === "amc" || hl === "after market close") return " AMC"; return ""; })() : "";
                      if (d === 0) return `Today${hStr}`;
                      if (d === 1) return `Tmrw${hStr}`;
                      if (d === -1) return `Yday${hStr}`;
                      if (d < 0) return `${Math.abs(d)}d ago`;
                      return `${d}d${hStr}`;
                    })()}</span>
                  )}
                </div>
              )}

              {/* ── Section 4: Progress Bar — pushed to bottom ────────── */}
              <div className="mt-auto" />
              {(sl != null || tp != null || isActiveTrade) && (() => {
                let ep = isActiveTrade ? entryPrice : null;
                if (isActiveTrade && (!ep || ep <= 0) && openTrade) {
                  const epFromTrade = Number(openTrade.entryPrice ?? openTrade.entry_price) || 0;
                  if (epFromTrade > 0) ep = epFromTrade;
                }
                // Fallback to position_entry from server data
                if (isActiveTrade && (!ep || ep <= 0) && t?.position_entry) {
                  const epPos = Number(t.position_entry);
                  if (Number.isFinite(epPos) && epPos > 0) ep = epPos;
                }
                const cp = Number.isFinite(price) && price > 0 ? price : null;
                const slP = sl;

                // Original SL: from trade object or ticker position data
                const slOrigRaw = Number(openTrade?.sl_original ?? t?.position_sl_original ?? 0);
                const slOrig = Number.isFinite(slOrigRaw) && slOrigRaw > 0 ? slOrigRaw : null;
                // TSL is active when current SL differs from original SL by > 0.5%
                const tslActive = isActiveTrade && slP && slOrig &&
                  Math.abs(slP - slOrig) / slOrig > 0.005;

                // Prefer trade-level tpArray (direction-aware) over ticker-level (may be LONG-only)
                const tpArr = Array.isArray(openTrade?.tpArray) && openTrade.tpArray.length > 0
                  ? openTrade.tpArray
                  : (Array.isArray(t?.tpArray) ? t.tpArray : []);
                const tp1Raw = numFromAny(tpArr[0]?.price || t?.tp_trim);
                const tp2Raw = numFromAny(tpArr[1]?.price || t?.tp_exit);
                const xpRaw = numFromAny(tpArr[2]?.price || t?.tp_runner || tp);
                // Direction-aware TP sanity: must be on the profit side AND not yet passed through
                // Uses `dir` (authoritative direction from trade/position/bias) — NOT separate effectiveDir
                const isShortDir = dir === "SHORT";
                const tpSanity = (v) => {
                  if (!Number.isFinite(v) || v <= 0 || !cp) return null;
                  // TP must be on the correct side of entry (profit direction)
                  if (ep && !isShortDir && v <= ep) return null;
                  if (ep && isShortDir && v >= ep) return null;
                  // TP must not yet be passed through (already hit)
                  if (!isShortDir && v <= cp) return null;
                  if (isShortDir && v >= cp) return null;
                  return v;
                };
                const tp1 = tpSanity(tp1Raw);
                const tp2 = tpSanity(tp2Raw);
                const xp = tpSanity(xpRaw);

                const vals = [slP, slOrig, ep, cp, tp1, tp2, xp].filter(v => v != null && v > 0);
                if (vals.length < 2) return null;
                const rawLo = Math.min(...vals);
                const rawHi = Math.max(...vals);
                const rawRange = rawHi - rawLo;
                const pad = rawRange * 0.08;
                const lo = rawLo - pad;
                const hi = rawHi + pad;
                const range = hi - lo;
                const isShort = dir === "SHORT";
                // For SHORT: mirror marker positions so SL is on left, TP on right
                // This makes both LONG and SHORT read as "left = risk, right = target"
                const pct = (v) => {
                  if (range <= 0) return 50;
                  const raw = Math.max(0, Math.min(100, ((v - lo) / range) * 100));
                  return isShort ? (100 - raw) : raw;
                };

                const fillPct = cp ? pct(cp) : 0;
                const slMovedPastEntry = isActiveTrade && ep && slP && (
                  (dir === "LONG" && slP > ep) || (dir === "SHORT" && slP < ep)
                );

                // Collect marker positions to detect overlaps
                const markerPositions = [];
                const registerMarker = (val, label) => {
                  if (!val) return { bottom: false };
                  const pos = pct(val);
                  // Check if any existing marker is within 6% — put label on bottom if collision
                  const collision = markerPositions.some(m => Math.abs(m.pos - pos) < 6);
                  markerPositions.push({ pos, label });
                  return { bottom: collision };
                };
                const Marker = ({ val, label, color, textColor, bold, bottom, dashed }) => {
                  if (!val) return null;
                  return (
                    <div className="absolute" style={{ left: `${pct(val)}%`, width: "22px", marginLeft: "-11px", top: "-14px", bottom: "-14px" }}
                      title={`${label}: $${val.toFixed(2)}`}>
                      <div className={`absolute left-1/2 -translate-x-1/2 ${bold ? "w-1" : "w-0.5"} ${color}`}
                        style={{ top: "14px", bottom: "14px", ...(dashed ? { opacity: 0.5 } : {}) }} />
                      <span className={`absolute left-1/2 ${bottom ? "bottom-0" : "top-0"} -translate-x-1/2 text-[7px] font-extrabold ${textColor} whitespace-nowrap`}
                        style={{ textShadow: "0 1px 3px rgba(0,0,0,0.9)", ...(dashed ? { opacity: 0.6 } : {}) }}>{label}</span>
                    </div>
                  );
                };

                // Fill color + glow based on progress
                const fillColorStyle = fillPct >= 50
                  ? (fillPct >= 80
                    ? { background: "rgba(0,200,83,0.75)", boxShadow: "0 0 6px rgba(0,200,83,0.5)" }
                    : { background: "rgba(0,200,83,0.55)", boxShadow: "0 0 4px rgba(0,200,83,0.3)" })
                  : (fillPct <= 20
                    ? { background: "rgba(239,68,68,0.6)", boxShadow: "0 0 4px rgba(239,68,68,0.35)" }
                    : { background: "rgba(255,255,255,0.25)" });

                return (
                  <div className="relative px-2.5 pb-2" style={{ zIndex: 1 }}>
                    <div className="relative h-3 rounded-sm overflow-visible mt-3 mb-2.5" style={{
                      background: "rgba(0,0,0,0.45)",
                      border: "1px solid rgba(255,255,255,0.10)",
                      boxShadow: "inset 0 1px 3px rgba(0,0,0,0.4), 0 0 4px rgba(0,0,0,0.3)",
                    }}>
                      {cp && (
                        <div
                          className="absolute top-0 bottom-0 rounded-sm left-0 overflow-visible"
                          style={{ width: `${fillPct}%`, ...fillColorStyle }}
                          title={`CP: $${cp.toFixed(2)}`}
                        >
                          <span className="absolute -translate-x-1/2 text-[7px] font-extrabold text-white whitespace-nowrap"
                            style={{ left: "100%", bottom: "-14px", transform: "translateX(-50%)", textShadow: "0 1px 3px rgba(0,0,0,0.8)" }}>CP</span>
                        </div>
                      )}
                      {/* Original SL marker (dimmed) — shown when TSL is active for context */}
                      {(() => { const o = registerMarker(tslActive ? slOrig : null, "SL"); return tslActive && <Marker val={slOrig} label="SL" color="bg-rose-500/40" textColor="text-rose-400" dashed bottom={o.bottom} />; })()}
                      {/* Current stop: labeled TSL when trailing is active, SL otherwise */}
                      {(() => { const o = registerMarker(slP, tslActive ? "TSL" : "SL"); return <Marker val={slP} label={tslActive ? "TSL" : "SL"} color={slMovedPastEntry ? "bg-teal-500" : "bg-rose-500/80"} textColor={slMovedPastEntry ? "text-teal-400" : "text-rose-400"} bold={slMovedPastEntry} bottom={o.bottom} />; })()}
                      {(() => { const o = registerMarker(ep, "EP"); return <Marker val={ep} label="EP" color="bg-yellow-400/80" textColor="text-yellow-300" bottom={o.bottom} />; })()}
                      {(() => { const o = registerMarker(tp1, "TP"); return <Marker val={tp1} label="TP" color="bg-teal-400/80" textColor="text-teal-300" bottom={o.bottom} />; })()}
                      {(() => { const o = registerMarker(tp2, "TP2"); return <Marker val={tp2} label="TP2" color="bg-teal-400/80" textColor="text-teal-300" bottom={o.bottom} />; })()}
                      {(() => { const o = registerMarker(xp, "XP"); return <Marker val={xp} label="XP" color="bg-[#00e676]" textColor="text-[#69f0ae]" bold bottom={o.bottom} />; })()}
                    </div>
                  </div>
                );
              })()}
              </div>{/* end content wrapper */}
            </div>
          );
      }, (prev, next) => {
        const pt = prev.t, nt = next.t;
        if (!pt || !nt) return false;
        const sym = pt.ticker;
        if (sym !== nt.ticker) return false;
        // Compare trade object for this ticker (tradeByTicker Map changes identity every render)
        const prevTrade = prev.tradeByTicker?.get?.(String(sym).toUpperCase());
        const nextTrade = next.tradeByTicker?.get?.(String(sym).toUpperCase());
        const tradeEqual = prevTrade === nextTrade || (
          prevTrade?.status === nextTrade?.status
          && prevTrade?.entry_price === nextTrade?.entry_price
          && prevTrade?.exit_ts === nextTrade?.exit_ts
          && prevTrade?.trimmed_pct === nextTrade?.trimmed_pct
          && prevTrade?.sl_original === nextTrade?.sl_original
        );
        return tradeEqual
          && pt.price === nt.price
          && pt.state === nt.state
          && pt.kanban_stage === nt.kanban_stage
          && pt.score === nt.score
          && pt.sl === nt.sl
          && pt.tp_trim === nt.tp_trim
          && pt.tp_exit === nt.tp_exit
          && pt.tp_runner === nt.tp_runner
          && pt.day_change_pct === nt.day_change_pct
          && pt._live_daily_change_pct === nt._live_daily_change_pct
          && pt._ah_change_pct === nt._ah_change_pct
          && pt.has_open_position === nt.has_open_position
          && pt.position_sl === nt.position_sl
          && pt.position_tp === nt.position_tp
          && pt.entry_price === nt.entry_price
          && pt.__execution_block_reason === nt.__execution_block_reason
          && pt._sparkline === nt._sparkline
          && prev.savedTickers === next.savedTickers
          && prev.onSelectTicker === next.onSelectTicker
          && prev.addingTicker === next.addingTicker;
      });

      function renderCompactCardFn(t, { onSelectTicker, savedTickers, toggleSavedTicker, tradeByTicker, addingTicker } = {}) {
        return <CompactCard t={t} onSelectTicker={onSelectTicker} savedTickers={savedTickers} toggleSavedTicker={toggleSavedTicker} tradeByTicker={tradeByTicker} addingTicker={addingTicker} />;
      }

      // ─────────────────────────────────────────────────────────────
      // Action Center: Unified panel for Early Movers + Active Positions
      // ─────────────────────────────────────────────────────────────
      function ActionCenterPanel({
        tickers = [],
        allTickersWithRanks = [],
        rankPositions = {},
        onSelectTicker = null,
        allData = null,
        defaultLimit = 12,
        storageKey = "timedTrading_activeMovesSnapshot_v1",
        trades = [],
        accountSummary = null,
        queuedPending = [],
        queuedPendingCount = 0,
        savedTickers = new Set(),
        toggleSavedTicker = null,
      }) {
        const [expandedSections, setExpandedSections] = React.useState({
          earlyMovers: true,
          activePositions: true,
        });

        const toggleSection = (section) => {
          setExpandedSections((prev) => ({
            ...prev,
            [section]: !prev[section],
          }));
        };

        // Early Movers logic (trigger flags - for live indicators)
        const flipWatch = tickers
          .filter((t) => {
            const flags = t?.flags || {};
            return !!flags.flip_watch;
          })
          .slice(0, 8);

        const justFlipped = tickers
          .filter((t) => {
            const state = String(t?.state || "");
            const isMomentum =
              state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
            if (!isMomentum) return false;
            const seq = t?.seq || {};
            const corridorEntry = seq.corridorEntry_60m === true;
            return corridorEntry;
          })
          .slice(0, 8);

        const highProb = tickers
          .filter((t) => {
            const ent = entryType(t);
            const flags = t?.flags || {};
            return ent?.corridor && flags.sq30_release;
          })
          .slice(0, 8);

        const hasEarlyMovers =
          flipWatch.length > 0 || justFlipped.length > 0 || highProb.length > 0;
        const earlyMoversCount =
          flipWatch.length + justFlipped.length + highProb.length;

        // Build local trade-by-ticker map from trades prop (mirrors EarlyMoversPanel logic)
        const localTradeByTicker = React.useMemo(() => {
          const map = new Map();
          if (!Array.isArray(trades)) return map;
          trades.forEach((tr) => {
            const sym = String(tr?.ticker || "").toUpperCase();
            if (!sym) return;
            const existing = map.get(sym);
            if (!existing) { map.set(sym, tr); return; }
            const exitTs = tr.exit_ts ?? tr.exitTs ?? 0;
            const entryTs = tr.entry_ts ?? tr.entryTime ?? tr.entryTs ?? 0;
            const exExit = existing.exit_ts ?? existing.exitTs ?? 0;
            const exEntry = existing.entry_ts ?? existing.entryTime ?? existing.entryTs ?? 0;
            const trOpen = !exitTs, exOpen = !exExit;
            if ((trOpen && !exOpen) || (trOpen && exOpen && entryTs > exEntry) || (!trOpen && !exOpen && exitTs > exExit)) map.set(sym, tr);
          });
          return map;
        }, [trades]);

        // Kanban stage counts (for pipeline summary badge)
        // Applies the same trade-lifecycle override as the lane categoriser
        const kanbanStageCounts = React.useMemo(() => {
          const counts = { setup: 0, enter: 0, hold: 0, defend: 0, trim: 0, exit: 0 };
          tickers.forEach((t) => {
            let stage = String(t?.kanban_stage || "").toLowerCase();
            const sym = String(t?.ticker || "").toUpperCase();
            const trade = localTradeByTicker.get(sym);
            if (trade) {
              const st = String(trade.status || "").toUpperCase();
              const trimPct = Number(trade?.trimmed_pct ?? trade?.trimmedPct ?? 0);
              const isClosed = st === "WIN" || st === "LOSS" || !!(trade?.exit_ts ?? trade?.exitTs) || trimPct >= 0.9999;
              const isOpen = !isClosed && (st === "OPEN" || st === "TP_HIT_TRIM" || !st);
              if (isOpen) {
                if (st === "TP_HIT_TRIM" || trimPct > 0) stage = "trim";
                else if (stage !== "defend" && stage !== "trim" && stage !== "exit" &&
                         stage !== "hold" && stage !== "active" && stage !== "just_entered") stage = "hold";
              }
              // Recently closed trades (< 24h) count in Exit lane — unless scorer is promoting a new setup
              if (isClosed) {
                const exitMs = Number(trade.exit_ts ?? trade.exitTs ?? 0);
                const scorerStage = String(t?.kanban_stage || "");
                const newOpportunity = ["setup", "enter", "enter_now", "just_flipped"].includes(scorerStage);
                if (exitMs > 0 && (Date.now() - exitMs) < 24 * 60 * 60 * 1000 && !newOpportunity) stage = "exit";
              }
            }
            if (stage === "setup" || stage === "setup_watch" || stage === "flip_watch") counts.setup++;
            else if (stage === "enter" || stage === "enter_now" || stage === "just_flipped") counts.enter++;
            else if (stage === "active" || stage === "just_entered" || stage === "hold") counts.hold++;
            else if (stage === "defend") counts.defend++;
            else if (stage === "trim") counts.trim++;
            else if (stage === "exit") counts.exit++;
          });
          return counts;
        }, [tickers, localTradeByTicker]);

        // Total tickers in actionable kanban stages (excluding watch and null)
        const kanbanActiveCount = 
          kanbanStageCounts.setup + 
          kanbanStageCounts.enter + 
          kanbanStageCounts.hold + 
          kanbanStageCounts.defend + 
          kanbanStageCounts.trim + 
          kanbanStageCounts.exit;

        // Has kanban data if there are tickers in any stage beyond watch
        const hasKanbanData = kanbanActiveCount > 0;

        // Active Positions snapshot logic
        const [snap, setSnap] = React.useState(() => {
          try {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || !Array.isArray(parsed.items)) return null;
            return parsed;
          } catch {
            return null;
          }
        });

        const buildSnapshot = React.useCallback(
          (sourceTickers) => {
            const list = Array.isArray(sourceTickers) ? sourceTickers : [];
            const items = [];
            for (const t of list) {
              if (!t?.ticker) continue;
              const mv = getMoveStatusInfo(t);
              if (!mv.hasMoveStatus) continue;
              if (mv.status !== "ACTIVE") continue;
              const triggerTs = Number(t?.trigger_ts);
              if (!Number.isFinite(triggerTs) || triggerTs <= 0) continue;
              const sym = String(t.ticker).toUpperCase();
              const rp =
                getRankPositionFromMap(rankPositions, sym) ??
                Number(t?.rank_position);
              const inCorridor = !!entryType(t)?.corridor;
              const rr = Number(t?.rr);
              const flags =
                t?.flags && typeof t.flags === "object" ? t.flags : {};
              const momentumElite = !!flags.momentum_elite;
              const sqRelease = !!flags.sq30_release;
              const inSqueeze = !!flags.sq30_on && !flags.sq30_release;
              const thesis = flags.thesis_match === true;
              const prime = isPrimeBubble(t);
              const winnerSig = isWinnerSignature(t);
              const flipWatch = !!flags.flip_watch;
              // Use server-provided SL/TP directly (no client-side inflation)
              const sl = numFromAny(t?.sl ?? t?.sl_price ?? t?.stop_loss ?? t?.stop ?? t?.trade?.sl ?? t?.trade?.sl_price);
              const tp = numFromAny(t?.tp ?? t?.tp_trim);
              const eta = computeEtaDays(t);
              const price = Number(t?.price ?? t?.close ?? t?.c ?? t?.last);
              const intent = classifyEntryIntent(t);
              const comp = completionForSize(t);
              const progress = Number.isFinite(comp) ? comp : null;
              const phase = Number(t?.phase_pct);
              const age = formatAgeFromTs(triggerTs);
              items.push({
                sym,
                rp: Number.isFinite(rp) ? rp : null,
                inCorridor,
                rr: Number.isFinite(rr) ? rr : null,
                progress: Number.isFinite(progress) ? progress : null,
                phase: Number.isFinite(phase) ? phase : null,
                age,
                momentumElite,
                sqRelease,
                inSqueeze,
                thesis,
                prime,
                winnerSig,
                flipWatch,
                sl: Number.isFinite(sl) && sl > 0 ? sl : null,
                tp: Number.isFinite(tp) && tp > 0 ? tp : null,
                eta: Number.isFinite(eta) && eta > 0 ? eta : null,
                price: Number.isFinite(price) && price > 0 ? price : null,
                intent,
                t,
              });
            }
            items.sort((a, b) => {
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              if (a.rp != null) return -1;
              if (b.rp != null) return 1;
              return a.sym.localeCompare(b.sym);
            });
            const out = {
              createdAt: Date.now(),
              items: items.slice(0, Math.max(1, defaultLimit)),
            };
            try {
              localStorage.setItem(storageKey, JSON.stringify(out));
            } catch {}
            return out;
          },
          [defaultLimit, rankPositions, storageKey],
        );

        const MAX_SNAPSHOT_AGE_MS = 60 * 60 * 1000;

        React.useEffect(() => {
          if (snap && Array.isArray(snap.items) && snap.items.length > 0) {
            const ageOk =
              Number.isFinite(Number(snap.createdAt)) &&
              Date.now() - Number(snap.createdAt) <= MAX_SNAPSHOT_AGE_MS;
            if (ageOk) return;
          }
          if (
            !Array.isArray(allTickersWithRanks) ||
            allTickersWithRanks.length === 0
          )
            return;
          setSnap(buildSnapshot(allTickersWithRanks));
        }, [allTickersWithRanks, buildSnapshot, snap]);

        const onRefresh = React.useCallback(() => {
          setSnap(buildSnapshot(allTickersWithRanks));
        }, [buildSnapshot, allTickersWithRanks]);

        const onClear = React.useCallback(() => {
          setSnap(null);
          try {
            localStorage.removeItem(storageKey);
          } catch {}
        }, [storageKey]);

        const asOf = snap?.createdAt ? new Date(Number(snap.createdAt)) : null;
        const rows = Array.isArray(snap?.items) ? snap.items : [];
        const activePositionsCount = rows.length;
        const rankTotal =
          rankPositions && typeof rankPositions === "object"
            ? Object.keys(rankPositions).length
            : null;

        // Calculate Kanban count for display (EarlyMoversPanel will handle actual categorization)
        // Use kanban stage counts when no live trigger flags, otherwise use early movers count
        const kanbanCount = hasEarlyMovers ? earlyMoversCount : kanbanActiveCount;

        // Show panel if we have early movers, kanban data, or active positions
        if (!hasEarlyMovers && !hasKanbanData && activePositionsCount === 0) {
          return null;
        }

        // Daily activity summary (entries + exits today)
        const todayLocal = (() => {
          const d = new Date();
          return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
        })();
        const todayStartMs = new Date(todayLocal + "T00:00:00").getTime();
        const todayEndMs = todayStartMs + 86400000;
        const tsToMs = (v) => {
          if (!v) return 0;
          const n = Number(v);
          if (!Number.isFinite(n)) return 0;
          return n < 1e12 ? n * 1000 : n;
        };
        // Entries today (opened today)
        const todayEntries = (trades || []).filter((tr) => {
          const ms = tsToMs(tr.entry_ts ?? tr.entryTime ?? tr.created_at);
          return ms >= todayStartMs && ms < todayEndMs;
        });
        // Exits today (closed today) — only count proper WIN/LOSS exits
        const todayExits = (trades || []).filter((tr) => {
          const ms = tsToMs(tr.exit_ts ?? tr.exitTs ?? tr.exitTime);
          const s = String(tr?.status || "").toUpperCase();
          return ms >= todayStartMs && ms < todayEndMs && (s === "WIN" || s === "LOSS");
        });
        const todayWins = todayExits.filter((t) => (Number(t?.pnl ?? t?.realizedPnl) || 0) > 0).length;
        const todayLosses = todayExits.filter((t) => (Number(t?.pnl ?? t?.realizedPnl) || 0) <= 0).length;
        const todayRealizedPnl = todayExits.reduce((sum, t) => sum + (Number(t?.pnl ?? t?.realizedPnl) || 0), 0);
        const todayActivityCount = todayEntries.length + todayExits.length;

        // Account summary from server-side ledger (single source of truth)
        const accountValue = accountSummary?.accountValue ?? null;
        const allRealizedPnl = accountSummary?.totalRealized ?? 0;
        const openPnl = accountSummary?.unrealized ?? 0;
        const openPositionCount = (trades || []).filter(t => {
          const s = String(t?.status || "").toUpperCase();
          return s === "OPEN" || s === "TP_HIT_TRIM";
        }).length;

        return (
          <div className="mb-2">
            <div className="px-3 py-2 rounded-lg bg-white/[0.03] border border-white/[0.06] flex items-center justify-between flex-wrap gap-2">
              {/* Left: Today Summary — matches right-side font style */}
              <div className="flex items-center gap-5 text-[11px]">
                {todayActivityCount > 0 || queuedPendingCount > 0 || queuedPending.length > 0 ? (
                  <>
                    <span className="text-[#6b7280]">Entries <span className="text-white font-bold tabular-nums">{todayEntries.length}</span></span>
                    <span className="text-[#6b7280]">Exits <span className="text-white font-bold tabular-nums">{todayExits.length}</span></span>
                    {todayExits.length > 0 && (
                      <span className="text-[#6b7280]">W/L <span className="text-teal-400 font-bold tabular-nums">{todayWins}</span><span className="text-[#4b5563]">/</span><span className="text-rose-400 font-bold tabular-nums">{todayLosses}</span></span>
                    )}
                    {(queuedPendingCount > 0 || queuedPending.length > 0) && (
                      <span className="text-amber-400/80" title={queuedPending.map(a => `${a.ticker}: ${a.action} (${a.reason})`).join("\n")}>
                        Queued <span className="text-amber-300 font-bold tabular-nums">{queuedPendingCount || queuedPending.length}</span>
                      </span>
                    )}
                    {todayExits.length > 0 && (
                      <span className="text-[#6b7280]">Today Realized <span className={`font-bold tabular-nums ${todayRealizedPnl >= 0 ? "text-teal-400" : "text-rose-400"}`}>{todayRealizedPnl >= 0 ? "+" : ""}{typeof fmtUsd === "function" ? fmtUsd(todayRealizedPnl) : `$${todayRealizedPnl.toFixed(2)}`}</span></span>
                    )}
                  </>
                ) : (
                  <span className="text-[#4b5563]">No activity today</span>
                )}
              </div>
              {/* Right: Account + Open Positions — Realized = total from all closed trades */}
              <div className="flex items-center gap-5 text-[11px]">
                <span className="text-[#6b7280]">Account <span className="text-white font-bold tabular-nums">{accountValue != null ? (typeof fmtUsd === "function" ? fmtUsd(accountValue) : `$${accountValue.toFixed(0)}`) : "Loading..."}</span></span>
                <span className="text-[#6b7280]">Realized <span className={`font-bold tabular-nums ${allRealizedPnl >= 0 ? "text-teal-400" : "text-rose-400"}`}>{allRealizedPnl >= 0 ? "+" : ""}{typeof fmtUsd === "function" ? fmtUsd(allRealizedPnl) : `$${allRealizedPnl.toFixed(2)}`}</span></span>
                <span className="text-[#6b7280]">Open <span className="text-white font-bold tabular-nums">{openPositionCount}</span></span>
                <span className="text-[#6b7280]">Open P&L <span className={`font-bold tabular-nums ${openPnl >= 0 ? "text-teal-400" : "text-rose-400"}`}>{openPnl >= 0 ? "+" : ""}{typeof fmtUsd === "function" ? fmtUsd(openPnl) : `$${openPnl.toFixed(2)}`}</span></span>
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Simple Kanban Table: flat table view of all tickers with stages
      // ─────────────────────────────────────────────────────────────
      const STAGE_ORDER = { watch: 0, setup: 1, enter: 2, new: 3, hold: 4, defend: 5, trim: 6, exit: 7 };
      const STAGE_META = {
        watch:  { label: "Watch",  icon: "👁", cls: "bg-gray-700/60 text-gray-300 border-gray-500/40" },
        setup:  { label: "Setup",  icon: "📋", cls: "bg-amber-900/40 text-amber-400 border-amber-500/40" },
        enter:  { label: "Enter",  icon: "🎯", cls: "bg-teal-900/40 text-teal-400 border-teal-500/40" },
        new:    { label: "New",    icon: "🆕", cls: "bg-[#00c853]/10 text-[#00e676] border-[#00c853]/40" },
        hold:   { label: "Hold",   icon: "🔒", cls: "bg-cyan-900/40 text-cyan-400 border-cyan-500/40" },
        defend: { label: "Defend", icon: "🛡", cls: "bg-orange-900/40 text-orange-400 border-orange-500/40" },
        trim:   { label: "Trim",   icon: "✂️", cls: "bg-yellow-900/40 text-yellow-400 border-yellow-500/40" },
        exit:   { label: "Exit",   icon: "🚪", cls: "bg-rose-900/40 text-rose-400 border-rose-500/40" },
      };

      function SimpleKanbanTable({
        tickers = [],
        trades = [],
        onSelectTicker = null,
        rankPositions = {},
        savedTickers = new Set(),
        toggleSavedTicker = null,
        contextData = null,
      }) {
        const [sortCol, setSortCol] = React.useState(() => {
          try { return localStorage.getItem("tt_tableSort_col") || "ticker"; } catch { return "ticker"; }
        });
        const [sortDir, setSortDir] = React.useState(() => {
          try { return localStorage.getItem("tt_tableSort_dir") || "asc"; } catch { return "asc"; }
        });
        const [stageFilter, setStageFilter] = React.useState("all");

        // Build trade-by-ticker map
        const tradeByTicker = React.useMemo(() => {
          const map = new Map();
          if (!Array.isArray(trades)) return map;
          trades.forEach((tr) => {
            const sym = String(tr?.ticker || "").toUpperCase();
            if (!sym) return;
            const existing = map.get(sym);
            const exitTs = tr.exit_ts ?? tr.exitTs ?? 0;
            const entryTs = tr.entry_ts ?? tr.entryTime ?? tr.entryTs ?? 0;
            if (!existing) { map.set(sym, tr); return; }
            const exExit = existing.exit_ts ?? existing.exitTs ?? 0;
            const exEntry = existing.entry_ts ?? existing.entryTime ?? existing.entryTs ?? 0;
            const trOpen = !exitTs, exOpen = !exExit;
            if ((trOpen && !exOpen) || (trOpen && exOpen && entryTs > exEntry) || (!trOpen && !exOpen && exitTs > exExit)) map.set(sym, tr);
          });
          return map;
        }, [trades]);

        // Assign stage to each ticker (reuses EarlyMoversPanel logic + adds "watch")
        const tickersWithStage = React.useMemo(() => {
          return tickers.map((t) => {
            if (t?.kanban_stage === null) return { ...t, _stage: "watch" };
            let stage = String(t?.kanban_stage || "");
            const sym = String(t?.ticker || "").toUpperCase();
            const trade = tradeByTicker.get(sym);
            const status = trade ? String(trade.status || "").toUpperCase() : "";
            const trimmedPct = Number(trade?.trimmed_pct ?? trade?.trimmedPct ?? 0);
            const isClosed = status === "WIN" || status === "LOSS" || !!(trade?.exit_ts ?? trade?.exitTs) || trimmedPct >= 0.9999;
            const isOpen = !isClosed && (status === "OPEN" || status === "TP_HIT_TRIM" || !status);
            if (trade && isOpen) {
              if (status === "TP_HIT_TRIM" || trimmedPct > 0) stage = "trim";
              else if (!["defend", "trim", "exit", "hold", "active", "just_entered"].includes(stage)) stage = "hold";
            }
            // Recently closed trades stay in Exit lane for 24h — unless scorer is promoting a new setup
            if (trade && isClosed) {
              const exitMs = Number(trade.exit_ts ?? trade.exitTs ?? 0);
              const scorerStage = String(t?.kanban_stage || "");
              const newOpportunity = ["setup", "enter", "enter_now", "just_flipped"].includes(scorerStage);
              if (exitMs > 0 && (Date.now() - exitMs) < 24 * 60 * 60 * 1000 && !newOpportunity) stage = "exit";
            }
            // Map server stages to UI stages
            let uiStage;
            switch (stage) {
              case "setup": case "setup_watch": case "flip_watch": uiStage = "setup"; break;
              case "enter": case "enter_now": case "just_flipped": uiStage = "enter"; break;
              case "just_entered": uiStage = "new"; break;
              case "active": case "hold": uiStage = "hold"; break;
              case "defend": uiStage = "defend"; break;
              case "trim": uiStage = "trim"; break;
              case "exit": uiStage = "exit"; break;
              default: uiStage = "watch"; break;
            }
            return { ...t, _stage: uiStage };
          });
        }, [tickers, tradeByTicker]);

        // Stage counts
        const stageCounts = React.useMemo(() => {
          const c = { watch: 0, setup: 0, enter: 0, new: 0, hold: 0, defend: 0, trim: 0, exit: 0 };
          tickersWithStage.forEach(t => { if (c[t._stage] !== undefined) c[t._stage]++; });
          return c;
        }, [tickersWithStage]);

        // Filter + Sort
        const filtered = React.useMemo(() => {
          let items = tickersWithStage;
          if (stageFilter !== "all") items = items.filter(t => t._stage === stageFilter);
          items = [...items].sort((a, b) => {
            let va, vb;
            const sym = (x) => String(x?.ticker || "").toUpperCase();
            const ctx = (x) => {
              const s = sym(x);
              return contextData?.[s]?.context || x?.context || {};
            };
            if (sortCol === "ticker") { va = sym(a); vb = sym(b); }
            else if (sortCol === "stage") { va = (STAGE_ORDER[a._stage] ?? 99); vb = (STAGE_ORDER[b._stage] ?? 99); }
            else if (sortCol === "score") { va = Number(a?.score ?? 0); vb = Number(b?.score ?? 0); }
            else if (sortCol === "price") { va = Number(a?.price ?? 0); vb = Number(b?.price ?? 0); }
            else if (sortCol === "change") {
              const da = getDailyChange(a) || {}; const db = getDailyChange(b) || {};
              va = Number.isFinite(da.dayPct) ? da.dayPct : -999;
              vb = Number.isFinite(db.dayPct) ? db.dayPct : -999;
            }
            else if (sortCol === "sector") { va = String(a?.sector || ctx(a).sector || ""); vb = String(b?.sector || ctx(b).sector || ""); }
            else if (sortCol === "industry") { va = String(ctx(a).industry || ""); vb = String(ctx(b).industry || ""); }
            else if (sortCol === "mcap") { va = Number(ctx(a).market_cap || 0); vb = Number(ctx(b).market_cap || 0); }
            else if (sortCol === "rank") { va = Number(rankPositions?.[sym(a)] || 9999); vb = Number(rankPositions?.[sym(b)] || 9999); }
            else { va = sym(a); vb = sym(b); }
            // Secondary sort by score desc for stage sort, or by ticker alpha for other sorts
            let cmp;
            if (typeof va === "string") cmp = sortDir === "asc" ? va.localeCompare(vb) : vb.localeCompare(va);
            else cmp = sortDir === "asc" ? va - vb : vb - va;
            if (cmp !== 0) return cmp;
            // Tie-break: score desc, then ticker alpha
            const sa = Number(a?.score ?? 0), sb = Number(b?.score ?? 0);
            if (sa !== sb) return sb - sa;
            return sym(a).localeCompare(sym(b));
          });
          return items;
        }, [tickersWithStage, stageFilter, sortCol, sortDir, contextData]);

        // Sort handler — persist to localStorage so it survives view switches
        const handleSort = (col) => {
          let newDir;
          if (sortCol === col) {
            newDir = sortDir === "asc" ? "desc" : "asc";
            setSortDir(newDir);
          } else {
            newDir = (col === "ticker" || col === "sector" || col === "industry") ? "asc" : "desc";
            setSortCol(col);
            setSortDir(newDir);
          }
          try { localStorage.setItem("tt_tableSort_col", col); localStorage.setItem("tt_tableSort_dir", newDir); } catch {}
        };
        const sortArrow = (col) => sortCol !== col ? "" : sortDir === "asc" ? " ▲" : " ▼";

        // Helpers
        const fmtMCap = (v) => {
          if (!v || !Number.isFinite(v) || v <= 0) return null;
          if (v >= 1e12) return `$${(v / 1e12).toFixed(1)}T`;
          if (v >= 1e9) return `$${(v / 1e9).toFixed(1)}B`;
          if (v >= 1e6) return `$${(v / 1e6).toFixed(0)}M`;
          return `$${v.toLocaleString()}`;
        };

        // Mini progress bar for a ticker row
        const MiniProgressBar = ({ t, trade }) => {
          const state = String(t?.state || "");
          const isBullish = state.startsWith("HTF_BULL");
          const statusUp = String(trade?.status || "").toUpperCase();
          const hasOpen = trade && (["OPEN", "TP_HIT_TRIM"].includes(statusUp) || (!(trade?.exit_ts ?? trade?.exitTs) && statusUp !== "WIN" && statusUp !== "LOSS"));
          let dir = isBullish ? "LONG" : "SHORT";
          if (hasOpen) { const d = String(trade?.direction || "").toUpperCase(); if (d === "LONG" || d === "SHORT") dir = d; }
          if (!hasOpen && t?.has_open_position) { const pd = String(t?.position_direction || "").toUpperCase(); if (pd === "LONG" || pd === "SHORT") dir = pd; }
          // effectiveDir for SL/TP sanity uses position direction when available
          const posDir = t?.has_open_position ? String(t?.position_direction || "").toUpperCase() : null;
          const effectiveDir = (posDir === "LONG" || posDir === "SHORT") ? posDir : dir;
          const price = Number(t?.price ?? t?.close);
          // Prefer position SL (direction-aware) over ticker SL
          const hasPos = !!t?.has_open_position;
          const slRaw = hasPos && Number.isFinite(Number(t?.position_sl)) && Number(t?.position_sl) > 0
            ? Number(t.position_sl)
            : Number(t?.sl ?? t?.sl_price ?? t?.stop_loss ?? t?.stop);
          const tpRaw = numFromAny(t?.tp ?? t?.tp_trim);
          const slSane = (() => {
            if (!Number.isFinite(slRaw) || slRaw <= 0 || !Number.isFinite(price) || price <= 0) return null;
            if (effectiveDir === "LONG" && slRaw >= price) return null;
            if (effectiveDir === "SHORT" && slRaw <= price) return null;
            return slRaw;
          })();
          // Original SL for TSL detection
          const slOrigRaw = Number(trade?.sl_original ?? t?.position_sl_original ?? 0);
          const slOrig = Number.isFinite(slOrigRaw) && slOrigRaw > 0 ? slOrigRaw : null;
          const tslActive = hasOpen && slSane && slOrig && Math.abs(slSane - slOrig) / slOrig > 0.005;
          let ep = null;
          if (hasOpen && trade) {
            const epv = Number(trade.entryPrice ?? trade.entry_price) || 0;
            if (epv > 0) ep = epv;
          }
          if (!ep) {
            const epv = numFromAny(t?.entry_price ?? t?.position_entry);
            if (Number.isFinite(epv) && epv > 0) ep = epv;
          }
          const cp = Number.isFinite(price) && price > 0 ? price : null;
          // Prefer trade-level tpArray (direction-aware) over ticker-level
          const tpArr = Array.isArray(trade?.tpArray) && trade.tpArray.length > 0
            ? trade.tpArray
            : (Array.isArray(t?.tpArray) ? t.tpArray : []);
          const tp1Raw = numFromAny(tpArr[0]?.price || t?.tp_trim);
          const tp2Raw = numFromAny(tpArr[1]?.price || t?.tp_exit);
          const xpRaw = numFromAny(tpArr[2]?.price || t?.tp_runner || tpRaw);
          // Direction-aware TP sanity: must be on profit side AND not yet passed through
          const tpSanity = (v) => {
            if (!Number.isFinite(v) || v <= 0 || !cp) return null;
            if (ep && effectiveDir === "LONG" && v <= ep) return null;
            if (ep && effectiveDir === "SHORT" && v >= ep) return null;
            if (effectiveDir === "LONG" && v <= cp) return null;
            if (effectiveDir === "SHORT" && v >= cp) return null;
            return v;
          };
          const sl = slSane;
          const tp1 = tpSanity(tp1Raw);
          const tp2 = tpSanity(tp2Raw);
          const xp = tpSanity(xpRaw);
          const vals = [sl, slOrig, ep, cp, tp1, tp2, xp].filter(v => v != null && v > 0);
          if (vals.length < 2) return <span className="text-[9px] text-gray-600">—</span>;
          const rawLo = Math.min(...vals);
          const rawHi = Math.max(...vals);
          const pad = (rawHi - rawLo) * 0.08;
          const lo = rawLo - pad;
          const hi = rawHi + pad;
          const range = hi - lo;
          const isShort = dir === "SHORT";
          // For SHORT: mirror positions so SL=left, TP=right (same as card view)
          const pct = (v) => {
            if (range <= 0) return 50;
            const raw = Math.max(0, Math.min(100, ((v - lo) / range) * 100));
            return isShort ? (100 - raw) : raw;
          };
          const fillPct = cp ? pct(cp) : 0;
          const slMovedPastEntry = ep && sl && ((dir === "LONG" && sl > ep) || (dir === "SHORT" && sl < ep));
          const fillColor = fillPct >= 50 ? (fillPct >= 80 ? "bg-[#00c853]/70" : "bg-[#00c853]/50") : (fillPct <= 20 ? "bg-rose-500/55" : "bg-white/[0.30]");
          const Mk = ({ val, label, color, tc, bottom, dimmed }) => {
            if (!val) return null;
            return (
              <div className="absolute" style={{ left: `${pct(val)}%`, width: "20px", marginLeft: "-10px", top: "-14px", bottom: "-14px" }}
                title={`${label}: $${val.toFixed(2)}`}>
                <div className={`absolute left-1/2 -translate-x-1/2 w-0.5 ${color}`} style={{ top: "14px", bottom: "14px", ...(dimmed ? { opacity: 0.5 } : {}) }} />
                <span className={`absolute left-1/2 ${bottom ? "bottom-0" : "top-0"} -translate-x-1/2 text-[7px] font-extrabold ${tc} whitespace-nowrap`}
                  style={dimmed ? { opacity: 0.6 } : {}}>{label}</span>
              </div>
            );
          };
          return (
            <div className="w-full min-w-[140px]">
              <div className="relative h-[6px] rounded bg-white/[0.06] border border-white/[0.08] overflow-visible mt-3 mb-3">
                {cp && (
                  <div
                    className={`absolute top-0 bottom-0 rounded left-0 ${fillColor}`}
                    style={{ width: `${fillPct}%` }}
                  >
                    <span className="absolute -translate-x-1/2 text-[7px] font-extrabold text-white whitespace-nowrap"
                      style={{ left: "100%", bottom: "-14px" }}>CP</span>
                  </div>
                )}
                {tslActive && <Mk val={slOrig} label="SL" color="bg-rose-500/40" tc="text-rose-400" dimmed />}
                <Mk val={sl} label={tslActive ? "TSL" : "SL"} color={slMovedPastEntry ? "bg-teal-500" : "bg-rose-500/80"} tc={slMovedPastEntry ? "text-teal-400" : "text-rose-400"} />
                <Mk val={ep} label="EP" color="bg-yellow-400/80" tc="text-yellow-300" />
                <Mk val={tp1} label="TP" color="bg-teal-400/80" tc="text-teal-300" />
                <Mk val={tp2} label="TP2" color="bg-teal-400/80" tc="text-teal-300" bottom />
                <Mk val={xp} label="XP" color="bg-[#00e676]" tc="text-[#69f0ae]" />
              </div>
            </div>
          );
        };

        // Rank total for display
        const rankTotal = React.useMemo(() => {
          return rankPositions ? Object.keys(rankPositions).length : 0;
        }, [rankPositions]);

        const STAGE_KEYS = ["watch", "setup", "enter", "new", "hold", "defend", "trim", "exit"];

        return (
          <div className="mb-4">
            {/* Stage filter pills */}
            <div className="flex flex-wrap items-center gap-1.5 mb-3">
              <span className="text-[11px] text-[#6b7280] mr-1">Stage:</span>
              {[
                { key: "all", label: "All", count: tickersWithStage.length },
                ...Object.entries(STAGE_META).map(([k, v]) => ({ key: k, label: v.label, count: stageCounts[k] || 0, icon: v.icon })),
              ].map(({ key, label, count, icon }) => (
                <button
                  key={key}
                  onClick={() => setStageFilter(prev => prev === key ? "all" : key)}
                  className={`px-2 py-1 rounded-md text-[11px] font-medium transition-colors border ${
                    stageFilter === key
                      ? "bg-white/[0.10] text-white border-white/[0.15]"
                      : "bg-white/[0.02] text-[#6b7280] border-white/[0.05] hover:text-white hover:bg-white/[0.05]"
                  }`}
                >
                  {icon ? `${icon} ` : ""}{label} <span className="text-[10px] opacity-60">{count}</span>
                </button>
              ))}
            </div>

            {/* Badge Legend */}
            <div className="mb-3 px-2 py-1.5 rounded-lg border border-white/[0.04] bg-white/[0.015] flex items-center flex-nowrap gap-x-5 text-[10px] text-[#6b7280] overflow-x-auto">
              <span className="text-[11px] font-semibold text-white/70 shrink-0">Badges</span>
              <span className="shrink-0">💎 <span className="text-[#8b95a5]">Prime — top-quality setup</span></span>
              <span className="shrink-0">🎯 <span className="text-[#8b95a5]">Entry Zone — actionable window</span></span>
              <span className="shrink-0">🔥 <span className="text-[#8b95a5]">MoElite — strong momentum</span></span>
              <span className="shrink-0">🧨 <span className="text-[#8b95a5]">Squeeze — pressure building</span></span>
              <span className="shrink-0">⚡ <span className="text-[#8b95a5]">Release — breakout firing</span></span>
              <span className="shrink-0">📅 <span className="text-[#8b95a5]">Earnings — within 7 days</span></span>
            </div>

            {/* Table */}
            <div className="overflow-x-auto border border-white/[0.05] rounded-lg">
              <table className="text-sm w-full" style={{ minWidth: 1600 }}>
                <thead>
                  <tr className="bg-white/[0.03] border-b border-white/[0.05]">
                    <th className="px-2 py-2 text-left text-[11px] font-medium text-gray-400 cursor-pointer hover:text-white select-none" onClick={() => handleSort("stage")}>
                      Stage{sortArrow("stage")}
                    </th>
                    <th className="px-2 py-2 text-left text-[11px] font-medium text-gray-400 cursor-pointer hover:text-white select-none" onClick={() => handleSort("ticker")}>
                      Ticker{sortArrow("ticker")}
                    </th>
                    <th className="px-2 py-2 text-left text-[11px] font-medium text-gray-400">Name</th>
                    <th className="px-2 py-2 text-center text-[11px] font-medium text-gray-400">Bias</th>
                    {window._ttIsPro && <th className="px-1 py-2 text-right text-[11px] font-medium text-gray-400 cursor-pointer hover:text-white select-none" onClick={() => handleSort("price")}>
                      Price{sortArrow("price")}
                    </th>}
                    {window._ttIsPro && <th className="px-1 py-2 text-right text-[11px] font-medium text-gray-400 cursor-pointer hover:text-white select-none" onClick={() => handleSort("change")}>
                      Day %{sortArrow("change")}
                    </th>}
                    {window._ttIsPro && <th className="px-1 py-2 text-right text-[11px] font-medium text-gray-400">Day $</th>}
                    <th className="px-2 py-2 text-center text-[11px] font-medium text-gray-400" title="SL/EP/TP Progress">Trade</th>
                    <th className="px-1 py-2 text-center text-[11px] font-medium text-gray-400 cursor-pointer hover:text-white select-none" onClick={() => handleSort("score")}>
                      Score{sortArrow("score")}
                    </th>
                    <th className="px-1 py-2 text-center text-[11px] font-medium text-gray-400 cursor-pointer hover:text-white select-none" onClick={() => handleSort("rank")}>
                      Rank{sortArrow("rank")}
                    </th>
                    <th className="px-1 py-2 text-center text-[11px] font-medium text-gray-400">R:R</th>
                    <th className="px-1 py-2 text-center text-[11px] font-medium text-gray-400">Flags</th>
                    {/* Stage lane columns with spelled-out labels */}
                    {STAGE_KEYS.map(sk => {
                      const m = STAGE_META[sk];
                      return (
                        <th key={sk} className="px-1 py-2 text-center text-[10px] font-medium text-gray-500 cursor-pointer hover:text-white select-none whitespace-nowrap" onClick={() => handleSort("stage")}
                          title={`${m.label} (${stageCounts[sk] || 0})`}>
                          {m.icon} {m.label}
                        </th>
                      );
                    })}
                  </tr>
                </thead>
                <tbody>
                  {filtered.map((t, idx) => {
                    const sym = String(t?.ticker || "").toUpperCase();
                    const trade = tradeByTicker.get(sym);
                    const stg = t._stage;
                    const ctxObj = contextData?.[sym] || {};
                    const ctx = ctxObj?.context || t?.context || {};
                    const name = ctx.name || "";
                    const score = Number(t?.score ?? t?.flip_watch_score ?? 0);
                    const price = Number(t?.price ?? t?.close ?? 0);
                    const dailyResult = getDailyChange(t) || {};
                    const dayPct = Number.isFinite(dailyResult.dayPct) ? dailyResult.dayPct : null;
                    const dayChg = Number.isFinite(dailyResult.dayChg) ? dailyResult.dayChg : null;
                    // Rank
                    const rank = rankPositions?.[sym] || null;
                    // R:R
                    const state = String(t?.state || "");
                    const isBullish = state.startsWith("HTF_BULL");
                    const tickerBiasDir = isBullish ? "LONG" : "SHORT";
                    const slRaw = Number(t?.sl ?? t?.sl_price ?? 0);
                    const tpRaw = numFromAny(t?.tp ?? t?.tp_trim);
                    const slOk = Number.isFinite(slRaw) && slRaw > 0 && Number.isFinite(price) && price > 0 &&
                      !(tickerBiasDir === "LONG" && slRaw >= price) && !(tickerBiasDir === "SHORT" && slRaw <= price);
                    const tpOk = Number.isFinite(tpRaw) && tpRaw > 0 && Number.isFinite(price) && price > 0 &&
                      !(tickerBiasDir === "LONG" && tpRaw <= price) && !(tickerBiasDir === "SHORT" && tpRaw >= price);
                    const rr = slOk && tpOk ? (Math.abs(tpRaw - price) / Math.abs(price - slRaw)) : null;
                    // Direction / Bias
                    const statusUp = String(trade?.status || "").toUpperCase();
                    const hasOpen = trade && (["OPEN", "TP_HIT_TRIM"].includes(statusUp) || (!(trade?.exit_ts ?? trade?.exitTs) && statusUp !== "WIN" && statusUp !== "LOSS"));
                    let dir = isBullish ? "L" : "S";
                    if (hasOpen) { const d = String(trade?.direction || "").toUpperCase(); if (d === "LONG") dir = "L"; else if (d === "SHORT") dir = "S"; }
                    const dirColor = dir === "L" ? "text-[#00e676]" : "text-rose-400";
                    // Badges
                    const flg = t?.flags || {};
                    const badges = [];
                    if (isPrimeBubble(t)) badges.push("💎");
                    if (flg.flip_watch) badges.push("🎯");
                    if (flg.momentum_elite) badges.push("🔥");
                    if (flg.sq30_release) badges.push("⚡");
                    if (flg.sq30_on && !flg.sq30_release) badges.push("🧨");
                    const showProgress = ["enter", "new", "hold", "defend", "trim", "exit"].includes(stg);
                    // Stage display
                    const stageMeta = STAGE_META[stg] || STAGE_META.watch;
                    // Prime + Entry Zone highlight
                    const _tblPrime = isPrimeBubble(t);
                    const _tblEntryZone = !!flg.flip_watch;
                    const _tblPrimeEntry = _tblPrime && _tblEntryZone;

                    return (
                      <tr
                        key={sym}
                        className={`border-b border-white/[0.03] hover:bg-white/[0.03] cursor-pointer transition-colors ${_tblPrimeEntry ? "bg-amber-500/[0.06] border-l-2 border-l-amber-400/50" : idx % 2 === 0 ? "" : "bg-white/[0.01]"}`}
                        onClick={() => onSelectTicker && onSelectTicker(sym)}
                      >
                        {/* Stage (first column) */}
                        <td className="px-2 py-1.5">
                          <span className={`inline-flex items-center gap-1 text-[10px] font-semibold px-1.5 py-0.5 rounded border ${stageMeta.cls}`}>
                            <span>{stageMeta.icon}</span>
                            <span>{stageMeta.label}</span>
                          </span>
                        </td>
                        {/* Ticker */}
                        <td className="px-2 py-1.5">
                          <span className={`font-semibold text-[12px] ${_tblPrimeEntry ? "text-amber-300" : "text-blue-400"}`}>{sym}</span>
                        </td>
                        {/* Name */}
                        <td className="px-2 py-1 text-[11px] text-gray-400 truncate max-w-[120px]" title={name}>{name || "—"}</td>
                        {/* Directional Bias (after Name) */}
                        <td className="px-2 py-1.5 text-center">
                          <span className={`text-[11px] font-bold ${dirColor}`}>{dir === "L" ? "LONG" : "SHORT"}</span>
                        </td>
                        {window._ttIsPro && <td className="px-1 py-1 text-right text-[11px] text-white font-medium tabular-nums">
                          {price > 0 ? `$${price.toFixed(2)}` : <span className="text-gray-600">—</span>}
                        </td>}
                        {window._ttIsPro && <td className="px-1 py-1 text-right text-[11px] tabular-nums">
                          {dayPct !== null ? (
                            <span style={{ color: dayPct > 0 ? "#00e676" : dayPct < 0 ? "#ef4444" : "#9ca3af" }}>
                              {dayPct > 0 ? "+" : ""}{dayPct.toFixed(2)}%
                            </span>
                          ) : <span className="text-gray-600">—</span>}
                        </td>}
                        {window._ttIsPro && <td className="px-1 py-1 text-right text-[11px] tabular-nums">
                          {dayChg !== null ? (
                            <span style={{ color: dayChg > 0 ? "#00e676" : dayChg < 0 ? "#ef4444" : "#9ca3af" }}>
                              {dayChg > 0 ? "+" : ""}{dayChg.toFixed(2)}
                            </span>
                          ) : <span className="text-gray-600">—</span>}
                        </td>}
                        {/* Progress Bar / Trade */}
                        <td className="px-1 py-1" style={{ minWidth: showProgress ? 160 : 40 }}>
                          {showProgress ? (
                            <MiniProgressBar t={t} trade={trade} />
                          ) : <span className="text-[9px] text-gray-600 block text-center">—</span>}
                        </td>
                        {/* Score */}
                        <td className="px-1 py-1.5 text-center">
                          {score > 0 ? (
                            <span
                              className="text-[11px] font-bold px-1 py-0.5 rounded"
                              style={{
                                color: score >= 80 ? "#22c55e" : score >= 50 ? "#f59e0b" : "#ef4444",
                                background: score >= 80 ? "rgba(34,197,94,0.12)" : score >= 50 ? "rgba(245,158,11,0.12)" : "rgba(239,68,68,0.12)",
                              }}
                            >
                              {Math.round(score)}
                            </span>
                          ) : <span className="text-[11px] text-gray-600">—</span>}
                        </td>
                        {/* Rank */}
                        <td className="px-1 py-1.5 text-center text-[11px] tabular-nums">
                          {rank ? (
                            <span className="text-gray-300">{rank}<span className="text-gray-600 text-[9px]">/{rankTotal}</span></span>
                          ) : <span className="text-gray-600">—</span>}
                        </td>
                        {/* R:R */}
                        <td className="px-1 py-1.5 text-center text-[11px] tabular-nums">
                          {rr !== null && Number.isFinite(rr) ? (
                            <span className={rr >= 2 ? "text-[#00e676] font-semibold" : rr >= 1 ? "text-gray-300" : "text-rose-400"}>
                              {rr.toFixed(1)}
                            </span>
                          ) : <span className="text-gray-600">—</span>}
                        </td>
                        {/* Flags */}
                        <td className="px-1 py-1.5 text-center text-[11px]">
                          {badges.length > 0 ? badges.join("") : <span className="text-gray-600">—</span>}
                        </td>
                        {/* Stage lane columns: colored dot in active stage, pulse for critical */}
                        {STAGE_KEYS.map(sk => {
                          const isActive = sk === stg;
                          const isCritical = isActive && ["enter", "defend", "trim"].includes(sk);
                          const pulseStyle = isCritical ? {
                            animation: "stage-dot-pulse 1.8s ease-in-out infinite",
                            boxShadow: sk === "enter" ? "0 0 6px rgba(45,212,191,0.5)" : sk === "defend" ? "0 0 6px rgba(251,146,60,0.5)" : "0 0 6px rgba(250,204,21,0.5)",
                          } : {};
                          return (
                            <td key={sk} className="px-1 py-1 text-center">
                              {isActive ? (
                                <span
                                  className={`inline-block w-3 h-3 rounded-full border ${STAGE_META[sk].cls}`}
                                  style={pulseStyle}
                                  title={STAGE_META[sk].label}
                                />
                              ) : null}
                            </td>
                          );
                        })}
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
            <div className="mt-2 text-[10px] text-[#6b7280] flex items-center justify-between">
              <span>Showing {filtered.length} of {tickersWithStage.length} tickers</span>
              <span className="flex items-center gap-3">
                {Object.entries(STAGE_META).map(([k, v]) => (
                  <span key={k} className="flex items-center gap-1">
                    <span>{v.icon}</span>
                    <span>{v.label}: {stageCounts[k] || 0}</span>
                  </span>
                ))}
              </span>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // KanbanColumn — extracted outside EarlyMoversPanel so React
      // treats it as a STABLE component type across re-renders.
      // Defining it inline caused unmount/remount on every price tick
      // → scroll position destroyed → useLayoutEffect re-animated it
      // → visible "jerk back and come back" every 30 seconds.
      // ─────────────────────────────────────────────────────────────
      const KanbanColumn = React.memo(function KanbanColumn({
        laneKey,
        title,
        subtitle,
        count,
        icon,
        color,
        items,
        showProgress,
        showOpen,
        showDetails,
        laneScrollTopRef,
        renderCompactCard,
      }) {
        const listRef = React.useRef(null);

        // Restore horizontal scroll position ONLY when the lane
        // membership changes (items added/removed/reordered).
        // Price-only updates don't touch scroll.
        const itemKeys = React.useMemo(
          () => (items || []).map((t) => t.ticker || t.symbol || "").join(","),
          [items],
        );
        React.useLayoutEffect(() => {
          try {
            const el = listRef.current;
            if (!el) return;
            const saved = laneScrollTopRef.current[laneKey];
            if (Number.isFinite(saved) && saved > 0) el.scrollLeft = saved;
          } catch {}
        }, [itemKeys, laneKey]);

        return (
          <div className="flex items-stretch gap-0 mb-1 kanban-lane">
            {/* Lane label */}
            <div
              className={`flex flex-col justify-center items-center w-[52px] shrink-0 rounded-l-xl border-l-2 border-t border-b border-t-white/[0.04] border-b-white/[0.04] ${color} px-1 py-2`}
              style={{ background: "linear-gradient(180deg, rgba(255,255,255,0.04) 0%, rgba(255,255,255,0.015) 100%)" }}
              title={subtitle || title}
            >
              <span className="text-[11px] font-semibold text-white/90 tracking-wide text-center leading-tight">
                {icon}<br/>{title}
              </span>
              <span className={`text-[10px] font-bold tabular-nums mt-0.5 ${count > 0 ? "text-white/80" : "text-[#4b5563]"}`}>
                {count}
              </span>
            </div>
            {/* Horizontal scrollable card area */}
            <div
              ref={listRef}
              className="flex-1 rounded-r-xl border-t border-r border-b border-white/[0.04] p-1.5 overflow-x-auto scrollbar-hide"
              style={{ overflowAnchor: "none", WebkitOverflowScrolling: "touch", background: "rgba(255,255,255,0.01)" }}
              onScroll={() => {
                try {
                  const el = listRef.current;
                  if (!el) return;
                  laneScrollTopRef.current[laneKey] = el.scrollLeft;
                } catch {}
              }}
            >
              {Array.isArray(items) && items.length > 0 ? (
                <div className="flex gap-1.5">
                  {items
                    .slice(0, 80)
                    .map((t) => (
                      <div key={t.ticker || t.symbol} className="w-[280px] shrink-0 kanban-card">
                        {renderCompactCard(t)}
                      </div>
                    ))}
                  {!window._ttIsPro && (
                    <div className="w-[280px] shrink-0 kanban-card flex items-center justify-center">
                      <div className="w-full rounded-xl border border-amber-500/30 bg-gradient-to-br from-amber-500/10 to-amber-600/5 p-4 flex flex-col items-center gap-2 text-center cursor-pointer hover:border-amber-400/50 transition-colors"
                        onClick={() => window.dispatchEvent(new CustomEvent("tt-go-pro"))}>
                        <svg className="w-6 h-6 text-amber-400" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/></svg>
                        <span className="text-[11px] font-bold text-amber-300">Unlock All Tickers</span>
                        <span className="text-[9px] text-gray-400">Upgrade to Pro for full access</span>
                        <span className="mt-1 px-3 py-1 rounded-full bg-amber-500/20 border border-amber-500/40 text-[10px] font-bold text-amber-300 hover:bg-amber-500/30 transition-colors">Go Pro</span>
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                <div className="text-[10px] text-[#4b5563] italic flex items-center h-full px-2">
                  {!window._ttIsPro ? (
                    <span className="flex items-center gap-1 cursor-pointer text-amber-400/70 hover:text-amber-300 transition-colors" onClick={() => window.dispatchEvent(new CustomEvent("tt-go-pro"))}>
                      <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/></svg>
                      Go Pro to unlock
                    </span>
                  ) : "No tickers"}
                </div>
              )}
            </div>
          </div>
        );
      });

      // ─────────────────────────────────────────────────────────────
      // Early Movers Panel: Kanban-style trading flow
      // ─────────────────────────────────────────────────────────────
      function EarlyMoversPanel({
        tickers = [],
        trades = [],
        onSelectTicker = null,
        rankPositions = {},
        rankTotal = null,
        savedTickers = new Set(),
        toggleSavedTicker = null,
        addingTicker = null,
      }) {
        const now = Date.now();
        const laneScrollTopRef = React.useRef({});
        const [expandedTicker, setExpandedTicker] = React.useState(null);
        const toggleExpanded = (sym) => {
          const t = String(sym || "").toUpperCase();
          if (!t) return;
          setExpandedTicker((cur) =>
            String(cur || "").toUpperCase() === t ? null : t,
          );
        };

        // Map ticker -> latest trade (by exit_ts or entry_ts) for lane override
        const tradeByTicker = React.useMemo(() => {
          const map = new Map();
          if (!Array.isArray(trades)) return map;
          trades.forEach((tr) => {
            const sym = String(tr?.ticker || "").toUpperCase();
            if (!sym) return;
            const existing = map.get(sym);
            const exitTs = tr.exit_ts ?? tr.exitTs ?? 0;
            const entryTs = tr.entry_ts ?? tr.entryTime ?? tr.entryTs ?? 0;
            if (!existing) {
              map.set(sym, tr);
              return;
            }
            const exExit = existing.exit_ts ?? existing.exitTs ?? 0;
            const exEntry = existing.entry_ts ?? existing.entryTime ?? existing.entryTs ?? 0;
            const trOpen = !exitTs, exOpen = !exExit;
            if ((trOpen && !exOpen) || (trOpen && exOpen && entryTs > exEntry) || (!trOpen && !exOpen && exitTs > exExit)) {
              map.set(sym, tr);
            }
          });
          return map;
        }, [trades]);

        // Categorize tickers into Kanban lanes
        // Discovery: Setup | Enter
        // Management: Hold | Defend | Trim | Exit
        const categories = React.useMemo(() => {
          const setup = [];
          const enter = [];
          const newLane = [];
          const hold = [];
          const defend = [];
          const trim = [];
          const exit = [];

          tickers.forEach((t) => {
            if (t?.kanban_stage === null) return;

            let stage = String(t?.kanban_stage || "");
            const sym = String(t?.ticker || "").toUpperCase();
            const trade = tradeByTicker.get(sym);
            const status = trade ? String(trade.status || "").toUpperCase() : "";
            const trimmedPct = Number(trade?.trimmed_pct ?? trade?.trimmedPct ?? 0);
            const isClosed =
              status === "WIN" ||
              status === "LOSS" ||
              !!(trade?.exit_ts ?? trade?.exitTs) ||
              trimmedPct >= 0.9999;
            const isOpen = !isClosed && (status === "OPEN" || status === "TP_HIT_TRIM" || !status);

            // ═══════════════════════════════════════════════════════════════
            // TRADE LIFECYCLE OVERRIDE — open trades NEVER fall back to
            // discovery lanes (setup/enter).  They stay in management lanes.
            // Priority: exit > trim > defend > hold (based on trade state)
            // Recently closed trades (< 24h) → Exit lane for visibility.
            // ═══════════════════════════════════════════════════════════════
            if (trade && isOpen) {
              // Trim lane: partial TP hit or manually trimmed
              if (status === "TP_HIT_TRIM" || (Number(trade.trimmed_pct ?? trade.trimmedPct ?? 0) > 0)) {
                stage = "trim";
              }
              // If stage is already a valid management lane, keep it
              else if (stage === "defend" || stage === "trim" || stage === "exit") {
                // keep stage as-is
              }
              // Everything else (setup, enter, flip_watch, just_flipped, archive, empty, etc.)
              // → force to HOLD.  An open trade is a held position, period.
              else if (stage !== "hold" && stage !== "active" && stage !== "just_entered") {
                stage = "hold";
              }
            }

            // Recently closed trades stay in Exit lane for 24h — unless scorer is promoting a new setup
            if (trade && isClosed) {
              const exitMs = Number(trade.exit_ts ?? trade.exitTs ?? 0);
              const scorerStage = String(t?.kanban_stage || "");
              const newOpportunity = ["setup", "enter", "enter_now", "just_flipped"].includes(scorerStage);
              if (exitMs > 0 && (Date.now() - exitMs) < 24 * 60 * 60 * 1000 && !newOpportunity) stage = "exit";
            }

            // Map server stages to UI lanes
            switch (stage) {
              case "setup":
              case "setup_watch":
              case "flip_watch":
                setup.push(t);
                break;
              case "enter":
              case "enter_now":
              case "just_flipped":
                enter.push(t);
                break;
              case "just_entered":
                newLane.push(t);
                break;
              case "active":
              case "hold":
                hold.push(t);
                break;
              case "defend":
                defend.push(t);
                break;
              case "trim":
                trim.push(t);
                break;
              case "exit":
                exit.push(t);
                break;
              default:
                // watch, closed, archive, unrecognized → not shown in pipeline
                break;
            }
          });

          // Sort discovery lanes (setup/enter): best score first, then alpha tie-break
          const sortByScore = (arr) => arr.sort((a, b) => {
            const sa = Number(a?.score ?? a?.flip_watch_score ?? 0) || 0;
            const sb = Number(b?.score ?? b?.flip_watch_score ?? 0) || 0;
            if (sb !== sa) return sb - sa;
            return String(a?.ticker || "").localeCompare(String(b?.ticker || ""));
          });
          // Sort management lanes (hold/defend/trim/exit): alphabetical ASC
          const sortAlpha = (arr) => arr.sort((a, b) =>
            String(a?.ticker || "").localeCompare(String(b?.ticker || ""))
          );

          return {
            setup: sortByScore(setup),
            enter: sortByScore(enter),
            new: sortAlpha(newLane),
            hold: sortAlpha(hold),
            defend: sortAlpha(defend),
            trim: sortAlpha(trim),
            exit: sortAlpha(exit),
          };
        }, [tickers, tradeByTicker]);

        const {
          setup,
          enter,
          new: newEntries,
          hold,
          defend,
          trim,
          exit,
        } = categories;

        // Compact card renderer — memoized so KanbanColumn React.memo can skip re-renders
        // when only prices change (same card renderer reference → shallow equal).
        const renderCompactCard = React.useCallback(
          (t) => renderCompactCardFn(t, { onSelectTicker, savedTickers, toggleSavedTicker, tradeByTicker, addingTicker }),
          [onSelectTicker, savedTickers, toggleSavedTicker, tradeByTicker, addingTicker],
        );

        if (
          setup.length === 0 &&
          enter.length === 0 &&
          newEntries.length === 0 &&
          hold.length === 0 &&
          defend.length === 0 &&
          trim.length === 0 &&
          exit.length === 0
        ) {
          // Show skeleton cards while data is loading
          if (tickers.length === 0) {
            return (
              <div className="flex flex-col gap-1 mt-2">
                {[0,1,2].map(i => (
                  <div key={`skel-row-${i}`} className="flex items-stretch gap-0 mb-1">
                    <div className="w-[52px] shrink-0 rounded-l-xl border-l-2 border-t border-b border-white/[0.04] skeleton-card" style={{ minHeight: 134 }} />
                    <div className="flex-1 rounded-r-xl border-t border-r border-b border-white/[0.04] p-1.5 flex gap-1.5" style={{ background: "rgba(255,255,255,0.01)" }}>
                      {[0,1,2,3].map(j => (
                        <div key={`skel-${i}-${j}`} className="w-[280px] h-[134px] shrink-0 skeleton-card" />
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            );
          }
          return null;
        }

        return (
          <div>
            {/* Legend Bar: Badges with descriptions (matches Table View) */}
            <div className="mb-2 px-2 py-1.5 rounded-lg border border-white/[0.04] bg-white/[0.015] flex items-center flex-nowrap gap-x-5 text-[10px] text-[#6b7280] overflow-x-auto">
              <span className="text-[11px] font-semibold text-white/70 shrink-0">Badges</span>
              <span className="shrink-0">💎 <span className="text-[#8b95a5]">Prime — top-quality setup</span></span>
              <span className="shrink-0">🎯 <span className="text-[#8b95a5]">Entry Zone — actionable window</span></span>
              <span className="shrink-0">🔥 <span className="text-[#8b95a5]">MoElite — strong momentum</span></span>
              <span className="shrink-0">🧨 <span className="text-[#8b95a5]">Squeeze — pressure building</span></span>
              <span className="shrink-0">⚡ <span className="text-[#8b95a5]">Release — breakout firing</span></span>
              <span className="shrink-0">📅 <span className="text-[#8b95a5]">Earnings — within 7 days</span></span>
            </div>
            <div>
              <div className="flex flex-col">
                {/* DISCOVERY MODE - No position yet */}
                <KanbanColumn
                  laneKey="setup"
                  title="Setup"
                  subtitle="Entry qualified — awaiting execution window"
                  count={setup.length}
                  icon="📋"
                  color="border-amber-500"
                  items={setup}
                  showDetails={true}
                  laneScrollTopRef={laneScrollTopRef}
                  renderCompactCard={renderCompactCard}
                />
                <KanbanColumn
                  laneKey="enter"
                  title="Enter"
                  subtitle="All gates clear — system will execute"
                  count={enter.length}
                  icon="🎯"
                  color="border-teal-500"
                  items={enter}
                  showDetails={true}
                  laneScrollTopRef={laneScrollTopRef}
                  renderCompactCard={renderCompactCard}
                />
                <KanbanColumn
                  laneKey="new"
                  title="New"
                  subtitle="Entered today — position just opened"
                  count={newEntries.length}
                  icon="🆕"
                  color="border-[#00c853]"
                  items={newEntries}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                  laneScrollTopRef={laneScrollTopRef}
                  renderCompactCard={renderCompactCard}
                />
                {/* MANAGEMENT MODE - Has open position */}
                <KanbanColumn
                  laneKey="hold"
                  title="Hold"
                  subtitle="Position healthy - let it run"
                  count={hold.length}
                  icon="🔒"
                  color="border-cyan-500"
                  items={hold}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                  laneScrollTopRef={laneScrollTopRef}
                  renderCompactCard={renderCompactCard}
                />
                <KanbanColumn
                  laneKey="defend"
                  title="Defend"
                  subtitle="Warning indicators - tighten stops"
                  count={defend.length}
                  icon="🛡"
                  color="border-orange-500"
                  items={defend}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                  laneScrollTopRef={laneScrollTopRef}
                  renderCompactCard={renderCompactCard}
                />
                <KanbanColumn
                  laneKey="trim"
                  title="Trim"
                  subtitle="Near TP - take partial profits"
                  count={trim.length}
                  icon="✂️"
                  color="border-yellow-500"
                  items={trim}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                  laneScrollTopRef={laneScrollTopRef}
                  renderCompactCard={renderCompactCard}
                />
                <KanbanColumn
                  laneKey="exit"
                  title="Exit"
                  subtitle="Stop hit or invalidated - close"
                  count={exit.length}
                  icon="🚪"
                  color="border-rose-500"
                  items={exit}
                  showProgress={true}
                  showOpen={true}
                  showDetails={true}
                  laneScrollTopRef={laneScrollTopRef}
                  renderCompactCard={renderCompactCard}
                />
                {/* Closed lane removed - completed trades available in Simulation Dashboard */}
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Opportunities Panel: unified (Prime/Eligible/Watch)
      // ─────────────────────────────────────────────────────────────
      function OpportunitiesPanel({
        tickers = [],
        rankPositions = null,
        onSelectTicker,
        trades = [],
        defaultView = "prime",
        title = "✨ Opportunities",
        maxHeightClass = "max-h-[520px]",
        fillHeight = false,
        onFilteredTickersChange = null,
        showControls = true,
        thesisMode = false,
        savedTickers = new Set(),
        toggleSavedTicker = null,
        addingTicker = null,
      }) {
        const [view, setView] = React.useState(defaultView); // prime | eligible | watch | all | today
        const [dir, setDir] = React.useState("ALL"); // ALL | LONG | SHORT
        const [horizon, setHorizon] = React.useState("ALL"); // ALL | SHORT_TERM | SWING | POSITIONAL
        const [moveFilter, setMoveFilter] = React.useState("ALL"); // ALL | ACTIVE | INVALIDATED | COMPLETED
        const [query, setQuery] = React.useState("");
        const [sortBy, setSortBy] = React.useState("RANK"); // RANK | ABC | DCHG
        const [todaySnapshot, setTodaySnapshot] = React.useState(null); // { createdAt, tickers: [], rpBy: {} }

        const todayStorageKey = React.useMemo(() => {
          // Daily key (keeps “Today” list stable across refreshes)
          const d = new Date();
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, "0");
          const day = String(d.getDate()).padStart(2, "0");
          return `timedTrading_todayBest_${y}-${m}-${day}`;
        }, []);

        const tradeByTicker = React.useMemo(() => {
          const map = new Map();
          if (!Array.isArray(trades)) return map;
          trades.forEach((tr) => {
            const sym = String(tr?.ticker || "").toUpperCase();
            if (!sym) return;
            const existing = map.get(sym);
            const exitTs = tr.exit_ts ?? tr.exitTs ?? 0;
            const entryTs = tr.entry_ts ?? tr.entryTime ?? tr.entryTs ?? 0;
            if (!existing) {
              map.set(sym, tr);
              return;
            }
            const exExit = existing.exit_ts ?? existing.exitTs ?? 0;
            const exEntry = existing.entry_ts ?? existing.entryTime ?? existing.entryTs ?? 0;
            const trOpen = !exitTs, exOpen = !exExit;
            if ((trOpen && !exOpen) || (trOpen && exOpen && entryTs > exEntry) || (!trOpen && !exOpen && exitTs > exExit)) {
              map.set(sym, tr);
            }
          });
          return map;
        }, [trades]);

        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isEligible = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);

          // corridor is a core requirement for entry-readiness
          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct)
            return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct)
            return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf)
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr)
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const toBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const classify = (t) => {
          const prime = isPrimeBubble(t);
          const eligible = isEligible(t);
          const ms =
            t?.move_status && typeof t.move_status === "object"
              ? t.move_status
              : null;
          const moveStatus =
            ms && ms.status ? String(ms.status).toUpperCase() : "ACTIVE";
          return {
            prime,
            eligible,
            bucket: toBucket(t),
            dir: getDirection(t)?.text || "NEUTRAL",
            moveStatus,
          };
        };

        // “Today’s Best Setups” (stable snapshot): favor corridor candidates with good RR/phase/completion.
        const isTodayBestSetup = (t) => {
          if (!t) return false;
          const ent = entryType(t);
          if (!ent?.corridor) return false;
          const rr = Number(t?.rr);
          const comp = completionForSize(t);
          const phase = Number(t?.phase_pct);
          const zone = String(t?.phase_zone || "").toUpperCase();
          if (Number.isFinite(rr) && rr < 1.5) return false;
          // Keep this list broad enough to be useful, while avoiding late/extended conditions.
          if (Number.isFinite(comp) && comp > 0.6) return false;
          if (zone === "HIGH" || zone === "EXTREME") return false;
          if (Number.isFinite(phase) && phase > 0.7) return false;
          return true;
        };

        const bestLiveForToday = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const out = [];
          for (const t of list) {
            if (!t?.ticker) continue;
            if (!isTodayBestSetup(t)) continue;
            const sym = String(t.ticker).toUpperCase();
            const rp =
              getRankPositionFromMap(rankPositions, sym) ??
              Number(t?.rank_position);
            out.push({
              sym,
              rp: Number.isFinite(rp) ? rp : null,
            });
          }
          out.sort((a, b) => {
            if (a.rp != null && b.rp != null) return a.rp - b.rp;
            if (a.rp != null) return -1;
            if (b.rp != null) return 1;
            return a.sym.localeCompare(b.sym);
          });
          const top = out.slice(0, 25);
          const rpBy = {};
          for (const x of top) {
            if (x.sym && x.rp != null) rpBy[x.sym] = x.rp;
          }
          return { tickers: top.map((x) => x.sym), rpBy };
        }, [tickers, rankPositions]);

        // Load snapshot from localStorage (per-day).
        React.useEffect(() => {
          try {
            const raw = localStorage.getItem(todayStorageKey);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (parsed && Array.isArray(parsed.tickers)) {
              setTodaySnapshot(parsed);
            }
          } catch {
            // ignore
          }
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [todayStorageKey]);

        const updateTodaySnapshot = React.useCallback(() => {
          const snap = {
            createdAt: Date.now(),
            tickers: bestLiveForToday.tickers,
            rpBy: bestLiveForToday.rpBy,
          };
          setTodaySnapshot(snap);
          try {
            localStorage.setItem(todayStorageKey, JSON.stringify(snap));
          } catch {
            // ignore
          }
        }, [bestLiveForToday, todayStorageKey]);

        // Ensure snapshot exists when user switches to “Today”.
        React.useEffect(() => {
          if (view !== "today") return;
          if (
            todaySnapshot &&
            Array.isArray(todaySnapshot.tickers) &&
            todaySnapshot.tickers.length > 0
          )
            return;
          if (bestLiveForToday.tickers.length > 0) updateTodaySnapshot();
        }, [view, todaySnapshot, bestLiveForToday, updateTodaySnapshot]);

        const counts = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          let prime = 0;
          let eligibleOnly = 0;
          let watch = 0;
          let active = 0;
          let invalidated = 0;
          let completed = 0;
          for (const t of list) {
            const c = classify(t);
            if (c.prime) prime++;
            else if (c.eligible) eligibleOnly++;
            else watch++;
            if (c.moveStatus === "INVALIDATED") invalidated++;
            else if (c.moveStatus === "COMPLETED") completed++;
            else active++;
          }
          return {
            prime,
            eligibleOnly,
            watch,
            all: list.length,
            active,
            invalidated,
            completed,
          };
        }, [tickers]);

        const filtered = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const q = String(query || "")
            .trim()
            .toUpperCase();

          const itemsAll = list
            .map((t) => {
              const c = classify(t);
              const status = c.prime
                ? "prime"
                : c.eligible
                  ? "eligible"
                  : "watch";
              const score = Number(rankScoreForTicker(t) || 0);
              const sym = String(t?.ticker || "").toUpperCase();
              const rp =
                getRankPositionFromMap(rankPositions, sym) ??
                Number(t?.rank_position);
              return {
                t,
                c,
                status,
                score,
                rp: Number.isFinite(rp) ? rp : null,
                sym,
              };
            })
            .filter(({ t }) => !!t?.ticker);

          // Special mode: stable “Today” list (snapshot + movement deltas).
          if (view === "today") {
            const bySym = {};
            for (const it of itemsAll) {
              if (it.sym && !bySym[it.sym]) bySym[it.sym] = it;
            }

            const snapTickers =
              todaySnapshot &&
              Array.isArray(todaySnapshot.tickers) &&
              todaySnapshot.tickers.length > 0
                ? todaySnapshot.tickers
                : bestLiveForToday.tickers;
            const snapRpBy =
              todaySnapshot && todaySnapshot.rpBy
                ? todaySnapshot.rpBy
                : bestLiveForToday.rpBy;

            const out = [];
            const inSnap = new Set();
            for (const sym of snapTickers) {
              const S = String(sym || "").toUpperCase();
              if (!S) continue;
              inSnap.add(S);
              const it = bySym[S];
              if (!it) continue;
              out.push({
                ...it,
                snapRp: Number.isFinite(Number(snapRpBy?.[S]))
                  ? Number(snapRpBy[S])
                  : null,
                dropped: !isTodayBestSetup(it.t),
              });
            }

            // Append newly-qualifying setups (so you don’t miss fresh arrivals) but keep them after the snapshot.
            for (const sym of bestLiveForToday.tickers) {
              const S = String(sym || "").toUpperCase();
              if (!S || inSnap.has(S)) continue;
              const it = bySym[S];
              if (!it) continue;
              out.push({ ...it, snapRp: null, dropped: false, isNew: true });
            }

            // Apply move filter to Today list too (optional, but matches user intent).
            if (moveFilter !== "ALL") {
              return out.filter((it) => it?.c?.moveStatus === moveFilter);
            }
            return out;
          }

          const items = itemsAll
            .filter(({ t, c, status }) => {
              if (!showControls) return true;
              if (view !== "all" && status !== view) return false;
              if (dir !== "ALL" && c.dir !== dir) return false;
              if (moveFilter !== "ALL" && c.moveStatus !== moveFilter)
                return false;
              if (horizon !== "ALL" && c.bucket !== horizon) return false;
              if (q && !String(t.ticker).toUpperCase().includes(q))
                return false;
              return true;
            })
            .sort((a, b) => {
              const mode = String(sortBy || "RANK").toUpperCase();
              if (mode === "ABC") {
                return String(a.t.ticker).localeCompare(String(b.t.ticker));
              }
              if (mode === "DCHG") {
                const ad = Number(getDailyChange(a.t)?.dayPct);
                const bd = Number(getDailyChange(b.t)?.dayPct);
                const aOk = Number.isFinite(ad);
                const bOk = Number.isFinite(bd);
                if (aOk && bOk) return bd - ad; // highest % first
                if (aOk) return -1;
                if (bOk) return 1;
                // fallback to rank
              }

              // Default: Rank-position first (stable + intuitive).
              // If rank position isn't available, fall back to score.
              const ar = a.rp;
              const br = b.rp;
              if (ar != null && br != null) return ar - br;
              if (ar != null) return -1;
              if (br != null) return 1;
              const ds = (b.score || 0) - (a.score || 0);
              if (ds !== 0) return ds;
              return String(a.t.ticker).localeCompare(String(b.t.ticker));
            });

          return items;
        }, [
          tickers,
          view,
          dir,
          moveFilter,
          horizon,
          query,
          rankPositions,
          sortBy,
          todaySnapshot,
          bestLiveForToday,
        ]);

        React.useEffect(() => {
          if (!onFilteredTickersChange) return;
          try {
            onFilteredTickersChange(
              filtered.map((x) => x.t),
              { view, dir, horizon, query, count: filtered.length },
            );
          } catch (e) {
            console.warn("[Viewport] onFilteredTickersChange failed", e);
          }
        }, [filtered, view, dir, horizon, query, onFilteredTickersChange]);

        const Row = ({ item }) => {
          const t = item.t;
          const c = item.c;
          const winnerSig = isWinnerSignature(t);
          const flags = t?.flags || {};
          const isInSqueeze = !!flags.sq30_on && !flags.sq30_release;
          const badgeEmojis = [
            isPrimeBubble(t) ? "💎" : null,
            flags.flip_watch ? "🎯" : null,
            flags.momentum_elite ? "🔥" : null,
            flags.sq30_release ? "⚡" : null,
            isInSqueeze ? "🧨" : null,
            item?.isNew ? "🆕" : null,
            item?.dropped ? "⚠️" : null,
          ].filter(Boolean);
          const actionInfo = getActionDescription(t);
          const price = Number(t?.price);
          const rr = Number(t?.rr);
          const eta = computeEtaDays(t);
          const ingestText = formatIngestTime(t);
          const sl = numFromAny(t?.sl ?? t?.sl_price);
          // Use server-provided TP directly
          const tpDisplay = numFromAny(t?.tp ?? t?.tp_trim);

          const dc = getDailyChange(t);
          const stale = dc?.stale;
          const marketOpen = dc?.marketOpen;
          const isStale = !!stale?.isStale;

          const skin = getCardSkin(t);
          const dayChg = skin?.dayChg;
          const dayPct = skin?.dayPct;
          const chgColor =
            isStale && marketOpen
              ? "text-yellow-300"
              : Number(dayChg || dayPct || 0) >= 0
                ? "text-sky-300"
                : "text-orange-300";

          const statusPill =
            item.status === "prime"
              ? {
                  label: "Prime",
                  cls: "bg-yellow-500/15 text-yellow-300 border-yellow-500/40",
                }
              : item.status === "eligible"
                ? {
                    label: "Eligible",
                    cls: "bg-teal-500/15 text-teal-400 border-teal-500/40",
                  }
                : {
                    label: "Watch",
                    cls: "bg-white/[0.04] text-[#6b7280] border-white/[0.06]",
                  };

          const dirPill =
            c.dir === "LONG"
              ? {
                  label: "L",
                  cls: "bg-cyan-400/20 text-cyan-200 border-cyan-400/50",
                }
              : c.dir === "SHORT"
                ? {
                    label: "S",
                    cls: "bg-rose-500/20 text-rose-200 border-rose-400/50",
                  }
                : {
                    label: c.dir === "LONG" ? "L" : c.dir === "SHORT" ? "S" : c.dir,
                    cls: "bg-white/[0.04] text-[#6b7280] border-white/[0.06]",
                  };
          const dirAccentCls = c.dir === "LONG" ? "border-l-4 border-l-cyan-400" : c.dir === "SHORT" ? "border-l-4 border-l-rose-500" : "";

          const moveStatus = String(c?.moveStatus || "ACTIVE").toUpperCase();
          const moveEmoji =
            moveStatus === "INVALIDATED"
              ? "⛔"
              : moveStatus === "COMPLETED"
                ? "✅"
                : "🟢";
          const moveTitle = (() => {
            const ms =
              t?.move_status && typeof t.move_status === "object"
                ? t.move_status
                : null;
            if (!ms) return `Move: ${moveStatus}`;
            const reasons = Array.isArray(ms.reasons) ? ms.reasons : [];
            const r = reasons
              .filter((x) => x != null)
              .map((x) => String(x))
              .filter((x) => x.trim())
              .slice(0, 6)
              .join(", ");
            return r ? `Move: ${moveStatus} — ${r}` : `Move: ${moveStatus}`;
          })();

          const dirOutlineCls = c.dir === "LONG" ? "border border-cyan-400/40" : c.dir === "SHORT" ? "border border-rose-500/40" : "border border-white/[0.06]";
          const stage = String(t?.kanban_stage || "").toLowerCase();
          const isActionLane = ["enter_now", "trim", "exit"].includes(stage);
          const pulseCls = isActionLane ? (c.dir === "LONG" ? "card-pulse" : c.dir === "SHORT" ? "card-pulse-short" : "") : "";
          return (
            <button
              key={t.ticker}
              onClick={() => onSelectTicker && onSelectTicker(t.ticker)}
              className={`w-full text-left px-3 py-2 rounded-lg hover:brightness-[1.06] relative ${
                winnerSig
                  ? "border border-purple-500/50 hover:border-purple-400"
                  : dirOutlineCls
              } ${dirAccentCls} ${pulseCls}`}
              style={{
                backgroundColor: "transparent",
                backgroundImage: skin?.bgImage || undefined,
              }}
              title="Open in right rail"
            >
              {c.dir && <div className={`absolute top-0 left-0 right-0 h-0.5 rounded-t-lg ${c.dir === "LONG" ? "bg-cyan-400/60" : "bg-rose-500/60"}`} />}
              <div className="flex items-start justify-between gap-2">
                <div className="min-w-0">
                  <div className="flex items-center gap-2 flex-wrap">
                    <span
                      className="text-[12px]"
                      title={moveTitle}
                      aria-label={`Move status ${moveStatus}`}
                    >
                      {moveEmoji}
                    </span>
                    <div className="font-bold text-white">{t.ticker}</div>
                    {badgeEmojis.length > 0 && (
                      <span className="px-2 py-0.5 rounded border border-white/[0.06] bg-white/[0.03] text-[10px] font-semibold text-[#d1d5db]">
                        {badgeEmojis.join("")}
                      </span>
                    )}
                    <span
                      className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${statusPill.cls}`}
                    >
                      {statusPill.label}
                    </span>
                    <span
                      className={`px-3 py-1 rounded-md border text-xs font-extrabold tracking-wide ${dirPill.cls}`}
                      title="Directional bias (makes LONG/SHORT stand out)"
                    >
                      {dirPill.label}
                    </span>
                    {c.bucket && c.bucket !== "UNKNOWN" && (
                      <span className="px-2 py-0.5 rounded border border-white/[0.06] bg-white/[0.03] text-[10px] text-[#6b7280]">
                        {c.bucket === "SHORT_TERM"
                          ? "≤7d"
                          : c.bucket === "SWING"
                            ? "8–30d"
                            : "31d+"}
                      </span>
                    )}
                  </div>
                  <div className="mt-0.5 text-[11px] text-[#6b7280] whitespace-nowrap overflow-hidden text-ellipsis">
                    <span className="text-[#4b5563]">{actionInfo.action}</span>
                  </div>
                </div>

                <div className="flex items-center gap-3 flex-shrink-0">
                  {t._sparkline && t._sparkline.length >= 3 && (
                    <div style={{ width: 120 }}>
                      <Sparkline data={(() => {
                        const lp = Number(t._live_price || t.price);
                        const sp = t._sparkline;
                        if (lp > 0 && sp.length > 0 && Math.abs(lp - sp[sp.length - 1]) / sp[sp.length - 1] > 0.005) return [...sp, lp];
                        return sp;
                      })()} width={120} height={24} />
                    </div>
                  )}
                  <div className="text-right text-[11px]">
                    <div className="text-white">
                      {Number.isFinite(price) ? `$${price.toFixed(2)}` : "—"}
                    </div>
                    <div className={`mt-0.5 ${chgColor}`}>
                      {Number.isFinite(dayPct)
                        ? `${dayPct >= 0 ? "+" : ""}${dayPct.toFixed(2)}%`
                        : "—"}{" "}
                      {Number.isFinite(dayChg)
                        ? `(${dayChg >= 0 ? "+" : ""}${fmtUsdAbs(dayChg)})`
                        : ""}
                      {isStale && marketOpen && (
                        <span className="text-yellow-200/80">
                          {` (stale${stale?.ageLabel ? ` ${stale.ageLabel}` : ""})`}
                        </span>
                      )}
                      {!marketOpen && (
                        <span className="text-[#6b7280] text-[10px]">
                          {stale?.ageLabel
                            ? ` AH • as of ${stale.ageLabel}`
                            : " AH"}
                        </span>
                      )}
                    </div>
                    <div className="text-[#4b5563]">{ingestText}</div>
                  </div>
                </div>
              </div>

              <div className="mt-1 grid grid-cols-6 gap-2 text-[10px] text-[#6b7280]">
                <div>
                  <span className="text-[#4b5563]">Score</span>{" "}
                  <span className="text-white font-semibold">
                    {(() => {
                      const s = rankScoreForTicker(item);
                      return Number.isFinite(s) ? s.toFixed(1) : "—";
                    })()}
                  </span>
                </div>
                <div>
                  <span className="text-[#4b5563]">Rank</span>{" "}
                  <span className="text-white font-semibold">
                    {item.rp != null ? `#${item.rp}` : "—"}
                    {item.snapRp != null && item.rp != null ? (
                      <span className="ml-1 text-[10px] text-[#4b5563]">
                        {item.snapRp > item.rp
                          ? `↑${item.snapRp - item.rp}`
                          : item.snapRp < item.rp
                            ? `↓${item.rp - item.snapRp}`
                            : "→0"}
                      </span>
                    ) : null}
                  </span>
                </div>
                <div>
                  <span className="text-[#4b5563]">RR</span>{" "}
                  <span className="text-white font-semibold">
                    {Number.isFinite(rr) ? rr.toFixed(2) : "—"}
                  </span>
                </div>
                <div>
                  <span className="text-[#4b5563]">SL</span>{" "}
                  <span className="text-rose-400 font-semibold">
                    {Number.isFinite(sl) ? `$${sl.toFixed(2)}` : "—"}
                  </span>
                </div>
                <div>
                  <span className="text-[#4b5563]">TP</span>{" "}
                  <span className="text-teal-400 font-semibold">
                    {Number.isFinite(tpDisplay)
                      ? `$${tpDisplay.toFixed(2)}`
                      : "—"}
                  </span>
                </div>
                <div>
                  <span className="text-[#4b5563]">ETA</span>{" "}
                  <span className="text-white font-semibold">
                    {eta != null ? `${eta.toFixed(1)}d` : "—"}
                  </span>
                </div>
              </div>

              {(() => {
                const phaseP = Math.max(
                  0,
                  Math.min(1, Number(t?.phase_pct) || 0),
                );
                const compP = completionForSize(t);
                const phaseColor = phaseToColor(phaseP);
                const compColor = phaseToColor(compP);
                const Bar = ({ label, p, color }) => (
                  <div className="flex items-center gap-2">
                    <div className="w-20 text-[10px] text-[#4b5563]">
                      {label}
                    </div>
                    <div className="flex-1 h-1.5 rounded bg-white/[0.03] border border-white/[0.06] overflow-hidden">
                      <div
                        className="h-full"
                        style={{
                          width: `${Math.round(p * 100)}%`,
                          background: color,
                        }}
                      />
                    </div>
                    <div className="w-10 text-right text-[10px] text-[#6b7280]">
                      {Math.round(p * 100)}%
                    </div>
                  </div>
                );
                return (
                  <div className="mt-2 space-y-1">
                    <Bar label="Phase" p={phaseP} color={phaseColor} />
                    <Bar label="Completion" p={compP} color={compColor} />
                  </div>
                );
              })()}
            </button>
          );
        };

        const pill = (label, isActive, onClick, count = null) => {
          const hasCount = Number.isFinite(count);
          return (
            <button
              onClick={onClick}
              className={`px-2.5 py-1 rounded-lg border text-xs font-semibold transition-all ${
                isActive
                  ? "border-blue-400 bg-blue-500/20 text-blue-200"
                  : "border-white/[0.06] bg-white/[0.03] text-[#6b7280] hover:text-white"
              }`}
            >
              <span className="inline-flex items-center gap-2">
                <span>{label}</span>
                {hasCount ? (
                  <span
                    className={`px-1.5 py-0.5 rounded-md text-[10px] font-bold border ${
                      isActive
                        ? "border-blue-400/40 bg-blue-400/10 text-blue-100"
                        : "border-white/[0.06] bg-white/[0.02] text-[#c8d2ff]"
                    }`}
                    title={`${count} tickers`}
                  >
                    {count}
                  </span>
                ) : null}
              </span>
            </button>
          );
        };

        return (
          <div
            className={`bg-transparent border border-white/[0.03] rounded-xl p-3 ${
              fillHeight ? "h-full flex flex-col" : ""
            }`}
          >
            <div className="flex items-start justify-between gap-3 flex-wrap">
              <div>
                <div className="text-[13px] font-medium text-[#d1d5db]">{title}</div>
                <div className="text-[10px] text-[#6b7280] mt-0.5">
                  Prime {counts.prime} • Eligible {counts.eligibleOnly} • Watch{" "}
                  {counts.watch} • Total {counts.all}
                  <span className="ml-2 text-[#4b5563]">
                    • 🟢 {counts.active} ⛔ {counts.invalidated} ✅{" "}
                    {counts.completed}
                  </span>
                </div>
              </div>
              <div className="flex items-center gap-2">
                {showControls && (
                  <input
                    value={query}
                    onChange={(e) => setQuery(e.target.value)}
                    placeholder="Ticker…"
                    className="px-2 py-1 text-xs bg-white/[0.03] border border-white/[0.06] rounded text-white w-[110px]"
                  />
                )}
                <select
                  value={sortBy}
                  onChange={(e) => setSortBy(e.target.value)}
                  className="px-2 py-1 text-xs bg-white/[0.03] border border-white/[0.06] rounded text-white"
                  title="Sort Viewport"
                >
                  <option value="RANK">Sort: Rank</option>
                  <option value="ABC">Sort: ABC</option>
                  <option value="DCHG">Sort: Daily %</option>
                </select>
                {view === "today" && (
                  <button
                    onClick={updateTodaySnapshot}
                    className="px-2 py-1 text-xs bg-blue-500/15 border border-blue-500/40 rounded text-blue-300 hover:bg-blue-500/25"
                    title="Refresh the Today snapshot (keeps list stable)"
                  >
                    Update snapshot
                  </button>
                )}
              </div>
            </div>

            {showControls && (
              <div className="mt-2 flex items-center gap-2 flex-wrap">
                {pill(
                  "Prime",
                  view === "prime",
                  () => setView("prime"),
                  counts.prime,
                )}
                {pill(
                  "Eligible",
                  view === "eligible",
                  () => setView("eligible"),
                  counts.eligibleOnly,
                )}
                {pill(
                  "Watch",
                  view === "watch",
                  () => setView("watch"),
                  counts.watch,
                )}
                {pill("All", view === "all", () => setView("all"), counts.all)}
                {pill(
                  "📅 Today",
                  view === "today",
                  () => setView("today"),
                  todaySnapshot &&
                    Array.isArray(todaySnapshot.tickers) &&
                    todaySnapshot.tickers.length > 0
                    ? todaySnapshot.tickers.length
                    : bestLiveForToday.tickers.length,
                )}
                <div className="w-px h-6 bg-white/[0.04] mx-1" />
                {pill("All", dir === "ALL", () => setDir("ALL"))}
                {pill("Long", dir === "LONG", () => setDir("LONG"))}
                {pill("Short", dir === "SHORT", () => setDir("SHORT"))}
                <div className="w-px h-6 bg-white/[0.04] mx-1" />
                {pill("Move: All", moveFilter === "ALL", () =>
                  setMoveFilter("ALL"),
                )}
                {pill("🟢 Active", moveFilter === "ACTIVE", () =>
                  setMoveFilter("ACTIVE"),
                )}
                {pill("⛔ Invalid", moveFilter === "INVALIDATED", () =>
                  setMoveFilter("INVALIDATED"),
                )}
                {pill("✅ Done", moveFilter === "COMPLETED", () =>
                  setMoveFilter("COMPLETED"),
                )}
              </div>
            )}

            <div
              className={`mt-3 ${
                fillHeight ? "flex-1" : maxHeightClass
              } overflow-y-auto space-y-2 pr-1`}
            >
              {filtered.length === 0 ? (
                <div className="text-xs text-[#4b5563] p-3">No matches.</div>
              ) : (
                filtered.map((item) => renderCompactCardFn(item.t, { onSelectTicker, savedTickers, toggleSavedTicker, tradeByTicker, addingTicker }))
              )}
            </div>
          </div>
        );
      }

      function ActionPanel({ tickers = [], onSelectTicker }) {
        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isActionable = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);

          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct)
            return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct)
            return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf)
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr)
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const selectWithConstraints = (list, limit) => {
          const maxPerSector = 1;
          const sectorCounts = new Map();
          const picks = [];
          for (const t of list) {
            if (picks.length >= limit) break;
            if (!isActionable(t)) continue;
            const sector =
              t.sector ||
              (t.fundamentals && t.fundamentals.sector) ||
              "UNKNOWN";
            const count = sectorCounts.get(sector) || 0;
            if (count >= maxPerSector) continue;
            sectorCounts.set(sector, count + 1);
            picks.push(t);
          }
          return picks;
        };

        const normBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const byBucket = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const pickWithConstraints = (bucket, limit) => {
            const sorted = list
              .filter((t) => normBucket(t) === bucket)
              .slice()
              .sort(
                (a, b) =>
                  (Number(b.dynamicRank) || 0) - (Number(a.dynamicRank) || 0),
              );
            return selectWithConstraints(sorted, limit);
          };
          return {
            SHORT_TERM: pickWithConstraints("SHORT_TERM", 3),
            SWING: pickWithConstraints("SWING", 3),
            POSITIONAL: pickWithConstraints("POSITIONAL", 2),
          };
        }, [tickers]);

        const renderRow = (label, bucket, items) => {
          return (
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="text-xs font-bold text-[#d1d5db]">{label}</div>
                <div className="text-[10px] text-[#6b7280]">{bucket}</div>
              </div>
              {items.length === 0 ? (
                <div className="text-xs text-[#4b5563]">No matches.</div>
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-2">
                  {items.map((t) => {
                    const eta = computeEtaDays(t);
                    const retPct = computeReturnPct(t);
                    const riskPct = computeRiskPct(t);
                    const conf = getNum(t.eta_confidence);
                    const entryZone = formatEntryZone(t);
                    const sl = numFromAny(t?.sl);
                    // Use server-provided TP directly
                    const tpDisplay = numFromAny(t?.tp ?? t?.tp_trim);
                    const price = Number(t?.price);
                    const staleness = String(t?.staleness || "").toUpperCase();
                    const isStale = staleness && staleness !== "FRESH";
                    const ingestText = formatIngestTime(t);
                    const avgCorr = Number(t?.avg_corr);
                    const diversity = Number(t?.diversity_score);
                    const skin = getCardSkin(t);
                    return (
                      <button
                        key={`${bucket}-${t.ticker}`}
                        onClick={() =>
                          onSelectTicker && onSelectTicker(t.ticker)
                        }
                        className={`text-left px-3 py-2 rounded-lg border border-white/[0.06] bg-white/[0.02] hover:brightness-[1.06] hover:border-[#3a4aa0] ${
                          skin?.dayEdgeClass || ""
                        }`}
                        style={{ backgroundImage: skin?.bgImage }}
                        title="Open in right rail"
                      >
                        <div className="flex items-center justify-between gap-2">
                          <div className="font-bold text-white">{t.ticker}</div>
                          <div className="text-[10px] text-[#6b7280]">
                            Score {rankScoreForTicker(t).toFixed(1)}
                          </div>
                        </div>
                        <div className="mt-0.5 flex items-center justify-between gap-2 text-[10px] text-[#6b7280]">
                          <div className="text-white">
                            {Number.isFinite(price)
                              ? `$${price.toFixed(2)}`
                              : "—"}
                          </div>
                          <div className="flex items-center gap-2">
                            {isStale && (
                              <span className="px-1.5 py-0.5 rounded bg-yellow-500/20 text-yellow-300 border border-yellow-500/40">
                                Delayed
                              </span>
                            )}
                            <span className="text-[#4b5563]">{ingestText}</span>
                          </div>
                        </div>
                        <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[#6b7280]">
                          <div>
                            <span className="text-[#4b5563]">ETA</span>{" "}
                            <span className="text-white">
                              {eta != null ? `${eta.toFixed(1)}d` : "—"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#4b5563]">Ret</span>{" "}
                            <span className="text-white">
                              {retPct != null ? `${retPct.toFixed(1)}%` : "—"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#4b5563]">Risk</span>{" "}
                            <span className="text-white">
                              {riskPct != null ? `${riskPct.toFixed(1)}%` : "—"}
                            </span>
                          </div>
                        </div>
                        <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[#4b5563]">
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">Entry</span>{" "}
                            <span className="text-white whitespace-normal break-words">
                              {entryZone}
                            </span>
                          </div>
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">TP</span>{" "}
                            <span className="text-teal-400">
                              {Number.isFinite(tpDisplay)
                                ? `$${tpDisplay.toFixed(2)}`
                                : "—"}
                            </span>
                          </div>
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">SL</span>{" "}
                            <span className="text-rose-400">
                              {Number.isFinite(sl) ? `$${sl.toFixed(2)}` : "—"}
                            </span>
                          </div>
                        </div>
                        <div className="mt-1 text-[10px] text-[#4b5563]">
                          {conf != null ? `ETA conf: ${conf.toFixed(2)}` : ""}
                          {Number.isFinite(diversity) && (
                            <span className="ml-2 text-[#6b7280]">
                              Div {Math.round(diversity)}
                            </span>
                          )}
                          {Number.isFinite(avgCorr) && (
                            <span className="ml-2 text-[#6b7280]">
                              Corr {avgCorr.toFixed(2)}
                            </span>
                          )}
                        </div>
                      </button>
                    );
                  })}
                </div>
              )}
            </div>
          );
        };

        return (
          <div className="mb-4 p-3 bg-white/[0.03] border border-white/[0.06] rounded-xl">
            <div className="flex items-center justify-between mb-3">
              <div className="text-sm font-bold text-white">
                🎯 Action Panel (Top Picks)
              </div>
              <div className="text-[10px] text-[#6b7280]">
                Short=≤7d • Swing=8–30d • Positional=31d+
              </div>
            </div>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
              {renderRow("Short-Term", "SHORT_TERM", byBucket.SHORT_TERM)}
              {renderRow("Swing", "SWING", byBucket.SWING)}
              {renderRow("Positional", "POSITIONAL", byBucket.POSITIONAL)}
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Ingestion Status Panel (minimizable)
      // ─────────────────────────────────────────────────────────────
      function IngestionStatusPanel({
        allData,
        filteredTickers,
        onRefresh,
        defaultMinimized = true,
      }) {
        const storageKey = "timedTrading_ingestionPanelMinimized";
        const [minimized, setMinimized] = React.useState(() => {
          try {
            const raw = localStorage.getItem(storageKey);
            if (raw === null) return defaultMinimized;
            return raw === "true";
          } catch {
            return defaultMinimized;
          }
        });

        React.useEffect(() => {
          try {
            localStorage.setItem(storageKey, String(minimized));
          } catch {}
        }, [minimized]);

        const now = Date.now();
        const allTickers = React.useMemo(() => {
          if (!allData || typeof allData !== "object") return [];
          const values = Array.isArray(allData)
            ? allData
            : Object.values(allData);
          return values.filter((t) => t && typeof t === "object" && t.ticker);
        }, [allData]);

        const getMs = (x) => {
          if (!x) return null;
          if (typeof x === "number" && Number.isFinite(x)) return x;
          if (typeof x === "string") {
            const ms = new Date(x).getTime();
            return Number.isFinite(ms) ? ms : null;
          }
          return null;
        };

        const toAgeMin = (t) => {
          // Prefer ingest_ts, then ts
          const ms =
            getMs(t.ingest_ts) ||
            getMs(t.ts) ||
            getMs(t.timestamp) ||
            getMs(t.last_update);
          if (!ms) return null;
          return (now - ms) / 60000;
        };

        const stats = React.useMemo(() => {
          const bucket = {
            total: allTickers.length,
            filtered: Array.isArray(filteredTickers)
              ? filteredTickers.length
              : 0,
            missing: 0,
            fresh: 0,
            warn: 0,
            stale: 0,
            veryStale: 0,
            worst: [],
          };

          const withAge = allTickers
            .map((t) => {
              const ageMin = toAgeMin(t);
              return {
                ticker: t.ticker,
                ageMin,
                ingest_ts: t.ingest_ts,
                ts: t.ts,
              };
            })
            .sort((a, b) => {
              const aa = a.ageMin ?? -1;
              const bb = b.ageMin ?? -1;
              return bb - aa;
            });

          withAge.forEach((r) => {
            if (r.ageMin === null) {
              bucket.missing++;
              return;
            }
            if (r.ageMin <= 10) bucket.fresh++;
            else if (r.ageMin <= 20) bucket.warn++;
            else if (r.ageMin <= 60) bucket.stale++;
            else bucket.veryStale++;
          });

          bucket.worst = withAge.filter((r) => r.ageMin !== null).slice(0, 10);

          return bucket;
        }, [allTickers, filteredTickers, now]);

        const badge = (() => {
          if (stats.total === 0) return "—";
          if (stats.veryStale > 0 || stats.missing > 0) return "⚠️";
          if (stats.stale > 0) return "🟡";
          return "✅";
        })();

        if (minimized) {
          return (
            <div className="fixed bottom-4 left-4 z-50">
              <button
                onClick={() => setMinimized(false)}
                className="px-3 py-2 bg-white/[0.03]/95 backdrop-blur-sm border border-white/[0.06] rounded-lg text-xs text-white shadow-lg hover:bg-white/[0.04]"
              >
                📡 Ingestion {badge} ({stats.fresh}/{stats.total})
              </button>
            </div>
          );
        }

        return (
          <div className="fixed bottom-4 left-4 z-50 w-[340px] max-w-[90vw] bg-[#0b0e11]/90 backdrop-blur-md border border-white/[0.04] rounded-xl shadow-lg">
            <div className="flex items-center justify-between px-3 py-2 border-b border-white/[0.06]">
              <div className="text-sm font-bold text-white flex items-center gap-2">
                📡 Ingestion Status <span className="text-xs">{badge}</span>
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={onRefresh}
                  className="px-2 py-1 bg-white/[0.04] hover:bg-white/[0.06] rounded text-xs text-white"
                  title="Refresh data"
                >
                  🔄
                </button>
                <button
                  onClick={() => setMinimized(true)}
                  className="px-2 py-1 bg-white/[0.04] hover:bg-white/[0.06] rounded text-xs text-white"
                  title="Minimize"
                >
                  ▾
                </button>
              </div>
            </div>

            <div className="p-3 text-xs text-[#6b7280] space-y-2">
              <div className="flex flex-wrap gap-x-3 gap-y-1">
                <div>
                  <span className="text-white font-semibold">Total:</span>{" "}
                  {stats.total}
                </div>
                <div>
                  <span className="text-white font-semibold">Visible:</span>{" "}
                  {stats.filtered}
                </div>
              </div>

              <div className="grid grid-cols-2 gap-2">
                <div className="bg-white/[0.02] border border-white/[0.06] rounded p-2">
                  <div className="text-white font-semibold">Fresh (≤10m)</div>
                  <div className="text-[#14b8a6] font-bold">{stats.fresh}</div>
                </div>
                <div className="bg-white/[0.02] border border-white/[0.06] rounded p-2">
                  <div className="text-white font-semibold">Warn (10–20m)</div>
                  <div className="text-[#eab308] font-bold">{stats.warn}</div>
                </div>
                <div className="bg-white/[0.02] border border-white/[0.06] rounded p-2">
                  <div className="text-white font-semibold">Stale (20–60m)</div>
                  <div className="text-[#e67e22] font-bold">{stats.stale}</div>
                </div>
                <div className="bg-white/[0.02] border border-white/[0.06] rounded p-2">
                  <div className="text-white font-semibold">
                    &gt;60m / Missing
                  </div>
                  <div className="text-[#e11d48] font-bold">
                    {stats.veryStale + stats.missing}
                  </div>
                </div>
              </div>

              <div className="mt-2">
                <div className="text-white font-semibold mb-1">
                  Worst offenders
                </div>
                <div className="max-h-[160px] overflow-y-auto space-y-1 pr-1">
                  {stats.worst.length === 0 ? (
                    <div className="text-[#6b7280]">No timestamps found.</div>
                  ) : (
                    stats.worst.map((r) => (
                      <div
                        key={r.ticker}
                        className="flex items-center justify-between bg-white/[0.02] border border-white/[0.06] rounded px-2 py-1"
                      >
                        <div className="text-white font-semibold">
                          {r.ticker}
                        </div>
                        <div className="text-[#6b7280]">
                          {Math.round(r.ageMin)}m
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>

              <div className="text-[10px] text-[#4b5563]">
                Freshness based on latest data timestamp per ticker (Alpaca + scoring pipeline).
              </div>
            </div>
          </div>
        );
      }

      // Helper: Get quadrant from state
      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK")
          return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL")
          return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR")
          return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK")
          return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      // Pattern detection
      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map((p) => p.state).filter(Boolean);
        const safeFlags = flags || {};

        // Pattern 1: Clean Q1→Q2 or Q4→Q3 transition (ideal entry)
        for (let i = 1; i < states.length; i++) {
          if (
            states[i - 1] === "HTF_BULL_LTF_PULLBACK" &&
            states[i] === "HTF_BULL_LTF_BULL"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1→Q2 transition (Bull Entry)",
              quadrant: "Q1→Q2",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
          if (
            states[i - 1] === "HTF_BEAR_LTF_PULLBACK" &&
            states[i] === "HTF_BEAR_LTF_BEAR"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4→Q3 transition (Bear Entry)",
              quadrant: "Q4→Q3",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 2: Momentum Elite + Setup quadrant
        const currentState = states[states.length - 1];
        if (
          (currentState === "HTF_BULL_LTF_PULLBACK" ||
            currentState === "HTF_BEAR_LTF_PULLBACK") &&
          safeFlags.momentum_elite
        ) {
          patterns.push({
            type: "ELITE_SETUP",
            description: "Momentum Elite in Setup Quadrant",
            quadrant: getQuadrantFromState(currentState)?.name,
            confidence: "HIGH",
          });
        }

        // Pattern 3: Squeeze release in setup quadrant
        const lastPoint = trail[trail.length - 1];
        if (lastPoint && lastPoint.flags && lastPoint.flags.sq30_release) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "SQUEEZE_SETUP",
              description: "Squeeze Release in Setup Quadrant",
              quadrant: q.name,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 4: Multiple quadrant visits (chop vs clean)
        const uniqueQuads = new Set(
          states.map((s) => getQuadrantFromState(s)?.q).filter(Boolean),
        );
        if (uniqueQuads.size > 2 && states.length > 5) {
          patterns.push({
            type: "CHOPPY",
            description: "Multiple quadrant visits (choppy action)",
            confidence: "MEDIUM",
          });
        } else if (uniqueQuads.size === 1 && states.length >= 3) {
          patterns.push({
            type: "STABLE",
            description: "Stable quadrant (consistent state)",
            quadrant: getQuadrantFromState(states[0])?.name,
            confidence: "MEDIUM",
          });
        }

        // Pattern 5: Phase zone change in setup
        if (lastPoint && lastPoint.flags && lastPoint.flags.phase_zone_change) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "PHASE_SHIFT",
              description: "Phase zone change in Setup",
              quadrant: q.name,
              confidence: "MEDIUM",
            });
          }
        }

        return patterns;
      }

      // Separate component for Quadrant Progression to properly use hooks
      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = React.useState([]);
        const [loading, setLoading] = React.useState(false); // Start as false
        const [hasLoaded, setHasLoaded] = React.useState(false);

        React.useEffect(() => {
          // Defer trail loading to not block initial render
          // Only load if component is mounted and ticker is valid
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const controller = new AbortController();
                const timeoutId2 = setTimeout(() => controller.abort(), 3000); // 3s timeout (reduced from 5s)

                const response = await fetch(
                  `/timed/trail?ticker=${encodeURIComponent(
                    ticker.ticker,
                  )}`,
                  { signal: controller.signal },
                );

                clearTimeout(timeoutId2);

                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                if (data.ok && Array.isArray(data.trail)) {
                  setTrail(data.trail);
                } else {
                  setTrail([]); // Set empty if no trail data
                }
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.error("Failed to load trail:", e);
                }
                // Set empty trail on error to prevent infinite retries
                setTrail([]);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300); // Slightly longer delay to ensure overlay is rendered first
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);

        const sampledTrail = React.useMemo(
          () => downsampleByInterval(trail, 15 * 60 * 1000),
          [trail],
        );

        const patterns = detectPatterns(sampledTrail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = sampledTrail
          .map((p) => getQuadrantFromState(p.state))
          .filter(Boolean);

        return (
          <div className="mb-4 p-4 bg-white/[0.03] rounded-lg border border-white/[0.06]">
            <div className="text-sm font-bold mb-3 text-[#6b7280]">
              Quadrant Progression (15m increments)
            </div>

            {/* Quadrant Map */}
            <div className="grid grid-cols-2 gap-2 mb-4">
              {/* Q1 - Bull Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 1
                    ? "border-blue-400 bg-blue-500/20"
                    : quadHistory.some((q) => q && q.q === 1)
                      ? "border-blue-500/50 bg-blue-500/10"
                      : "border-white/[0.06] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-blue-400">
                  Q1: Bull Setup
                </div>
                <div className="text-[10px] text-[#6b7280] mt-1">
                  HTF_BULL_LTF_PULLBACK
                </div>
              </div>

              {/* Q2 - Bull Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 2
                    ? "border-teal-400 bg-teal-500/20"
                    : quadHistory.some((q) => q && q.q === 2)
                      ? "border-teal-500/50 bg-teal-500/10"
                      : "border-white/[0.06] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-teal-400">
                  Q2: Bull Momentum
                </div>
                <div className="text-[10px] text-[#6b7280] mt-1">
                  HTF_BULL_LTF_BULL
                </div>
              </div>

              {/* Q4 - Bear Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 4
                    ? "border-orange-400 bg-orange-500/20"
                    : quadHistory.some((q) => q && q.q === 4)
                      ? "border-orange-500/50 bg-orange-500/10"
                      : "border-white/[0.06] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-orange-400">
                  Q4: Bear Setup
                </div>
                <div className="text-[10px] text-[#6b7280] mt-1">
                  HTF_BEAR_LTF_PULLBACK
                </div>
              </div>

              {/* Q3 - Bear Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 3
                    ? "border-rose-400 bg-rose-500/20"
                    : quadHistory.some((q) => q && q.q === 3)
                      ? "border-rose-500/50 bg-rose-500/10"
                      : "border-white/[0.06] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-rose-400">
                  Q3: Bear Momentum
                </div>
                <div className="text-[10px] text-[#6b7280] mt-1">
                  HTF_BEAR_LTF_BEAR
                </div>
              </div>
            </div>

            {/* Path Visualization */}
            {trail.length > 0 && (
              <div className="mb-4">
                <div className="text-xs font-semibold text-[#6b7280] mb-2">
                  Path ({trail.length} points)
                </div>
                <div className="flex items-center gap-1 flex-wrap">
                  {quadHistory.map((q, idx) => {
                    if (!q) return null;
                    const isLast = idx === quadHistory.length - 1;
                    const colorClasses = {
                      blue: isLast
                        ? "bg-blue-500/30 border-2 border-blue-400 text-blue-300"
                        : "bg-blue-500/10 border border-blue-500/50 text-blue-400",
                      green: isLast
                        ? "bg-teal-500/30 border-2 border-teal-400 text-teal-300"
                        : "bg-teal-500/10 border border-teal-500/50 text-teal-400",
                      red: isLast
                        ? "bg-rose-500/30 border-2 border-rose-400 text-rose-300"
                        : "bg-rose-500/10 border border-rose-500/50 text-rose-400",
                      orange: isLast
                        ? "bg-orange-500/30 border-2 border-orange-400 text-orange-300"
                        : "bg-orange-500/10 border border-orange-500/50 text-orange-400",
                    };
                    return (
                      <React.Fragment key={idx}>
                        <div
                          className={`px-2 py-1 rounded text-[10px] font-bold ${
                            colorClasses[q.color] || colorClasses.blue
                          }`}
                        >
                          {q.name}
                        </div>
                        {idx < quadHistory.length - 1 && (
                          <span className="text-[#6b7280] text-xs">→</span>
                        )}
                      </React.Fragment>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Pattern Detection */}
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-white/[0.06]">
                <div className="text-xs font-bold text-yellow-400 mb-2">
                  🎯 Detected Patterns
                </div>
                <div className="space-y-2">
                  {patterns.map((pattern, idx) => (
                    <div
                      key={idx}
                      className={`p-2 rounded border ${
                        pattern.confidence === "HIGH"
                          ? "bg-yellow-500/20 border-yellow-400/50"
                          : "bg-blue-500/10 border-blue-500/30"
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="text-xs font-bold text-white">
                            {pattern.description}
                          </div>
                          {pattern.quadrant && (
                            <div className="text-[10px] text-[#6b7280] mt-0.5">
                              {pattern.quadrant}
                            </div>
                          )}
                        </div>
                        <span
                          className={`text-[10px] px-1.5 py-0.5 rounded ${
                            pattern.confidence === "HIGH"
                              ? "bg-yellow-500/30 text-yellow-300"
                              : "bg-blue-500/30 text-blue-300"
                          }`}
                        >
                          {pattern.confidence}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {loading && (
              <div className="text-xs text-[#6b7280] text-center py-2">
                Loading history...
              </div>
            )}
          </div>
        );
      }

      // Universal Right Rail (shared component from shared-right-rail.js)
      // Defensive fallbacks to prevent ReferenceErrors when deps may be out of scope
      const _fmtUsd = typeof fmtUsd === "function" ? fmtUsd : (v) => (Number.isFinite(Number(v)) ? new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2 }).format(Number(v)) : "—");
      const _fmtUsdAbs = typeof fmtUsdAbs === "function" ? fmtUsdAbs : (n) => (Number.isFinite(Number(n)) ? `$${Math.abs(Number(n)).toFixed(2)}` : "—");
      const _computeHorizonBucket = typeof computeHorizonBucket === "function" ? computeHorizonBucket : (src) => { const b = String(src?.horizon_bucket || "").trim().toUpperCase(); if (b) return b.replace("_", " "); return "—"; };
      const _TRADE_SIZE = typeof TRADE_SIZE === "number" && Number.isFinite(TRADE_SIZE) ? TRADE_SIZE : 1000;
      const TickerDetailRightRail = window.TickerDetailRightRailFactory({
        React,
        API_BASE,
        fmtUsd: _fmtUsd,
        fmtUsdAbs: _fmtUsdAbs,
        getDailyChange,
        isPrimeBubble,
        entryType,
        getActionDescription,
        rankScoreForTicker,
        getRankedTickers,
        getRankPosition,
        getRankPositionFromMap,
        detectPatterns,
        normalizeTrailPoints,
        phaseToColor,
        completionForSize,
        computeHorizonBucket: _computeHorizonBucket,
        computeEtaDays,
        computeReturnPct,
        computeRiskPct,
        computeTpTargetPrice,
        computeTpMaxPrice,
        summarizeEntryDecision,
        getDirectionFromState,
        getDirection,
        numFromAny,
        groupsForTicker,
        GROUP_ORDER,
        GROUP_LABELS,
        TRADE_SIZE: _TRADE_SIZE,
        FUTURES_SPECS,
        getStaleInfo,
        isNyRegularMarketOpen,
        downsampleByInterval,
        getTickerSector,
        normalizeSectorKey,
        sectorKeyToCanonicalName,
      });

      // Legacy TickerDetails component - kept for backward compatibility but now uses unified component
      function TickerDetails({
        ticker,
        onClose,
        allTickers = [],
        allLoadedData = null,
      }) {
        if (!ticker) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);

        // Convert allLoadedData (object) to array if provided, otherwise use allTickers
        // allLoadedData contains ALL loaded tickers (unfiltered), while allTickers is filtered
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) {
              return allLoadedData;
            } else {
              // Convert object to array: { "GOOGL": {...}, "MSFT": {...} } -> [...]
              return Object.values(allLoadedData).filter(
                (t) => t && typeof t === "object" && t.ticker,
              );
            }
          }
          // Fallback to allTickers if allLoadedData not provided
          return allTickers || [];
        })();

        return (
          <div className="w-full h-full flex flex-col">
            {/* Detail Card - slides in from right, positioned in hero layout */}
            <div
              className="bg-white/[0.02] border-2 border-white/[0.06] rounded-xl w-full h-full flex flex-col shadow-lg"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Scrollable Content Area */}
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button
                    onClick={onClose}
                    className="text-[#6b7280] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-white/[0.04]"
                  >
                    ✕
                  </button>
                </div>

                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      🔥 MOMENTUM ELITE 🔥
                    </div>
                    <div className="text-xs text-purple-200/80 font-normal mb-2">
                      High-quality momentum stock with strong fundamentals
                    </div>
                    {ticker.momentum_pct && (
                      <div className="mt-2 pt-2 border-t border-purple-400/30">
                        <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">
                          Momentum Performance:
                        </div>
                        <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                          {ticker.momentum_pct.week != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1W:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.week) >= 10
                                    ? "text-teal-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.week).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.month != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.month) >= 25
                                    ? "text-teal-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.month).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.three_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">3M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.three_months) >= 50
                                    ? "text-teal-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(
                                  ticker.momentum_pct.three_months,
                                ).toFixed(1)}
                                %
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.six_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">6M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.six_months) >= 100
                                    ? "text-teal-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.six_months).toFixed(
                                  1,
                                )}
                                %
                              </span>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {prime && (() => {
                  const labels = { aligned: "Aligned", thesis: "Thesis Confirmed", winner: "Early Pattern", squeeze_release: "Squeeze Release", momentum: "Momentum", phase_change: "Phase Shift" };
                  return (
                    <div className="mb-4 p-3 bg-teal-500/20 border-2 border-teal-500 rounded-lg text-center font-bold text-teal-500 prime-glow">
                      💎 PRIME — {labels[prime.reason] || "Quality Setup"} 💎
                    </div>
                  );
                })()}

                {/* Bias/Direction - Prominent */}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-white/[0.03] border-2 border-white/[0.06] rounded-lg">
                      <div className="text-sm text-[#6b7280] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}
                      >
                        {dir.text === "LONG"
                          ? "📈 L"
                          : dir.text === "SHORT"
                            ? "📉 S"
                            : dir.text}
                      </div>
                    </div>
                  );
                })()}

                {/* Action Description */}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[#6b7280]">
                    {actionInfo.description}
                  </div>
                </div>

                {/* Quadrant Progression Visualization */}
                <QuadrantProgression ticker={ticker} flags={flags} />

                {/* Phase indicator */}
                <div className="mb-4 p-3 bg-white/[0.03] rounded-lg border border-white/[0.06]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[#6b7280]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                      {ticker.phase_zone && ` (${ticker.phase_zone})`}
                    </span>
                  </div>
                  <div className="h-3 bg-white/[0.04] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                        boxShadow: `0 0 8px ${phaseColor}40`,
                      }}
                    />
                  </div>
                </div>

                <div className="space-y-2.5 text-sm">
                  {(() => {
                    const baseScore = Number(ticker.rank) || 0; // Base Score from worker
                    const sortedByRank = getRankedTickers(
                      allLoadedTickersArray,
                    );
                    const rankPosition = getRankPosition(
                      sortedByRank,
                      ticker.ticker,
                    );
                    const totalTickersRaw = sortedByRank.length;
                    const totalTickers =
                      Number.isFinite(Number(ticker.rank_total)) &&
                      Number(ticker.rank_total) > 0
                        ? Number(ticker.rank_total)
                        : totalTickersRaw;

                    return (
                      <>
                        <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                          <span className="text-[#6b7280]">Base Score</span>
                          <span className="font-semibold text-blue-400">
                            {baseScore}
                          </span>
                        </div>
                        <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                          <span className="text-[#6b7280]">Rank</span>
                          <span className="font-semibold">
                            {rankPosition > 0
                              ? `#${rankPosition} of ${totalTickers}`
                              : "—"}
                          </span>
                        </div>
                      </>
                    );
                  })()}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const breakdownComponents = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-teal-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-teal-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-teal-400"
                                : "text-rose-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-teal-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return breakdownComponents.length > 0 ? (
                      <>
                        <div className="border-t border-white/[0.06] my-3 pt-3">
                          <div className="text-xs text-[#6b7280] mb-3 font-semibold">
                            Score Breakdown
                          </div>
                          <div className="space-y-1.5">
                            {breakdownComponents.map((comp, idx) => (
                              <div
                                key={idx}
                                className="flex justify-between items-center text-xs"
                              >
                                <span className="text-[#6b7280]">
                                  {comp.label}
                                </span>
                                <span className={`font-semibold ${comp.color}`}>
                                  {comp.value}
                                </span>
                              </div>
                            ))}
                            <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-white/[0.06]">
                              <span className="text-[#6b7280] font-semibold">
                                Total Score
                              </span>
                              <span className="text-blue-400 font-bold text-base">
                                {Math.round(breakdown.total)}
                              </span>
                            </div>
                          </div>
                        </div>
                      </>
                    ) : null;
                  })()}

                  <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                    <span className="text-[#6b7280]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                    <span className="text-[#6b7280]">State</span>
                    <span className="font-semibold">{ticker.state || "—"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                    <span className="text-[#6b7280]">Completion</span>
                    <span className="font-semibold">
                      {Math.round(completionForSize(ticker) * 100)}%
                    </span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                      <span className="text-[#6b7280]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-teal-500/20 text-teal-400 text-xs font-semibold">
                        {ent.side}
                      </span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                    <span className="text-[#6b7280]">Current Price</span>
                    <span className="font-semibold text-lg">
                      {ticker.price
                        ? `$${Number(ticker.price).toFixed(2)}`
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                    <span className="text-[#6b7280]">TP (Primary)</span>
                    <span className="font-semibold">
                      {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "—"}
                      {ticker.tp_levels &&
                        Array.isArray(ticker.tp_levels) &&
                        ticker.tp_levels.length > 0 &&
                        (() => {
                          const firstTp = ticker.tp_levels[0];
                          const tpInfo =
                            typeof firstTp === "object" && firstTp !== null
                              ? firstTp
                              : { price: firstTp };
                          if (tpInfo.label) {
                            const refParts = [];
                            if (tpInfo.timeframe)
                              refParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              refParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`,
                              );
                            }
                            const refStr =
                              refParts.length > 0
                                ? ` (${tpInfo.label} - ${refParts.join(", ")})`
                                : ` (${tpInfo.label})`;
                            return refStr;
                          }
                          return "";
                        })()}
                    </span>
                  </div>
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 1 &&
                    (() => {
                      // Calculate max TP
                      const tpPrices = ticker.tp_levels
                        .map((tpItem) => {
                          if (
                            typeof tpItem === "object" &&
                            tpItem !== null &&
                            tpItem.price != null
                          ) {
                            return Number(tpItem.price);
                          }
                          return typeof tpItem === "number"
                            ? tpItem
                            : Number(tpItem);
                        })
                        .filter((p) => Number.isFinite(p));

                      if (tpPrices.length > 0) {
                        const maxTP = Math.max(...tpPrices);
                        const primaryTP = Number(ticker.tp) || tpPrices[0];

                        if (maxTP > primaryTP) {
                          return (
                            <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                              <span className="text-[#6b7280]">TP (Max)</span>
                              <span className="font-semibold text-teal-400">
                                ${maxTP.toFixed(2)}
                              </span>
                            </div>
                          );
                        }
                      }
                      return null;
                    })()}
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 0 && (
                      <div className="py-1 border-b border-white/[0.06]/50">
                        <div className="text-[#6b7280] text-xs mb-2 font-semibold">
                          TP Levels
                        </div>
                        <div className="space-y-1.5 max-h-48 overflow-y-auto">
                          {ticker.tp_levels.map((tp, idx) => {
                            // Handle both old format (just price) and new format (object with metadata)
                            const tpInfo =
                              typeof tp === "object" && tp !== null
                                ? tp
                                : { price: tp, label: `TP${idx + 1}` };
                            const price = Number(tpInfo.price || tp);
                            const label = tpInfo.label || `TP${idx + 1}`;
                            const source = tpInfo.source || "";
                            const type = tpInfo.type || "";
                            const confidence = tpInfo.confidence || null;

                            // Build reference string from all available metadata
                            const referenceParts = [];
                            if (tpInfo.timeframe)
                              referenceParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              referenceParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`,
                              );
                            }
                            if (tpInfo.source)
                              referenceParts.push(tpInfo.source);
                            if (tpInfo.type) referenceParts.push(tpInfo.type);
                            const referenceStr =
                              referenceParts.length > 0
                                ? referenceParts.join(" • ")
                                : null;

                            return (
                              <div
                                key={idx}
                                className="flex items-start justify-between p-1.5 rounded bg-white/[0.03] border border-white/[0.06]/50 hover:border-[#3a4aa0] transition-colors"
                              >
                                <div className="flex-1">
                                  <div className="flex items-center gap-2 flex-wrap">
                                    <span className="text-xs font-semibold text-teal-400">
                                      {label}
                                    </span>
                                    <span className="text-xs font-mono text-white font-bold">
                                      ${price.toFixed(2)}
                                    </span>
                                    {confidence !== null && (
                                      <span
                                        className={`text-[10px] px-1 py-0.5 rounded ${
                                          confidence >= 0.8
                                            ? "bg-teal-500/20 text-teal-400"
                                            : confidence >= 0.6
                                              ? "bg-yellow-500/20 text-yellow-400"
                                              : "bg-orange-500/20 text-orange-400"
                                        }`}
                                      >
                                        {Math.round(confidence * 100)}%
                                      </span>
                                    )}
                                  </div>
                                  {referenceStr && (
                                    <div className="text-[10px] text-[#6b7280] mt-1 italic">
                                      {referenceStr}
                                    </div>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}
                  <div className="flex justify-between items-center py-1 border-b border-white/[0.06]/50">
                    <span className="text-[#6b7280]">SL</span>
                    <span className="font-semibold">
                      {ticker.sl ? Number(ticker.sl).toFixed(2) : "—"}
                    </span>
                  </div>
                </div>

                {/* Flags */}
                {(flags.sq30_on ||
                  flags.sq30_release ||
                  flags.phase_dot ||
                  flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[#6b7280] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && (
                        <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                          🧨 Squeeze ON
                        </span>
                      )}
                      {flags.sq30_release && (
                        <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                          ⚡ Squeeze Release
                        </span>
                      )}
                      {flags.phase_dot && (
                        <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                          Phase Dot
                        </span>
                      )}
                      {flags.phase_zone_change && (
                        <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                          Zone Change
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </div>

              {/* Fixed Footer - Open in TradingView button */}
              <div className="flex-shrink-0 p-6 pt-4 border-t border-white/[0.06] bg-white/[0.02]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(
                    ticker.ticker,
                  )}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  📊 Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // AI Chat Interface Component
      // ─────────────────────────────────────────────────────────────
      const AIChatInterface = ({ isOpen, onClose, tickerData }) => {
        const [messages, setMessages] = useState([
          {
            role: "assistant",
            content:
              "Hi, I'm your trading assistant. I can look up system guidance for any ticker (Rank, RR, Phase %, Completion %), prime setups, and market conditions. Ask about a symbol by name—e.g. \"System guidance for CRS\" or \"Show me prime setups.\"",
            timestamp: new Date(),
          },
        ]);
        const [input, setInput] = useState("");
        const [loading, setLoading] = useState(false);
        const messagesEndRef = useRef(null);
        const inputRef = useRef(null);

        const scrollToBottom = () => {
          if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
          }
        };

        useEffect(() => {
          scrollToBottom();
        }, [messages]);

        useEffect(() => {
          if (isOpen && inputRef.current) {
            inputRef.current.focus();
          }
        }, [isOpen]);

        const handleMarketPulse = async () => {
          setLoading(true);

          const pulseMessage = {
            role: "user",
            content: "📈 Market Pulse",
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, pulseMessage]);

          try {
            const timestamp = Date.now();
            const response = await fetch(
              `${API_BASE}/timed/ai/monitor?_t=${timestamp}`,
              {
                method: "GET",
                cache: "no-store",
                headers: {
                  "Content-Type": "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                },
              },
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "Monitoring service error");
            }

            const assistantMessage = {
              role: "assistant",
              content: `📊 **Market Monitoring Analysis**\n\n${data.analysis}\n\n---\n**Stats:** ${data.stats.primeSetups} prime setups, ${data.stats.highRiskPositions} high-risk positions, ${data.stats.momentumElite} Momentum Elite`,
              timestamp: new Date(),
              sources: [
                `Monitoring data: ${data.stats.totalTickers} tickers, ${data.stats.recentActivity} events`,
              ],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Market Pulse error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "⚠️ AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `❌ Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const handleSend = async (e) => {
          e.preventDefault();
          if (!input.trim() || loading) return;

          const userMessage = {
            role: "user",
            content: input.trim(),
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, userMessage]);
          setInput("");
          setLoading(true);

          try {
            // Fetch recent activity for context
            let activityData = [];
            try {
              const activityRes = await fetch(
                `${API_BASE}/timed/activity?limit=20`,
              );
              if (activityRes.ok) {
                const activityJson = await activityRes.json();
                if (activityJson.ok && Array.isArray(activityJson.events)) {
                  activityData = activityJson.events;
                }
              }
            } catch (e) {
              console.warn("Failed to fetch activity for chat:", e);
            }

            const timestamp = Date.now();
            const response = await fetch(
              `${API_BASE}/timed/ai/chat?_t=${timestamp}`,
              {
                method: "POST",
                cache: "no-store",
                headers: {
                  "Content-Type": "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                },
                body: JSON.stringify({
                  message: userMessage.content,
                  conversationHistory: messages.slice(-10).map((m) => ({
                    role: m.role,
                    content: m.content,
                  })),
                  tickerData: tickerData
                    ? Object.keys(tickerData).slice(0, 50)
                    : [],
                  activityData: activityData,
                }),
              },
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "AI service error");
            }

            const assistantMessage = {
              role: "assistant",
              content:
                data.response || "Sorry, I couldn't process that request.",
              timestamp: new Date(),
              sources: data.sources || [],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Chat error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "⚠️ AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `❌ Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const formatMessage = (content) => {
          // Simple markdown-like formatting
          const lines = content.split("\n");
          return lines.map((line, i) => {
            let formatted = line;
            // Bold
            formatted = formatted.replace(
              /\*\*(.+?)\*\*/g,
              '<strong class="font-semibold">$1</strong>',
            );
            // Code blocks
            formatted = formatted.replace(
              /`(.+?)`/g,
              '<code class="bg-white/[0.04] px-1 py-0.5 rounded text-xs">$1</code>',
            );
            // Links
            formatted = formatted.replace(
              /\[(.+?)\]\((.+?)\)/g,
              '<a href="$2" target="_blank" class="text-blue-400 hover:underline">$1</a>',
            );
            // Use React.createElement instead of JSX for better Babel compatibility
            return React.createElement("p", {
              key: i,
              dangerouslySetInnerHTML: { __html: formatted },
            });
          });
        };

        if (!isOpen) return null;

        return (
          <div className="fixed right-0 top-0 h-full w-[400px] max-w-[95vw] flex flex-col z-50 slide-in-right bg-[#0c0e12] border-l border-white/[0.06]" style={{ boxShadow: "-4px 0 24px rgba(0,0,0,0.35)" }}>
            {/* Header */}
            <div className="flex items-center justify-between px-5 py-3.5 border-b border-white/[0.06] bg-[#0f1116] shrink-0">
              <div className="flex items-center gap-3 min-w-0">
                <div className="w-9 h-9 rounded-xl bg-gradient-to-br from-[#2563eb] to-[#4f46e5] flex items-center justify-center text-white font-semibold text-sm shrink-0 shadow-lg">
                  AI
                </div>
                <div className="min-w-0">
                  <h3 className="text-[15px] font-semibold text-white tracking-tight">
                    Trading Assistant
                  </h3>
                  <p className="text-[11px] text-[#64748b] mt-0.5">Ask about tickers, setups, and system guidance</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={handleMarketPulse}
                  disabled={loading}
                  className="px-3 py-1.5 text-xs bg-emerald-500/15 hover:bg-emerald-500/25 disabled:bg-white/[0.04] disabled:text-[#4b5563] border border-emerald-500/25 rounded-lg text-emerald-400 font-medium transition-colors disabled:cursor-not-allowed"
                  title="Run market pulse analysis"
                >
                  📈 Market Pulse
                </button>
                <button
                  onClick={onClose}
                  className="text-[#64748b] hover:text-white transition-colors text-lg leading-none w-8 h-8 flex items-center justify-center rounded-md hover:bg-white/[0.06]"
                  aria-label="Close"
                >
                  ✕
                </button>
              </div>
            </div>

            {/* Messages */}
            <div className="flex-1 overflow-y-auto px-4 py-4 space-y-4 min-h-0">
              {messages.map((msg, idx) => (
                <div
                  key={idx}
                  className={`flex ${msg.role === "user" ? "justify-end" : "justify-start"}`}
                >
                  <div
                    className={`max-w-[88%] rounded-2xl px-4 py-3 ${
                      msg.role === "user"
                        ? "bg-[#1e3a5f] border border-[#2563eb]/30 text-white"
                        : msg.error
                          ? "bg-rose-500/10 border border-rose-500/20 text-rose-200"
                          : "bg-white/[0.04] border border-white/[0.06] text-[#e2e8f0]"
                    }`}
                  >
                    <div className="text-[13px] leading-relaxed whitespace-pre-wrap [word-break:break-word]">
                      {formatMessage(msg.content)}
                    </div>
                    {msg.sources && msg.sources.length > 0 && (
                      <div className="mt-3 pt-3 border-t border-white/[0.06]">
                        <p className="text-[11px] text-[#64748b] mb-1 font-medium">Sources</p>
                        <ul className="text-[11px] text-[#64748b] space-y-0.5">
                          {msg.sources.map((source, i) => (
                            <li key={i}>• {source}</li>
                          ))}
                        </ul>
                      </div>
                    )}
                    <div className="text-[11px] text-[#475569] mt-2">
                      {new Date(msg.timestamp).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })}
                    </div>
                  </div>
                </div>
              ))}
              {loading && (
                <div className="flex justify-start">
                  <div className="rounded-2xl px-4 py-3 bg-white/[0.04] border border-white/[0.06]">
                    <div className="flex items-center gap-2 text-[#64748b] text-[13px]">
                      <span className="flex gap-1">
                        <span className="w-1.5 h-1.5 bg-[#64748b] rounded-full animate-pulse" style={{ animationDelay: "0s" }} />
                        <span className="w-1.5 h-1.5 bg-[#64748b] rounded-full animate-pulse" style={{ animationDelay: "0.15s" }} />
                        <span className="w-1.5 h-1.5 bg-[#64748b] rounded-full animate-pulse" style={{ animationDelay: "0.3s" }} />
                      </span>
                      <span>Thinking...</span>
                    </div>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <form
              onSubmit={handleSend}
              className="p-4 pt-3 border-t border-white/[0.06] bg-[#0f1116] shrink-0"
            >
              <div className="flex gap-2">
                <input
                  ref={inputRef}
                  type="text"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="Ask about tickers, setups, or system guidance..."
                  className="flex-1 px-4 py-2.5 bg-white/[0.04] border border-white/[0.08] rounded-xl text-[14px] text-white placeholder-[#64748b] focus:outline-none focus:border-[#3b82f6]/50 focus:ring-1 focus:ring-[#3b82f6]/30 transition-colors disabled:opacity-60"
                  disabled={loading}
                />
                <button
                  type="submit"
                  disabled={loading || !input.trim()}
                  className="px-4 py-2.5 bg-[#2563eb] hover:bg-[#1d4ed8] disabled:bg-white/[0.06] disabled:text-[#475569] rounded-xl text-white text-[13px] font-medium transition-colors disabled:cursor-not-allowed shrink-0"
                >
                  Send
                </button>
              </div>
              <p className="text-[11px] text-[#475569] mt-2.5">
                e.g. &quot;System guidance for CRS&quot; or &quot;Prime setups&quot;
              </p>
              <p className="text-[10px] text-[#3f4a56] mt-1.5 italic">
                Not financial advice. For informational and educational purposes only. All trading involves risk.
              </p>
            </form>
          </div>
        );
      };

      // ─────────────────────────────────────────────────────────────
      // TickerDetailsLoader - must be defined before App
      // ─────────────────────────────────────────────────────────────
      const TickerDetailsLoader = ({
        tickerSymbol,
        onClose,
        rankAsOfMs = null,
        rankedTickers = null,
        rankedTickerPositions = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
        earningsMap = null,
        initialRailTab = null,
        addingTicker = null,
      }) => {
        const [tickerData, setTickerData] = useState(null);
        const [allLoadedData, setAllLoadedData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              // Fetch both the ticker data and all tickers for absolute ranking
              const timestamp = Date.now();
              const [tickerRes, allRes] = await Promise.all([
                fetch(
                  `${API_BASE}/timed/latest?ticker=${encodeURIComponent(
                    tickerSymbol,
                  )}&_t=${timestamp}`,
                  {
                    cache: "no-store",
                    headers: {
                      "Cache-Control": "no-cache, no-store, must-revalidate",
                      Pragma: "no-cache",
                      Expires: "0",
                    },
                  },
                ),
                fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
                  cache: "no-store",
                  headers: {
                    "Cache-Control": "no-cache, no-store, must-revalidate",
                    Pragma: "no-cache",
                    Expires: "0",
                  },
                }),
              ]);

              if (!tickerRes.ok) throw new Error(`HTTP ${tickerRes.status}`);
              const tickerJson = await tickerRes.json();
              if (!tickerJson.ok || !tickerJson.latestData) {
                throw new Error(tickerJson.error || "Ticker not found");
              }

              // Try to get all tickers for ranking (may fail, that's okay)
              let allData = null;
              try {
                if (allRes.ok) {
                  const allJson = await allRes.json();
                  if (allJson.ok && allJson.data) {
                    allData = allJson.data;
                  }
                }
              } catch (e) {
                console.warn("Failed to fetch all tickers for ranking:", e);
              }

              setTickerData(tickerJson.latestData);
              setAllLoadedData(allData);
            } catch (err) {
              console.error("Failed to fetch ticker:", err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };

          fetchTicker();
        }, [tickerSymbol]);

        if (loading) {
          const isAdding = addingTicker && String(addingTicker).toUpperCase() === String(tickerSymbol).toUpperCase();
          return (
            <div className="w-[450px] bg-white/[0.03] border border-white/[0.06] rounded-xl p-6">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[#6b7280]">{isAdding ? "Adding ticker… Scoring " : "Loading "}{tickerSymbol}...</div>
              </div>
            </div>
          );
        }

        if (error || !tickerData) {
          return (
            <div className="w-[450px] bg-white/[0.03] border border-rose-500 rounded-xl p-6">
              <div className="text-center">
                <div className="text-rose-400 mb-2">
                  Failed to load {tickerSymbol}
                </div>
                <div className="text-[#6b7280] text-sm mb-4">
                  {error || "No data available"}
                </div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-white/[0.04] hover:bg-white/[0.06] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }

        // Build a trade-like object from the ticker's position fields when no trade array is available
        const syntheticTrade = tickerData?.has_open_position ? {
          direction: tickerData.position_direction,
          sl: tickerData.position_sl,
          sl_original: tickerData.position_sl_original,
          tpArray: tickerData.tpArray || [],
          status: "OPEN",
        } : null;

        return (
          <TickerDetailRightRail
            ticker={tickerData}
            trade={syntheticTrade}
            onClose={onClose}
            allLoadedData={allLoadedData}
            rankedTickers={rankedTickers}
            rankedTickerPositions={rankedTickerPositions}
            rankAsOfMs={rankAsOfMs}
            sectors={sectors}
            onJourneyHover={onJourneyHover}
            onJourneySelect={onJourneySelect}
            selectedJourneyTs={selectedJourneyTs}
            earningsMap={earningsMap}
            initialRailTab={initialRailTab}
            addingTicker={addingTicker}
          />
        );
      };

      // ─────────────────────────────────────────────────────────────
      // OverlayPortal - must be defined before App
      // ─────────────────────────────────────────────────────────────
      const OverlayPortal = ({
        selectedTicker,
        tickers,
        data,
        trades = [],
        onClose,
        rankedTickers = null,
        rankedTickerPositions = null,
        rankAsOfMs = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
        earningsMap = null,
        dashboardMode = "trader",
        addingTicker = null,
      }) => {
        if (!selectedTicker) return null;

        try {
          // Normalize ticker name
          const tickerUpper = String(selectedTicker).toUpperCase();

          // Search in filtered tickers first
          let foundTicker = tickers.find((t) => {
            if (!t || typeof t !== "object") return false;
            const tTicker = String(t.ticker || "").toUpperCase();
            return tTicker === tickerUpper;
          });

          // If not found, search in original data object
          if (!foundTicker && data && typeof data === "object") {
            if (Array.isArray(data)) {
              foundTicker = data.find((t) => {
                if (!t || typeof t !== "object") return false;
                const tTicker = String(t.ticker || "").toUpperCase();
                return tTicker === tickerUpper;
              });
            } else {
              // Object format: check if ticker is a key (data structure: { "ETHA": {...}, ... })
              if (data[tickerUpper]) {
                foundTicker = data[tickerUpper];
              } else {
                // Search through all values in case structure is different
                const dataArray = Object.values(data);
                foundTicker = dataArray.find((t) => {
                  if (!t || typeof t !== "object") return false;
                  const tTicker = String(t.ticker || "").toUpperCase();
                  return tTicker === tickerUpper;
                });
              }
            }
          }

          // If still not found, fetch from API
          if (!foundTicker) {
            console.warn(
              "Ticker not found in local data, fetching from API:",
              tickerUpper,
            );
            const initialRailTab = dashboardMode === "investor" ? "INVESTOR" : "ANALYSIS";
            return (
              <TickerDetailsLoader
                tickerSymbol={tickerUpper}
                onClose={onClose}
                rankedTickers={rankedTickers}
                rankedTickerPositions={rankedTickerPositions}
                rankAsOfMs={rankAsOfMs}
                sectors={sectors}
                onJourneyHover={onJourneyHover}
                onJourneySelect={onJourneySelect}
                selectedJourneyTs={selectedJourneyTs}
                earningsMap={earningsMap}
                initialRailTab={initialRailTab}
                addingTicker={addingTicker}
              />
            );
          }

          // Find the open trade for this ticker (used by Right Rail for direction, TPs, SL)
          const openTrade = (() => {
            const map = new Map();
            if (!Array.isArray(trades)) return null;
            trades.forEach((tr) => {
              const sym = String(tr?.ticker || "").toUpperCase();
              if (!sym) return;
              const existing = map.get(sym);
              const exitTs = tr.exit_ts ?? tr.exitTs ?? 0;
              const entryTs = tr.entry_ts ?? tr.entryTime ?? tr.entryTs ?? 0;
              if (!existing || exitTs > (existing.exit_ts ?? existing.exitTs ?? 0) || (exitTs === 0 && entryTs > (existing.entry_ts ?? existing.entryTime ?? existing.entryTs ?? 0))) {
                map.set(sym, tr);
              }
            });
            const trade = map.get(tickerUpper);
            if (!trade) return null;
            const status = String(trade.status || "").toUpperCase();
            const isClosed = status === "WIN" || status === "LOSS" || !!(trade.exit_ts ?? trade.exitTs) || Number(trade?.trimmed_pct ?? trade?.trimmedPct ?? 0) >= 0.9999;
            const isOpen = !isClosed && (status === "OPEN" || status === "TP_HIT_TRIM" || !status);
            // Return open trades, or recently closed trades (< 24h) for Exit lane visibility
            if (isOpen) return trade;
            if (isClosed) {
              const exitMs = Number(trade.exit_ts ?? trade.exitTs ?? 0);
              if (exitMs > 0 && (Date.now() - exitMs) < 24 * 60 * 60 * 1000) return trade;
            }
            return null;
          })();

          // Effective stage for right rail
          const effectiveStage = (() => {
            if (!openTrade) return null;
            const status = String(openTrade.status || "").toUpperCase();
            const tradeClosed = status === "WIN" || status === "LOSS" || !!(openTrade.exit_ts ?? openTrade.exitTs);
            if (tradeClosed) return "exit";
            const stage = String(foundTicker?.kanban_stage ?? "").trim().toLowerCase();
            if (status === "TP_HIT_TRIM" || (Number(openTrade.trimmed_pct ?? openTrade.trimmedPct ?? 0) > 0)) return "trim";
            if (stage === "defend" || stage === "trim" || stage === "exit") return stage;
            return "hold";
          })();

          // TEMPORARILY DISABLE PORTAL - render inline to avoid freeze issues
          // TODO: Re-enable portal once freeze is resolved
          const initialRailTab = dashboardMode === "investor" ? "INVESTOR" : "ANALYSIS";
          return (
            <TickerDetailRightRail
              ticker={foundTicker}
              trade={openTrade}
              onClose={onClose}
              allLoadedData={data}
              rankedTickers={rankedTickers}
              rankedTickerPositions={rankedTickerPositions}
              rankAsOfMs={rankAsOfMs}
              sectors={sectors}
              onJourneyHover={onJourneyHover}
              onJourneySelect={onJourneySelect}
              selectedJourneyTs={selectedJourneyTs}
              effectiveStage={effectiveStage}
              earningsMap={earningsMap}
              initialRailTab={initialRailTab}
              addingTicker={addingTicker}
            />
          );

          /* Portal code - disabled for now
          const overlayContent = (
            <TickerDetails
              ticker={foundTicker}
              onClose={onClose}
            />
          );
          
          // Use portal to render at document body level, but only if available
          if (ReactDOM && ReactDOM.createPortal && document && document.body) {
            try {
              return ReactDOM.createPortal(overlayContent, document.body);
            } catch (portalError) {
              console.error('Portal error:', portalError);
              // Fallback to inline rendering
              return overlayContent;
            }
          }
          // Fallback if portal not available
          return overlayContent;
          */
        } catch (error) {
          console.error("OverlayPortal error:", error);
          return null;
        }
      };

      // ─────────────────────────────────────────────────────────────
      // Main App
      // ─────────────────────────────────────────────────────────────
      function GoProModal({ open, onClose }) {
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);

        const handleCheckout = async () => {
          setLoading(true);
          setError(null);
          try {
            const res = await fetch("/timed/stripe/create-checkout", {
              method: "POST",
              credentials: "include",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                success_url: window.location.origin + "/index-react.html?stripe=success",
                cancel_url: window.location.origin + "/index-react.html?stripe=cancel",
              }),
            });
            const json = await res.json();
            if (json.ok && json.url) {
              window.location.href = json.url;
            } else {
              setError(json.error === "stripe_not_configured"
                ? "Payments are not yet configured. Please contact support."
                : (json.details || json.error || "Failed to create checkout session"));
              setLoading(false);
            }
          } catch (e) {
            setError("Network error. Please try again.");
            setLoading(false);
          }
        };

        if (!open) return null;
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center p-4" onClick={onClose}>
            <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" />
            <div className="relative bg-[#0f1219] border border-white/[0.10] rounded-2xl shadow-2xl max-w-md w-full p-8 text-center" onClick={e => e.stopPropagation()}>
              <button onClick={onClose} className="absolute top-3 right-3 text-gray-500 hover:text-white transition-colors text-lg">&times;</button>
              <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-gradient-to-br from-amber-400 to-amber-600 flex items-center justify-center">
                <svg className="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
              </div>
              <h2 className="text-xl font-bold text-white mb-2">Unlock Timed Trading Pro</h2>
              <p className="text-[13px] text-gray-400 mb-1 leading-relaxed">
                Get full access to real-time prices, proprietary scoring, SL/TP levels, R:R analysis, entry/exit signals, all tickers, and deep technical analysis.
              </p>
              <p className="text-[22px] font-extrabold text-white mb-4">$60<span className="text-[13px] font-normal text-gray-500">/month</span></p>
              <div className="space-y-2 text-left mb-6">
                {[
                  "Real-time prices & daily change across all tickers",
                  "Composite Score, SL, TP, and R:R for every ticker",
                  "Entry & exit signals with confidence levels",
                  "Full Technicals, Model, Journey & Trade History tabs",
                  "Unlimited tickers + custom ticker slots",
                  "Open positions & complete trade ledger",
                ].map((f, i) => (
                  <div key={i} className="flex items-start gap-2">
                    <svg className="w-4 h-4 text-amber-400 mt-0.5 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd"/></svg>
                    <span className="text-[12px] text-gray-300">{f}</span>
                  </div>
                ))}
              </div>
              <button
                onClick={handleCheckout}
                disabled={loading}
                className={`block w-full py-3 rounded-xl text-white text-[14px] font-bold transition-all shadow-lg shadow-amber-500/25 border-none ${loading ? "bg-gray-700 cursor-wait" : "bg-gradient-to-r from-amber-500 to-amber-600 hover:from-amber-400 hover:to-amber-500 cursor-pointer"}`}
              >
                {loading ? "Redirecting to Stripe..." : "Subscribe Now"}
              </button>
              {error && <p className="text-[12px] text-red-400 mt-2">{error}</p>}
              <p className="text-[10px] text-gray-600 mt-3">Cancel anytime. Charged monthly.</p>
            </div>
          </div>
        );
      }

      function App() {
        const isAdmin = window._ttIsAdmin;

        const [goProOpen, setGoProOpen] = useState(false);
        useEffect(() => {
          const handler = () => setGoProOpen(true);
          window.addEventListener("tt-go-pro", handler);
          return () => window.removeEventListener("tt-go-pro", handler);
        }, []);

        const {
          data,
          socialAdditions = [],
          loading,
          error,
          lastUpdate,
          versionInfo,
          tickersWithoutScores,
          refetch,
          setData: setTickerData,
        } = useTickerData();

        // Record feature usage for Admin "Usage by Feature" (throttled 1h per user per feature)
        useEffect(() => {
          fetch(`${API_BASE}/timed/usage`, { method: "POST", credentials: "include", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ feature: "active_trader_view" }) }).catch(() => {});
        }, []);

        // Real-time price feed: WS push (primary) + HTTP poll fallback (every 30s)
        const { wsConnected, wsLastMessage } = useWebSocket(data, setTickerData);
        const { priceLastUpdated } = usePriceFeed(data, setTickerData);
        const { trades } = useTrades();
        const accountMode = dashboardMode === "investor" ? "investor" : "trader";
        const { summary: accountSummary } = useAccountSummary(accountMode);
        const { pending: queuedPending, pendingCount: queuedPendingCount } = useQueuedActions();
        const userTickers = useUserTickers();
        const { sectors } = useSectors();
        const { events: earningsEvents } = useEarningsEvents();

        // Build earnings lookup: symbol -> nearest upcoming (or most recent past) event
        // Uses NY calendar day comparison to avoid timezone-offset errors
        const earningsMap = useMemo(() => {
          const map = {};
          if (!earningsEvents || earningsEvents.length === 0) return map;
          const todayNy = new Date().toLocaleDateString("en-CA", { timeZone: "America/New_York" });
          const todayParts = todayNy.split("-").map(Number);
          const todayDayNum = todayParts[0] * 10000 + todayParts[1] * 100 + todayParts[2];
          for (const e of earningsEvents) {
            const sym = String(e.symbol || "").toUpperCase();
            if (!sym || !e.date) continue;
            const eParts = e.date.split("-").map(Number);
            const eDayNum = eParts[0] * 10000 + eParts[1] * 100 + eParts[2];
            const calDays = eDayNum - todayDayNum;
            if (calDays < -2 || calDays > 7) continue;
            if (!map[sym] || Math.abs(calDays) < Math.abs(map[sym]._daysAway)) {
              map[sym] = { ...e, _daysAway: calDays };
            }
          }
          return map;
        }, [earningsEvents]);
        window._ttEarningsMap = earningsMap;

        const [filters, setFilters] = useState(() => {
          // Safety check: reset to defaults if localStorage was cleared
          return {
            search: "",
            tickerFilter: "", // Comma-separated ticker symbols for filtering specific tickers
            quadrants: [
              "HTF_BULL_LTF_PULLBACK",
              "HTF_BULL_LTF_BULL",
              "HTF_BEAR_LTF_BEAR",
              "HTF_BEAR_LTF_PULLBACK",
            ],
            minRank: 0,
            minRR: 0,
            maxCompletion: 1.01,
            group: "ALL",
            sector: null, // Filter by sector name
            td9Setup: null, // Filter by TD9 setup: "bullish", "bearish", or null for all
          };
        });
        const thesisAppliedRef = useRef(false);
        const [selectedTicker, setSelectedTicker] = useState(() => {
          // Deep link: read ticker from URL hash on initial load
          try {
            const hash = window.location.hash;
            const match = hash.match(/ticker=([^&]+)/);
            if (match) return decodeURIComponent(match[1]).toUpperCase();
          } catch {}
          return null;
        });
        const [selectedTrail, setSelectedTrail] = useState(null);
        const [hoveredTicker, setHoveredTicker] = useState(null);
        const [journeyHoverPoint, setJourneyHoverPoint] = useState(null);
        const [journeySelectedPoint, setJourneySelectedPoint] = useState(null);
        // Dashboard view mode: "advanced" (Kanban cards) or "simple" (table)
        const [dashboardViewMode, setDashboardViewMode] = useState(() => {
          try { return localStorage.getItem("timedTrading_viewMode") || "advanced"; } catch { return "advanced"; }
        });
        const [dashboardMode, setDashboardMode] = useState(() => {
          try {
            const stored = localStorage.getItem("timedTrading_dashboardMode");
            if (stored === "trader" || stored === "investor" || stored === "analysis") return stored;
            return "analysis";
          } catch { return "analysis"; }
        });
        const handleDashboardModeChange = useCallback((mode) => {
          setDashboardMode(mode);
          try { localStorage.setItem("timedTrading_dashboardMode", mode); } catch {}
        }, []);
        const [viewSwitching, setViewSwitching] = useState(false);
        const toggleViewMode = useCallback((mode) => {
          if (mode === dashboardViewMode) return;
          setViewSwitching(true);
          try { localStorage.setItem("timedTrading_viewMode", mode); } catch {}
          // Defer the heavy re-render to the next frame so the loading overlay paints first
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              setDashboardViewMode(mode);
              setViewSwitching(false);
            });
          });
        }, [dashboardViewMode]);

        // AI Assistant removed (unused)
        // Admin panel moved to dedicated /admin-clients.html page
        const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
        const [showAiChat, setShowAiChat] = useState(false);
        const [showAddTicker, setShowAddTicker] = useState(false);
        const [addTickerInput, setAddTickerInput] = useState("");
        const addTickerRef = useRef(null);
        useEffect(() => {
          if (!showAddTicker) return;
          const handler = (e) => {
            if (addTickerRef.current && !addTickerRef.current.contains(e.target)) setShowAddTicker(false);
          };
          document.addEventListener("mousedown", handler);
          return () => document.removeEventListener("mousedown", handler);
        }, [showAddTicker]);
        const [showWelcomeDashboard, setShowWelcomeDashboard] = useState(() => {
          // Check if user has seen dashboard welcome page before
          const hasSeenWelcome = localStorage.getItem(
            "timedTrading_welcomeSeen",
          );
          return !hasSeenWelcome;
        });

        const [showWelcomeTracker, setShowWelcomeTracker] = useState(false);
        const [missingIngest, setMissingIngest] = useState([]);
        const [missingIngestLoading, setMissingIngestLoading] = useState(false);
        const [missingIngestError, setMissingIngestError] = useState(null);
        const [missingIngestOpen, setMissingIngestOpen] = useState(false);
        const [ingestAudit, setIngestAudit] = useState(null);
        const [ingestAuditLoading, setIngestAuditLoading] = useState(false);
        const [ingestAuditError, setIngestAuditError] = useState(null);
        const [ingestAuditOpen, setIngestAuditOpen] = useState(false);

        // ── Saved Tickers (per-user) ──────────────────────────────────
        const [savedTickers, setSavedTickers] = useState(new Set());
        const savedTickersLoadedRef = useRef(false);

        // Load saved tickers on mount (from /timed/me which includes saved_tickers)
        useEffect(() => {
          if (savedTickersLoadedRef.current) return;
          savedTickersLoadedRef.current = true;
          (async () => {
            try {
              const res = await fetch(`${API_BASE}/timed/saved`, { cache: "no-store", credentials: "include" });
              const json = await res.json();
              if (json.ok && Array.isArray(json.saved_tickers)) {
                setSavedTickers(new Set(json.saved_tickers));
              }
            } catch (_) { /* silent */ }
          })();
        }, []);

        const toggleSavedTicker = useCallback(async (ticker) => {
          const t = ticker.toUpperCase();
          setSavedTickers(prev => {
            const next = new Set(prev);
            if (next.has(t)) next.delete(t); else next.add(t);
            return next;
          });
          try {
            await fetch(`${API_BASE}/timed/saved/toggle`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              credentials: "include",
              body: JSON.stringify({ ticker: t }),
            });
          } catch (_) { /* optimistic, ignore failures */ }
        }, []);

        const fetchMissingIngest = useCallback(async () => {
          try {
            setMissingIngestLoading(true);
            setMissingIngestError(null);
            const res = await fetch(`${API_BASE}/timed/ingest-status`, {
              cache: "no-store",
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ingest_status_failed");
            const missing = Array.isArray(json.missing) ? json.missing : [];
            setMissingIngest(missing);
          } catch (e) {
            setMissingIngest([]);
            setMissingIngestError(String(e.message || e));
          } finally {
            setMissingIngestLoading(false);
          }
        }, []);

        const fetchIngestAudit = useCallback(async () => {
          try {
            setIngestAuditLoading(true);
            setIngestAuditError(null);
            const until = Date.now();
            const since = until - 6 * 60 * 60 * 1000;
            const res = await fetch(
              `${API_BASE}/timed/ingest-audit?since=${since}&until=${until}&bucket=5`,
              { cache: "no-store" },
            );
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ingest_audit_failed");
            setIngestAudit(json);
          } catch (e) {
            setIngestAudit(null);
            setIngestAuditError(String(e.message || e));
          } finally {
            setIngestAuditLoading(false);
          }
        }, []);

        const ingestAuditSummary = useMemo(() => {
          const rows = Array.isArray(ingestAudit?.perTicker)
            ? ingestAudit.perTicker
            : [];
          if (rows.length === 0) return null;
          let expected = 0;
          let received = 0;
          rows.forEach((r) => {
            expected += Number(r.expectedBuckets || 0);
            received += Number(r.receiptBuckets || 0);
          });
          const coveragePct = expected > 0 ? (received / expected) * 100 : 0;
          const worst = [...rows]
            .sort(
              (a, b) =>
                Number(b.missingReceipts || 0) - Number(a.missingReceipts || 0),
            )
            .slice(0, 12);
          return { expected, received, coveragePct, worst };
        }, [ingestAudit]);

        // Fetch trail data when ticker is selected
        useEffect(() => {
          if (selectedTicker) {
            // Reset any journey highlight when switching tickers
            setJourneyHoverPoint(null);
            setJourneySelectedPoint(null);

            // ✅ Immediately set to empty array to trigger selected-only view
            setSelectedTrail([]);

            const controller = new AbortController();
            // Trail payloads can be large; request a small window and allow a bit more time.
            const timeoutId = setTimeout(() => controller.abort(), 8000);

            const fetchSelectedTrail = async () => {
              const qs = new URLSearchParams();
              qs.set("ticker", String(selectedTicker || "").toUpperCase());
              // We only need recent history for Bubble Journey rendering
              qs.set("limit", "250");
              const url = `${API_BASE}/timed/trail?${qs.toString()}`;

              // A couple of light retries on 429/5xx to survive transient limits.
              for (let attempt = 0; attempt < 2; attempt++) {
                try {
                  const res = await fetch(url, {
                    signal: controller.signal,
                    cache: "no-store",
                  });

                  if (res.status === 429) {
                    // Respect Retry-After if present (seconds)
                    const retryAfterHeader = res.headers.get("Retry-After");
                    const retryAfterSec = retryAfterHeader
                      ? Math.min(60, Math.max(1, Number(retryAfterHeader)))
                      : 5;
                    await new Promise((r) =>
                      setTimeout(r, retryAfterSec * 1000),
                    );
                    continue;
                  }

                  if (!res.ok) {
                    // Retry once on 5xx; otherwise stop.
                    if (res.status >= 500 && attempt === 0) {
                      await new Promise((r) => setTimeout(r, 500));
                      continue;
                    }
                    setSelectedTrail([]);
                    return;
                  }

                  const data = await res.json();
                  if (data.ok && Array.isArray(data.trail)) {
                    const normalized = normalizeTrailPoints(data.trail);
                    const last20 =
                      normalized.length > 20
                        ? normalized.slice(-20)
                        : normalized;
                    // One-time sample log to confirm keys look right
                    if (!window._trailSampleLogged) {
                      window._trailSampleLogged = true;
                      console.log(`[TRAIL SAMPLE] ${selectedTicker}`, {
                        first: last20[0],
                        rawFirst: Array.isArray(data.trail)
                          ? data.trail[0]
                          : null,
                        rawKeys:
                          data.trail && data.trail[0]
                            ? Object.keys(data.trail[0])
                            : [],
                      });
                    }
                    setSelectedTrail(last20);
                    return;
                  }

                  setSelectedTrail([]);
                  return;
                } catch (err) {
                  if (err.name === "AbortError") return;
                  if (attempt === 0) {
                    await new Promise((r) => setTimeout(r, 300));
                    continue;
                  }
                  console.error("Failed to load trail:", err);
                  setSelectedTrail([]);
                  return;
                }
              }

              // If we exhausted retries, keep empty
              setSelectedTrail([]);
            };

            fetchSelectedTrail().finally(() => clearTimeout(timeoutId));
          } else {
            setSelectedTrail(null);
          }
        }, [selectedTicker]);

        // Debug: Log when selectedTicker changes
        React.useEffect(() => {
          console.log(`[SELECTED TICKER STATE] Changed to:`, selectedTicker, {
            isTruthy: !!selectedTicker,
            type: typeof selectedTicker,
            value: selectedTicker,
          });
        }, [selectedTicker]);

        // Safe setter for selectedTicker to prevent infinite loops
        const handleTickerSelect = useCallback((ticker) => {
          try {
            setSelectedTicker(ticker);
            // Sync URL hash for deep linking / sharing
            if (ticker) {
              window.history.replaceState(null, "", `#ticker=${encodeURIComponent(ticker)}`);
            } else {
              window.history.replaceState(null, "", window.location.pathname + window.location.search);
            }
          } catch (error) {
            console.error("Error setting selected ticker:", error);
          }
        }, []);

        // Listen for ticker selection from embedded Investor iframe (postMessage)
        useEffect(() => {
          const onMessage = (e) => {
            if (e?.data?.type === "tt-select-ticker") {
              handleTickerSelect(e.data.ticker || null);
            }
          };
          window.addEventListener("message", onMessage);
          return () => window.removeEventListener("message", onMessage);
        }, [handleTickerSelect]);

        const debouncedSearch = useDebounce(filters.search, 300);
        const effectiveFilters = { ...filters, search: debouncedSearch };

        const [timeTravelTickers, setTimeTravelTickers] = useState(null);

        const tickers = useMemo(() => {
          // If time travel is active, use time travel tickers, otherwise use filtered tickers
          if (timeTravelTickers !== null) {
            console.log('[TICKERS MEMO] Using timeTravelTickers:', timeTravelTickers.length);
            return timeTravelTickers;
          }
          
          const dataKeys = Object.keys(data || {});
          console.log('[TICKERS MEMO] Input data:', {
            inputDataKeys: dataKeys.length,
            firstKeys: dataKeys.slice(0, 5),
            dataType: typeof data,
            isObject: data && typeof data === 'object'
          });
          
          let filtered = applyFilters(data, effectiveFilters, trades, socialAdditions, savedTickers);
          if (!window._ttIsPro && window._ttMemberTickerSet) {
            filtered = filtered.filter(t => window._ttMemberTickerSet.has(String(t?.ticker || "").toUpperCase()));
          }
          return filtered;
        }, [data, effectiveFilters, trades, socialAdditions, timeTravelTickers, savedTickers]);

        // Base filtered tickers for Time Travel slider controls.
        // IMPORTANT: Hooks must never be called conditionally inside JSX.
        const timeTravelBaseTickers = useMemo(() => {
          return applyFilters(data, effectiveFilters, trades, socialAdditions, savedTickers);
        }, [data, effectiveFilters, trades, socialAdditions, savedTickers]);

        // Compute dynamic ranks once for all tickers to ensure consistency
        // IMPORTANT: Use ALL tickers from data, not filtered tickers, for ranking
        const allTickersForRanking = useMemo(() => {
          if (!data || typeof data !== "object") return [];
          return Object.values(data).filter(
            (t) =>
              t &&
              typeof t === "object" &&
              t.ticker &&
              t.rank !== undefined &&
              t.rank !== null,
          );
        }, [data]);

        // Use dynamicScore from API (backend calculation) - no frontend calculation needed
        const allTickersWithRanks = useMemo(() => {
          const withRanks = allTickersForRanking.map((t) => ({
            ...t,
            dynamicRank: t.dynamicScore || computeDynamicRank(t), // Use API value, fallback to calculation if missing
          }));

          return withRanks;
        }, [allTickersForRanking]);

        // Stabilize Rank display using 15-minute buckets.
        // Goal: keep ranks consistent across 1m ingests, and only refresh every 15m.
        const RANK_BUCKET_MS = 15 * 60 * 1000;
        const rankAsOfMs = useMemo(() => {
          const baseMs =
            lastUpdate && typeof lastUpdate.getTime === "function"
              ? lastUpdate.getTime()
              : Date.now();
          return Math.floor(baseMs / RANK_BUCKET_MS) * RANK_BUCKET_MS;
        }, [lastUpdate]);

        const rankSnapshotRef = React.useRef({
          asOfMs: null,
          ranked: [],
          positions: {},
        });

        const { ranked: rankedTickers, positions: rankedTickerPositions } =
          useMemo(() => {
            const prev = rankSnapshotRef.current;
            if (
              prev &&
              prev.asOfMs === rankAsOfMs &&
              Array.isArray(prev.ranked) &&
              prev.ranked.length > 0
            ) {
              return { ranked: prev.ranked, positions: prev.positions || {} };
            }

            const ranked = getRankedTickers(allTickersWithRanks);
            const positions = {};
            ranked.forEach((t, idx) => {
              const sym = String(t.ticker || "")
                .trim()
                .toUpperCase();
              const pos = Number(t?.rank_position);
              const rankPos = Number.isFinite(pos) && pos > 0 ? pos : idx + 1;
              if (sym && positions[sym] == null) {
                positions[sym] = rankPos;
              }
            });

            rankSnapshotRef.current = { asOfMs: rankAsOfMs, ranked, positions };
            return { ranked, positions };
          }, [allTickersWithRanks, rankAsOfMs]);

        // Use dynamicScore from API (backend calculation) - no frontend calculation needed
        const tickersWithRanks = useMemo(() => {
          return tickers.map((t) => ({
            ...t,
            dynamicRank: t.dynamicScore || computeDynamicRank(t), // Use API value, fallback to calculation if missing
          }));
        }, [tickers]);

        const primeTickers = useMemo(
          () => tickersWithRanks.filter(isPrimeBubble),
          [tickersWithRanks],
        );

        const handleFilterChange = useCallback((newFilters) => {
          setFilters((prev) => {
            // Create a new object to ensure React detects the change
            const updated = { ...prev };
            // Apply new filters
            Object.keys(newFilters).forEach((key) => {
              if (newFilters[key] === undefined || newFilters[key] === null) {
                // Explicitly delete undefined/null values to clear filters
                delete updated[key];
              } else {
                updated[key] = newFilters[key];
              }
            });
            return updated;
          });
        }, []);

        const [showAdvancedFilters, setShowAdvancedFilters] = useState(() => {
          try {
            const v = localStorage.getItem("timedTrading_showAdvancedFilters");
            if (v === "1") return true;
            if (v === "0") return false;
          } catch {}
          return false; // default: simpler
        });
        const toggleAdvancedFilters = useCallback(() => {
          setShowAdvancedFilters((v) => {
            const next = !v;
            try {
              localStorage.setItem(
                "timedTrading_showAdvancedFilters",
                next ? "1" : "0",
              );
            } catch {}
            return next;
          });
        }, []);

        // Disable auto-apply thesis preset (user wants no default filters)
        useEffect(() => {
          // Clear the auto-thesis flag and disable auto-apply
          try {
            localStorage.setItem("timedTrading_thesisAuto", "0");
          } catch {
            // ignore
          }
          thesisAppliedRef.current = true; // Mark as applied so it never triggers
        }, []);

        const handleWelcomeDashboardClose = () => {
          setShowWelcomeDashboard(false);
          localStorage.setItem("timedTrading_welcomeSeen", "true");
        };

        const handleWelcomeTrackerClose = () => {
          setShowWelcomeTracker(false);
        };

        return (
          <>
            {/* Welcome Modals */}
            {showWelcomeDashboard && (
              <DashboardWelcomeModal
                onClose={handleWelcomeDashboardClose}
                tickers={Object.values(data || {})}
                savedTickers={savedTickers}
                toggleSavedTicker={toggleSavedTicker}
              />
            )}
            {showWelcomeTracker && (
              <TrackerWelcomeModal onClose={handleWelcomeTrackerClose} />
            )}

            <div className="min-h-screen p-0 pt-2 pb-16">
              {/* Light page gutter: avoid edge bleed but keep width for Kanban lanes (14" MBP). */}
              {/* ═══ Unified Nav Bar ═══ */}
              <nav className="sticky top-0 z-50 border-b border-white/[0.06]" style={{background:"rgba(10,10,15,0.95)",backdropFilter:"blur(12px)"}}>
                <div className="flex items-center justify-between px-4 py-2.5">
                  <div className="flex items-center gap-3 md:gap-5 min-w-0">
                    <a href="index-react.html" className="flex items-center gap-2 no-underline shrink-0">
                      <div className="w-[28px] h-[28px] md:w-[32px] md:h-[32px] rounded-[8px] flex items-center justify-center" style={{background:"linear-gradient(135deg, #00c853, #00e676, #69f0ae)"}}>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                          <polyline points="22 7 13.5 15.5 8.5 10.5 2 17" />
                          <polyline points="16 7 22 7 22 13" />
                        </svg>
                      </div>
                      <span className="text-[14px] md:text-[15px] font-bold text-white hidden sm:inline" style={{letterSpacing:"-0.03em"}}>Timed Trading</span>
                    </a>
                    {wsConnected ? (
                      <span className="flex items-center gap-1 px-1.5 py-0.5 rounded bg-sky-500/10 border border-sky-500/25 shrink-0" title="WebSocket connected — real-time push active">
                        <span className="w-1.5 h-1.5 rounded-full bg-sky-400 animate-pulse" />
                        <span className="text-[9px] text-sky-400 font-medium">LIVE</span>
                      </span>
                    ) : (
                      <span className="flex items-center gap-1 px-1.5 py-0.5 rounded bg-red-900/30 border border-red-800/40 shrink-0" title="WebSocket disconnected — using polling fallback (30s)">
                        <span className="w-1.5 h-1.5 rounded-full bg-red-700" />
                        <span className="text-[9px] text-red-500 font-medium">POLL</span>
                      </span>
                    )}
                    {/* Desktop nav links */}
                    <div className="hidden lg:flex items-center gap-0.5" data-coachmark="nav-modes">
                      <a href="index-react.html" className="px-3 py-1 rounded-md text-[13px] text-white bg-white/[0.07] font-medium">Analysis</a>
                      <a href="simulation-dashboard.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Trades</a>
                      <a href="system-intelligence.html" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">System Intelligence</a>
                      <a href="screener.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Screener</a>
                      <a href="ticker-management.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Tickers</a>
                      {(window.TimedAuthHelpers?.getStoredSession()?.role === "admin" || window.TimedAuthHelpers?.getStoredSession()?.tier === "admin") && (
                        <a href="admin-clients.html" data-admin-only="true" className="px-3 py-1 rounded-md text-[13px] text-[#a78bfa]/80 hover:text-[#a78bfa] hover:bg-[#a78bfa]/[0.06] transition-all font-medium">Admin</a>
                      )}
                      <a href="daily-brief.html" id="nav-daily-brief" className="relative px-3 py-1 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium">
                        Daily Brief
                        <span id="brief-badge" className="hidden absolute -top-0.5 -right-0.5 w-2 h-2 rounded-full bg-[#f59e0b]" style={{animation: "pulse-badge 2s ease-in-out infinite"}} />
                      </a>
                    </div>
                  </div>
                  <div className="flex items-center gap-1.5 md:gap-2 shrink-0">
                    <button onClick={() => setShowWelcomeDashboard(true)} className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</button>
                    <button onClick={() => { try { localStorage.removeItem("tt_coachmarks_completed_v1"); } catch {} window.__restartCoachmarks?.(); }} className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all" title="Restart the UI tour">Tour</button>
                    <a href="/faq.html" className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all" title="Frequently Asked Questions">FAQ</a>
                    <button onClick={() => setShowAiChat(true)} className="hidden md:inline-flex px-2 py-1 rounded-md text-[11px] text-[#60a5fa] hover:text-[#93bbfc] hover:bg-[#60a5fa]/[0.06] transition-all font-medium" title="Ask the AI assistant">Ask AI</button>
                    {loading && <div className="loading-spinner"></div>}
                    {window.TimedNotificationCenter && <window.TimedNotificationCenter apiBase={API_BASE} />}
                    {window.TimedUserBadge && <window.TimedUserBadge user={window.TimedAuthHelpers?.getStoredSession()} compact />}
                    {/* Mobile hamburger */}
                    <button onClick={() => setMobileMenuOpen(v => !v)} className="lg:hidden p-1.5 rounded-md text-[#6b7280] hover:text-white hover:bg-white/[0.06] transition-all" aria-label="Toggle menu">
                      {mobileMenuOpen ? (
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                      ) : (
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                      )}
                    </button>
                  </div>
                </div>
                {/* Mobile dropdown menu */}
                {mobileMenuOpen && (
                  <div className="lg:hidden border-t border-white/[0.06] px-4 py-2 flex flex-col gap-0.5" style={{background:"rgba(10,10,15,0.98)"}}>
                    <a href="index-react.html" className="px-3 py-2 rounded-md text-[13px] text-white bg-white/[0.07] font-medium" onClick={() => setMobileMenuOpen(false)}>Analysis</a>
                    <a href="simulation-dashboard.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Trades</a>
                    <a href="system-intelligence.html" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>System Intelligence</a>
                    <a href="screener.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Screener</a>
                    <a href="ticker-management.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#9ca3af] hover:text-white hover:bg-white/[0.04] transition-all" onClick={() => setMobileMenuOpen(false)}>Tickers</a>
                    {(window.TimedAuthHelpers?.getStoredSession()?.role === "admin" || window.TimedAuthHelpers?.getStoredSession()?.tier === "admin") && (
                      <a href="admin-clients.html" data-admin-only="true" className="px-3 py-2 rounded-md text-[13px] text-[#a78bfa]/80 hover:text-[#a78bfa] hover:bg-[#a78bfa]/[0.06] transition-all font-medium" onClick={() => setMobileMenuOpen(false)}>Admin</a>
                    )}
                    <a href="daily-brief.html" className="px-3 py-2 rounded-md text-[13px] text-[#f59e0b]/80 hover:text-[#f59e0b] hover:bg-[#f59e0b]/[0.06] transition-all font-medium" onClick={() => setMobileMenuOpen(false)}>Daily Brief</a>
                    <div className="border-t border-white/[0.06] mt-1 pt-1 flex items-center gap-2">
                      <button onClick={() => { setShowWelcomeDashboard(true); setMobileMenuOpen(false); }} className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Guide</button>
                      <button onClick={() => { try { localStorage.removeItem("tt_coachmarks_completed_v1"); } catch {} window.__restartCoachmarks?.(); setMobileMenuOpen(false); }} className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all" title="Restart tour">Tour</button>
                      <a href="/faq.html" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">FAQ</a>
                      <button onClick={() => { setShowAiChat(true); setMobileMenuOpen(false); }} className="px-3 py-2 rounded-md text-[12px] text-[#60a5fa] hover:text-white hover:bg-white/[0.04] transition-all">Ask AI</button>
                      <a href="mailto:support@timed-trading.com" className="px-3 py-2 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] transition-all">Contact</a>
                    </div>
                  </div>
                )}
              </nav>
              {/* Admin panel moved to dedicated /admin-clients.html page */}

              {/* AI Chat Panel */}
              <AIChatInterface isOpen={showAiChat} onClose={() => setShowAiChat(false)} tickerData={data} />

              <div className="mx-auto w-full px-2 sm:px-4 lg:px-5">
                <header className="mb-4 pt-3">

                  {/* ═══ 0. EVENTS BAR — earnings, dividends, notable dates ═══ */}
                  {earningsEvents.length > 0 && (() => {
                    const now = Date.now();
                    const todayStr = new Date().toLocaleDateString("en-CA", { timeZone: "America/New_York" });
                    const tomorrowStr = new Date(now + 86400000).toLocaleDateString("en-CA", { timeZone: "America/New_York" });
                    const formatHour = (h) => {
                      if (!h) return "";
                      const hl = String(h).toLowerCase();
                      if (hl === "bmo" || hl === "before market open") return "BMO";
                      if (hl === "amc" || hl === "after market close") return "AMC";
                      if (hl === "dmh" || hl === "during market hours") return "DMH";
                      return String(h).toUpperCase();
                    };
                    const formatDate = (d) => {
                      if (d === todayStr) return "Today";
                      if (d === tomorrowStr) return "Tomorrow";
                      return new Date(d + "T12:00:00").toLocaleDateString("en-US", { month: "short", day: "numeric", timeZone: "America/New_York" });
                    };
                    const chipColor = (e) => {
                      if (e.epsActual != null && e.epsEstimate != null) {
                        return e.epsActual >= e.epsEstimate
                          ? "border-green-500/30 bg-green-500/10 text-green-300"
                          : "border-rose-500/30 bg-rose-500/10 text-rose-300";
                      }
                      if (e.date === todayStr) return "border-amber-500/30 bg-amber-500/10 text-amber-300";
                      return "border-white/[0.08] bg-white/[0.03] text-gray-300";
                    };
                    return (
                      <div className="mb-3">
                        <div className="flex items-center gap-2 mb-1.5">
                          <span className="text-[10px] text-[#6b7280] font-semibold tracking-wide uppercase">Upcoming Events</span>
                          <span className="text-[9px] text-[#4b5563] tabular-nums">{earningsEvents.length} earnings</span>
                        </div>
                        <div className="flex items-center gap-2 overflow-x-auto pb-1" style={{ scrollbarWidth: "none" }}>
                          {earningsEvents.slice(0, 20).map((e, i) => {
                            const beatMiss = e.epsActual != null && e.epsEstimate != null
                              ? (e.epsActual >= e.epsEstimate ? "Beat" : "Miss")
                              : null;
                            return (
                              <button key={`ev-${i}`} onClick={() => handleTickerSelect(e.symbol)}
                                className={`flex items-center gap-1.5 px-2 py-1 rounded-lg border ${chipColor(e)} flex-shrink-0 hover:brightness-125`}>
                                <span className="text-[10px] font-bold">{e.symbol}</span>
                                <span className="text-[9px] opacity-70">{formatDate(e.date)}</span>
                                {formatHour(e.hour) && <span className="text-[8px] opacity-60">{formatHour(e.hour)}</span>}
                                {beatMiss && <span className={`text-[8px] font-semibold ${beatMiss === "Beat" ? "text-green-400" : "text-rose-400"}`}>{beatMiss}</span>}
                              </button>
                            );
                          })}
                        </div>
                      </div>
                    );
                  })()}

                  {/* ═══ 1. MARKET PULSE — Pro/VIP/Admin only (real-time prices) ═══ */}
                  {window._ttIsPro && (() => {
                    const allData = data && typeof data === "object" ? data : {};
                    const renderPulseChip = (sym) => {
                      const td = allData[sym];
                      const price = Number(td?.price ?? td?.close ?? 0);
                      if (price <= 0) return null;
                      let pct = null;
                      if (td) { const dc = getDailyChange(td); if (dc && Number.isFinite(dc.dayPct)) pct = dc.dayPct; }
                      if (pct === null) pct = 0;
                      const up = pct >= 0;
                      const borderCls = up ? "border-[#00c853]/20" : "border-rose-500/20";
                      const chg = (() => { if (!td) return null; const dc = getDailyChange(td); return dc && Number.isFinite(dc.dayChg) ? dc.dayChg : null; })();
                      return (
                        <button key={`mp2-${sym}`} onClick={() => handleTickerSelect(sym)}
                          className={`flex items-center gap-1.5 px-2 py-1 rounded-lg border ${borderCls} bg-white/[0.03] hover:bg-white/[0.06] flex-shrink-0`}>
                          <span className="text-[10px] text-white font-bold">{sym}</span>
                          <span className="text-[9px] text-gray-400">${price.toFixed(2)}</span>
                          <span className={`text-[9px] font-semibold ${up ? "text-[#00e676]" : "text-rose-400"}`}>{pct >= 0 ? "+" : ""}{pct.toFixed(2)}%</span>
                          {chg !== null && <span className={`text-[8px] tabular-nums ${up ? "text-[#00e676]/70" : "text-rose-400/70"}`}>{chg >= 0 ? "+" : ""}{chg.toFixed(2)}</span>}
                        </button>
                      );
                    };
                    const row1 = ["US500", "ES1!", "NQ1!", "RTY1!", "YM1!", "VX1!", "CL1!", "GC1!", "SI1!", "BTCUSD", "ETHUSD"];
                    const row2 = ["SPX", "SPY", "QQQ", "IWM", "XLK", "XLF", "XLY", "XLP", "XLC", "XLI", "XLB", "XLE", "XLRE", "XLU", "XLV"];
                    const row1Chips = row1.map(s => renderPulseChip(s)).filter(Boolean);
                    const row2Chips = row2.map(s => renderPulseChip(s)).filter(Boolean);
                    if (row1Chips.length === 0 && row2Chips.length === 0) return null;
                    const freshness = (() => {
                      if (!priceLastUpdated || priceLastUpdated <= 0) return null;
                      const ago = Math.round((Date.now() - priceLastUpdated) / 1000);
                      if (ago < 60) return `${ago}s ago`;
                      if (ago < 3600) return `${Math.floor(ago / 60)}m ago`;
                      return `${Math.floor(ago / 3600)}h ago`;
                    })();
                    return (
                      <div className="mb-4">
                        <div className="flex items-center gap-2 mb-1.5">
                          <span className="text-[10px] text-[#6b7280] font-semibold tracking-wide uppercase">Market Pulse</span>
                          {freshness && <span className="text-[9px] text-[#4b5563] tabular-nums">updated {freshness}</span>}
                        </div>
                        {row1Chips.length > 0 && (
                          <div className="flex items-center gap-2 overflow-x-auto pb-1" style={{ scrollbarWidth: "none" }}>{row1Chips}</div>
                        )}
                        {row2Chips.length > 0 && (
                          <div className="flex items-center gap-2 overflow-x-auto pt-1 pb-1" style={{ scrollbarWidth: "none" }}>{row2Chips}</div>
                        )}
                      </div>
                    );
                  })()}

                  {/* ═══ 2. TOP GAINERS/LOSERS — visible to all users ═══ */}
                  {(() => {
                    const allArr = data && typeof data === 'object' ? Object.values(data) : [];
                    const CRYPTO_24H = new Set(["BTCUSD", "ETHUSD"]);
                    const chip = (t, isGain, pctKey = "_pct", priceKey = "_price") => {
                      const sym = t?.ticker || t?.symbol || "?";
                      const pct = t[pctKey];
                      const price = t[priceKey];
                      const name = t?.context?.name || t?.companyName || "";
                      const title = name ? `${sym} — ${name}` : sym;
                      const cls = isGain ? "text-[#00e676] border-[#00c853]/30 bg-[#00c853]/10" : "text-rose-400 border-rose-500/30 bg-rose-500/10";
                      return (
                        <button key={sym} onClick={() => handleTickerSelect(sym)} title={title}
                          className={`px-2 py-0.5 rounded-lg border text-[10px] font-semibold flex items-center gap-1 hover:opacity-80 transition-opacity ${cls}`}>
                          <span className="text-white font-bold">{sym}</span>
                          {Number.isFinite(price) && price > 0 && <span>${Number(price).toFixed(2)}</span>}
                          <span>{pct >= 0 ? "+" : ""}{pct.toFixed(2)}%</span>
                        </button>
                      );
                    };
                    const moversRow = (label, badgeCls, gainers, losers, pctKey, priceKey) => (
                      <div className="flex items-center gap-2 flex-wrap text-[10px]">
                        <span className={`px-1.5 py-px rounded text-[9px] font-bold tracking-wide border shrink-0 ${badgeCls}`}>{label}</span>
                        <div className="flex items-center gap-1.5">
                          <span className="text-[#6b7280] font-semibold whitespace-nowrap">Gainers</span>
                          {gainers.map(t => chip(t, true, pctKey, priceKey))}
                        </div>
                        <div className="w-px h-4 bg-white/10" />
                        <div className="flex items-center gap-1.5">
                          <span className="text-[#6b7280] font-semibold whitespace-nowrap">Losers</span>
                          {losers.map(t => chip(t, false, pctKey, priceKey))}
                        </div>
                      </div>
                    );

                    // RTH movers: daily change (close vs prev_close)
                    const rthArr = allArr.map(t => {
                      const px = Number(t?.price ?? t?.close);
                      if (!Number.isFinite(px) || px <= 0) return null;
                      const dc = getDailyChange(t);
                      const pct = dc?.dayPct;
                      if (!Number.isFinite(pct)) return null;
                      return { ...t, _pct: pct, _price: px };
                    }).filter(Boolean);
                    const rthSorted = [...rthArr].sort((a, b) => b._pct - a._pct);
                    const rthGainers = rthSorted.slice(0, 5);
                    const rthLosers = rthSorted.slice(-5).reverse();

                    // ETH movers: only show when market is closed
                    const _moversMarketOpen = isNyRegularMarketOpen();
                    const ethArr = _moversMarketOpen ? [] : allArr.filter(t => !CRYPTO_24H.has(t?.ticker)).map(t => {
                      const pct = Number(t?._ah_change_pct);
                      if (!Number.isFinite(pct) || pct === 0) return null;
                      const px = Number(t?._ah_price) || Number(t?.price ?? t?.close) || 0;
                      return { ...t, _ethPct: pct, _ethPrice: px };
                    }).filter(Boolean);
                    const ethSorted = [...ethArr].sort((a, b) => b._ethPct - a._ethPct);
                    const ethGainers = ethSorted.slice(0, 5);
                    const ethLosers = ethSorted.slice(-5).reverse();
                    const hasEth = ethGainers.length > 0 || ethLosers.length > 0;

                    if (rthGainers.length === 0 && rthLosers.length === 0 && !hasEth) return null;
                    return (
                      <div className="mb-4 space-y-1.5">
                        {(rthGainers.length > 0 || rthLosers.length > 0) &&
                          moversRow("RTH", "bg-cyan-500/15 text-cyan-400 border-cyan-500/30", rthGainers, rthLosers, "_pct", "_price")
                        }
                        {hasEth &&
                          moversRow("EXT", "bg-amber-500/15 text-amber-400 border-amber-500/30", ethGainers, ethLosers, "_ethPct", "_ethPrice")
                        }
                      </div>
                    );
                  })()}

                  {/* ═══ 3. ACCOUNT SUMMARY — above search (Active Trader / Investor modes only) ═══ */}
                  {(dashboardMode === "trader" || dashboardMode === "investor") && <div className="mb-4">
                    <ActionCenterPanel
                      tickers={tickers}
                      trades={trades}
                      accountSummary={accountSummary}
                      queuedPending={queuedPending}
                      queuedPendingCount={queuedPendingCount}
                      allTickersWithRanks={allTickersWithRanks}
                      rankPositions={rankedTickerPositions}
                      onSelectTicker={handleTickerSelect}
                      allData={data}
                      defaultLimit={12}
                      savedTickers={savedTickers}
                      toggleSavedTicker={toggleSavedTicker}
                    />
                  </div>}

                  {/* ═══ 4. SEARCH (left) + FILTERS + PILLS & REFRESH (right) ═══ */}
                  <div className="mb-3 flex flex-wrap items-center justify-between gap-3" data-coachmark="search-filter">
                    {/* Left: Search */}
                    <div className="flex items-center gap-2">
                      <div className="w-[320px] relative">
                        <svg className="absolute left-3 top-1/2 pointer-events-none" style={{transform:"translateY(-50%)"}} width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#6b7280" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                        <input
                          type="text"
                          placeholder="Search tickers or filters..."
                          value={filters.search}
                          onChange={(e) => {
                            const value = e.target.value;
                            handleFilterChange({ search: value });
                            if (value.includes(",") && !value.match(/rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup|above|over|below|under/)) {
                              handleFilterChange({ tickerFilter: value });
                            } else if (!value.trim()) {
                              handleFilterChange({ tickerFilter: "" });
                            }
                          }}
                          className="w-full pl-9 pr-3 py-1.5 bg-white/[0.03] border border-white/[0.08] rounded-2xl text-white text-sm placeholder-[#6b7280] focus:border-white/[0.15] focus:outline-none transition-colors"
                        />
                        {filters.search && filters.search.trim().length >= 2 && tickers.length === 0 && !loading && (() => {
                          const sym = filters.search.toUpperCase().trim();
                          const symValid = /^[A-Z]{1,5}$/.test(sym);
                          const alreadyInSlots = userTickers.slots.some(s => s.ticker === sym && (s.active || s.held));
                          return (
                            <div className="absolute top-full left-0 mt-1 z-50 w-full bg-[#1a1e2e] border border-white/[0.12] rounded-lg shadow-xl p-2.5">
                              <div className="text-[11px] text-[#6b7280] mb-1.5">No tickers found for "{filters.search.trim()}"</div>
                              {symValid && (
                                <button
                                  onClick={async () => {
                                    try {
                                      const res = await fetch(`${API_BASE}/timed/latest?ticker=${encodeURIComponent(sym)}`, { cache: "no-store" });
                                      const json = await res.json();
                                      if (json?.ok && json?.latestData) {
                                        setTickerData(prev => ({ ...prev, [sym]: json.latestData }));
                                        handleTickerSelect(sym);
                                      }
                                    } catch (e) { console.warn("Load ticker failed:", e); }
                                  }}
                                  className="w-full flex items-center gap-2 px-2.5 py-1.5 rounded-lg bg-blue-600/10 border border-blue-500/20 text-blue-300 text-xs font-medium hover:bg-blue-600/20 transition-colors mb-1.5"
                                >
                                  <span className="text-sm">↻</span>
                                  <span>Load <span className="font-bold">{sym}</span> from API</span>
                                </button>
                              )}
                              {alreadyInSlots ? (
                                <div className="flex items-center justify-between gap-2 px-1">
                                  <div className="text-[10px] text-amber-400/70">
                                    {sym} is in your custom tickers{userTickers.slots.find(s => s.ticker === sym)?.held ? " (held)" : ""}.
                                  </div>
                                  {!userTickers.slots.find(s => s.ticker === sym)?.held && (
                                    <button
                                      onClick={async () => {
                                        const result = await userTickers.addTicker(sym);
                                        if (result) {
                                          if (result.seed_data) setTickerData(prev => ({ ...prev, [sym]: result.seed_data }));
                                          refetch();
                                        }
                                      }}
                                      disabled={userTickers.adding}
                                      className="shrink-0 px-2 py-0.5 rounded bg-amber-600/20 border border-amber-500/30 text-amber-300 text-[10px] font-medium hover:bg-amber-600/30 transition-colors disabled:opacity-40"
                                    >
                                      {userTickers.adding ? "…" : "Retry"}
                                    </button>
                                  )}
                                </div>
                              ) : !window._ttIsPro ? (
                                <button
                                  onClick={() => window.dispatchEvent(new CustomEvent("tt-go-pro"))}
                                  className="w-full flex items-center gap-2 px-2.5 py-1.5 rounded-lg bg-amber-500/10 border border-amber-500/25 text-amber-300 text-xs font-medium hover:bg-amber-500/20 transition-colors"
                                >
                                  <svg className="w-3.5 h-3.5 text-amber-400" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/></svg>
                                  <span>Go Pro to add <span className="font-bold">{sym}</span></span>
                                </button>
                              ) : (
                                <button
                                  onClick={() => { setAddTickerInput(sym); setShowAddTicker(true); }}
                                  className="w-full flex items-center gap-2 px-2.5 py-1.5 rounded-lg bg-cyan-600/10 border border-cyan-500/20 text-cyan-300 text-xs font-medium hover:bg-cyan-600/20 transition-colors"
                                >
                                  <span className="text-sm">+</span>
                                  <span>Add <span className="font-bold">{sym}</span> as a custom ticker</span>
                                </button>
                              )}
                            </div>
                          );
                        })()}
                      </div>
                    </div>
                    {/* Right: Pills + Refresh */}
                    <div className="flex items-center gap-2 flex-wrap">
                      <div className="flex gap-1.5 text-[12px] items-center flex-wrap">
                        <div className="px-2.5 py-1 rounded-full bg-white/5 border border-white/5">
                          <span className="text-[#6b7280]">Tickers </span>
                          <span className="font-semibold text-white">{tickers.length}</span>
                        </div>
                        <div className="px-2.5 py-1 rounded-full bg-[#00c853]/8 border border-[#00c853]/15">
                          <span className="text-[#00e676]/80">Prime </span>
                          <span className="font-semibold text-[#00e676]">{primeTickers.length}</span>
                        </div>
                        {tickers.length > 0 && (
                          <div className="px-2.5 py-1 rounded-full bg-white/5 border border-white/5">
                            <span className="text-[#6b7280]">In Corridor </span>
                            <span className="font-semibold text-white">{tickers.filter((t) => entryType(t).corridor).length}</span>
                          </div>
                        )}
                      </div>
                      <button
                        onClick={refetch}
                        className="px-3 py-1 rounded-md text-[12px] text-[#6b7280] hover:text-white hover:bg-white/[0.04] border border-white/[0.06] transition-all"
                      >
                        ↻ Refresh
                      </button>
                      {lastUpdate && <span className="text-[11px] text-[#4b5563]">{lastUpdate.toLocaleTimeString()}</span>}
                    </div>
                  </div>

                  {/* ═══ 4b. MODE SELECTOR — Analysis / Active Trader / Investor ═══ */}
                  <div className="mb-3 flex items-center gap-3">
                    <div className="inline-flex items-center bg-white/[0.04] border border-white/[0.10] rounded-xl overflow-hidden shadow-sm">
                      <button
                        onClick={() => handleDashboardModeChange("analysis")}
                        className={`flex items-center gap-1.5 px-4 py-2 text-[12px] font-semibold transition-all ${
                          dashboardMode === "analysis"
                            ? "bg-gradient-to-r from-violet-500/20 to-indigo-500/15 text-white"
                            : "text-[#6b7280] hover:text-white hover:bg-white/[0.05]"
                        }`}
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" /></svg>
                        Analysis
                      </button>
                      <button
                        onClick={() => handleDashboardModeChange("trader")}
                        className={`flex items-center gap-1.5 px-4 py-2 text-[12px] font-semibold transition-all border-l border-white/[0.06] ${
                          dashboardMode === "trader"
                            ? "bg-gradient-to-r from-cyan-500/20 to-teal-500/15 text-white"
                            : "text-[#6b7280] hover:text-white hover:bg-white/[0.05]"
                        }`}
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" /></svg>
                        Active Trader
                      </button>
                      <button
                        onClick={() => handleDashboardModeChange("investor")}
                        className={`flex items-center gap-1.5 px-4 py-2 text-[12px] font-semibold transition-all border-l border-white/[0.06] ${
                          dashboardMode === "investor"
                            ? "bg-gradient-to-r from-emerald-500/20 to-teal-500/15 text-white"
                            : "text-[#6b7280] hover:text-white hover:bg-white/[0.05]"
                        }`}
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        Investor
                      </button>
                    </div>
                  </div>

                  {/* View toggle + saved filter moved into Active Trader section below */}
                  <div className="mb-3 flex flex-wrap items-center gap-3" data-coachmark="view-toggle">

                    {/* Filters Toggle */}
                    <button
                      onClick={toggleAdvancedFilters}
                      className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg border text-xs font-semibold transition-colors whitespace-nowrap ${
                        showAdvancedFilters
                          ? "bg-blue-500/20 border-blue-500/40 text-blue-300"
                          : "bg-white/[0.02] border-white/[0.06] text-[#6b7280] hover:text-white hover:bg-[#16224a]"
                      }`}
                      title="Show/hide filter groups"
                    >
                      <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="20" y2="18"/>
                        <circle cx="8" cy="6" r="2" fill="currentColor"/><circle cx="16" cy="12" r="2" fill="currentColor"/><circle cx="10" cy="18" r="2" fill="currentColor"/>
                      </svg>
                      Filters {showAdvancedFilters ? "▾" : "▸"}
                    </button>

                    {/* Saved Filter */}
                    <button
                      onClick={() => handleFilterChange({ group: effectiveFilters.group === "SAVED" ? "ALL" : "SAVED" })}
                      className={`px-3 py-1.5 rounded-lg border text-xs font-semibold transition-colors ${
                        effectiveFilters.group === "SAVED"
                          ? "bg-amber-500/20 border-amber-500/40 text-amber-300"
                          : "bg-white/[0.02] border-white/[0.06] text-[#6b7280] hover:text-amber-300 hover:bg-amber-500/10"
                      }`}
                      title={`Show only saved tickers (${savedTickers.size} saved)`}
                    >
                      ⭐ Saved{savedTickers.size > 0 ? ` (${savedTickers.size})` : ""}
                    </button>

                    {/* Add Custom Ticker (Phase 5) — Pro only; Members see Go Pro CTA */}
                    <div className="relative" ref={addTickerRef}>
                      {!window._ttIsPro ? (
                        <button
                          onClick={() => window.dispatchEvent(new CustomEvent("tt-go-pro"))}
                          className="px-3 py-1.5 rounded-lg border border-amber-500/30 bg-amber-500/10 text-xs font-semibold text-amber-300 hover:bg-amber-500/20 hover:border-amber-400/40 transition-colors flex items-center gap-1"
                          title="Upgrade to Pro to add custom tickers"
                        >
                          <svg className="w-3 h-3 text-amber-400" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/></svg>
                          Go Pro to Add Tickers
                        </button>
                      ) : (
                        <button
                          onClick={() => setShowAddTicker(!showAddTicker)}
                          className={`px-3 py-1.5 rounded-lg border text-xs font-semibold transition-colors ${
                            showAddTicker
                              ? "bg-cyan-500/20 border-cyan-500/40 text-cyan-300"
                              : "bg-white/[0.02] border-white/[0.06] text-[#6b7280] hover:text-cyan-300 hover:bg-cyan-500/10"
                          }`}
                          title={`Add custom tickers (${userTickers.slotsUsed}/${userTickers.slotsMax} slots)`}
                        >
                          + Add Ticker{userTickers.slotsUsed > 0 ? ` (${userTickers.slotsUsed}/${userTickers.slotsMax})` : ""}
                        </button>
                      )}
                      {showAddTicker && (
                        <div className="absolute top-full left-0 mt-1.5 z-50 w-[360px] bg-[#1a1e2e] border border-white/[0.12] rounded-xl shadow-2xl p-4" onClick={e => e.stopPropagation()}>
                          <div className="text-[11px] text-[#6b7280] mb-1">
                            Custom Tickers — <span className="text-white font-medium">{userTickers.slotsUsed}/{userTickers.slotsMax}</span> slots
                          </div>
                          <div className="text-[9px] text-[#4b5563] mb-3">
                            Add tickers not in the Timed Trading universe. Each slot is held for 7 days after removal.
                          </div>
                          <form onSubmit={async (e) => {
                            e.preventDefault();
                            const val = addTickerInput.toUpperCase().trim();
                            if (!val) return;
                            const result = await userTickers.addTicker(val);
                            if (result) {
                              if (result.seed_data) setTickerData(prev => ({ ...prev, [val]: result.seed_data }));
                              setAddTickerInput("");
                              refetch();
                            }
                          }} className="flex gap-1.5 mb-2">
                            <input
                              type="text"
                              value={addTickerInput}
                              onChange={e => { setAddTickerInput(e.target.value.toUpperCase()); userTickers.setError(null); }}
                              placeholder="e.g. IONQ, SMCI"
                              maxLength={6}
                              disabled={userTickers.adding}
                              className="flex-1 px-2.5 py-1.5 rounded-lg bg-white/[0.06] border border-white/[0.10] text-white text-xs placeholder:text-[#4b5563] focus:outline-none focus:border-cyan-500/50 disabled:opacity-50"
                              autoFocus
                            />
                            <button
                              type="submit"
                              disabled={userTickers.adding || !addTickerInput.trim()}
                              className="px-3 py-1.5 rounded-lg bg-cyan-600/80 hover:bg-cyan-500/80 text-white text-xs font-semibold disabled:opacity-40 disabled:cursor-not-allowed transition-colors min-w-[48px]"
                            >
                              {userTickers.adding ? (
                                <span className="inline-flex items-center gap-1"><span className="loading-spinner loading-spinner-sm" style={{width:"12px",height:"12px",borderWidth:"1.5px"}}></span></span>
                              ) : "Add"}
                            </button>
                          </form>
                          {userTickers.adding && userTickers.addingTicker && (
                            <div className="flex items-center gap-2 px-2 py-2 mb-2 rounded-lg bg-cyan-500/[0.08] border border-cyan-500/20 text-xs">
                              <span className="loading-spinner loading-spinner-sm" style={{width:"14px",height:"14px",borderWidth:"1.5px",borderColor:"rgba(6,182,212,0.3)",borderTopColor:"rgb(6,182,212)"}}></span>
                              <span className="text-cyan-300">Scoring <span className="font-bold">{userTickers.addingTicker}</span>...</span>
                            </div>
                          )}
                          {userTickers.error && (
                            <div className="text-[10px] text-rose-400 mb-2 px-1 flex items-start gap-1">
                              <span className="shrink-0">⚠</span>
                              <span>{userTickers.error}</span>
                            </div>
                          )}
                          {userTickers.slots.length > 0 ? (
                            <div className="max-h-[200px] overflow-y-auto space-y-1">
                              {userTickers.slots.filter(s => s.active).map(s => (
                                <div key={s.ticker} className="flex items-center justify-between px-2 py-1.5 rounded bg-white/[0.03] border border-white/[0.06] text-xs group">
                                  <span className="text-white font-medium">{s.ticker}</span>
                                  <div className="flex items-center gap-2">
                                    <span className="text-[10px] text-[#4b5563]">{new Date(s.added_at).toLocaleDateString()}</span>
                                    <button
                                      onClick={async () => {
                                        if (confirm(`Remove ${s.ticker}?\n\nThis slot will be held for 7 days and cannot be reused until then.`)) {
                                          await userTickers.removeTicker(s.ticker);
                                        }
                                      }}
                                      className="text-[#4b5563] hover:text-rose-400 transition-colors opacity-0 group-hover:opacity-100"
                                      title={`Remove ${s.ticker} (7-day hold)`}
                                    >
                                      ✕
                                    </button>
                                  </div>
                                </div>
                              ))}
                              {userTickers.slots.filter(s => s.held && !s.active).map(s => (
                                <div key={`held-${s.ticker}`} className="flex items-center justify-between px-2 py-1.5 rounded bg-white/[0.02] border border-white/[0.04] text-xs opacity-50">
                                  <span className="text-[#6b7280]">{s.ticker}</span>
                                  <span className="text-[10px] text-[#4b5563]">held until {new Date(s.held_until).toLocaleDateString()}</span>
                                </div>
                              ))}
                            </div>
                          ) : (
                            <div className="text-[11px] text-[#4b5563] text-center py-3">No custom tickers added yet</div>
                          )}
                          {userTickers.slotsUsed >= userTickers.slotsMax && (
                            <div className="text-[10px] text-amber-400/70 mt-2 text-center">
                              All slots used. Upgrade for more slots.
                            </div>
                          )}
                        </div>
                      )}
                    </div>

                    {/* Time Travel — Pro feature: full control for Pro, teaser for Members */}
                    {window._ttIsPro ? (
                      <div className="flex-1 min-w-[200px]">
                        <TimeTravelSlider
                          tickers={timeTravelBaseTickers}
                          allTickers={data}
                          data={data}
                          onTimeChange={setTimeTravelTickers}
                          tickerFilter={filters.tickerFilter}
                          selectedTicker={selectedTicker}
                          compact={true}
                        />
                      </div>
                    ) : (
                      <div className="flex-1 min-w-[140px]">
                        <button
                          onClick={() => window.dispatchEvent(new CustomEvent("tt-go-pro"))}
                          className="flex items-center gap-1.5 px-3 py-1.5 rounded-lg border border-amber-500/40 bg-amber-500/5 hover:bg-amber-500/10 hover:border-amber-400/50 transition-colors text-[11px] text-amber-400/90 font-medium"
                          title="Replay historical bubble positions — Pro feature"
                        >
                          <svg className="w-3.5 h-3.5 text-amber-400/80" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/></svg>
                          <span>⏱️ Time Travel</span>
                          <span className="text-[10px] text-amber-300/70">Pro</span>
                        </button>
                      </div>
                    )}
                  </div>

                  {/* Filter Groups (collapsible) */}
                  {showAdvancedFilters && (
                    <div className="mb-3 rounded-xl border border-white/[0.06] bg-white/[0.03] p-2">
                      <ViewportFilterTags
                        filters={filters}
                        onChange={handleFilterChange}
                        sectors={sectors}
                        allData={data}
                        trades={trades}
                        socialAdditions={socialAdditions}
                      />
                    </div>
                  )}

                </header>

                {/* Error Display */}
                {error && (
                  <div className="mb-4 p-4 bg-rose-500/20 border-2 border-rose-500 rounded-xl">
                    <div className="flex items-center justify-between">
                      <div>
                        <h3 className="text-lg font-bold text-rose-400 mb-2">
                          Error Loading Data
                        </h3>
                        <p className="text-rose-300">{error}</p>
                      </div>
                      <button
                        onClick={refetch}
                        className="px-4 py-2 bg-rose-500 hover:bg-rose-600 rounded-lg text-white font-semibold"
                      >
                        Retry
                      </button>
                    </div>
                  </div>
                )}

                {/* Ingestion Status Panel removed — was a floating widget showing stale/fresh ticker counts.
                     Not useful for end users; admin can check via /admin-clients.html or Worker logs. */}

                {/* Main Content — mode-exclusive rendering */}
                {!error && (
                  <div className="space-y-4">

                    {/* ═══ ANALYSIS MODE: Viewport + Bubble Chart ═══ */}
                    {dashboardMode === "analysis" && (
                    <div className="flex flex-col lg:flex-row gap-4 items-stretch">
                      {/* Viewport - Left side */}
                      <div className="w-full lg:w-[320px] lg:flex-shrink-0 h-[600px] sm:h-[700px] md:h-[800px] lg:h-[900px]" data-coachmark="viewport">
                        <OpportunitiesPanel
                          tickers={tickersWithRanks}
                          rankPositions={rankedTickerPositions}
                          onSelectTicker={handleTickerSelect}
                          trades={trades}
                          title="🔭 Viewport"
                          maxHeightClass="max-h-[900px]"
                          fillHeight={true}
                          showControls={false}
                          thesisMode={isThesisModeActive(filters)}
                          savedTickers={savedTickers}
                          toggleSavedTicker={toggleSavedTicker}
                          addingTicker={userTickers.addingTicker}
                        />
                      </div>

                      {/* Bubble Chart - Center Hero (flexible, takes remaining space) */}
                      <div
                        className={`relative w-full lg:flex-1 lg:min-w-0 transition-[margin] duration-300 ${
                          selectedTicker ? "lg:mr-[470px]" : ""
                        }`}
                      >
                        {/* Bubble Chart Legend — single line */}
                        <div className="px-3 py-1.5 mb-1 rounded-lg border border-white/[0.06] bg-white/[0.02] flex items-center gap-3 text-[10px] text-[#9ca3af] overflow-x-auto flex-nowrap" data-coachmark="bubble-chart">
                          <span className="font-semibold text-white text-[11px] shrink-0">Bubble Chart</span>
                          <span className="flex items-center gap-1 shrink-0" title="Long-term trend is bullish"><svg width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" fill="rgba(34,211,238,0.5)" stroke="#22d3ee" strokeWidth="0.8"/></svg> Long</span>
                          <span className="flex items-center gap-1 shrink-0" title="Long-term trend is bearish"><svg width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" fill="rgba(225,29,72,0.5)" stroke="#e11d48" strokeWidth="0.8"/></svg> Short</span>
                          <span className="flex items-center gap-1 shrink-0" title="No clear directional bias"><svg width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" fill="rgba(234,179,8,0.4)" stroke="#eab308" strokeWidth="0.8"/></svg> Neutral</span>
                          <span className="text-[#4b5563] shrink-0">|</span>
                          <span className="shrink-0" title="X-axis = short-term momentum, Y-axis = long-term trend">X: Momentum · Y: Trend</span>
                          <span className="shrink-0" title="Bigger bubble = higher risk-to-reward with more upside remaining">Size = R:R</span>
                          <span className="shrink-0" title="Filled = has scoring data, Dashed outline = awaiting data">Filled = scored</span>
                          <span className="text-[#4b5563] shrink-0">|</span>
                          <span className="flex items-center gap-1 shrink-0" title="Pulsing glow = system highlighting for entry or active management"><svg width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="3.5" fill="none" stroke="#22d3ee" strokeWidth="1" opacity="0.6"><animate attributeName="r" values="3;4.5;3" dur="2s" repeatCount="indefinite"/><animate attributeName="opacity" values="0.3;0.7;0.3" dur="2s" repeatCount="indefinite"/></circle></svg> Actionable</span>
                          <span className="shrink-0" title="High-conviction momentum setup">🔥 MoElite</span>
                          <span className="shrink-0" title="Price near optimal entry level">🎯 Flip Watch</span>
                          <span className="flex items-center gap-1 shrink-0" title="Upcoming or recent earnings event (within 7 days)"><svg width="12" height="12" viewBox="0 0 12 12"><circle cx="6" cy="6" r="4.5" fill="none" stroke="#f59e0b" strokeWidth="1.5" strokeDasharray="3 2" opacity="0.7"/></svg> Earnings</span>
                        </div>
                        <div className="h-[600px] sm:h-[700px] md:h-[800px] lg:h-[870px]">
                          {loading && tickers.length === 0 ? (
                            <div className="w-full h-full bg-white/[0.02] rounded-xl border border-white/[0.06] flex items-center justify-center" style={{ animation: "fadeIn 0.3s ease-out" }}>
                              <div className="text-center">
                                <div className="loading-spinner loading-spinner-lg mx-auto mb-4"></div>
                                <div className="text-[#6b7280] text-sm">
                                  Loading tickers...
                                </div>
                              </div>
                            </div>
                          ) : (
                            <BubbleChart
                              tickers={tickers}
                              onBubbleClick={handleTickerSelect}
                              hoveredTicker={hoveredTicker}
                              onHover={setHoveredTicker}
                              selectedTicker={selectedTicker}
                              selectedTrail={selectedTrail}
                              isTimeTravelActive={timeTravelTickers !== null}
                              highlightTrailPoint={
                                journeyHoverPoint || journeySelectedPoint
                              }
                              allData={data}
                              rankedTickers={rankedTickers}
                              rankedTickerPositions={rankedTickerPositions}
                              thesisMode={isThesisModeActive(filters)}
                            />
                          )}
                          {!window._ttIsPro && (
                            <div className="absolute bottom-3 left-1/2 -translate-x-1/2 z-10">
                              <button className="flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-[#0d1117]/90 border border-amber-500/40 backdrop-blur-sm hover:border-amber-400/60 transition-colors"
                                onClick={() => window.dispatchEvent(new CustomEvent("tt-go-pro"))}>
                                <svg className="w-3.5 h-3.5 text-amber-400" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/></svg>
                                <span className="text-[10px] font-bold text-amber-300">Showing {window._ttMemberTickers?.length || 10} tickers</span>
                                <span className="text-[9px] text-gray-400 mx-0.5">—</span>
                                <span className="text-[10px] font-bold text-amber-400">Go Pro for all</span>
                              </button>
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                    )}

                    {/* Cards / Table View controller — Active Trader only */}
                    {dashboardMode === "trader" && (
                      <div className="flex flex-wrap items-center gap-3">
                        <div className="flex items-center bg-white/[0.04] border border-white/[0.10] rounded-xl overflow-hidden shadow-sm">
                          <button
                            onClick={() => toggleViewMode("advanced")}
                            className={`flex items-center gap-1.5 px-4 py-2 text-[12px] font-semibold transition-all ${
                              dashboardViewMode === "advanced"
                                ? "bg-gradient-to-r from-cyan-500/20 to-teal-500/15 text-white border-r border-white/10"
                                : "text-[#6b7280] hover:text-white hover:bg-white/[0.05] border-r border-white/[0.06]"
                            }`}
                            title="Kanban card view"
                          >
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                              <rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/>
                            </svg>
                            Cards
                          </button>
                          <button
                            onClick={() => toggleViewMode("simple")}
                            className={`flex items-center gap-1.5 px-4 py-2 text-[12px] font-semibold transition-all ${
                              dashboardViewMode === "simple"
                                ? "bg-gradient-to-r from-blue-500/20 to-indigo-500/15 text-white"
                                : "text-[#6b7280] hover:text-white hover:bg-white/[0.05]"
                            }`}
                            title="Table view"
                          >
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                              <line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/>
                            </svg>
                            Table
                          </button>
                        </div>
                      </div>
                    )}

                    {/* Right Rail - Detail View (slides in from right, fixed to viewport) */}
                    {selectedTicker && (
                      <>
                        {/* Backdrop: click outside closes Right Rail */}
                        <div
                          className="fixed inset-0 z-30"
                          onMouseDown={() => handleTickerSelect(null)}
                        />
                        <div
                          className="fixed right-0 top-[60px] sm:top-[52px] w-full sm:w-[450px] bottom-[64px] sm:bottom-[56px] bg-[#0b0e11] border-l border-white/[0.04] z-40 slide-in-right shadow-xl overflow-y-auto"
                          onMouseDown={(e) => e.stopPropagation()}
                        >
                          <OverlayPortal
                            selectedTicker={selectedTicker}
                            tickers={tickers}
                            data={data}
                            trades={trades}
                            onClose={() => handleTickerSelect(null)}
                            rankedTickers={rankedTickers}
                            rankedTickerPositions={rankedTickerPositions}
                            rankAsOfMs={rankAsOfMs}
                            sectors={sectors}
                            onJourneyHover={setJourneyHoverPoint}
                            onJourneySelect={(p) => {
                              setJourneySelectedPoint(p);
                            }}
                            selectedJourneyTs={journeySelectedPoint?.ts ?? null}
                            earningsMap={earningsMap}
                            dashboardMode={dashboardMode}
                            addingTicker={userTickers.addingTicker}
                          />
                        </div>
                      </>
                    )}
                    {/* ═══ ACTIVE TRADER MODE: Kanban Lanes ═══ */}
                    {dashboardMode === "trader" && (
                      <div className="relative" data-coachmark="kanban-lanes">
                        {viewSwitching && (
                          <div className="absolute inset-0 z-30 flex items-center justify-center bg-[#0d1117]/80 backdrop-blur-sm rounded-xl" style={{ minHeight: 200 }}>
                            <div className="flex flex-col items-center gap-2">
                              <svg className="animate-spin h-7 w-7 text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                              </svg>
                              <span className="text-[11px] text-gray-400 font-medium">Switching view…</span>
                            </div>
                          </div>
                        )}
                        {dashboardViewMode === "simple" ? (
                          <SimpleKanbanTable
                            tickers={tickers}
                            trades={trades}
                            onSelectTicker={handleTickerSelect}
                            rankPositions={rankedTickerPositions}
                            savedTickers={savedTickers}
                            toggleSavedTicker={toggleSavedTicker}
                            contextData={data}
                          />
                        ) : (
                          <EarlyMoversPanel
                            tickers={tickers}
                            trades={trades}
                            onSelectTicker={handleTickerSelect}
                            rankPositions={rankedTickerPositions}
                            rankTotal={allTickersWithRanks.length}
                            savedTickers={savedTickers}
                            toggleSavedTicker={toggleSavedTicker}
                            addingTicker={userTickers.addingTicker}
                          />
                        )}
                      </div>
                    )}

                    {/* ═══ INVESTOR MODE: Market Health + Investor Kanban ═══ */}
                    {dashboardMode === "investor" && (
                      <div className="rounded-xl border border-white/[0.06] overflow-hidden p-4" style={{ minHeight: 600, background: "#0b0e11" }}>
                        {typeof window.InvestorPanel === "function" ? (
                          React.createElement(window.InvestorPanel, {
                            apiBase: API_BASE,
                            onSelectTicker: handleTickerSelect,
                            savedTickers,
                            toggleSavedTicker,
                            selectedTicker,
                            tickerData: data,
                            searchQuery: filters.search || "",
                            filterGroup: effectiveFilters.group || "ALL",
                          })
                        ) : (
                          <div className="flex items-center justify-center h-64 text-[#6b7280]">
                            <span>Loading Investor panel…</span>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
            <Coachmarks />
            <GoProModal open={goProOpen} onClose={() => setGoProOpen(false)} />
          </>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Coachmarks — First-time user onboarding tour
      // Shows a guided spotlight tour on first visit. Completion is
      // persisted in localStorage so it only shows once.
      // ─────────────────────────────────────────────────────────────
      const COACHMARK_STEPS = [
        {
          target: "[data-coachmark='nav-modes']",
          title: "Navigation Modes",
          body: "Active Trader is for shorter-horizon swing trades \u2014 the system enters, manages, and exits positions over days to weeks. Investor is for longer-horizon portfolio management. Trades shows every trade the simulation portfolio has executed. Each mode offers a different view of the same universe.",
          position: "bottom",
          icon: "compass",
        },
        {
          target: "[data-coachmark='search-filter']",
          title: "Search, Filter & Discover",
          body: "Type a ticker, a comma-separated list, or natural language filters like \"rank > 80\" or \"squeeze\". The Filters button opens advanced screening by indicators, sectors, and scoring thresholds.",
          position: "bottom",
          icon: "search",
        },
        {
          target: "[data-coachmark='view-toggle']",
          title: "Cards, Table & Saved",
          body: "Toggle between Card view (visual Kanban cards) and Table view (sortable data grid). The Saved button filters to bookmarked tickers for quick access.",
          position: "bottom",
          icon: "layout",
        },
        {
          target: "[data-coachmark='kanban-lanes']",
          title: "Kanban Pipeline",
          body: "The system moves tickers through stages: Setup (building a case) \u2192 Enter (ready for entry) \u2192 Hold (active position) \u2192 Defend/Trim/Exit (position management). Each lane represents the system\u2019s current recommendation.",
          position: "top",
          icon: "columns",
        },
        {
          target: "[data-coachmark='viewport']",
          title: "Viewport",
          body: "A ranked list of all tickers sorted by score and opportunity quality. Click any ticker to open the Right Rail with full analysis. Filter tags above narrow by direction, sector, or trade phase.",
          position: "right",
          icon: "telescope",
        },
        {
          target: "[data-coachmark='bubble-chart']",
          title: "Bubble Chart",
          body: "The entire universe at a glance. X-axis shows short-term momentum, Y-axis shows long-term trend, and bubble size reflects risk/reward ratio. Cyan = LONG, Red = SHORT. Click any bubble for details.",
          position: "left",
          icon: "scatter",
        },
      ];

      const COACHMARK_ICONS = {
        compass: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="12" cy="12" r="10"/><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"/>
          </svg>
        ),
        search: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>
          </svg>
        ),
        layout: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/>
          </svg>
        ),
        columns: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/>
          </svg>
        ),
        telescope: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="12" cy="12" r="2"/><path d="M12 2v4m0 12v4m-7.07-2.93 2.83-2.83m8.48-8.48 2.83-2.83M2 12h4m12 0h4M4.93 4.93l2.83 2.83m8.48 8.48 2.83 2.83"/>
          </svg>
        ),
        scatter: (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="7.5" cy="7.5" r="2.5"/><circle cx="17" cy="17" r="2.5"/><circle cx="17" cy="7" r="2"/><circle cx="7" cy="17" r="2"/>
          </svg>
        ),
      };

      function Coachmarks() {
        const STORAGE_KEY = "tt_coachmarks_completed_v1";
        const [step, setStep] = useState(-1); // -1 = not showing
        const [rect, setRect] = useState(null);
        const [visible, setVisible] = useState(false);
        const rafRef = useRef(null);

        // Check if user has already completed the tour
        // IMPORTANT: Wait for the Welcome modal to be dismissed first so they
        // don't overlap. Poll until "timedTrading_welcomeSeen" is set.
        useEffect(() => {
          try {
            const done = localStorage.getItem(STORAGE_KEY);
            if (done) return; // already completed tour
          } catch { return; }

          let cancelled = false;
          const tryStart = () => {
            if (cancelled) return;
            try {
              const welcomeSeen = localStorage.getItem("timedTrading_welcomeSeen");
              if (welcomeSeen) {
                // Welcome modal dismissed — start coachmarks after a short delay
                setTimeout(() => { if (!cancelled) setStep(0); }, 800);
              } else {
                // Welcome modal still showing — check again in 1s
                setTimeout(tryStart, 1000);
              }
            } catch { /* silently retry */ setTimeout(tryStart, 1000); }
          };
          // Initial delay so the page has time to render
          const t = setTimeout(tryStart, 2000);
          return () => { cancelled = true; clearTimeout(t); };
        }, []);

        // Expose restart function for the nav "Tour" button
        useEffect(() => {
          window.__restartCoachmarks = () => setStep(0);
          return () => { delete window.__restartCoachmarks; };
        }, []);

        // Position the tooltip relative to the target element
        useEffect(() => {
          if (step < 0 || step >= COACHMARK_STEPS.length) {
            setVisible(false);
            return;
          }
          const measure = () => {
            const el = document.querySelector(COACHMARK_STEPS[step].target);
            if (el) {
              el.scrollIntoView({ behavior: "smooth", block: "nearest" });
              // Small delay so scrollIntoView settles
              setTimeout(() => {
                const r = el.getBoundingClientRect();
                setRect({ top: r.top, left: r.left, width: r.width, height: r.height });
                setVisible(true);
              }, 400);
            } else {
              // Target not found — skip step
              setRect(null);
              setVisible(true);
            }
          };
          setVisible(false);
          const t = setTimeout(measure, 200);
          return () => clearTimeout(t);
        }, [step]);

        const handleNext = useCallback(() => {
          if (step < COACHMARK_STEPS.length - 1) {
            setStep((s) => s + 1);
          } else {
            // Tour complete
            try { localStorage.setItem(STORAGE_KEY, Date.now()); } catch {}
            setStep(-1);
          }
        }, [step]);

        const handleSkip = useCallback(() => {
          try { localStorage.setItem(STORAGE_KEY, "skipped"); } catch {}
          setStep(-1);
        }, []);

        const handleBack = useCallback(() => {
          if (step > 0) setStep((s) => s - 1);
        }, [step]);

        if (step < 0 || step >= COACHMARK_STEPS.length) return null;

        const currentStep = COACHMARK_STEPS[step];
        const pad = 8;

        // Compute tooltip position
        let tooltipStyle = {};
        if (rect) {
          const pos = currentStep.position || "bottom";
          if (pos === "bottom") {
            tooltipStyle = {
              top: rect.top + rect.height + pad + 12,
              left: Math.max(16, rect.left + rect.width / 2 - 180),
            };
          } else if (pos === "top") {
            tooltipStyle = {
              top: Math.max(16, rect.top - pad - 12 - 220),
              left: Math.max(16, rect.left + rect.width / 2 - 180),
            };
          } else if (pos === "right") {
            tooltipStyle = {
              top: Math.max(16, rect.top + rect.height / 2 - 80),
              left: rect.left + rect.width + pad + 12,
            };
          } else if (pos === "left") {
            tooltipStyle = {
              top: Math.max(16, rect.top + rect.height / 2 - 80),
              left: Math.max(16, rect.left - pad - 12 - 360),
            };
          }
          // Keep within viewport
          tooltipStyle.left = Math.min(tooltipStyle.left, window.innerWidth - 380);
          tooltipStyle.top = Math.max(16, tooltipStyle.top);
        } else {
          // No target found — center on screen
          tooltipStyle = {
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
          };
        }

        return ReactDOM.createPortal(
          <div
            style={{
              position: "fixed",
              inset: 0,
              zIndex: 99999,
              pointerEvents: "auto",
              transition: "opacity 0.3s ease",
              opacity: visible ? 1 : 0,
            }}
          >
            {/* Dark overlay with spotlight cutout */}
            <svg
              style={{ position: "absolute", inset: 0, width: "100%", height: "100%", pointerEvents: "none" }}
              xmlns="http://www.w3.org/2000/svg"
            >
              <defs>
                <mask id="coachmark-mask">
                  <rect width="100%" height="100%" fill="white" />
                  {rect && (
                    <rect
                      x={rect.left - pad}
                      y={rect.top - pad}
                      width={rect.width + pad * 2}
                      height={rect.height + pad * 2}
                      rx="12"
                      fill="black"
                    />
                  )}
                </mask>
              </defs>
              <rect
                width="100%"
                height="100%"
                fill="rgba(0,0,0,0.65)"
                mask="url(#coachmark-mask)"
                style={{ pointerEvents: "auto" }}
                onClick={handleNext}
              />
            </svg>

            {/* Spotlight ring glow */}
            {rect && (
              <div
                style={{
                  position: "absolute",
                  top: rect.top - pad - 2,
                  left: rect.left - pad - 2,
                  width: rect.width + pad * 2 + 4,
                  height: rect.height + pad * 2 + 4,
                  borderRadius: 14,
                  border: "2px solid rgba(56, 189, 248, 0.5)",
                  boxShadow: "0 0 20px rgba(56, 189, 248, 0.2), inset 0 0 20px rgba(56, 189, 248, 0.05)",
                  pointerEvents: "none",
                  animation: "coachmark-pulse 2s ease-in-out infinite",
                }}
              />
            )}

            {/* Tooltip card */}
            <div
              style={{
                position: "fixed",
                ...tooltipStyle,
                width: 360,
                pointerEvents: "auto",
                animation: visible ? "coachmark-slide-in 0.35s ease-out" : "none",
              }}
            >
              <div
                style={{
                  background: "linear-gradient(135deg, rgba(15, 23, 42, 0.97), rgba(15, 23, 42, 0.95))",
                  border: "1px solid rgba(56, 189, 248, 0.25)",
                  borderRadius: 16,
                  padding: "20px 22px 16px",
                  boxShadow: "0 25px 50px rgba(0,0,0,0.5), 0 0 40px rgba(56, 189, 248, 0.08)",
                  backdropFilter: "blur(20px)",
                }}
              >
                {/* Header */}
                <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
                  <div
                    style={{
                      width: 36,
                      height: 36,
                      borderRadius: 10,
                      background: "linear-gradient(135deg, rgba(56, 189, 248, 0.15), rgba(59, 130, 246, 0.1))",
                      border: "1px solid rgba(56, 189, 248, 0.2)",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      color: "#38bdf8",
                      flexShrink: 0,
                    }}
                  >
                    {COACHMARK_ICONS[currentStep.icon] || COACHMARK_ICONS.compass}
                  </div>
                  <div style={{ flex: 1 }}>
                    <div style={{ fontSize: 15, fontWeight: 700, color: "#f0f6fc", letterSpacing: "-0.01em" }}>
                      {currentStep.title}
                    </div>
                    <div style={{ fontSize: 10, color: "#64748b", marginTop: 1, fontWeight: 500 }}>
                      Step {step + 1} of {COACHMARK_STEPS.length}
                    </div>
                  </div>
                  <button
                    onClick={handleSkip}
                    style={{
                      background: "none",
                      border: "none",
                      color: "#475569",
                      cursor: "pointer",
                      padding: 4,
                      borderRadius: 6,
                      lineHeight: 1,
                      fontSize: 18,
                    }}
                    onMouseEnter={(e) => e.target.style.color = "#94a3b8"}
                    onMouseLeave={(e) => e.target.style.color = "#475569"}
                    title="Skip tour"
                  >
                    ✕
                  </button>
                </div>

                {/* Body */}
                <p style={{ fontSize: 13, lineHeight: 1.6, color: "#94a3b8", margin: "0 0 16px" }}>
                  {currentStep.body}
                </p>

                {/* Progress dots + navigation */}
                <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between" }}>
                  {/* Progress dots */}
                  <div style={{ display: "flex", gap: 6 }}>
                    {COACHMARK_STEPS.map((_, i) => (
                      <div
                        key={i}
                        style={{
                          width: i === step ? 20 : 6,
                          height: 6,
                          borderRadius: 3,
                          background: i === step
                            ? "linear-gradient(90deg, #38bdf8, #3b82f6)"
                            : i < step
                              ? "rgba(56, 189, 248, 0.4)"
                              : "rgba(255,255,255,0.1)",
                          transition: "all 0.3s ease",
                        }}
                      />
                    ))}
                  </div>

                  {/* Buttons */}
                  <div style={{ display: "flex", gap: 8 }}>
                    {step > 0 && (
                      <button
                        onClick={handleBack}
                        style={{
                          padding: "6px 14px",
                          fontSize: 12,
                          fontWeight: 600,
                          color: "#94a3b8",
                          background: "rgba(255,255,255,0.05)",
                          border: "1px solid rgba(255,255,255,0.1)",
                          borderRadius: 8,
                          cursor: "pointer",
                          transition: "all 0.2s",
                        }}
                        onMouseEnter={(e) => { e.target.style.background = "rgba(255,255,255,0.1)"; e.target.style.color = "#f0f6fc"; }}
                        onMouseLeave={(e) => { e.target.style.background = "rgba(255,255,255,0.05)"; e.target.style.color = "#94a3b8"; }}
                      >
                        Back
                      </button>
                    )}
                    <button
                      onClick={handleNext}
                      style={{
                        padding: "6px 18px",
                        fontSize: 12,
                        fontWeight: 600,
                        color: "#0f172a",
                        background: "linear-gradient(135deg, #38bdf8, #3b82f6)",
                        border: "none",
                        borderRadius: 8,
                        cursor: "pointer",
                        transition: "all 0.2s",
                        boxShadow: "0 2px 8px rgba(56, 189, 248, 0.3)",
                      }}
                      onMouseEnter={(e) => e.target.style.boxShadow = "0 4px 16px rgba(56, 189, 248, 0.5)"}
                      onMouseLeave={(e) => e.target.style.boxShadow = "0 2px 8px rgba(56, 189, 248, 0.3)"}
                    >
                      {step === COACHMARK_STEPS.length - 1 ? "Got it!" : "Next"}
                    </button>
                  </div>
                </div>

                {/* Skip all link */}
                {step < COACHMARK_STEPS.length - 1 && (
                  <div style={{ textAlign: "center", marginTop: 10 }}>
                    <button
                      onClick={handleSkip}
                      style={{
                        background: "none",
                        border: "none",
                        color: "#475569",
                        fontSize: 11,
                        cursor: "pointer",
                        textDecoration: "underline",
                        textUnderlineOffset: 2,
                      }}
                      onMouseEnter={(e) => e.target.style.color = "#64748b"}
                      onMouseLeave={(e) => e.target.style.color = "#475569"}
                    >
                      Skip tour
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>,
          document.body
        );
      }

      // Make App accessible from outside the Babel script
      window.App = App;
      window.Coachmarks = Coachmarks;
    </script>

    <!-- Initialize app - separate script to avoid Babel parsing issues -->
    <script>
      // Render with error handling
      // Wait for all scripts to load before rendering
      function initializeApp() {
        try {
          // Check if React and ReactDOM are loaded
          if (typeof React === "undefined") {
            throw new Error("React not loaded. Check CDN connection.");
          }
          if (typeof ReactDOM === "undefined") {
            throw new Error("ReactDOM not loaded. Check CDN connection.");
          }

          const rootElement = document.getElementById("root");
          if (!rootElement) {
            throw new Error("Root element not found");
          }

          // Check if App component is available (from Babel script)
          if (typeof window.App === "undefined") {
            throw new Error(
              "App component not loaded. Babel may not have finished processing.",
            );
          }

          // Check if React 18 createRoot is available
          const AuthGate = window.TimedAuthGate;
          const wrappedApp = AuthGate
            ? React.createElement(AuthGate, { apiBase: "", requiredTier: "free" },
                (user) => React.createElement(window.App, { user }))
            : React.createElement(window.App);
          if (ReactDOM.createRoot) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(wrappedApp);
          } else {
            // Fallback for React 17
            ReactDOM.render(wrappedApp, rootElement);
          }

          console.log("[App] Dashboard initialized successfully");
          // Push notification registration is handled by AuthGate after server-verified auth.
          // Do NOT call TimedPushRegister here — it would fire before auth is confirmed.
        } catch (error) {
          console.error("Error rendering app:", error);
          const rootElement = document.getElementById("root");
          if (rootElement) {
            rootElement.innerHTML = `
              <div style="padding: 40px; text-align: center; color: #f0f2f5; max-width: 800px; margin: 0 auto;">
                <h2 style="color: #e11d48; margin-bottom: 20px;">Error Loading Dashboard</h2>
                <p style="margin-bottom: 20px; color: #ff6b6b;">${error.message}</p>
                <div style="background: #1a2440; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left; color: #8b92a0;">
                  <h3 style="color: #f0f2f5; margin-bottom: 10px;">Troubleshooting:</h3>
                  <ul style="list-style: disc; padding-left: 20px; line-height: 1.8;">
                    <li>Open browser console (F12 or Cmd+Option+I) to see detailed errors</li>
                    <li>Check your internet connection - CDN resources need to load</li>
                    <li>Try refreshing the page (Cmd+R or Ctrl+R)</li>
                    <li>Check if React is loaded: <code style="background: #252b36; padding: 2px 6px; border-radius: 4px;">typeof React !== 'undefined'</code></li>
                    <li>Check if API is reachable: <a href="/timed/health" target="_blank" style="color: #4a9eff;">API Health Check</a></li>
                  </ul>
                </div>
                <button 
                  onclick="window.location.reload()" 
                  style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;"
                >
                  Reload Page
                </button>
              </div>
            `;
          }
        }
      }

      // Poll for window.App (Babel may take a while on large scripts >500KB)
      function waitForAppAndInit() {
        var attempts = 0;
        var maxAttempts = 100; // 10 seconds max (100 * 100ms)
        function poll() {
          attempts++;
          if (typeof window.App !== "undefined") {
            console.log("[App] Babel ready after " + (attempts * 100) + "ms");
            initializeApp();
          } else if (attempts < maxAttempts) {
            setTimeout(poll, 100);
          } else {
            console.error("[App] Timed out waiting for Babel after 10s");
            initializeApp(); // will show error UI
          }
        }
        poll();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", waitForAppAndInit);
      } else {
        waitForAppAndInit();
      }

      // Fallback: If React still isn't loaded after 5 seconds, show error
      setTimeout(function () {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          const rootElement = document.getElementById("root");
          if (
            rootElement &&
            rootElement.innerHTML.includes("Loading dashboard")
          ) {
            rootElement.innerHTML = `
          <div style="padding: 40px; text-align: center; color: #f0f2f5;">
                <h2 style="color: #e11d48;">CDN Resources Not Loading</h2>
                <p style="margin: 20px 0; color: #8b92a0;">
                  React or other CDN resources failed to load. This may be due to:
                </p>
                <ul style="text-align: left; display: inline-block; color: #8b92a0; margin: 20px 0;">
                  <li>Network connectivity issues</li>
                  <li>Ad blockers blocking CDN scripts</li>
                  <li>Corporate firewall blocking unpkg.com</li>
                </ul>
                <p style="margin-top: 20px;">
                  <button onclick="window.location.reload()" style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Retry
                  </button>
            </p>
          </div>
        `;
          }
        }
      }, 5000);
    </script>
    <script>
      // Daily Brief badge check
      (function() {
        fetch("/timed/daily-brief/badge", { cache: "no-store" })
          .then(r => r.json())
          .then(d => {
            if (d?.badge?.ts) {
              const seen = Number(localStorage.getItem("tt_brief_seen") || 0);
              if (d.badge.ts > seen) {
                const el = document.getElementById("brief-badge");
                if (el) el.classList.remove("hidden");
              }
            }
          })
          .catch(() => {});
      })();
    </script>
    <footer id="legal-footer" style="position:fixed;bottom:0;left:0;right:0;z-index:9999;background:rgba(10,10,15,0.92);backdrop-filter:blur(6px);border-top:1px solid rgba(255,255,255,0.06);padding:6px 16px;text-align:center;font-size:10px;color:#6b7280;line-height:1.4;">
      For informational and educational purposes only. Not investment advice. Past performance does not guarantee future results. All trading involves risk of loss. <a href="/terms.html" style="color:#6b7280;text-decoration:underline;">Full Terms</a> · Market data powered by <a href="https://twelvedata.com" target="_blank" rel="noopener" style="color:#6b7280;text-decoration:underline;">Twelve Data</a>
    </footer>
  </body>
</html>
