//@version=6
indicator("TimedTrading_ScoreEngine_v2.0.0", overlay=false, max_labels_count=50)

//─────────────────────────────────────────────────────────────────────────────
// Inputs
//─────────────────────────────────────────────────────────────────────────────
groupAxes = "Axes & Timeframes"
tfW   = input.string("W",   "HTF #1 (Weekly)", group=groupAxes)
tfD   = input.string("D",   "HTF #2 (Daily)",  group=groupAxes)
tf4H  = input.string("240", "HTF #3 (4H)",     group=groupAxes)
tf1H  = input.string("60",  "HTF #4 (1H Bridge)", group=groupAxes)

tf30  = input.string("30", "LTF #1 (30m)", group=groupAxes)
tf10  = input.string("10", "LTF #2 (10m)", group=groupAxes)
tf3   = input.string("3",  "LTF #3 (3m)",  group=groupAxes)

// Base weights (will be adjusted by volatility)
wW  = input.float(0.50, "HTF Weekly base weight", group=groupAxes, minval=0, maxval=1)
wD  = input.float(0.35, "HTF Daily base weight",  group=groupAxes, minval=0, maxval=1)
w4H = input.float(0.10, "HTF 4H base weight",     group=groupAxes, minval=0, maxval=1)
w1H = input.float(0.05, "HTF 1H base weight",     group=groupAxes, minval=0, maxval=1)

w30 = input.float(0.60, "LTF 30m base weight", group=groupAxes, minval=0, maxval=1)
w10 = input.float(0.30, "LTF 10m base weight", group=groupAxes, minval=0, maxval=1)
w3  = input.float(0.10, "LTF 3m base weight",  group=groupAxes, minval=0, maxval=1)

// Adaptive features
useVolatilityAdjust = input.bool(true, "Volatility-adjusted weights", group=groupAxes)
useSessionAware = input.bool(true, "Session-aware LTF weights (RTH)", group=groupAxes)
useAssetAdaptive = input.bool(true, "Asset-class adaptive timeframes", group=groupAxes)

groupST = "SuperTrend (Phoenix default)"
stLen   = input.int(10, "ST ATR Length", group=groupST, minval=1)
stFac   = input.float(3.0, "ST Factor",  group=groupST, minval=0.1, step=0.1)

groupEMA = "EMAs (Phoenix default)"
emaFastLen = input.int(5,  "Fast EMA", group=groupEMA, minval=1)
emaSlowLen = input.int(48, "Slow EMA", group=groupEMA, minval=1)

groupSqueeze = "TTM Squeeze"
sqLen   = input.int(20,   "Squeeze length", group=groupSqueeze, minval=5)
bbMult  = input.float(2.0,"BB stdev mult",  group=groupSqueeze, step=0.1)
kcMult  = input.float(1.5,"KC ATR mult",    group=groupSqueeze, step=0.1)
momLen  = input.int(20,   "Momentum len (linreg)", group=groupSqueeze, minval=5)

groupGG = "Golden Gate (Distance-based)"
useGoldenGate = input.bool(true, "Include Golden Gate in LTF score", group=groupGG)
ggATRmult      = input.float(0.382, "GG ATR mult (PC ± mult*ATRd)", group=groupGG, step=0.001)
ggDistanceMode = input.bool(true, "Distance-based GG (vs binary cross)", group=groupGG)

groupPhase = "Phase (Multi-factor)"
phaseExitAbs = input.float(61.8, "Phase band (|osc|) reference", group=groupPhase, step=0.1)
phaseMaxAbs  = input.float(100.0,"Phase max for % (cap)", group=groupPhase, step=0.1)
useMultiFactorPhase = input.bool(true, "Multi-factor phase (price+momentum+volume)", group=groupPhase)
usePhaseZones = input.bool(true, "Graduated phase zones", group=groupPhase)

groupTP = "TP/SL (Dynamic)"
expMoveATRx = input.float(2.0, "Expected move = ATRw × (swing)", group=groupTP, step=0.1, minval=0.1)
useDynamicTP = input.bool(true, "Dynamic TP based on swing size", group=groupTP)
useVolatilitySL = input.bool(true, "Volatility-adjusted SL", group=groupTP)
usePivotSR = input.bool(true, "Pivot-based S/R integration", group=groupTP)
pivotLookback = input.int(5, "Pivot lookback", group=groupTP, minval=3, maxval=10)

groupAlerts = "Alerts (Baseline + Meaningful change)"
scoreDelta = input.float(3.0, "Min |Δscore| to resend", group=groupAlerts, minval=0.5, step=0.5)
minMinutesBetweenSends = input.int(5, "Min minutes between sends (throttle)", group=groupAlerts, minval=0)
forceBaseline = input.bool(false, "FORCE: Send baseline every bar (temporary)", group=groupAlerts)
debugHeartbeat = input.bool(false, "DEBUG: Heartbeat alert every bar close", group=groupAlerts)

//─────────────────────────────────────────────────────────────────────────────
// Utils
//─────────────────────────────────────────────────────────────────────────────
clamp(x, lo, hi) => math.max(lo, math.min(hi, x))
prevBoolSeries(b) => bar_index > 0 ? b[1] : false

f_fmt(x, dec) =>
    dec <= 0 ? str.tostring(math.round(x)) :
     str.tostring(math.round(x * math.pow(10, dec)) / math.pow(10, dec))

// Asset class detection
f_is_crypto() =>
    ticker = syminfo.ticker
    str.contains(ticker, "USD") or str.contains(ticker, "USDT") or str.contains(ticker, "BTC") or str.contains(ticker, "ETH")

f_is_futures() =>
    str.contains(syminfo.ticker, "1!")

f_is_forex() =>
    str.contains(syminfo.ticker, "DXY") or str.contains(syminfo.ticker, "EUR") or str.contains(syminfo.ticker, "GBP")

// Session detection (for equities)
f_is_rth() =>
    hour >= 9 and hour < 16

f_is_premarket() =>
    hour >= 4 and hour < 9

f_is_afterhours() =>
    hour >= 16 and hour < 20

//─────────────────────────────────────────────────────────────────────────────
// DAILY anchors (Golden Gate)
//─────────────────────────────────────────────────────────────────────────────
PCd  = request.security(syminfo.tickerid, "D", close[1],   barmerge.gaps_off, barmerge.lookahead_off)
ATRd = request.security(syminfo.tickerid, "D", ta.atr(14), barmerge.gaps_off, barmerge.lookahead_off)
GGup = PCd + ggATRmult * ATRd
GGdn = PCd - ggATRmult * ATRd

//─────────────────────────────────────────────────────────────────────────────
// WEEKLY anchors (Swing mode: 1–4 weeks)
//─────────────────────────────────────────────────────────────────────────────
PCw  = request.security(syminfo.tickerid, "W", close[1],   barmerge.gaps_off, barmerge.lookahead_off)
ATRw = request.security(syminfo.tickerid, "W", ta.atr(14), barmerge.gaps_off, barmerge.lookahead_off)

// Recent swing for dynamic TP
swingHighW = request.security(syminfo.tickerid, "W", ta.highest(high, 20), barmerge.gaps_off, barmerge.lookahead_off)
swingLowW  = request.security(syminfo.tickerid, "W", ta.lowest(low, 20), barmerge.gaps_off, barmerge.lookahead_off)
recentSwingW = swingHighW - swingLowW

//─────────────────────────────────────────────────────────────────────────────
// Enhanced bundle: includes volume and RSI
//─────────────────────────────────────────────────────────────────────────────
f_tf_bundle() =>
    e5   = ta.ema(close, 5)
    e8   = ta.ema(close, 8)
    e13  = ta.ema(close, 13)
    e21  = ta.ema(close, 21)
    e48  = ta.ema(close, 48)
    e200 = ta.ema(close, 200)

    eFast = ta.ema(close, emaFastLen)
    eSlow = ta.ema(close, emaSlowLen)

    [stLine, stDir] = ta.supertrend(stFac, stLen)

    basis = ta.sma(close, sqLen)
    dev   = bbMult * ta.stdev(close, sqLen)
    bbU   = basis + dev
    bbL   = basis - dev
    atrKC = ta.atr(sqLen)
    kcU   = basis + kcMult * atrKC
    kcL   = basis - kcMult * atrKC
    sqOn  = (bbU < kcU) and (bbL > kcL)

    mom = ta.linreg(close - ta.sma(close, momLen), momLen, 0)
    momStd = ta.stdev(mom, 20)

    // Volume
    vol = volume
    volSma = ta.sma(vol, 20)
    volRatio = volSma > 0 ? vol / volSma : 1.0

    // RSI for mean reversion
    rsi = ta.rsi(close, 14)

    // Multi-factor phase
    piv = ta.ema(close, 21)
    a14 = ta.atr(14)
    pricePhase = a14 == 0 ? 0.0 : ((close - piv) / (3.0 * a14)) * 100.0
    momentumPhase = momStd > 0 ? (mom / momStd) * 20.0 : 0.0
    volumePhase = (volRatio - 1.0) * 30.0
    
    rawPhase = useMultiFactorPhase ? (pricePhase * 0.6) + (momentumPhase * 0.3) + (volumePhase * 0.1) : pricePhase
    phaseOsc = ta.ema(rawPhase, 3)

    // Phase velocity
    phaseVelocity = phaseOsc - phaseOsc[1]
    phaseAccel = phaseVelocity - phaseVelocity[1]

    // Phase zones
    phaseAbs = math.abs(phaseOsc)
    phaseZone = usePhaseZones ? (phaseAbs > 100 ? "EXTREME" : phaseAbs > 61.8 ? "HIGH" : phaseAbs > 38.2 ? "MEDIUM" : "LOW") : (phaseAbs > phaseExitAbs ? "HIGH" : "LOW")

    bbo = 2.0 * ta.stdev(close, 21)
    bup = piv + bbo
    bdn = piv - bbo
    ctU = piv + (2.0 * a14)
    ctD = piv - (2.0 * a14)
    exU = piv + (1.854 * a14)
    exD = piv - (1.854 * a14)
    above = close >= piv
    comp  = above ? (bup - ctU) : (ctD - bdn)
    inExp = above ? (bup - exU) : (exD - bdn)
    expanding = bar_index > 0 ? (comp[1] <= comp) : false
    compressed = (not (expanding and inExp > 0)) and (comp <= 0)

    // ATR for volatility
    atr14 = ta.atr(14)
    atrSma = ta.sma(atr14, 20)
    atrRatio = atrSma > 0 ? atr14 / atrSma : 1.0

    ggUpCross = ta.crossover(close, GGup)
    ggDnCross = ta.crossunder(close, GGdn)

    // Distance to Golden Gate
    ggDist = math.max(0, math.min(1, close >= PCd ? ((close - GGdn) / (GGup - GGdn)) : ((GGup - close) / (GGup - GGdn))))

    [close, e5, e8, e13, e21, e48, e200, eFast, eSlow, stLine, stDir, sqOn, mom, momStd, phaseOsc, phaseVelocity, phaseAccel, phaseZone, compressed, ggUpCross, ggDnCross, ggDist, volRatio, rsi, atrRatio]

f_get_bundle(tf) =>
    request.security(syminfo.tickerid, tf, f_tf_bundle(), barmerge.gaps_off, barmerge.lookahead_off)

// Pull bundles
[cW, e5W, e8W, e13W, e21W, e48W, e200W, eFastW, eSlowW, stLW, stDW, sqW, momW, momStdW, phW, phVelW, phAccW, phZoneW, compW, ggUpW, ggDnW, ggDistW, volRW, rsiW, atrRW] = f_get_bundle(tfW)
[cD, e5D, e8D, e13D, e21D, e48D, e200D, eFastD, eSlowD, stLD, stDD, sqD, momD, momStdD, phD, phVelD, phAccD, phZoneD, compD, ggUpD, ggDnD, ggDistD, volRD, rsiD, atrRD] = f_get_bundle(tfD)
[c4, e5H, e8H, e13H, e21H, e48H, e200H, eFast4, eSlow4, stL4, stD4, sq4, mom4, momStd4, ph4, phVel4, phAcc4, phZone4, comp4, ggUp4, ggDn4, ggDist4, volR4, rsi4, atrR4] = f_get_bundle(tf4H)
[c1, e5_1, e8_1, e13_1, e21_1, e48_1, e200_1, eFast1, eSlow1, stL1, stD1, sq1, mom1, momStd1, ph1, phVel1, phAcc1, phZone1, comp1, ggUp1, ggDn1, ggDist1, volR1, rsi1, atrR1] = f_get_bundle(tf1H)

[c30, e5_30, e8_30, e13_30, e21_30, e48_30, e200_30, eFast30, eSlow30, stL30, stD30, sq30, mom30, momStd30, ph30, phVel30, phAcc30, phZone30, comp30, ggUp30, ggDn30, ggDist30, volR30, rsi30, atrR30] = f_get_bundle(tf30)
[c10, e5_10, e8_10, e13_10, e21_10, e48_10, e200_10, eFast10, eSlow10, stL10, stD10, sq10, mom10, momStd10, ph10, phVel10, phAcc10, phZone10, comp10, ggUp10, ggDn10, ggDist10, volR10, rsi10, atrR10] = f_get_bundle(tf10)
[c3,  e5_3,  e8_3,  e13_3,  e21_3,  e48_3,  e200_3,  eFast3,  eSlow3,  stL3,  stD3,  sq3,  mom3,  momStd3,  ph3,  phVel3,  phAcc3,  phZone3,  comp3,  ggUp3,  ggDn3,  ggDist3,  volR3,  rsi3,  atrR3 ] = f_get_bundle(tf3)

//─────────────────────────────────────────────────────────────────────────────
// Enhanced HTF Scoring
//─────────────────────────────────────────────────────────────────────────────
f_htf_from_bundle(px, ema200, stDir, e5, e8, e13, e21, e48, comp, osc, eFast, eSlow, volRatio, atrRatio) =>
    // Trend bias (unchanged)
    trendBias = (px >= ema200 ? 10.0 : -10.0) + (stDir < 0 ? 10.0 : -10.0)

    // GRADUATED STRUCTURE SCORING (not binary)
    stackScore = 0.0
    if e5 > e8
        stackScore += 2.0
    if e8 > e13
        stackScore += 2.5
    if e13 > e21
        stackScore += 2.5
    if e21 > e48
        stackScore += 3.0
    // Partial stacks get partial credit
    slope48Up = e48 > e48[1]
    structure = (stackScore > 0 ? stackScore : (stackScore < 0 ? stackScore : 0.0)) + (slope48Up ? 5.0 : -5.0)

    // MULTI-FACTOR REGIME DETECTION
    bias = (trendBias >= 0) ? 1 : -1
    regimeScore = 0.0
    
    // Compression factor
    if comp
        regimeScore += (bias == 1 ? 5.0 : -5.0)
    
    // Phase exhaustion
    phaseExtreme = math.abs(osc) > phaseExitAbs
    if phaseExtreme
        regimeScore -= 3.0
    
    // ATR expansion/contraction
    atrExpansion = atrRatio > 1.1
    if atrExpansion and not comp
        regimeScore += 2.0
    
    // Volume regime
    if volRatio > 1.3
        regimeScore += 1.0
    if volRatio < 0.7
        regimeScore -= 0.5

    // Momentum component
    momC = (eFast >= eSlow) ? 5.0 : -5.0
    
    // VOLUME-WEIGHTED MOMENTUM BOOST
    volBoost = volRatio > 1.2 ? 3.0 : (volRatio < 0.8 ? -2.0 : 0.0)
    momC += volBoost

    clamp(trendBias + structure + regimeScore + momC, -50, 50)

//─────────────────────────────────────────────────────────────────────────────
// Enhanced LTF Scoring
//─────────────────────────────────────────────────────────────────────────────
f_ltf_from_bundle(px, sqOn, mom, momStd, ggUpCross, ggDnCross, ggDist, e21, e48, e5, e13, stLine, stDir, comp, volRatio, rsi, atrRatio) =>
    sqPrev = prevBoolSeries(sqOn)
    release = sqPrev and not sqOn
    
    // MOMENTUM-NORMALIZED SQUEEZE RELEASE
    relDir = release ? (mom >= 0 ? 1 : -1) : 0
    momStrength = (momStd > 0) ? math.min(1.5, math.abs(mom) / momStd) : 1.0
    trig = release ? (relDir == 1 ? 8.0 : -8.0) * momStrength : 0.0

    // DISTANCE-BASED GOLDEN GATE (vs binary cross)
    gg = 0.0
    if useGoldenGate
        if ggDistanceMode
            // Distance-based scoring
            if ggDist > 0.8
                gg += 6.0
            if ggDist < 0.2
                gg -= 4.0
            // Proximity bonus
            if math.abs(px - GGup) < ATRd * 0.1
                gg += 2.0
            if math.abs(px - GGdn) < ATRd * 0.1
                gg -= 2.0
        else
            // Binary cross (original)
            gg += ggUpCross ? 8.0 : 0.0
            gg += ggDnCross ? -8.0 : 0.0
    trigger = trig + gg

    // Alignment
    align = (px >= e21 ? 6.0 : -6.0) + (px >= e48 ? 6.0 : -6.0)
    bullStack = (e5 > e13) and (e13 > e21) and (e21 > e48)
    bearStack = (e5 < e13) and (e13 < e21) and (e21 < e48)
    align += (bullStack ? 3.0 : bearStack ? -3.0 : 0.0)

    // GRADUATED SUPERTREND SUPPORT (distance-based)
    stSlopeUp = stLine > stLine[1]
    stSlopeDn = stLine < stLine[1]
    stDist = atrRatio > 0 ? math.abs(px - stLine) / (atrRatio * ATRd) : 999
    stSupport = 0.0
    if stDir < 0 and stSlopeUp and px > stLine
        stSupport := 10.0 * math.max(0, 1.0 - stDist / 2.0)  // Fade with distance
    if stDir > 0 and stSlopeDn and px < stLine
        stSupport := -10.0 * math.max(0, 1.0 - stDist / 2.0)

    // RSI MEAN REVERSION COMPONENT
    meanRev = rsi > 70 ? -4.0 : (rsi < 30 ? 4.0 : 0.0)

    guard = (sqOn ? -3.0 : 0.0) + (comp ? -2.0 : 0.0)

    clamp(trigger + align + stSupport + meanRev + guard, -50, 50)

// HTF scores
htfWScore  = f_htf_from_bundle(cW, e200W, stDW, e5W, e8W, e13W, e21W, e48W, compW, phW, eFastW, eSlowW, volRW, atrRW)
htfDScore  = f_htf_from_bundle(cD, e200D, stDD, e5D, e8D, e13D, e21D, e48D, compD, phD, eFastD, eSlowD, volRD, atrRD)
htf4HScore = f_htf_from_bundle(c4, e200H, stD4, e5H, e8H, e13H, e21H, e48H, comp4, ph4, eFast4, eSlow4, volR4, atrR4)
htf1HScore = f_htf_from_bundle(c1, e200_1, stD1, e5_1, e8_1, e13_1, e21_1, e48_1, comp1, ph1, eFast1, eSlow1, volR1, atrR1)

// LTF scores
ltf30Score = f_ltf_from_bundle(c30, sq30, mom30, momStd30, ggUp30, ggDn30, ggDist30, e21_30, e48_30, e5_30, e13_30, stL30, stD30, comp30, volR30, rsi30, atrR30)
ltf10Score = f_ltf_from_bundle(c10, sq10, mom10, momStd10, ggUp10, ggDn10, ggDist10, e21_10, e48_10, e5_10, e13_10, stL10, stD10, comp10, volR10, rsi10, atrR10)
ltf3Score  = f_ltf_from_bundle(c3,  sq3,  mom3,  momStd3,  ggUp3,  ggDn3,  ggDist3,  e21_3,  e48_3,  e5_3,  e13_3,  stL3,  stD3,  comp3,  volR3,  rsi3,  atrR3)

//─────────────────────────────────────────────────────────────────────────────
// Volatility-adjusted weights
//─────────────────────────────────────────────────────────────────────────────
f_volatility_adjusted_weights(wW_base, wD_base, w4H_base, w1H_base, atrRW, atrRD, atrR4, atrR1) =>
    if not useVolatilityAdjust
        [wW_base, wD_base, w4H_base, w1H_base]
    else
        // High vol → favor Daily/4H/1H, Low vol → favor Weekly
        volW = atrRW
        volD = atrRD
        vol4H = atrR4
        vol1H = atrR1
        
        // Adjust based on volatility ratios
        wW_adj = volW > 1.5 ? wW_base * 0.7 : wW_base * 1.2
        wD_adj = volD > 1.3 ? wD_base * 1.2 : wD_base * 0.9
        w4H_adj = vol4H > 1.2 ? w4H_base * 1.3 : w4H_base * 0.8
        w1H_adj = vol1H > 1.1 ? w1H_base * 1.2 : w1H_base * 0.9
        
        // Normalize
        total = wW_adj + wD_adj + w4H_adj + w1H_adj
        [wW_adj / total, wD_adj / total, w4H_adj / total, w1H_adj / total]

[wW_adj, wD_adj, w4H_adj, w1H_adj] = f_volatility_adjusted_weights(wW, wD, w4H, w1H, atrRW, atrRD, atrR4, atrR1)

// Session-aware LTF weights
f_session_adjusted_ltf_weights(w30_base, w10_base, w3_base) =>
    if not useSessionAware or not f_is_rth()
        [w30_base, w10_base, w3_base]
    else
        // RTH: favor 30m, reduce 3m
        w30_adj = w30_base * 1.15
        w10_adj = w10_base * 1.0
        w3_adj = w3_base * 0.7
        total = w30_adj + w10_adj + w3_adj
        [w30_adj / total, w10_adj / total, w3_adj / total]

[w30_adj, w10_adj, w3_adj] = f_session_adjusted_ltf_weights(w30, w10, w3)

// Blend HTF
htfScore = clamp(htfWScore*wW_adj + htfDScore*wD_adj + htf4HScore*w4H_adj + htf1HScore*w1H_adj, -50, 50)

// Blend LTF
ltfScore = clamp(ltf30Score*w30_adj + ltf10Score*w10_adj + ltf3Score*w3_adj, -50, 50)

// State
htfBull = htfScore >= 0
ltfBull = ltfScore >= 0
state =
     htfBull and not ltfBull ? "HTF_BULL_LTF_PULLBACK" :
     htfBull and ltfBull     ? "HTF_BULL_LTF_BULL" :
     (not htfBull) and (not ltfBull) ? "HTF_BEAR_LTF_BEAR" :
                                       "HTF_BEAR_LTF_PULLBACK"

// Phase % (using Daily multi-factor phase)
phaseD = phD
phasePct = clamp(math.abs(phaseD) / math.max(phaseMaxAbs, 1e-9), 0, 1)
phaseDir = phaseD > 0 ? "bull" : phaseD < 0 ? "bear" : "flat"
phaseZoneD = phZoneD

// Phase dot (enhanced with zone transitions)
phasePrev = bar_index > 0 ? phaseD[1] : na
phaseZonePrev = bar_index > 0 ? phZoneD[1] : ""
phaseLeaveUp   = (not na(phasePrev)) and (phasePrev >=  phaseExitAbs) and (phaseD <  phaseExitAbs)
phaseLeaveDn   = (not na(phasePrev)) and (phasePrev <= -phaseExitAbs) and (phaseD > -phaseExitAbs)
phaseLeave100U = (not na(phasePrev)) and (phasePrev >=  100) and (phaseD < 100)
phaseLeave100D = (not na(phasePrev)) and (phasePrev <= -100) and (phaseD > -100)
phaseZoneChange = usePhaseZones and (phaseZoneD != phaseZonePrev)
phaseDot = phaseLeaveUp or phaseLeaveDn or phaseLeave100U or phaseLeave100D or phaseZoneChange

//─────────────────────────────────────────────────────────────────────────────
// Enhanced Trigger + completion
//─────────────────────────────────────────────────────────────────────────────
sq30_prev = prevBoolSeries(sq30)
sq30_rel  = sq30_prev and not sq30
rel30Dir  = sq30_rel ? (mom30 >= 0 ? 1 : -1) : 0

crossUp30 = ta.crossover(eFast30, eSlow30)
crossDn30 = ta.crossunder(eFast30, eSlow30)

htfBiasSign = htfBull ? 1 : -1

goEvent =
     (sq30_rel and rel30Dir == htfBiasSign) or
     (crossUp30 and htfBull) or
     (crossDn30 and not htfBull)

// Trigger metadata
var string triggerReason = ""
var string triggerDirStr = ""
var float  triggerPrice  = na
var int    triggerTs     = na

if barstate.isconfirmed and goEvent
    triggerPrice := c30
    triggerTs    := time

    if (sq30_rel and rel30Dir == htfBiasSign)
        triggerReason := "SQUEEZE_RELEASE"
        triggerDirStr := rel30Dir == 1 ? "BULL" : "BEAR"
    else if (crossUp30 and htfBull)
        triggerReason := "EMA_CROSS"
        triggerDirStr := "BULL"
    else if (crossDn30 and not htfBull)
        triggerReason := "EMA_CROSS"
        triggerDirStr := "BEAR"
    else
        triggerReason := "OTHER"
        triggerDirStr := (htfBull ? "BULL" : "BEAR")

// Dynamic expected move
expectedMove = useDynamicTP ? expMoveATRx * math.max(ATRw, recentSwingW * 0.5) : expMoveATRx * ATRw

completion = na(triggerPrice) or expectedMove <= 0 ? 0.0 : clamp(math.abs(close - triggerPrice) / expectedMove, 0, 1)

//─────────────────────────────────────────────────────────────────────────────
// Enhanced TP/SL Calculation
//─────────────────────────────────────────────────────────────────────────────
price_now = close
dir = htfBull ? 1 : -1

// DYNAMIC TP based on swing size
swingBasedATR = useDynamicTP ? math.max(ATRw, recentSwingW * 0.5) : ATRw
tp618_up  = PCw + 0.618 * swingBasedATR
tp100_up  = PCw + 1.000 * swingBasedATR
tp161_up  = PCw + 1.618 * swingBasedATR  // Extension level
tp618_dn  = PCw - 0.618 * swingBasedATR
tp100_dn  = PCw - 1.000 * swingBasedATR
tp161_dn  = PCw - 1.618 * swingBasedATR

// Pivot-based S/R integration
pivotHigh = request.security(syminfo.tickerid, "D", ta.pivothigh(high, pivotLookback, pivotLookback), barmerge.gaps_off, barmerge.lookahead_off)
pivotLow  = request.security(syminfo.tickerid, "D", ta.pivotlow(low, pivotLookback, pivotLookback), barmerge.gaps_off, barmerge.lookahead_off)

// Find nearest resistance/support
float nearestResistance = na
float nearestSupport = na
for i = 0 to 20
    if not na(pivotHigh[i]) and pivotHigh[i] > price_now and na(nearestResistance)
        nearestResistance := pivotHigh[i]
        break
    if not na(pivotLow[i]) and pivotLow[i] < price_now and na(nearestSupport)
        nearestSupport := pivotLow[i]
        break

// Select TP (respect S/R if enabled)
float tp = na
if dir == 1
    candidates = array.new<float>()
    if tp618_up > price_now
        array.push(candidates, tp618_up)
    if tp100_up > price_now
        array.push(candidates, tp100_up)
    if tp161_up > price_now
        array.push(candidates, tp161_up)
    
    if array.size(candidates) > 0
        tp := array.min(candidates)
        // Adjust to respect resistance
        if usePivotSR and not na(nearestResistance) and nearestResistance < tp
            tp := nearestResistance * 0.98  // 2% below resistance
else
    candidates = array.new<float>()
    if tp618_dn < price_now
        array.push(candidates, tp618_dn)
    if tp100_dn < price_now
        array.push(candidates, tp100_dn)
    if tp161_dn < price_now
        array.push(candidates, tp161_dn)
    
    if array.size(candidates) > 0
        tp := array.max(candidates)
        // Adjust to respect support
        if usePivotSR and not na(nearestSupport) and nearestSupport > tp
            tp := nearestSupport * 1.02  // 2% above support

// VOLATILITY-ADJUSTED SL
atrStopBase = ATRw * 0.35
atrStop = useVolatilitySL ? (atrStopBase * math.max(0.8, math.min(1.5, atrRD > 0 ? atrRD : 1.0))) : atrStopBase
if useVolatilitySL
    minSL = ATRd * 1.5
    atrStop := math.max(atrStop, minSL)

float sl = na
if dir == 1
    sl := stLW < price_now ? stLW : (not na(triggerPrice) ? (triggerPrice - atrStop) : (price_now - atrStop))
    // Respect support if enabled
    if usePivotSR and not na(nearestSupport) and nearestSupport > sl
        sl := nearestSupport * 0.99
else
    sl := stLW > price_now ? stLW : (not na(triggerPrice) ? (triggerPrice + atrStop) : (price_now + atrStop))
    // Respect resistance if enabled
    if usePivotSR and not na(nearestResistance) and nearestResistance < sl
        sl := nearestResistance * 1.01

elapsedDays = (not na(triggerTs)) ? ((time - triggerTs) / 86400000.0) : na
etaDays = (not na(elapsedDays) and completion > 0 and completion < 0.999) ? (elapsedDays * (1.0 / completion - 1.0)) : na

minRisk = math.max(price_now * 0.005, ATRw * 0.25)
risk = math.max(math.abs(price_now - sl), minRisk)
gain = na(tp) ? na : math.abs(tp - price_now)
rr = (risk > 0 and not na(gain)) ? (gain / risk) : na

//─────────────────────────────────────────────────────────────────────────────
// Alert gating
//─────────────────────────────────────────────────────────────────────────────
var bool   sentBaseline  = false
var float  lastSentHTF   = na
var float  lastSentLTF   = na
var string lastSentState = ""
var int    lastSentTime  = na

scoreMoved = (na(lastSentHTF) or na(lastSentLTF)) ? true :            (math.abs(htfScore - lastSentHTF) >= scoreDelta) or (math.abs(ltfScore - lastSentLTF) >= scoreDelta)

stateChanged = (lastSentState != state)

throttleOK =
     forceBaseline ? true :
     minMinutesBetweenSends <= 0 ? true :
     na(lastSentTime) ? true :
     (time - lastSentTime >= minMinutesBetweenSends * 60 * 1000)

meaningful = stateChanged or scoreMoved or sq30_rel
shouldSend = barstate.isconfirmed and throttleOK and (forceBaseline or (not sentBaseline or meaningful))

// Reasons
reason1 = (htfBull ? "HTF bullish bias" : "HTF bearish bias") + " (W/D/4H/1H)"
reason2 = (ltfBull ? "LTF bullish" : "LTF bearish") + " (30/10/3)"
reason3 = sq30_rel ? ("30m SQUEEZE RELEASE " + (rel30Dir==1 ? "BULL" : "BEAR")) : (sq30 ? "30m SQUEEZE ON" : "30m no squeeze")
reason4 = phaseDot ? ("D Phase " + (usePhaseZones ? phaseZoneD : "dot/leave")) : ("D Phase " + phaseDir + " pct=" + f_fmt(phasePct,2))

// Build JSON
json =    "{" +      "\"ts\":" + str.tostring(time) + "," +      "\"ticker\":\"" + syminfo.ticker + "\"," +      "\"tf_hint\":\"" + timeframe.period + "\"," +      "\"htf_score\":" + f_fmt(htfScore,2) + "," +      "\"ltf_score\":" + f_fmt(ltfScore,2) + "," +      "\"completion\":" + f_fmt(completion,2) + "," +      "\"phase_pct\":" + f_fmt(phasePct,2) + "," +      "\"phase_zone\":\"" + (usePhaseZones ? phaseZoneD : "") + "\"," +      "\"state\":\"" + state + "\"," +      "\"price\":" + f_fmt(price_now,2) + "," +      "\"trigger_ts\":" + (na(triggerTs) ? "null" : str.tostring(triggerTs)) + "," +      "\"trigger_price\":" + (na(triggerPrice) ? "null" : f_fmt(triggerPrice,2)) + "," +      "\"trigger_reason\":\"" + triggerReason + "\"," +      "\"trigger_dir\":\"" + triggerDirStr + "\"," +      "\"sl\":" + (na(sl) ? "null" : f_fmt(sl,2)) + "," +      "\"tp\":" + (na(tp) ? "null" : f_fmt(tp,2)) + "," +      "\"eta_days\":" + (na(etaDays) ? "null" : f_fmt(etaDays,2)) + "," +      "\"rr\":" + (na(rr) ? "null" : f_fmt(rr,2)) + "," +      "\"flags\":{" +        "\"sq30_on\":" + (sq30 ? "true":"false") + "," +        "\"sq30_release\":" + (sq30_rel ? "true":"false") + "," +        "\"phase_dot\":" + (phaseDot ? "true":"false") + "," +        "\"phase_zone_change\":" + (phaseZoneChange ? "true":"false") +      "}," +      "\"reasons\":[" +        "\"" + reason1 + "\"," +        "\"" + reason2 + "\"," +        "\"" + reason3 + "\"," +        "\"" + reason4 + "\"" +      "]" +    "}"

// Send
if shouldSend
    alert(json, alert.freq_once_per_bar_close)
    sentBaseline  := true
    lastSentHTF   := htfScore
    lastSentLTF   := ltfScore
    lastSentState := state
    lastSentTime  := time

// Debug heartbeat
if debugHeartbeat and barstate.isconfirmed
    alert("{\"ts\":" + str.tostring(time) + ",\"ticker\":\"" + syminfo.ticker + "\",\"debug\":\"HEARTBEAT\"}", alert.freq_once_per_bar_close)

//─────────────────────────────────────────────────────────────────────────────
// Visual sanity
//─────────────────────────────────────────────────────────────────────────────
plot(ltfScore, "LTF Score (X)", linewidth=2)
plot(htfScore, "HTF Score (Y)", linewidth=2)
hline(0, "Zero", linestyle=hline.style_dotted)

plotchar(sq30_rel, title="30m Squeeze Release", char="⚡", location=location.top)
plotchar(phaseDot, title="Daily Phase Dot/Zone Change", char="•", location=location.bottom)
