<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"
    />
    <title>Timed Trading</title>

    <!-- React & ReactDOM via CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
      onerror="console.error('Failed to load React')"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      onerror="console.error('Failed to load ReactDOM')"
    ></script>

    <!-- PropTypes for Recharts compatibility (React 18 doesn't include it) -->
    <script
      crossorigin
      src="https://unpkg.com/prop-types@15/prop-types.min.js"
      onerror="console.error('Failed to load PropTypes')"
    ></script>
    <script>
      // Make PropTypes available globally for Recharts
      if (typeof PropTypes === "undefined" && typeof window !== "undefined") {
        console.warn("PropTypes not loaded, Recharts may have issues");
      } else if (typeof PropTypes !== "undefined") {
        // Ensure React.PropTypes is available for older libraries
        if (typeof React !== "undefined" && !React.PropTypes) {
          React.PropTypes = PropTypes;
        }
      }
    </script>

    <!-- Babel Standalone for JSX -->
    <script
      src="https://unpkg.com/@babel/standalone/babel.min.js"
      onerror="console.error('Failed to load Babel')"
    ></script>

    <!-- Tailwind CSS -->
    <script
      src="https://cdn.tailwindcss.com"
      onerror="console.error('Failed to load Tailwind')"
    ></script>

    <!-- Recharts for lightweight charting - try multiple sources -->
    <script
      src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"
      onerror="console.error('Failed to load Recharts from unpkg, trying alternative...'); loadRechartsFallback();"
    ></script>
    <script>
      function loadRechartsFallback() {
        // Try alternative CDN
        const script = document.createElement("script");
        script.src =
          "https://cdn.jsdelivr.net/npm/recharts@2.10.3/umd/Recharts.js";
        script.onerror = function () {
          console.error("Recharts failed to load from all sources");
          window.RechartsFailed = true;
        };
        script.onload = function () {
          console.log("Recharts loaded from jsdelivr");
        };
        document.head.appendChild(script);
      }

      // Check if Recharts loaded after a delay
      window.addEventListener("load", function () {
        setTimeout(function () {
          if (typeof Recharts === "undefined" && !window.RechartsFailed) {
            console.warn("Recharts may not have loaded yet");
          }
        }, 2000);
      });
    </script>

    <!-- Loading indicator while scripts load -->
    <script>
      window.addEventListener("load", function () {
        // Check if all scripts loaded
        setTimeout(function () {
          const root = document.getElementById("root");
          if (root && root.innerHTML === "") {
            if (typeof React === "undefined") {
              root.innerHTML =
                '<div style="padding: 40px; text-align: center; color: #e7ecff;"><h2 style="color: #e74c3c;">Loading Error</h2><p>React failed to load. Check console (F12) for details.</p></div>';
            }
          }
        }, 2000);
      });
    </script>

    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --text: #e7ecff;
        --muted: #93a4d6;
        --line: #26325f;
        --good: #2ecc71;
        --bad: #e74c3c;
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Arial;
        background: var(--bg);
        color: var(--text);
      }

      .slider-thumb::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #00ffff;
        cursor: pointer;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
      }

      .slider-thumb::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #00ffff;
        cursor: pointer;
        border: none;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
      }

      .loading-spinner {
        border: 2px solid var(--line);
        border-top: 2px solid var(--text);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .prime-glow {
        box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        animation: pulse-glow 2s ease-in-out infinite;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        }
        50% {
          box-shadow: 0 0 20px rgba(46, 204, 113, 0.6);
        }
      }

      .momentum-elite-glow {
        box-shadow: 0 0 15px rgba(168, 85, 247, 0.5),
          0 0 25px rgba(236, 72, 153, 0.3);
        animation: momentum-pulse 2.5s ease-in-out infinite;
      }

      @keyframes momentum-pulse {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(168, 85, 247, 0.8),
            0 0 45px rgba(236, 72, 153, 0.6);
        }
      }

      /* Slide-in overlay from right */
      .slide-in-right {
        animation: slideInRight 0.3s ease-out;
      }
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      /* Comet trail effect */
      .comet-trail {
        stroke-dasharray: 5, 5;
        animation: cometMove 2s linear infinite;
      }
      @keyframes cometMove {
        from {
          stroke-dashoffset: 0;
        }
        to {
          stroke-dashoffset: 20;
        }
      }

      /* Bubble Trail path (prefer readability over animation) */
      .trail-path {
        stroke-linecap: round;
        stroke-linejoin: round;
        filter: drop-shadow(0 0 4px rgba(0, 255, 255, 0.25));
      }

      @keyframes momentum-pulse-old {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(168, 85, 247, 0.7),
            0 0 35px rgba(236, 72, 153, 0.5);
        }
      }

      .bubble-transition {
        transition: all 0.2s ease-out;
      }

      .bubble-hover {
        transform: scale(1.15);
        filter: brightness(1.2);
      }

      .fade-in {
        animation: fadeIn 0.3s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slide-in {
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Phase color gradient helper */
      .phase-gradient {
        background: linear-gradient(
          to right,
          #2ecc71 0%,
          #27ae60 20%,
          #f39c12 40%,
          #e67e22 60%,
          #e74c3c 80%,
          #c0392b 100%
        );
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div style="padding: 40px; text-align: center; color: #e7ecff">
        <div class="loading-spinner" style="margin: 0 auto 20px"></div>
        <p>Loading dashboard...</p>
      </div>
    </div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef, memo } = React;

      // Get Recharts components with fallback
      let RechartsComponents = null;
      if (typeof Recharts !== "undefined") {
        RechartsComponents = {
          ScatterChart: Recharts.ScatterChart,
          Scatter: Recharts.Scatter,
          XAxis: Recharts.XAxis,
          YAxis: Recharts.YAxis,
          CartesianGrid: Recharts.CartesianGrid,
          Tooltip: Recharts.Tooltip,
          ResponsiveContainer: Recharts.ResponsiveContainer,
          ReferenceLine: Recharts.ReferenceLine,
          ReferenceArea: Recharts.ReferenceArea,
        };
      }

      // ─────────────────────────────────────────────────────────────
      // Types & Constants
      // ─────────────────────────────────────────────────────────────
      const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
      const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
      const API_BASE = "https://timed-trading-ingest.shashant.workers.dev";

      // ─────────────────────────────────────────────────────────────
      // Hooks
      // ─────────────────────────────────────────────────────────────
      // Normalize trail point keys so chart rendering doesn't collapse to 0,0
      // Supports older / alternate API formats (x/y, ltf/htf, etc.)
      function normalizeTrailPoints(trail) {
        if (!Array.isArray(trail)) return [];
        return trail
          .map((p) => {
            if (!p || typeof p !== "object") return null;

            const ltf =
              p.ltf_score ??
              p.ltfScore ??
              p.ltf ??
              p.x ??
              p.ltf_value ??
              p.ltfValue ??
              p.ltf_score_value;
            const htf =
              p.htf_score ??
              p.htfScore ??
              p.htf ??
              p.y ??
              p.htf_value ??
              p.htfValue ??
              p.htf_score_value;

            const phase =
              p.phase_pct ??
              p.phasePct ??
              p.phase ??
              p.phase_completion ??
              p.phaseCompletion;
            const completion =
              p.completion ?? p.comp ?? p.completion_pct ?? p.completionPct;

            return {
              ...p,
              ltf_score: Number.isFinite(Number(ltf)) ? Number(ltf) : 0,
              htf_score: Number.isFinite(Number(htf)) ? Number(htf) : 0,
              phase_pct: Number.isFinite(Number(phase))
                ? Math.max(0, Math.min(1, Number(phase)))
                : Number.isFinite(Number(p.phase_pct))
                ? Number(p.phase_pct)
                : 0,
              completion: Number.isFinite(Number(completion))
                ? Math.max(0, Math.min(1, Number(completion)))
                : Number.isFinite(Number(p.completion))
                ? Number(p.completion)
                : 0,
            };
          })
          .filter(Boolean);
      }

      function useTickerData() {
        const [data, setData] = useState({});
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [lastUpdate, setLastUpdate] = useState(null);
        const [versionInfo, setVersionInfo] = useState(null);
        const [tickersWithoutScores, setTickersWithoutScores] = useState([]);

        const fetchData = useCallback(async () => {
          try {
            setLoading(true);
            setError(null); // Clear any previous errors
            // Add timeout to prevent hanging - increased to 30s for large datasets
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

            // Fetch both ticker data and ticker index to ensure all 133 tickers are shown
            const timestamp = Date.now();
            const [dataRes, tickersRes] = await Promise.all([
              fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
                signal: controller.signal,
                cache: "no-store",
                headers: {
                  Accept: "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `data-${timestamp}`,
                },
              }),
              fetch(`${API_BASE}/timed/tickers?_t=${timestamp}`, {
                signal: controller.signal,
                cache: "no-store",
                headers: {
                  Accept: "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `tickers-${timestamp}`,
                },
              }),
            ]);

            clearTimeout(timeoutId);

            if (!dataRes.ok) {
              const errorText = await dataRes.text();
              throw new Error(
                `HTTP ${dataRes.status}: ${errorText || "Unknown error"}`
              );
            }

            const dataJson = await dataRes.json();
            const tickersJson = await tickersRes.json();

            if (dataJson.ok) {
              const tickerData = dataJson.data || {};
              const allTickers =
                tickersJson.ok && tickersJson.tickers
                  ? tickersJson.tickers
                  : [];

              // Log version information for debugging
              const dataVersion = dataJson.dataVersion || "unknown";
              const versionsSeen = dataJson.versionsSeen || [];
              const versionFiltered = dataJson.versionFiltered || 0;
              const versionBreakdown = dataJson.versionBreakdown || {};
              const acceptedVersions = dataJson.acceptedVersions || [];
              const currentDataVersion =
                dataJson.currentDataVersion || "unknown";

              // Store version info for UI display
              setVersionInfo({
                storedVersion: dataVersion,
                versionsSeen: versionsSeen,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                acceptedVersions: acceptedVersions,
                currentDataVersion: currentDataVersion,
              });

              console.log(`[UI] Data Version Info:`, {
                storedVersion: dataVersion,
                currentDataVersion: currentDataVersion,
                versionsSeen: versionsSeen,
                acceptedVersions: acceptedVersions,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                tickersReturned: Object.keys(tickerData).length,
                totalTickersInIndex: allTickers.length,
              });

              // Normalize ticker keys: BRK.B -> BRK-B
              const normalizedData = {};
              Object.keys(tickerData).forEach((key) => {
                const normalizedKey = normTicker(key);
                normalizedData[normalizedKey] = tickerData[key];
                // If we normalized, ensure ticker field matches
                if (normalizedKey !== key && normalizedData[normalizedKey]) {
                  normalizedData[normalizedKey].ticker = normalizedKey;
                }
              });

              // Merge: ensure all tickers from index are present, even if no recent data
              // This maintains the full 133 ticker baseline
              const mergedData = { ...normalizedData };
              allTickers.forEach((ticker) => {
                const normalizedTicker = normTicker(ticker);
                if (!mergedData[normalizedTicker]) {
                  // Add placeholder for tickers without recent data
                  // They'll appear on the chart with their last known position (if available)
                  // or won't render until data comes in
                  mergedData[normalizedTicker] = {
                    ticker: normalizedTicker,
                    // Note: Without data, these tickers won't render bubbles
                    // but they'll be available when data arrives
                  };
                }
              });

              setData(mergedData);
              setLastUpdate(new Date());
              setError(null);

              // Log ticker counts for debugging
              const tickersWithData = Object.keys(mergedData).filter((t) => {
                const d = mergedData[t];
                return (
                  d && d.htf_score !== undefined && d.ltf_score !== undefined
                );
              });
              // Log detailed breakdown
              const tickersByVersion = {};
              const tickersWithoutScores = [];
              Object.keys(mergedData).forEach((t) => {
                const d = mergedData[t];
                if (d) {
                  const version = d.script_version || "unknown";
                  if (!tickersByVersion[version]) {
                    tickersByVersion[version] = [];
                  }
                  tickersByVersion[version].push(t);

                  if (d.htf_score === undefined && d.ltf_score === undefined) {
                    tickersWithoutScores.push({
                      ticker: t,
                      version: version,
                      hasPrice: !!d.price,
                    });
                  }
                }
              });

              console.log(
                `[UI] Loaded ${tickersWithData.length} tickers with scores, ${allTickers.length} total in index`
              );
              console.log(`[UI] Tickers by version:`, tickersByVersion);
              if (tickersWithoutScores.length > 0) {
                console.warn(
                  `[UI] ⚠️ ${tickersWithoutScores.length} tickers without scores:`,
                  tickersWithoutScores.slice(0, 10)
                );
                // Store in state for UI display
                setTickersWithoutScores(tickersWithoutScores);
              } else {
                setTickersWithoutScores([]);
              }

              if (versionFiltered > 0) {
                console.warn(
                  `[UI] ⚠️ ${versionFiltered} tickers filtered out due to version mismatch.`,
                  {
                    storedVersion: dataVersion,
                    currentDataVersion: currentDataVersion,
                    versionsSeen: versionsSeen,
                    acceptedVersions: acceptedVersions,
                    versionBreakdown: versionBreakdown,
                  }
                );
              }

              // Log sample tickers to see what we're getting
              const sampleTickers = Object.keys(tickerData).slice(0, 10);
              console.log(
                `[UI] Sample tickers:`,
                sampleTickers.map((t) => ({
                  ticker: t,
                  version: tickerData[t]?.script_version || "unknown",
                  hasScores: !!(
                    tickerData[t]?.htf_score !== undefined &&
                    tickerData[t]?.ltf_score !== undefined
                  ),
                  htf_score: tickerData[t]?.htf_score,
                  ltf_score: tickerData[t]?.ltf_score,
                  dynamicScore: tickerData[t]?.dynamicScore, // Check if API provides this
                  rank: tickerData[t]?.rank,
                }))
              );

              // Check if dynamicScore is coming from API
              const hasDynamicScore = Object.values(tickerData).some(
                (t) => t?.dynamicScore !== undefined
              );
              console.log(
                `[UI] API provides dynamicScore: ${
                  hasDynamicScore
                    ? "YES ✅"
                    : "NO ❌ (will use fallback calculation)"
                }`
              );

              // Check order of tickers from API
              const apiTickerOrder = Object.keys(tickerData).slice(0, 10);
              console.log(
                `[UI] First 10 tickers from API (order):`,
                apiTickerOrder
              );
            } else {
              setError(
                `API Error: ${dataJson.error || "Failed to fetch data"}`
              );
            }
          } catch (e) {
            if (e.name === "AbortError") {
              setError("Request timeout - please try again");
            } else if (
              e.message.includes("Failed to fetch") ||
              e.message.includes("Load failed")
            ) {
              setError(
                "Network error - check console for details. API may be temporarily unavailable."
              );
            } else {
              setError(e.message);
            }
            console.error("Fetch error:", e);
            console.error("Error details:", {
              name: e.name,
              message: e.message,
              stack: e.stack,
            });
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 180000); // 3 minutes auto-refresh
          return () => clearInterval(interval);
        }, [fetchData]);

        return {
          data,
          loading,
          error,
          lastUpdate,
          versionInfo,
          tickersWithoutScores,
          refetch: fetchData,
        };
      }

      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = useState(value);

        useEffect(() => {
          const handler = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);

          return () => {
            clearTimeout(handler);
          };
        }, [value, delay]);

        return debouncedValue;
      }

      function useTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchTrades = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/trades`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.trades)) {
              setTrades(json.trades);
            } else {
              setTrades([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch trades:", err);
            setTrades([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchTrades();
          const interval = setInterval(fetchTrades, 180000); // Refresh every 3 minutes
          return () => clearInterval(interval);
        }, [fetchTrades]);

        return { trades, loading, error, refetch: fetchTrades };
      }

      // Hook to fetch sector ratings
      function useSectors() {
        const [sectors, setSectors] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSectors = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/sectors`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.sectors)) {
              setSectors(json.sectors);
            } else {
              setSectors([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch sectors:", err);
            setSectors([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchSectors();
          // Refresh sectors every 5 minutes
          const interval = setInterval(fetchSectors, 300000);
          return () => clearInterval(interval);
        }, [fetchSectors]);

        return { sectors, loading, error, refetch: fetchSectors };
      }

      // ─────────────────────────────────────────────────────────────
      // Sector Mapping (matching worker sector-mapping.js)
      // ─────────────────────────────────────────────────────────────
      // Sector mapping function - matches worker/sector-mapping.js
      function getTickerSector(ticker) {
        const T = normTicker(ticker).toUpperCase();
        // This mapping should match worker/sector-mapping.js
        // For now, we'll fetch from API, but provide a fallback lookup
        const SECTOR_MAP = {
          // Consumer Discretionary
          AMZN: "Consumer Discretionary",
          TSLA: "Consumer Discretionary",
          NKE: "Consumer Discretionary",
          TJX: "Consumer Discretionary",
          HD: "Consumer Discretionary",
          MCD: "Consumer Discretionary",
          SBUX: "Consumer Discretionary",
          LOW: "Consumer Discretionary",
          NFLX: "Consumer Discretionary",
          BKNG: "Consumer Discretionary",
          CMG: "Consumer Discretionary",
          ABNB: "Consumer Discretionary",
          EXPE: "Consumer Discretionary",
          RBLX: "Consumer Discretionary",
          ULTA: "Consumer Discretionary",
          SHOP: "Consumer Discretionary",
          // Industrials
          CAT: "Industrials",
          GE: "Industrials",
          BA: "Industrials",
          HON: "Industrials",
          RTX: "Industrials",
          EMR: "Industrials",
          ETN: "Industrials",
          DE: "Industrials",
          PH: "Industrials",
          CSX: "Industrials",
          UNP: "Industrials",
          UPS: "Industrials",
          FDX: "Industrials",
          LMT: "Industrials",
          NOC: "Industrials",
          GD: "Industrials",
          TT: "Industrials",
          PWR: "Industrials",
          AWI: "Industrials",
          WTS: "Industrials",
          DY: "Industrials",
          FIX: "Industrials",
          ITT: "Industrials",
          STRL: "Industrials",
          // Information Technology
          AAPL: "Information Technology",
          MSFT: "Information Technology",
          NVDA: "Information Technology",
          AVGO: "Information Technology",
          AMD: "Information Technology",
          ORCL: "Information Technology",
          CRM: "Information Technology",
          ADBE: "Information Technology",
          INTC: "Information Technology",
          CSCO: "Information Technology",
          QCOM: "Information Technology",
          TXN: "Information Technology",
          AMAT: "Information Technology",
          LRCX: "Information Technology",
          KLAC: "Information Technology",
          ANET: "Information Technology",
          CDNS: "Information Technology",
          CRWD: "Information Technology",
          PANW: "Information Technology",
          PLTR: "Information Technology",
          MDB: "Information Technology",
          PATH: "Information Technology",
          QLYS: "Information Technology",
          PEGA: "Information Technology",
          IOT: "Information Technology",
          PSTG: "Information Technology",
          MU: "Information Technology",
          APLD: "Information Technology",
          // Communication Services
          META: "Communication Services",
          GOOGL: "Communication Services",
          GOOG: "Communication Services",
          NFLX: "Communication Services",
          DIS: "Communication Services",
          CMCSA: "Communication Services",
          VZ: "Communication Services",
          T: "Communication Services",
          TWLO: "Communication Services",
          RDDT: "Communication Services",
          // Basic Materials
          LIN: "Basic Materials",
          APD: "Basic Materials",
          ECL: "Basic Materials",
          SHW: "Basic Materials",
          PPG: "Basic Materials",
          FCX: "Basic Materials",
          NEM: "Basic Materials",
          ALB: "Basic Materials",
          MP: "Basic Materials",
          NEU: "Basic Materials",
          AU: "Basic Materials",
          CCJ: "Basic Materials",
          RGLD: "Basic Materials",
          SN: "Basic Materials",
          // Energy
          XOM: "Energy",
          CVX: "Energy",
          SLB: "Energy",
          EOG: "Energy",
          COP: "Energy",
          MPC: "Energy",
          PSX: "Energy",
          VST: "Energy",
          FSLR: "Energy",
          // Financials
          JPM: "Financials",
          BAC: "Financials",
          WFC: "Financials",
          GS: "Financials",
          MS: "Financials",
          C: "Financials",
          AXP: "Financials",
          COF: "Financials",
          SPGI: "Financials",
          MCO: "Financials",
          BLK: "Financials",
          SCHW: "Financials",
          PNC: "Financials",
          BK: "Financials",
          TFC: "Financials",
          USB: "Financials",
          ALLY: "Financials",
          EWBC: "Financials",
          WAL: "Financials",
          SOFI: "Financials",
          HOOD: "Financials",
          // Real Estate
          AMT: "Real Estate",
          PLD: "Real Estate",
          EQIX: "Real Estate",
          PSA: "Real Estate",
          WELL: "Real Estate",
          SPG: "Real Estate",
          O: "Real Estate",
          DLR: "Real Estate",
          VICI: "Real Estate",
          EXPI: "Real Estate",
          // Healthcare
          UNH: "Healthcare",
          JNJ: "Healthcare",
          LLY: "Healthcare",
          ABBV: "Healthcare",
          MRK: "Healthcare",
          TMO: "Healthcare",
          ABT: "Healthcare",
          DHR: "Healthcare",
          BMY: "Healthcare",
          AMGN: "Healthcare",
          GILD: "Healthcare",
          REGN: "Healthcare",
          VRTX: "Healthcare",
          BIIB: "Healthcare",
          UTHR: "Healthcare",
          HIMS: "Healthcare",
          NBIS: "Healthcare",
          // Utilities
          NEE: "Utilities",
          DUK: "Utilities",
          SO: "Utilities",
          D: "Utilities",
          AEP: "Utilities",
          SRE: "Utilities",
          EXC: "Utilities",
          XEL: "Utilities",
          WEC: "Utilities",
          ES: "Utilities",
          PEG: "Utilities",
          ETR: "Utilities",
          FE: "Utilities",
          AEE: "Utilities",
        };
        const sector = SECTOR_MAP[T] || null;
        // Return empty string instead of null for easier filtering
        return sector || "";
      }

      // ─────────────────────────────────────────────────────────────
      // Groups (matching original)
      // ─────────────────────────────────────────────────────────────
      const GROUPS = {
        UPTICKS: new Set([
          "TSLA",
          "STX",
          "AU",
          "CCJ",
          "CLS",
          "CRS",
          "VST",
          "FSLR",
          "JCI",
          "ORCL",
          "AMZN",
          "BRK.B",
          "BABA",
          "WMT",
          "PH",
          "GEV",
          "HII",
          "ULTA",
          "SHOP",
          "CSX",
          "PWR",
          "HOOD",
          "SPGI",
          "APP",
          "PANW",
          "RDDT",
          "TT",
          "GLXY",
          "ETHA",
        ]),
        SuperGranny: new Set(["META", "NVDA", "AMD", "ANET", "GS"]),
        GRNI: new Set([
          "VST",
          "TSLA",
          "TJX",
          "SPGI",
          "SOFI",
          "PWR",
          "PNC",
          "PLTR",
          "PANW",
          "NVDA",
          "NFLX",
          "MSTR",
          "MSFT",
          "MNST",
          "META",
          "LRCX",
          "KLAC",
          "JPM",
          "HOOD",
          "GS",
          "GOOGL",
          "GEV",
          "GE",
          "EXPE",
          "ETN",
          "EMR",
          "DE",
          "CRWD",
          "COST",
          "CDNS",
          "CAT",
          "BK",
          "AXP",
          "AXON",
          "AVGO",
          "ANET",
          "AMZN",
          "AMD",
          "AAPL",
        ]),
        GRNJ: new Set([
          "RKLB",
          "LITE",
          "SN",
          "ALB",
          "RDDT",
          "RGLD",
          "MTZ",
          "ON",
          "ALLY",
          "DY",
          "CCJ",
          "EWBC",
          "PATH",
          "WFRD",
          "WAL",
          "IESC",
          "ENS",
          "TWLO",
          "MLI",
          "KTOS",
          "MDB",
          "TLN",
          "EME",
          "AWI",
          "IBP",
          "DCI",
          "WTS",
          "FIX",
          "UTHR",
          "NBIS",
          "SGI",
          "AYI",
          "RIOT",
          "NXT",
          "SANM",
          "BWXT",
          "PEGA",
          "JOBY",
          "IONQ",
          "SOFI",
          "ITT",
          "STRL",
          "QLYS",
          "MP",
          "GLXY",
          "HIMS",
          "IOT",
          "BE",
          "NEU",
          "AVAV",
          "PSTG",
          "RBLX",
        ]),
        GRNY: new Set([
          "GEV",
          "LRCX",
          "PNC",
          "GOOGL",
          "GS",
          "META",
          "MNST",
          "KLAC",
          "TJX",
          "GE",
          "EXPE",
          "CAT",
          "BK",
          "SPGI",
          "TSLA",
          "EMR",
          "JPM",
          "AXP",
          "ANET",
          "AXON",
          "AAPL",
          "NVDA",
          "AVGO",
          "PWR",
          "CDNS",
          "DE",
          "MSFT",
          "COST",
          "VST",
          "PLTR",
          "AMZN",
          "HOOD",
          "ETN",
          "SOFI",
          "AMD",
          "PANW",
          "CRWD",
          "NFLX",
          "MSTR",
        ]),
        Social: new Set(["CSCO", "BA", "NKE", "AAPL", "PI", "APLD", "MU"]),
        SP_Sectors: new Set([
          "XLK",
          "XLF",
          "XLY",
          "XLP",
          "XLC",
          "XLI",
          "XLB",
          "XLE",
          "XLRE",
          "XLU",
          "XLV",
        ]),
        Futures: new Set(["ES1!", "NQ1!", "BTCUSD", "ETHUSD", "ETHA", "VIX"]),
      };

      const GROUP_LABELS = {
        SP_Sectors: "S&P Sectors",
        Futures: "Futures",
      };

      const GROUP_ORDER = [
        "SP_Sectors",
        "Futures",
        "UPTICKS",
        "SuperGranny",
        "GRNI",
        "GRNJ",
        "GRNY",
        "Social",
        "No Group",
      ];

      function normTicker(t) {
        let s = String(t || "")
          .trim()
          .toUpperCase();
        // Normalize BRK.B to BRK-B (TradingView sends BRK.B, but we use BRK-B for US market)
        if (s === "BRK.B" || s === "BRK-B") {
          s = "BRK-B";
        }
        return s;
      }

      function groupsForTicker(t) {
        const T = normTicker(t);
        const out = [];
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) out.push(g);
        // If ticker is not in any group, add it to "No Group"
        if (out.length === 0) {
          out.push("No Group");
        }
        return out;
      }

      // Check if ticker is in any group (including "No Group")
      function isTickerInGroups(t) {
        const T = normTicker(t);
        // Check if ticker is in any actual group
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) return true;
        // If not in any group, it's in "No Group" - return true
        return true;
      }

      // ─────────────────────────────────────────────────────────────
      // Utils
      // ─────────────────────────────────────────────────────────────

      // Phase-based color (Turbo-like gradient: 0=green, 0.5=yellow, 1=red)
      // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
      function phaseCompletionToColor(phasePct) {
        const p = Math.max(0, Math.min(1, phasePct));
        if (p < 0.3) {
          // Green: #2ecc71 (under 30%)
          return "#2ecc71";
        } else if (p < 0.6) {
          // Yellow: #f39c12 (30-60%)
          return "#f39c12";
        } else {
          // Red: #e74c3c (60-100%)
          return "#e74c3c";
        }
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          // Green to light green: #2ecc71 to #27ae60
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(
            204 + (174 - 204) * t
          )}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          // Light green to yellow: #27ae60 to #f39c12
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(
            174 + (156 - 174) * t
          )}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          // Yellow to orange: #f39c12 to #e67e22
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(
            156 + (126 - 156) * t
          )}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          // Orange to red: #e67e22 to #e74c3c
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(
            126 + (76 - 126) * t
          )}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          // Red to dark red: #e74c3c to #c0392b
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(
            76 + (57 - 76) * t
          )}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }

      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";

        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function completionForSize(ticker) {
        // Use the completion value from Pine Script payload directly
        // Pine Script calculates: completion = abs(close - triggerPrice) / expectedMove
        // This is more accurate than recalculating from trigger to TP because:
        // 1. It accounts for expectedMove (which may differ from TP distance)
        // 2. It handles direction correctly
        // 3. It works even when price hasn't reached trigger yet
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      function getDirectionFromState(ticker) {
        const state = String(ticker?.state || "");
        if (state.includes("BULL")) return "LONG";
        if (state.includes("BEAR")) return "SHORT";
        return null;
      }

      function computeEntryRef(ticker) {
        const entryRef = Number(ticker?.entry_ref);
        if (Number.isFinite(entryRef) && entryRef > 0) return entryRef;
        const trigger = Number(ticker?.trigger_price);
        if (Number.isFinite(trigger) && trigger > 0) return trigger;
        const price = Number(ticker?.price);
        return Number.isFinite(price) && price > 0 ? price : null;
      }

      function computeTpMaxPrice(ticker) {
        const entry = computeEntryRef(ticker);
        if (!Number.isFinite(entry)) return null;
        const directMax = Number(ticker?.tp_max_price ?? ticker?.tp_max);
        if (Number.isFinite(directMax) && directMax > 0) return directMax;
        const dir = getDirectionFromState(ticker);
        const tpLevels = Array.isArray(ticker?.tp_levels)
          ? ticker.tp_levels
          : [];
        const candidates = tpLevels
          .map((tp) => {
            const price =
              tp && typeof tp === "object" && tp.price != null
                ? Number(tp.price)
                : Number(tp);
            return Number.isFinite(price) ? price : null;
          })
          .filter((p) => Number.isFinite(p));

        if (ticker?.tp != null) {
          const tp = Number(ticker.tp);
          if (Number.isFinite(tp)) candidates.push(tp);
        }

        if (candidates.length === 0) return null;

        if (dir === "LONG") {
          const valid = candidates.filter((p) => p > entry);
          return valid.length > 0 ? Math.max(...valid) : null;
        }
        if (dir === "SHORT") {
          const valid = candidates.filter((p) => p < entry);
          return valid.length > 0 ? Math.min(...valid) : null;
        }

        return null;
      }

      function computeTpTargetPrice(ticker) {
        const directTarget = Number(ticker?.tp_target_price ?? ticker?.tp_target);
        if (Number.isFinite(directTarget) && directTarget > 0) return directTarget;
        const primary = Number(ticker?.tp);
        if (Number.isFinite(primary) && primary > 0) return primary;
        return null;
      }

      function computeReturnPct(ticker) {
        const direct =
          Number(ticker?.expected_return_pct) ||
          Number(ticker?.tp_target_pct) ||
          Number(ticker?.tp_max_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(ticker);
        const tpTarget = computeTpTargetPrice(ticker) ?? computeTpMaxPrice(ticker);
        if (!Number.isFinite(entry) || !Number.isFinite(tpTarget)) return null;
        return (Math.abs(tpTarget - entry) / entry) * 100;
      }

      function computeRiskPct(ticker) {
        const direct = Number(ticker?.risk_pct);
        if (Number.isFinite(direct)) return direct;
        const entry = computeEntryRef(ticker);
        const sl = Number(ticker?.sl);
        if (!Number.isFinite(entry) || !Number.isFinite(sl)) return null;
        return (Math.abs(entry - sl) / entry) * 100;
      }

      function computeEtaDays(ticker) {
        const staleness = String(ticker?.staleness || "").toUpperCase();
        if (staleness && staleness !== "FRESH") return null;
        const baseEta = Number(ticker?.eta_days_v2 ?? ticker?.eta_days);
        if (!Number.isFinite(baseEta) || baseEta <= 0) return null;
        const dir = getDirectionFromState(ticker);
        const entry = computeEntryRef(ticker);
        const target = computeTpTargetPrice(ticker);
        const current = Number(ticker?.price);
        if (
          !Number.isFinite(entry) ||
          !Number.isFinite(target) ||
          !Number.isFinite(current) ||
          !dir
        ) {
          return baseEta;
        }
        const totalDist = Math.abs(target - entry);
        if (!Number.isFinite(totalDist) || totalDist <= 0) return baseEta;
        const progress =
          dir === "LONG"
            ? (current - entry) / (target - entry)
            : (entry - current) / (entry - target);
        if (!Number.isFinite(progress)) return baseEta;
        const clamped = Math.max(0, Math.min(1, progress));
        const remaining = baseEta * (1 - clamped);
        return Math.max(0.1, Math.round(remaining * 100) / 100);
      }

      function formatEntryZone(ticker) {
        const entry = computeEntryRef(ticker);
        const price = Number(ticker?.price);
        if (!Number.isFinite(entry) || !Number.isFinite(price)) return "—";
        const low = Math.min(entry, price);
        const high = Math.max(entry, price);
        if (Math.abs(high - low) < 0.01) return `$${entry.toFixed(2)}`;
        return `$${low.toFixed(2)}–$${high.toFixed(2)}`;
      }

      function formatIngestTime(ticker) {
        const raw = ticker?.ingest_time ?? ticker?.ingest_ts ?? ticker?.ts;
        if (raw == null) return "—";
        const ms =
          typeof raw === "number" ? raw : new Date(String(raw)).getTime();
        if (!Number.isFinite(ms)) return "—";
        try {
          return new Date(ms).toLocaleString();
        } catch (e) {
          return new Date(ms).toISOString();
        }
      }

      // Compute bubble visuals (radius + color) for historical trail points.
      // NOTE: Trail points from KV/D1 may not include `rr`, so we fall back to `rank`
      // (similar to the main bubble renderers) to preserve meaningful size variation.
      // We also scale trail bubble radii down for readability while preserving relative size.
      function bubbleVisualForTrailPoint(point, tickerSymbol) {
        const comp =
          point && point.completion != null ? Number(point.completion) : 0;
        const validComp = Number.isFinite(comp)
          ? Math.max(0, Math.min(1, comp))
          : 0;

        // Prefer explicit phase_pct; otherwise fall back to completion as a proxy
        const phasePctRaw =
          point && point.phase_pct != null ? Number(point.phase_pct) : null;
        const phasePct =
          phasePctRaw != null && Number.isFinite(phasePctRaw)
            ? Math.max(0, Math.min(1, phasePctRaw))
            : validComp > 0
            ? validComp
            : 0.1;

        const rrRaw = point && point.rr != null ? Number(point.rr) : null;
        const rankRaw = point && point.rank != null ? Number(point.rank) : null;
        const fallbackRR =
          rankRaw != null && Number.isFinite(rankRaw)
            ? Math.max(0.5, Math.min(5, rankRaw / 50))
            : 0.5;
        const validRR =
          rrRaw != null && Number.isFinite(rrRaw) && rrRaw > 0
            ? rrRaw
            : fallbackRR;

        const cappedRR = Math.min(validRR, 5);
        const baseSize = 4;
        const rrMultiplier = 2;
        const size = baseSize + cappedRR * rrMultiplier * (1 - validComp);

        const sym = String(tickerSymbol || point?.ticker || "")
          .trim()
          .toUpperCase();
        const tickerHash = sym
          .split("")
          .reduce((acc, char) => acc + char.charCodeAt(0), 0);
        const sizeVariation = (tickerHash % 5) * 0.8;
        const finalSize = Math.max(baseSize, size + sizeVariation);

        // Trail bubbles should reflect their true size-at-the-time.
        const TRAIL_SIZE_SCALE = 1.0;
        const radius = Math.max(2.5, Math.min(50, finalSize * TRAIL_SIZE_SCALE));
        const color = phaseCompletionToColor(phasePct);
        return { radius, color, phasePct, validComp, validRR };
      }

      // Split a trail into segments when there are big timestamp gaps.
      // This prevents confusing “teleport” lines (e.g., overnight / missing samples).
      function splitTrailByGaps(trail, gapMs = 30 * 60 * 1000) {
        if (!Array.isArray(trail) || trail.length === 0) return [];
        const segments = [];
        let cur = [];
        for (let i = 0; i < trail.length; i++) {
          const p = trail[i];
          const prev = i > 0 ? trail[i - 1] : null;
          const ts = Number(p?.ts);
          const prevTs = Number(prev?.ts);
          const hasGap =
            prev &&
            Number.isFinite(ts) &&
            Number.isFinite(prevTs) &&
            ts - prevTs > gapMs;
          if (hasGap && cur.length > 0) {
            segments.push(cur);
            cur = [];
          }
          cur.push(p);
        }
        if (cur.length > 0) segments.push(cur);
        return segments;
      }

      // Smooth path through points using Catmull-Rom → cubic Bezier conversion.
      function catmullRomPath(points) {
        if (!Array.isArray(points) || points.length < 2) return "";
        const pts = points.map((p) => ({
          x: Number(p?.x) || 0,
          y: Number(p?.y) || 0,
        }));
        let d = `M ${pts[0].x} ${pts[0].y}`;
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = i > 0 ? pts[i - 1] : pts[i];
          const p1 = pts[i];
          const p2 = pts[i + 1];
          const p3 = i + 2 < pts.length ? pts[i + 2] : p2;
          const c1x = p1.x + (p2.x - p0.x) / 6;
          const c1y = p1.y + (p2.y - p0.y) / 6;
          const c2x = p2.x - (p3.x - p1.x) / 6;
          const c2y = p2.y - (p3.y - p1.y) / 6;
          d += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
        }
        return d;
      }

      // Calculate score breakdown (mirrors worker computeRank logic)
      function calculateScoreBreakdown(ticker) {
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = Number(ticker.completion) || 0;
        const phase = Number(ticker.phase_pct) || 0;
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;

        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const momentumElite = !!flags.momentum_elite;

        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const setup =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";

        const breakdown = {
          base: 30,
          aligned: aligned ? 12 : 0,
          setup: setup ? 4 : 0,
          htf: 0,
          ltf: 0,
          completion: 0,
          phase: 0,
          squeezeRelease: sqRel ? 12 : 0,
          squeezeOn: sqOn && !sqRel ? 4 : 0,
          phaseZoneChange: phaseZoneChange ? 2 : 0,
          rr: 0,
          momentumElite: momentumElite ? 15 : 0,
        };

        // HTF contribution
        if (Number.isFinite(htf)) {
          const htfAbs = Math.abs(htf);
          if (htfAbs >= 25) breakdown.htf = Math.min(10, htfAbs * 0.4);
          else if (htfAbs >= 15) breakdown.htf = Math.min(7, htfAbs * 0.35);
          else breakdown.htf = Math.min(4, htfAbs * 0.25);
        }

        // LTF contribution
        if (Number.isFinite(ltf)) {
          const ltfAbs = Math.abs(ltf);
          if (ltfAbs >= 20) breakdown.ltf = Math.min(10, ltfAbs * 0.3);
          else if (ltfAbs >= 12) breakdown.ltf = Math.min(6, ltfAbs * 0.25);
          else breakdown.ltf = Math.min(3, ltfAbs * 0.2);
        }

        // Completion bonus
        if (Number.isFinite(comp)) {
          if (comp <= 0.2) breakdown.completion = 15;
          else if (comp <= 0.4) breakdown.completion = 10;
          else if (comp <= 0.6) breakdown.completion = 5;
        }

        // Phase penalty/bonus
        if (Number.isFinite(phase)) {
          if (phase > 0.5) breakdown.phase = -Math.max(0, (phase - 0.5) * 30);
          if (phase <= 0.3) breakdown.phase = 3;
        }

        // RR contribution
        if (Number.isFinite(rr)) {
          if (rr >= 2.0) breakdown.rr = 10;
          else if (rr >= 1.5) breakdown.rr = 7;
          else if (rr >= 1.2) breakdown.rr = 4;
        }

        // RSI Divergence boost/penalty
        const rsi = ticker.rsi;
        if (rsi && rsi.divergence) {
          const divType = String(rsi.divergence.type || "none");
          const divStrength = Number(rsi.divergence.strength || 0);
          if (divType === "bullish") {
            breakdown.rsiDivergence = 3 + Math.min(2, divStrength * 0.1);
          } else if (divType === "bearish") {
            breakdown.rsiDivergence = -(3 - Math.min(2, divStrength * 0.1));
          } else {
            breakdown.rsiDivergence = 0;
          }
        } else {
          breakdown.rsiDivergence = 0;
        }

        breakdown.total = Math.max(
          0,
          Math.min(
            100,
            breakdown.base +
              breakdown.aligned +
              breakdown.setup +
              breakdown.htf +
              breakdown.ltf +
              breakdown.completion +
              breakdown.phase +
              breakdown.squeezeRelease +
              breakdown.squeezeOn +
              breakdown.phaseZoneChange +
              breakdown.rr +
              breakdown.momentumElite +
              breakdown.rsiDivergence
          )
        );

        return breakdown;
      }

      // Dynamic SCORE calculation that considers real-time conditions
      // NOTE: This returns a SCORE (0-200+), not a RANK (position 1-135)
      // RANK is determined by sorting all tickers by this score
      function computeDynamicScore(ticker) {
        const baseScore = Number(ticker.rank) || 50; // Base score from worker (0-100)
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;

        let dynamicScore = baseScore;

        // Corridor bonus (high priority - active setups)
        if (inCorridor) {
          dynamicScore += 12; // Strong bonus for being in corridor

          // Extra bonus if aligned AND in corridor (perfect setup)
          if (aligned) {
            dynamicScore += 8;
          }
        }

        // Squeeze release in corridor = very strong signal
        if (sqRel && inCorridor) {
          dynamicScore += 10;
        }

        // Squeeze on in corridor = building pressure
        if (sqOn && inCorridor && !sqRel) {
          dynamicScore += 5;
        }

        // RR bonus (scaled - better RR = higher score)
        if (rr >= 2.0) {
          dynamicScore += 8; // Excellent RR
        } else if (rr >= 1.5) {
          dynamicScore += 5; // Good RR
        } else if (rr >= 1.0) {
          dynamicScore += 2; // Acceptable RR
        }

        // Phase bonus (early phase = better opportunity)
        if (phase < 0.3) {
          dynamicScore += 6; // Very early
        } else if (phase < 0.5) {
          dynamicScore += 3; // Early
        } else if (phase > 0.7) {
          dynamicScore -= 5; // Late phase penalty
        }

        // Completion bonus (low completion = more room to run)
        if (comp < 0.3) {
          dynamicScore += 5; // Early in move
        } else if (comp > 0.8) {
          dynamicScore -= 8; // Near completion penalty
        }

        // Score strength bonus (strong HTF/LTF scores)
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;

        // Phase zone change bonus
        if (phaseZoneChange) {
          dynamicScore += 4;
        }

        // NO CAP - let scores go above 100 to avoid ties
        // Minimum is 0, but no maximum cap
        dynamicScore = Math.max(0, dynamicScore);

        return Math.round(dynamicScore * 100) / 100; // Round to 2 decimals for precision
      }

      // Alias for backward compatibility (but rename internally)
      const computeDynamicRank = computeDynamicScore;

      function toTickerArray(source) {
        if (!source) return [];
        if (Array.isArray(source)) {
          return source.filter((t) => t && typeof t === "object" && t.ticker);
        }
        if (typeof source === "object") {
          return Object.values(source).filter(
            (t) => t && typeof t === "object" && t.ticker
          );
        }
        return [];
      }

      function rankScoreForTicker(ticker) {
        const rankScore = Number(ticker?.rank_score);
        if (Number.isFinite(rankScore)) return rankScore;
        const dynamicRank = Number(ticker?.dynamicRank);
        if (Number.isFinite(dynamicRank)) return dynamicRank;
        const dynamicScore = Number(ticker?.dynamicScore);
        if (Number.isFinite(dynamicScore)) return dynamicScore;
        return Number(computeDynamicRank(ticker)) || 0;
      }

      function getRankedTickers(source) {
        const list = toTickerArray(source);
        const withScores = list.map((t) => ({
          ...t,
          __rankPos: Number(t?.rank_position),
          __rankScore: rankScoreForTicker(t),
        }));
        withScores.sort((a, b) => {
          const rankA = Number(a.__rankPos);
          const rankB = Number(b.__rankPos);
          const hasRankA = Number.isFinite(rankA) && rankA > 0;
          const hasRankB = Number.isFinite(rankB) && rankB > 0;
          if (hasRankA && hasRankB) return rankA - rankB;
          if (hasRankA) return -1;
          if (hasRankB) return 1;
          const scoreA = Number(a.__rankScore) || 0;
          const scoreB = Number(b.__rankScore) || 0;
          return scoreB - scoreA;
        });
        return withScores;
      }

      function getRankPosition(sortedTickers, tickerSymbol) {
        const sym = String(tickerSymbol || "").trim().toUpperCase();
        if (!sym) return null;
        const index = sortedTickers.findIndex(
          (t) =>
            String(t.ticker || "")
              .trim()
              .toUpperCase() === sym
        );
        return index >= 0 ? index + 1 : null;
      }

      function getRankPositionFromMap(rankPositions, tickerSymbol) {
        if (!rankPositions) return null;
        const sym = String(tickerSymbol || "").trim().toUpperCase();
        if (!sym) return null;
        const pos = Number(rankPositions[sym]);
        return Number.isFinite(pos) && pos > 0 ? pos : null;
      }

      function downsampleByInterval(points, intervalMs) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const buckets = new Map();
        points.forEach((p) => {
          const tsRaw = p.__ts_ms ?? p.ts ?? p.ingest_ts ?? p.ingest_time;
          const ts =
            typeof tsRaw === "string"
              ? new Date(tsRaw).getTime()
              : Number(tsRaw);
          if (!Number.isFinite(ts)) return;
          const bucket = Math.floor(ts / intervalMs) * intervalMs;
          const prev = buckets.get(bucket);
          if (!prev || ts > prev.__ts_ms) {
            buckets.set(bucket, { ...p, __ts_ms: ts, __bucket: bucket });
          }
        });
        return Array.from(buckets.values()).sort(
          (a, b) => a.__ts_ms - b.__ts_ms
        );
      }

      // Debug: Verify function is loaded correctly
      console.log(
        "🔍 [RANKING SYSTEM] computeDynamicScore function loaded (no 100 cap)"
      );
      console.log(
        "🔍 [RANKING SYSTEM] Function signature:",
        typeof computeDynamicScore
      );

      // Parse natural language query into filter conditions
      function parseNaturalLanguageQuery(query) {
        if (!query || typeof query !== "string") return null;

        const queryLower = query.toLowerCase().trim();
        const conditions = {};

        // Multi-ticker search: "AAPL, GOOGL, TSLA"
        // Also check if it's a simple ticker list (comma-separated, no filter keywords)
        if (
          query.includes(",") &&
          !query.match(
            /rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup|above|over|below|under/
          )
        ) {
          return {
            type: "multi-ticker",
            tickers: query.split(",").map((t) => t.trim().toUpperCase()),
          };
        }

        // Ranked filter (all tickers sorted by rank)
        if (
          queryLower.match(/\btop\s*40\b|\btop40\b|\branked\b|\ball\s+ranked\b/)
        ) {
          conditions.top40 = true;
        }

        // Top Long Setup
        if (queryLower.match(/\btop\s*long\s*setup\b|\btop\s*long\b/)) {
          conditions.topLongSetup = true;
        }

        // Top Short Setup
        if (queryLower.match(/\btop\s*short\s*setup\b|\btop\s*short\b/)) {
          conditions.topShortSetup = true;
        }

        // Prime setup
        if (queryLower.match(/\bprime\b|\bprime setup\b/)) {
          conditions.prime = true;
        }

        // Momentum Elite
        if (queryLower.match(/\bmomentum elite\b|\belite\b/)) {
          conditions.momentumElite = true;
        }

        // In corridor
        if (queryLower.match(/\bin corridor\b|\bcorridor\b/)) {
          conditions.inCorridor = true;
        }

        // Squeeze release
        if (queryLower.match(/\bsqueeze release\b|\bsqueeze released\b/)) {
          conditions.squeezeRelease = true;
        }

        // Helper function to extract numeric value with various operators
        const extractNumericCondition = (
          pattern,
          fieldName,
          isPercentage = false
        ) => {
          // Match operators: >, >=, <, <=, above, below, over, under, greater than, less than, at least, at most
          const operators = {
            ">": "min",
            ">=": "min",
            above: "min",
            over: "min",
            "greater than": "min",
            "at least": "min",
            "<": "max",
            "<=": "max",
            below: "max",
            under: "max",
            "less than": "max",
            "at most": "max",
          };

          for (const [op, type] of Object.entries(operators)) {
            const regex = new RegExp(
              `\\b${pattern}\\s*(?:${op.replace(
                /[.*+?^${}()|[\]\\]/g,
                "\\$&"
              )})\\s*([\\d.]+)\\s*%?`,
              "i"
            );
            const match = queryLower.match(regex);
            if (match) {
              const value = isPercentage
                ? parseFloat(match[1]) / 100
                : parseFloat(match[1]);
              return { type, value };
            }
          }
          return null;
        };

        // Rank conditions: "rank > 75", "rank above 75", "rank over 75", "rank below 50", "rank under 50"
        const rankCondition = extractNumericCondition("rank", "rank");
        if (rankCondition) {
          if (rankCondition.type === "min") {
            conditions.minRank = rankCondition.value;
          } else {
            // For max rank, we'd need a maxRank filter - skip for now
          }
        }

        // RR/Risk-Reward conditions: "RR > 2", "risk reward over 2", "RR above 1.5"
        const rrCondition = extractNumericCondition(
          "(?:rr|risk[\\s-]?reward)",
          "rr"
        );
        if (rrCondition && rrCondition.type === "min") {
          conditions.minRR = rrCondition.value;
        }

        // Phase conditions: "phase > 50%", "phase over 50%", "phase above 50", "phase under 30%"
        const phaseMinCondition = extractNumericCondition(
          "phase",
          "phase",
          true
        );
        if (phaseMinCondition && phaseMinCondition.type === "min") {
          conditions.minPhase = phaseMinCondition.value;
        }
        const phaseMaxCondition = extractNumericCondition(
          "phase",
          "phase",
          true
        );
        if (phaseMaxCondition && phaseMaxCondition.type === "max") {
          conditions.maxPhase = phaseMaxCondition.value;
        }

        // Completion conditions: "completion < 30%", "completion under 30%", "completion below 50%"
        const compCondition = extractNumericCondition(
          "completion",
          "completion",
          true
        );
        if (compCondition && compCondition.type === "max") {
          conditions.maxCompletion = compCondition.value;
        }

        // Price change: "moved 5 points", "moved $5", "price change > 5", "price change over 5"
        const priceChangeMatch = queryLower.match(
          /\b(?:moved|price\s*change)\s+(?:over|above|greater\s*than|>|>=|at\s*least)\s*(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/
        );
        if (priceChangeMatch) {
          conditions.minPriceChange = parseFloat(priceChangeMatch[1]);
        } else {
          // Also support "moved 5 points" without operator
          const simplePriceChangeMatch = queryLower.match(
            /\bmoved\s+(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/
          );
          if (simplePriceChangeMatch) {
            conditions.minPriceChange = parseFloat(simplePriceChangeMatch[1]);
          }
        }

        // If we found any conditions, return them
        if (Object.keys(conditions).length > 0) {
          return { type: "query", conditions };
        }

        return null;
      }

      function applyFilters(dataObj, filters, trades = []) {
        const out = [];

        const deriveHorizonBucket = (t) => {
          const etaRaw = t?.eta_days_v2 ?? t?.eta_days;
          const eta = Number(etaRaw);
          if (!Number.isFinite(eta) || eta <= 0) return null;
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        // Opportunity classification used by Viewport + Bubble Chart filtering
        const isEligibleOpportunity = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = Number(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);

          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < 1.5) return false;
          if (Number.isFinite(completion) && completion > 0.6) return false;
          if (Number.isFinite(ret) && ret < 5) return false;
          if (Number.isFinite(risk) && risk < 0.5) return false;
          if (Number.isFinite(etaConf) && etaConf < 0.55) return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > 0.75) return false;
          if (Number.isFinite(diversity) && diversity < 25) return false;
          return true;
        };

        const guidanceCategoryForAction = (action) => {
          const a = String(action || "").toLowerCase();
          if (!a) return "OTHER";
          if (a.includes("exit") || a.includes("trim")) return "EXIT_TRIM";
          if (a.startsWith("monitor") || a.includes("monitor closely")) return "MONITOR";
          if (a.startsWith("initiate")) return "INITIATE";
          if (a.startsWith("consider")) return "CONSIDER";
          if (a.startsWith("wait")) return "WAIT";
          if (a.includes("blocked")) return "BLOCKED";
          return "OTHER";
        };

        // Create a set of tickers that have trades (normalize ticker names)
        const tickersWithTrades = new Set();
        if (Array.isArray(trades)) {
          trades.forEach((trade) => {
            if (trade && trade.ticker) {
              tickersWithTrades.add(normTicker(trade.ticker));
            }
          });
        }

        // Parse natural language query if search field looks like a query
        const queryResult = parseNaturalLanguageQuery(filters.search);
        let effectiveFilters = { ...filters };
        let multiTickerList = null;

        if (queryResult) {
          if (queryResult.type === "multi-ticker") {
            multiTickerList = queryResult.tickers;
            // Clear search filter since we're handling it manually
            effectiveFilters = { ...effectiveFilters, search: "" };
          } else if (queryResult.type === "query") {
            // Merge query conditions into filters
            effectiveFilters = {
              ...effectiveFilters,
              ...queryResult.conditions,
              search: "",
            };
          }
        }

        // Debug: Check if BMNR/BABA are in the data object at all
        if (dataObj["BMNR"] || dataObj["BABA"]) {
          console.log(`[DATA CHECK] BMNR/BABA found in dataObj:`, {
            BMNR: !!dataObj["BMNR"],
            BABA: !!dataObj["BABA"],
            BMNR_keys: dataObj["BMNR"] ? Object.keys(dataObj["BMNR"]) : [],
            BABA_keys: dataObj["BABA"] ? Object.keys(dataObj["BABA"]) : [],
            BMNR_htf: dataObj["BMNR"]?.htf_score,
            BMNR_ltf: dataObj["BMNR"]?.ltf_score,
            BABA_htf: dataObj["BABA"]?.htf_score,
            BABA_ltf: dataObj["BABA"]?.ltf_score,
          });
        } else {
          console.log(
            `[DATA CHECK] BMNR/BABA NOT found in dataObj. Total tickers: ${
              Object.keys(dataObj).length
            }`
          );
        }

        // Parse ticker filter (comma-separated ticker symbols)
        const tickerFilterSet = new Set();
        // Support tickerFilter from dedicated field OR from search query if it's a multi-ticker query
        if (
          effectiveFilters.tickerFilter &&
          typeof effectiveFilters.tickerFilter === "string"
        ) {
          effectiveFilters.tickerFilter
            .split(",")
            .map((t) => t.trim().toUpperCase())
            .filter(Boolean)
            .forEach((t) => tickerFilterSet.add(t));
        }
        // Also check if search query is a multi-ticker list
        if (queryResult && queryResult.type === "multi-ticker") {
          queryResult.tickers.forEach((t) => tickerFilterSet.add(t));
        }

        for (const [tickerRaw, d] of Object.entries(dataObj)) {
          // Skip completely empty entries, but allow entries with just ticker name
          if (!d || typeof d !== "object") continue;
          const ticker = String(tickerRaw || d.ticker || "")
            .trim()
            .toUpperCase();
          if (!ticker) continue;

          // Apply ticker filter if specified
          if (tickerFilterSet.size > 0 && !tickerFilterSet.has(ticker)) {
            continue;
          }

          // Horizon bucket filter (SHORT_TERM / SWING / POSITIONAL)
          if (
            effectiveFilters.horizonBucket &&
            typeof effectiveFilters.horizonBucket === "string"
          ) {
            const rawBucket = d?.horizon_bucket || deriveHorizonBucket(d) || "";
            const hb = String(rawBucket).trim().toUpperCase();
            if (
              hb !== String(effectiveFilters.horizonBucket).toUpperCase()
            ) {
              continue;
            }
          }

          // Debug BMNR/BABA at the very start of the loop
          if (ticker === "BMNR" || ticker === "BABA") {
            console.log(`[FILTER START] ${ticker}:`, {
              tickerRaw,
              hasData: !!d,
              dataKeys: d ? Object.keys(d) : [],
              htf_score: d?.htf_score,
              ltf_score: d?.ltf_score,
              state: d?.state,
              price: d?.price,
            });
          }

          // Show all tickers - they will be in a group (including "No Group" if unmapped)
          // S&P Sectors and Futures are always visible, and unmapped tickers go to "No Group"
          const isSPSector =
            GROUPS.SP_Sectors && GROUPS.SP_Sectors.has(normTicker(ticker));
          const isFuture =
            GROUPS.Futures && GROUPS.Futures.has(normTicker(ticker));
          const inGroups = isTickerInGroups(ticker); // Always returns true now (includes "No Group")

          // All tickers should be shown (either in a group or in "No Group")
          // This check is now redundant but kept for clarity
          if (!inGroups) {
            console.log(
              `[FILTER] ${ticker} skipped: unexpected - should be in a group`
            );
            continue;
          }

          // Include tickers even if they don't have scores yet - they'll show at center (0,0) with default values
          // This allows bubbles to appear immediately when tickers are added to watchlist
          // They'll update once TradingView sends data (within 5 minutes)
          const hasScores =
            d.htf_score !== undefined || d.ltf_score !== undefined;
          if (!hasScores) {
            // Provide default values so bubble can render
            d.htf_score = d.htf_score !== undefined ? d.htf_score : 0;
            d.ltf_score = d.ltf_score !== undefined ? d.ltf_score : 0;
            d.waitingForData = true; // Flag to indicate waiting for TradingView data
          }

          // Debug BMNR/BABA after score check
          if (ticker === "BMNR" || ticker === "BABA") {
            console.log(`[BMNR DEBUG] After score check:`, {
              ticker,
              hasScores,
              htf_score: d.htf_score,
              ltf_score: d.ltf_score,
              state: d.state,
              price: d.price,
              groups: groupsForTicker(normTicker(ticker)),
              inGroups,
            });
          }

          // Multi-ticker search
          if (multiTickerList && multiTickerList.length > 0) {
            if (!multiTickerList.includes(ticker)) continue;
          } else if (
            effectiveFilters.search &&
            !ticker.includes(effectiveFilters.search.toUpperCase())
          ) {
            // Regular search (if not multi-ticker)
            continue;
          }

          // Group filter
          if (effectiveFilters.group && effectiveFilters.group !== "ALL") {
            const T = normTicker(ticker);
            const gs = groupsForTicker(T);
            if (effectiveFilters.group === "ANY") {
              if (gs.length === 0) continue;
            } else if (effectiveFilters.group === "UNGROUPED") {
              // UNGROUPED means only in "No Group" (not in any actual group)
              const actualGroups = gs.filter((g) => g !== "No Group");
              if (actualGroups.length > 0) continue;
            } else {
              if (!gs.includes(effectiveFilters.group)) continue;
            }
          }

          // Handle Top Long Setup and Top Short Setup from natural language
          if (effectiveFilters.topLongSetup === true) {
            if (d.state !== "HTF_BULL_LTF_PULLBACK") continue;
          }
          if (effectiveFilters.topShortSetup === true) {
            if (d.state !== "HTF_BEAR_LTF_PULLBACK") continue;
          }

          if (
            effectiveFilters.quadrants &&
            !effectiveFilters.quadrants.includes(d.state)
          )
            continue;
          if (
            effectiveFilters.minRank &&
            (Number(d.rank) || 0) < effectiveFilters.minRank
          )
            continue;
          if (
            effectiveFilters.minRR &&
            (Number(d.rr) || 0) < effectiveFilters.minRR
          )
            continue;
          if (
            effectiveFilters.maxCompletion &&
            completionForSize(d) > effectiveFilters.maxCompletion
          )
            continue;
          if (effectiveFilters.inCorridor === true) {
            const ent = entryType(d);
            if (!ent.corridor) continue;
          }
          if (effectiveFilters.squeezeRelease === true) {
            const flags = d.flags || {};
            if (!flags.sq30_release) continue;
          }
          if (effectiveFilters.inSqueeze === true) {
            const flags = d.flags || {};
            // In Squeeze: sq30_on is true but sq30_release is false
            if (!flags.sq30_on || flags.sq30_release) continue;
          }
          if (effectiveFilters.momentumElite === true) {
            const flags = d.flags || {};
            if (!flags.momentum_elite) continue;
          }
          if (effectiveFilters.prime === true) {
            if (!isPrimeBubble(d)) continue;
          }

          // Opportunities filter (Viewport row 3)
          if (
            effectiveFilters.opportunities &&
            typeof effectiveFilters.opportunities === "string"
          ) {
            const mode = String(effectiveFilters.opportunities).toUpperCase();
            const prime = isPrimeBubble(d);
            const eligible = isEligibleOpportunity(d);
            if (mode === "PRIME") {
              if (!prime) continue;
            } else if (mode === "ELIGIBLE") {
              if (!eligible) continue;
            } else if (mode === "WATCH") {
              if (prime || eligible) continue;
            }
          }

          // Guidance filter (based on natural-language decision)
          if (
            effectiveFilters.guidanceCategory &&
            typeof effectiveFilters.guidanceCategory === "string"
          ) {
            const actionInfo = getActionDescription(d);
            const cat = guidanceCategoryForAction(actionInfo?.action);
            const want = String(effectiveFilters.guidanceCategory).toUpperCase();
            if (cat !== want) continue;
          }
          if (effectiveFilters.minPriceChange !== undefined) {
            // Calculate price change from trigger price to current price
            const currentPrice = Number(d.price) || 0;
            const triggerPrice = Number(d.trigger_price) || 0;
            if (triggerPrice > 0) {
              const priceChange = Math.abs(currentPrice - triggerPrice);
              if (priceChange < effectiveFilters.minPriceChange) continue;
            } else {
              // No trigger price, skip this filter
              continue;
            }
          }
          if (effectiveFilters.minPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase < effectiveFilters.minPhase) continue;
          }
          if (effectiveFilters.maxPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase > effectiveFilters.maxPhase) continue;
          }

          // Trades filter - only show tickers that have trades
          if (effectiveFilters.hasTrades === true) {
            if (!tickersWithTrades.has(normTicker(ticker))) continue;
          }

          // Sector filter - only show tickers in the selected sector
          if (effectiveFilters.sector) {
            // PRIORITIZE SECTOR_MAP lookup over TradingView sector data
            // TradingView uses industry classifications (e.g., "Electronic Technology", "Retail Trade")
            // but we use GICS sectors (e.g., "Information Technology", "Consumer Discretionary")
            // So we always check SECTOR_MAP first, then fall back to TradingView data
            const tickerSector =
              getTickerSector(ticker) ||
              d.sector ||
              d.fundamentals?.sector ||
              "";
            // Normalize both for case-insensitive comparison
            const normalizedTickerSector = String(tickerSector).trim();
            const normalizedFilterSector = String(
              effectiveFilters.sector
            ).trim();
            const matches =
              normalizedTickerSector.toLowerCase() ===
              normalizedFilterSector.toLowerCase();

            // Debug logging for first few tickers when sector filter is active
            if (out.length < 3 && normalizedTickerSector) {
              console.log(
                `[SECTOR FILTER] ${ticker}: tickerSector="${normalizedTickerSector}", filterSector="${normalizedFilterSector}", matches=${matches}, fromMap=${!!getTickerSector(
                  ticker
                )}`
              );
            }

            if (!matches) {
              continue;
            }
          }

          // TD9 Setup filter - only show tickers with TD9 signals
          if (effectiveFilters.td9Setup === "any") {
            const tdSeq = d.td_sequential || {};
            const hasTD9Bullish =
              tdSeq.td9_bullish === true || tdSeq.td9_bullish === "true";
            const hasTD9Bearish =
              tdSeq.td9_bearish === true || tdSeq.td9_bearish === "true";
            if (!hasTD9Bullish && !hasTD9Bearish) continue;
          }

          out.push({ ticker, ...d });
        }

        // Apply Ranked filter if active (using worker's rank field)
        // Shows ALL tickers sorted by rank (1 to whatever), not just top 40
        if (effectiveFilters.top40 === true) {
          // Get ALL tickers from dataObj (not filtered 'out' array)
          const allTickersWithRank = Object.values(dataObj).filter(
            (t) =>
              t &&
              typeof t === "object" &&
              t.ticker &&
              t.rank !== undefined &&
              t.rank !== null
          );

          // Sort by dynamicScore from API (backend calculation) - pure score sorting, no alphabetical tiebreaker
          allTickersWithRank.sort((a, b) => {
            const scoreA = Number(a.dynamicScore || a.rank) || 0; // Use dynamicScore from API, fallback to rank
            const scoreB = Number(b.dynamicScore || b.rank) || 0;
            // Descending order: higher score = better position
            return scoreB - scoreA;
          });

          // Get all ticker symbols sorted by rank (normalize to uppercase for comparison)
          const rankedTickers = new Set(
            allTickersWithRank.map((t) =>
              String(t.ticker || "")
                .trim()
                .toUpperCase()
            )
          );

          // Filter 'out' to only include tickers that have ranks, maintaining rank order
          return out
            .filter((t) => {
              const tickerUpper = String(t.ticker || "")
                .trim()
                .toUpperCase();
              return rankedTickers.has(tickerUpper);
            })
            .sort((a, b) => {
              // Re-sort filtered results by rank to maintain order
              const rankA = Number(a.rank) || 0;
              const rankB = Number(b.rank) || 0;
              return rankB - rankA;
            });
        }

        return out;
      }

      // ─────────────────────────────────────────────────────────────
      // Components
      // ─────────────────────────────────────────────────────────────
      // Native SVG Bubble component (works without Recharts)
      const SVGBubble = memo(
        ({
          ticker,
          onClick,
          onHover,
          isHovered,
          scaleX,
          scaleY,
          offsetX,
          offsetY,
          showLabels,
          isTopRanked = false,
        }) => {
          // CRITICAL DEBUG: Log EVERY bubble call immediately
          if (!window._svgBubbleCallCount) {
            window._svgBubbleCallCount = 0;
          }
          window._svgBubbleCallCount++;

          // Always log first 10 to see what's happening
          if (window._svgBubbleCallCount <= 10) {
            console.log(
              `[SVGBUBBLE CALLED] #${window._svgBubbleCallCount} - ${
                ticker?.ticker || "NO TICKER"
              }`,
              {
                ticker: ticker?.ticker,
                hasTicker: !!ticker,
                tickerKeys: ticker ? Object.keys(ticker).slice(0, 20) : [],
                hasPhasePct: ticker ? "phase_pct" in ticker : false,
                phasePct: ticker ? ticker.phase_pct : undefined,
              }
            );
          }

          // CRITICAL: If no ticker, return null immediately
          if (!ticker || !ticker.ticker) {
            console.error(`[SVGBUBBLE ERROR] No ticker provided!`, { ticker });
            return null;
          }

          // Ensure we have valid numeric values - check for null/undefined explicitly
          // Try multiple property names in case data structure varies
          const comp =
            ticker.completion != null
              ? Number(ticker.completion)
              : ticker.completion_pct != null
              ? Number(ticker.completion_pct)
              : 0;
          const phasePct =
            ticker.phase_pct != null
              ? Number(ticker.phase_pct)
              : ticker.phase != null
              ? Number(ticker.phase)
              : 0;
          const rr =
            ticker.rr != null
              ? Number(ticker.rr)
              : ticker.risk_reward != null
              ? Number(ticker.risk_reward)
              : 0;
          const waitingForData = ticker.waitingForData === true;

          // Validate values are finite numbers and clamp to valid ranges
          const validComp = Number.isFinite(comp)
            ? Math.max(0, Math.min(1, comp))
            : 0;

          // If phase_pct is missing, try to estimate from completion or use a default based on state
          let validPhasePct = Number.isFinite(phasePct)
            ? Math.max(0, Math.min(1, phasePct))
            : null;

          // Fallback: if phase_pct is missing, use completion as proxy or estimate from state
          if (validPhasePct === null) {
            if (validComp > 0) {
              validPhasePct = validComp; // Use completion as phase estimate
            } else if (ticker.state) {
              // Estimate phase based on state (early states = lower phase)
              const state = String(ticker.state).toUpperCase();
              if (state.includes("PREP") || state.includes("PULLBACK")) {
                validPhasePct = 0.2; // Early phase
              } else if (state.includes("BULL") || state.includes("BEAR")) {
                validPhasePct = 0.5; // Mid phase
              } else {
                validPhasePct = 0.1; // Default to early phase
              }
            } else {
              validPhasePct = 0.1; // Default to early phase (green)
            }
          }

          // Default RR to a small value if missing to ensure size variation
          // Use dynamicRank or rank as fallback for size if RR is missing
          const fallbackRR = ticker.dynamicRank
            ? Math.max(0.5, Math.min(5, (Number(ticker.dynamicRank) || 0) / 50))
            : ticker.rank
            ? Math.max(0.5, Math.min(5, (Number(ticker.rank) || 0) / 50))
            : 0.5;
          const validRR = Number.isFinite(rr) && rr > 0 ? rr : fallbackRR;

          // Bubble size based on RR, adjusted for completion (lower completion = larger size)
          // RR is the opportunity, but we want to reduce size as completion increases
          // Formula: baseSize + (RR * multiplier) * (1 - completion)
          // This makes high RR + low completion = largest bubbles
          // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
          const cappedRR = Math.min(validRR, 5); // Cap RR at 5 for size calculation
          const completionPenalty = 1 - validComp; // 1.0 when completion is 0, 0.0 when completion is 1
          const baseSize = 4; // Further reduced for less overlap
          const rrMultiplier = 2; // Further reduced for smaller bubbles
          // Smaller size for tickers waiting for data
          const size = waitingForData
            ? baseSize * 0.7
            : baseSize + cappedRR * rrMultiplier * completionPenalty;

          // Force minimum size variation - if all sizes are the same, add variation based on ticker
          // Use multiple factors for better variation
          const tickerHash = (ticker.ticker || "")
            .split("")
            .reduce((acc, char) => acc + char.charCodeAt(0), 0);
          const sizeVariation = (tickerHash % 5) * 0.8; // Add 0-3.2px variation based on ticker name
          const finalSize = Math.max(baseSize, size + sizeVariation); // Add variation, ensure minimum baseSize

          const prime = isPrimeBubble(ticker);
          const flags = ticker.flags || {};
          const ent = entryType(ticker);

          // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
          // Use gray for tickers waiting for data
          // SIMPLIFIED: Direct calculation to ensure it always works
          let color;

          // DEBUG: Log phase calculation for first few bubbles
          if (window._svgBubbleCallCount <= 5) {
            console.log(`[BUBBLE COLOR CALC] ${ticker.ticker}:`, {
              waitingForData,
              validPhasePct,
              phasePct,
              rawPhasePct: ticker.phase_pct,
              hasPhasePct: "phase_pct" in ticker,
            });
          }

          if (waitingForData) {
            color = "#6b7a9f"; // Gray for waiting
          } else {
            // Direct color calculation based on phase percentage
            // Ensure validPhasePct is a number
            const p = Number.isFinite(validPhasePct)
              ? Math.max(0, Math.min(1, validPhasePct))
              : 0.1; // Default to 0.1 (green) if invalid

            if (p < 0.3) {
              color = "#2ecc71"; // Green: under 30%
            } else if (p < 0.6) {
              color = "#f39c12"; // Yellow: 30-60%
            } else {
              color = "#e74c3c"; // Red: 60-100%
            }
          }

          // Final safety: ensure color is always valid
          if (!color || typeof color !== "string" || !color.startsWith("#")) {
            console.warn(
              `[BUBBLE COLOR] Invalid color for ${ticker.ticker}, using green fallback:`,
              color
            );
            color = "#2ecc71"; // Green fallback
          }

          // Ensure opacity is high enough to be visible (minimum 0.6)
          const opacity = waitingForData
            ? 0.6
            : isHovered
            ? 1
            : prime
            ? 0.95
            : 0.85; // Increased from 0.7 to 0.85 for better visibility

          const borderWidth = waitingForData
            ? 2
            : prime
            ? 3
            : flags.sq30_release
            ? 2
            : flags.sq30_on
            ? 2
            : 1.5; // Increased from 1 to 1.5 for better visibility

          const borderColor = waitingForData
            ? "#93a4d6"
            : prime
            ? "#2ecc71"
            : flags.sq30_release
            ? "#00ffff"
            : flags.sq30_on
            ? "#ffd700"
            : "#ffffff";

          const bubbleSize = isHovered ? finalSize * 1.2 : finalSize;

          // Debug logging for first few tickers to verify calculations
          const shouldLog =
            ticker.ticker === "AAPL" ||
            ticker.ticker === "QQQ" ||
            ticker.ticker === "NVDA" ||
            ticker.ticker === "ITT" ||
            ticker.ticker === "GOOGL" ||
            ticker.ticker === "MSFT";

          if (shouldLog) {
            console.log(`[BUBBLE DEBUG] ${ticker.ticker}:`, {
              size: size.toFixed(2),
              finalSize: finalSize.toFixed(2),
              bubbleSize: bubbleSize.toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              validRR: validRR.toFixed(2),
              validComp: validComp.toFixed(2),
              validPhasePct: validPhasePct.toFixed(2),
              rawRR: rr,
              rawComp: comp,
              rawPhasePct: phasePct,
              prime,
              flags,
              hasColor: !!color && color !== "#ffffff",
              hasSize: size > 0,
              tickerKeys: Object.keys(ticker).slice(0, 15),
            });
          }

          // ALWAYS log first bubble to ensure code is running
          if (!window._bubbleDebugLogged) {
            window._bubbleDebugLogged = true;
            console.log(`[BUBBLE DEBUG] FIRST BUBBLE: ${ticker.ticker}`, {
              size: size.toFixed(2),
              finalSize: finalSize.toFixed(2),
              bubbleSize: bubbleSize.toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              validRR,
              validComp,
              validPhasePct,
              rawRR: rr,
              rawComp: comp,
              rawPhasePct: phasePct,
              tickerKeys: Object.keys(ticker),
              ticker: ticker,
            });
          }

          // Log first 10 bubbles to verify styling is applied
          if (window._svgBubbleCallCount <= 10) {
            console.log(`[BUBBLE STYLE] ${ticker.ticker}:`, {
              color,
              colorType: typeof color,
              colorLength: color ? color.length : 0,
              size: bubbleSize.toFixed(2),
              phasePct: validPhasePct,
              rr: validRR,
              completion: validComp,
              rawPhasePct: phasePct,
              rawRR: rr,
              rawComp: comp,
              opacity,
              borderColor,
              borderWidth,
              tickerKeys: Object.keys(ticker).slice(0, 20),
              hasPhasePct: "phase_pct" in ticker,
              hasRR: "rr" in ticker,
              hasCompletion: "completion" in ticker,
            });
          }

          // Calculate position correctly:
          // BubbleChart passes pre-adjusted offsets:
          // - offsetX already includes +50*scaleX (centers at x=0)
          // - offsetY already includes plotHeight - 50*scaleY (centers at y=0)
          // - scaleY is negative for y-axis inversion
          // So we just multiply scores by scales and add offsets
          const ltfScore = Number(ticker.ltf_score) || 0;
          const htfScore = Number(ticker.htf_score) || 0;

          // X: LTF score * scaleX + offsetX (offsetX already centered)
          const x = ltfScore * scaleX + offsetX;

          // Y: HTF score * scaleY + offsetY (scaleY is negative, offsetY already centered)
          const y = htfScore * scaleY + offsetY;

          // Determine emoji and label position
          const hasSqueeze = flags.sq30_release || flags.sq30_on;
          // #1 Ranked gets priority emoji (huge!)
          const emoji = isTopRanked
            ? "👑"
            : waitingForData
            ? "⏳"
            : prime
            ? "⭐"
            : flags.sq30_release
            ? "⚡"
            : flags.sq30_on
            ? "🧨"
            : "";
          // For #1 ranked, position emoji higher (reduced from 50 to 20 for smaller crown)
          const labelY = y - bubbleSize - (emoji ? (isTopRanked ? 20 : 12) : 8);

          // FINAL SAFETY CHECK - ensure all values are valid before rendering
          // CRITICAL: Double-check color is valid before using
          const finalColor =
            color && typeof color === "string" && color.startsWith("#")
              ? color
              : "#2ecc71"; // Force green if invalid

          const finalOpacity =
            typeof opacity === "number" && opacity >= 0 && opacity <= 1
              ? opacity
              : 0.85;
          const renderedSize = Math.max(3, Math.min(50, bubbleSize)); // Clamp size between 3 and 50
          const finalBorderColor =
            borderColor && typeof borderColor === "string"
              ? borderColor
              : "#ffffff";
          const finalBorderWidth =
            typeof borderWidth === "number" && borderWidth > 0
              ? borderWidth
              : 1.5;
          const decisionSummary = summarizeEntryDecision(ticker);
          const decisionTooltip = decisionSummary
            ? `System ${decisionSummary.status}: ${decisionSummary.detail}`
            : null;

          // Log first 5 bubbles to verify styling
          if (window._svgBubbleCallCount <= 5) {
            console.log(`[BUBBLE STYLE] ${ticker.ticker}:`, {
              originalColor: color,
              finalColor: finalColor,
              size: renderedSize,
              phasePct: validPhasePct,
              opacity: finalOpacity,
              borderColor: finalBorderColor,
              willRender: true,
            });
          }

          return (
            <g
              onClick={() => onClick(ticker.ticker)}
              onMouseEnter={() => onHover(ticker.ticker)}
              onMouseLeave={() => onHover(null)}
              onTouchStart={(e) => {
                e.preventDefault();
                onHover(ticker.ticker);
                onClick(ticker.ticker);
              }}
              onTouchEnd={(e) => {
                e.preventDefault();
                onHover(null);
              }}
              style={{
                cursor: "pointer",
                transition: "all 0.2s ease-out",
                touchAction: "manipulation",
              }}
            >
              {decisionTooltip && <title>{decisionTooltip}</title>}
              {/* Glow effect for prime */}
              {prime && (
                <circle
                  cx={x}
                  cy={y}
                  r={renderedSize + 2}
                  fill="none"
                  stroke="#2ecc71"
                  strokeWidth="1"
                  opacity="0.3"
                />
              )}
              <circle
                cx={x}
                cy={y}
                r={renderedSize}
                fill={finalColor}
                fillOpacity={finalOpacity}
                stroke={finalBorderColor}
                strokeWidth={finalBorderWidth}
              />
              {/* Emoji above bubble - #1 ranked gets special treatment */}
              {emoji && (
                <g style={{ pointerEvents: "none" }}>
                  {/* Background circle for #1 ranked - reduced size */}
                  {isTopRanked && (
                    <circle
                      cx={x}
                      cy={labelY - 5}
                      r="18"
                      fill="#ffd700"
                      fillOpacity="0.3"
                    >
                      <animate
                        attributeName="fillOpacity"
                        values="0.2;0.5;0.2"
                        dur="1.5s"
                        repeatCount="indefinite"
                      />
                    </circle>
                  )}
                  {/* Outer glow ring for #1 - reduced size */}
                  {isTopRanked && (
                    <>
                      <circle
                        cx={x}
                        cy={labelY - 5}
                        r="22"
                        fill="none"
                        stroke="#ffd700"
                        strokeWidth="2"
                        opacity="0.6"
                      >
                        <animate
                          attributeName="r"
                          values="20;24;20"
                          dur="2s"
                          repeatCount="indefinite"
                        />
                        <animate
                          attributeName="opacity"
                          values="0.4;0.8;0.4"
                          dur="2s"
                          repeatCount="indefinite"
                        />
                      </circle>
                    </>
                  )}
                  {/* Main emoji text */}
                  <text
                    x={x}
                    y={labelY}
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fontSize={
                      isTopRanked
                        ? "24"
                        : waitingForData
                        ? "10"
                        : prime
                        ? "14"
                        : "12"
                    }
                    fill={
                      isTopRanked
                        ? "#ffd700"
                        : waitingForData
                        ? "#93a4d6"
                        : prime
                        ? "#2ecc71"
                        : flags.sq30_release
                        ? "#00ffff"
                        : "#ffd700"
                    }
                    fontWeight="bold"
                    style={{
                      textShadow: isTopRanked
                        ? "0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.6)"
                        : "0 0 3px rgba(0,0,0,0.8)",
                      filter: isTopRanked
                        ? "drop-shadow(0 0 15px rgba(255, 215, 0, 1)) drop-shadow(0 0 30px rgba(255, 215, 0, 0.9)) drop-shadow(0 0 45px rgba(255, 215, 0, 0.7))"
                        : "none",
                      pointerEvents: "none",
                    }}
                  >
                    {emoji}
                  </text>
                  {/* Additional sparkle effects for #1 - reduced size */}
                  {isTopRanked && (
                    <>
                      <text
                        x={x - 15}
                        y={labelY - 10}
                        textAnchor="middle"
                        dominantBaseline="middle"
                        fontSize="12"
                        fill="#ffd700"
                        opacity="0.9"
                        style={{ pointerEvents: "none" }}
                      >
                        ✨
                      </text>
                      <text
                        x={x + 15}
                        y={labelY - 10}
                        textAnchor="middle"
                        dominantBaseline="middle"
                        fontSize="12"
                        fill="#ffd700"
                        opacity="0.9"
                        style={{ pointerEvents: "none" }}
                      >
                        ✨
                      </text>
                    </>
                  )}
                </g>
              )}
              {/* Additional glow effect for #1 ranked - reduced size */}
              {isTopRanked && (
                <>
                  <circle
                    cx={x}
                    cy={y}
                    r={bubbleSize + 4}
                    fill="none"
                    stroke="#ffd700"
                    strokeWidth="2"
                    opacity="0.6"
                  >
                    <animate
                      attributeName="opacity"
                      values="0.3;0.9;0.3"
                      dur="2s"
                      repeatCount="indefinite"
                    />
                    <animate
                      attributeName="r"
                      values={`${bubbleSize + 3};${bubbleSize + 6};${
                        bubbleSize + 3
                      }`}
                      dur="2s"
                      repeatCount="indefinite"
                    />
                  </circle>
                  {/* Outer glow ring */}
                  <circle
                    cx={x}
                    cy={y}
                    r={bubbleSize + 6}
                    fill="none"
                    stroke="#ffd700"
                    strokeWidth="1.5"
                    opacity="0.3"
                  >
                    <animate
                      attributeName="opacity"
                      values="0.1;0.5;0.1"
                      dur="2s"
                      repeatCount="indefinite"
                    />
                  </circle>
                </>
              )}
              {/* Ticker label */}
              {(showLabels || isHovered) && (
                <text
                  x={x}
                  y={labelY - (emoji ? 14 : 8)}
                  textAnchor="middle"
                  fontSize="10"
                  fill={waitingForData ? "#93a4d6" : "#e7ecff"}
                  fontWeight="600"
                  style={{
                    textShadow: "0 0 4px rgba(0,0,0,0.9)",
                    pointerEvents: "none",
                  }}
                >
                  {ticker.ticker}
                </text>
              )}
            </g>
          );
        }
      );

      const Bubble = memo(
        ({ ticker, onClick, onHover, isHovered, showLabels }) => {
          // DEBUG: Log Recharts Bubble component calls
          if (!window._rechartsBubbleCallCount) {
            window._rechartsBubbleCallCount = 0;
          }
          window._rechartsBubbleCallCount++;
          if (window._rechartsBubbleCallCount <= 5) {
            console.log(
              `[RECHARTS BUBBLE CALLED] #${window._rechartsBubbleCallCount} - ${
                ticker?.ticker || "NO TICKER"
              }`,
              {
                ticker: ticker,
                hasTicker: !!ticker,
                tickerKeys: ticker ? Object.keys(ticker) : [],
              }
            );
          }

          // Ensure we have valid numeric values - check for null/undefined explicitly
          const comp =
            ticker.completion != null ? Number(ticker.completion) : 0;
          const phasePct =
            ticker.phase_pct != null ? Number(ticker.phase_pct) : 0;
          const rr = ticker.rr != null ? Number(ticker.rr) : 0;
          const waitingForData = ticker.waitingForData === true;

          // Validate values are finite numbers and clamp to valid ranges
          const validComp = Number.isFinite(comp)
            ? Math.max(0, Math.min(1, comp))
            : 0;
          const validPhasePct = Number.isFinite(phasePct)
            ? Math.max(0, Math.min(1, phasePct))
            : 0;
          const validRR = Number.isFinite(rr) && rr > 0 ? rr : 0;

          // Bubble size based on RR, adjusted for completion (lower completion = larger size)
          // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
          const cappedRR = Math.min(validRR, 5); // Cap RR at 5 for size calculation
          const completionPenalty = 1 - validComp; // 1.0 when completion is 0, 0.0 when completion is 1
          const baseSize = 8;
          const rrMultiplier = 6; // Scale factor for RR
          // Smaller size for tickers waiting for data
          const size = waitingForData
            ? baseSize * 0.7
            : baseSize + cappedRR * rrMultiplier * completionPenalty;

          // Force minimum size variation - if all sizes are the same, add variation based on ticker
          const sizeVariation = (ticker.ticker?.charCodeAt(0) || 0) % 3; // Add small variation based on ticker name
          const finalSize = Math.max(baseSize, size + sizeVariation * 0.5); // Add 0-1px variation, ensure minimum baseSize

          const prime = isPrimeBubble(ticker);
          const flags = ticker.flags || {};

          // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
          // Use gray for tickers waiting for data
          // SIMPLIFIED: Direct calculation to ensure it always works
          let color;
          if (waitingForData) {
            color = "#6b7a9f"; // Gray for waiting
          } else {
            // Direct color calculation based on phase percentage
            // Ensure validPhasePct is a number
            const p = Number.isFinite(validPhasePct)
              ? Math.max(0, Math.min(1, validPhasePct))
              : 0.1; // Default to 0.1 (green) if invalid

            if (p < 0.3) {
              color = "#2ecc71"; // Green: under 30%
            } else if (p < 0.6) {
              color = "#f39c12"; // Yellow: 30-60%
            } else {
              color = "#e74c3c"; // Red: 60-100%
            }
          }

          // Final safety: ensure color is always valid
          if (!color || typeof color !== "string" || !color.startsWith("#")) {
            color = "#2ecc71"; // Green fallback
          }

          // Ensure opacity is high enough to be visible (minimum 0.6)
          const opacity = waitingForData
            ? 0.6
            : isHovered
            ? 1
            : prime
            ? 0.95
            : 0.85; // Increased from 0.7 to 0.85 for better visibility

          const borderWidth = waitingForData
            ? 2
            : prime
            ? 3
            : flags.sq30_release
            ? 2
            : flags.sq30_on
            ? 2
            : 1.5; // Increased from 1 to 1.5 for better visibility

          const borderColor = waitingForData
            ? "#93a4d6"
            : prime
            ? "#2ecc71"
            : flags.sq30_release
            ? "#00ffff"
            : flags.sq30_on
            ? "#ffd700"
            : "#ffffff";

          // Debug logging for first few tickers to verify calculations
          if (
            ticker.ticker === "AAPL" ||
            ticker.ticker === "QQQ" ||
            ticker.ticker === "NVDA"
          ) {
            console.log(`[BUBBLE DEBUG] ${ticker.ticker}:`, {
              size: size.toFixed(2),
              bubbleSize: (isHovered ? size * 1.2 : size).toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              rr: rr.toFixed(2),
              comp: comp.toFixed(2),
              phasePct: phasePct.toFixed(2),
              prime,
              flags,
            });
          }

          const bubbleSize = isHovered ? finalSize * 1.2 : finalSize;

          // Debug logging for first few tickers
          const shouldLog =
            ticker.ticker === "AAPL" ||
            ticker.ticker === "QQQ" ||
            ticker.ticker === "NVDA" ||
            ticker.ticker === "ITT" ||
            ticker.ticker === "GOOGL" ||
            ticker.ticker === "MSFT";

          if (shouldLog) {
            console.log(`[RECHARTS BUBBLE DEBUG] ${ticker.ticker}:`, {
              size: size.toFixed(2),
              finalSize: finalSize.toFixed(2),
              bubbleSize: bubbleSize.toFixed(2),
              color,
              opacity,
              borderColor,
              borderWidth,
              validRR: validRR.toFixed(2),
              validComp: validComp.toFixed(2),
              validPhasePct: validPhasePct.toFixed(2),
              rawRR: rr,
              rawComp: comp,
              rawPhasePct: phasePct,
              prime,
              flags,
            });
          }

          // ALWAYS log first bubble to ensure code is running
          if (!window._rechartsBubbleDebugLogged) {
            window._rechartsBubbleDebugLogged = true;
            console.log(
              `[RECHARTS BUBBLE DEBUG] FIRST BUBBLE: ${ticker.ticker}`,
              {
                size: size.toFixed(2),
                finalSize: finalSize.toFixed(2),
                bubbleSize: bubbleSize.toFixed(2),
                color,
                opacity,
                borderColor,
                borderWidth,
                validRR,
                validComp,
                validPhasePct,
                ticker: ticker,
              }
            );
          }

          const x = Number(ticker.ltf_score) || 0;
          const y = Number(ticker.htf_score) || 0;

          // Determine emoji and label position
          const hasSqueeze = flags.sq30_release || flags.sq30_on;
          const emoji = prime
            ? "⭐"
            : flags.sq30_release
            ? "⚡"
            : flags.sq30_on
            ? "🧨"
            : "";
          const labelY = y - bubbleSize - (emoji ? 12 : 8);

          return (
            <g
              onClick={() => onClick(ticker.ticker)}
              onMouseEnter={() => onHover(ticker.ticker)}
              onMouseLeave={() => onHover(null)}
              onTouchStart={(e) => {
                e.preventDefault();
                onHover(ticker.ticker);
                onClick(ticker.ticker);
              }}
              onTouchEnd={(e) => {
                e.preventDefault();
                onHover(null);
              }}
              style={{
                cursor: "pointer",
                transition: "all 0.2s ease-out",
                touchAction: "manipulation",
              }}
            >
              {/* Glow effect for prime */}
              {prime && (
                <circle
                  cx={x}
                  cy={y}
                  r={bubbleSize + 2}
                  fill="none"
                  stroke="#2ecc71"
                  strokeWidth="1"
                  opacity="0.3"
                />
              )}
              <circle
                cx={x}
                cy={y}
                r={Math.max(3, bubbleSize)}
                fill={color}
                fillOpacity={opacity}
                stroke={borderColor}
                strokeWidth={borderWidth}
              />
              {/* Emoji above bubble */}
              {emoji && (
                <text
                  x={x}
                  y={labelY}
                  textAnchor="middle"
                  fontSize={prime ? "14" : "12"}
                  fill={
                    prime
                      ? "#2ecc71"
                      : flags.sq30_release
                      ? "#00ffff"
                      : "#ffd700"
                  }
                  fontWeight="bold"
                  style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
                >
                  {emoji}
                </text>
              )}
              {/* Ticker label */}
              {(showLabels || isHovered) && (
                <text
                  x={x}
                  y={labelY - (emoji ? 14 : 8)}
                  textAnchor="middle"
                  fontSize="10"
                  fill="#e7ecff"
                  fontWeight="600"
                  style={{
                    textShadow: "0 0 4px rgba(0,0,0,0.9)",
                    pointerEvents: "none",
                  }}
                >
                  {ticker.ticker}
                </text>
              )}
            </g>
          );
        }
      );

      // Hook to fetch trail data for all tickers
      // NOTE: This is intentionally "best effort" and must not hammer the API.
      function useAllTrails(tickers, enabled = true) {
        const [allTrails, setAllTrails] = useState({});
        const [loadingTrails, setLoadingTrails] = useState(false);
        const trailsFetchedRef = React.useRef(new Set());
        const trailsAttemptedAtRef = React.useRef(new Map()); // ticker -> lastAttemptMs

        React.useEffect(() => {
          // If disabled (e.g., a ticker is selected), do NOT continue background trail fetching.
          // This avoids starving the selected ticker's own /trail request and prevents 429 loops.
          if (!enabled) {
            setLoadingTrails(false);
            return;
          }

          if (!tickers || tickers.length === 0) {
            setAllTrails({});
            return;
          }

          // Only fetch trails for tickers we haven't fetched yet
          const tickersToFetch = tickers
            .map((t) => String(t?.ticker || "").toUpperCase())
            .filter((t) => {
              if (!t) return false;
              if (trailsFetchedRef.current.has(t)) return false;
              // Cooldown for failed attempts (especially 429)
              const lastAttempt = trailsAttemptedAtRef.current.get(t) || 0;
              const cooldownMs = 60_000; // 60s cooldown between attempts
              if (Date.now() - lastAttempt < cooldownMs) return false;
              return true;
            });

          if (tickersToFetch.length === 0) return;

          // Limit concurrent fetches to avoid overwhelming the API
          // Reduced batch size to avoid rate limiting and server errors
          const MAX_CONCURRENT = 5;
          const batches = [];
          for (let i = 0; i < tickersToFetch.length; i += MAX_CONCURRENT) {
            batches.push(tickersToFetch.slice(i, i + MAX_CONCURRENT));
          }

          setLoadingTrails(true);

          const fetchBatch = async (batch) => {
            const promises = batch.map(async (ticker) => {
              trailsAttemptedAtRef.current.set(ticker, Date.now());
              // Retry logic with exponential backoff
              let lastError = null;
              for (let attempt = 0; attempt < 3; attempt++) {
                try {
                  const res = await fetch(
                    `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                      ticker
                    )}`,
                    {
                      signal: AbortSignal.timeout(5000), // 5 second timeout
                    }
                  );

                  if (res.ok) {
                    const json = await res.json();
                    if (
                      json.ok &&
                      Array.isArray(json.trail) &&
                      json.trail.length > 0
                    ) {
                      return {
                        ticker,
                        trail: normalizeTrailPoints(json.trail),
                      };
                    }
                    // If ok but empty trail, return empty (not an error)
                    return { ticker, trail: [] };
                  } else if (res.status === 429) {
                    // Rate limited - wait longer before retry
                    await new Promise((resolve) =>
                      setTimeout(resolve, 1000 * (attempt + 1))
                    );
                    continue;
                  } else if (res.status >= 500) {
                    // Server error - retry with backoff
                    if (attempt < 2) {
                      await new Promise((resolve) =>
                        setTimeout(resolve, 500 * Math.pow(2, attempt))
                      );
                      continue;
                    }
                  }
                  // For other errors (400, 404, etc.), don't retry
                  return { ticker, trail: [] };
                } catch (err) {
                  lastError = err;
                  // Only retry on network errors or timeouts, not on abort
                  if (
                    err.name !== "AbortError" &&
                    err.name !== "TimeoutError" &&
                    attempt < 2
                  ) {
                    await new Promise((resolve) =>
                      setTimeout(resolve, 500 * Math.pow(2, attempt))
                    );
                    continue;
                  }
                  // If it's an abort/timeout or last attempt, return empty
                  if (attempt === 2 || err.name === "AbortError") {
                    break;
                  }
                }
              }
              // If we get here, all retries failed
              if (lastError && lastError.name !== "AbortError") {
                // Only log if it's not a timeout/abort (those are expected)
                console.warn(
                  `Failed to fetch trail for ${ticker} after 3 attempts:`,
                  lastError.message
                );
              }
              return { ticker, trail: [] };
            });

            const results = await Promise.all(promises);
            return results;
          };

          // Fetch all batches sequentially to avoid overwhelming the API
          const fetchAllBatches = async () => {
            const allResults = [];
            for (const batch of batches) {
              const results = await fetchBatch(batch);
              allResults.push(...results);

              // Update state incrementally for better UX
              setAllTrails((prev) => {
                const updated = { ...prev };
                results.forEach(({ ticker, trail }) => {
                  // IMPORTANT: Mark as fetched on ANY successful fetch attempt result (even empty)
                  // so we don't hammer the API in a tight loop when trails are missing or rate-limited.
                  trailsFetchedRef.current.add(ticker);
                  updated[ticker] = Array.isArray(trail) ? trail : [];

                  // Debug: Log when trails are loaded (or confirmed empty) for a small sample
                  if (
                    Object.keys(updated).length <= 10 ||
                    ticker === "AAPL" ||
                    ticker === "MSFT"
                  ) {
                    console.log(
                      `[TRAILS] Loaded ${
                        Array.isArray(trail) ? trail.length : 0
                      } points for ${ticker}`
                    );
                  }
                });
                return updated;
              });

              // Longer delay between batches to avoid overwhelming the API
              await new Promise((resolve) => setTimeout(resolve, 500));
            }
            setLoadingTrails(false);
          };

          fetchAllBatches();
        }, [tickers, enabled]);

        return { allTrails, loadingTrails };
      }

      function BubbleChart({
        tickers,
        onBubbleClick,
        hoveredTicker,
        onHover,
        selectedTicker,
        selectedTrail,
        highlightTrailPoint = null,
        allData,
        rankedTickers,
        rankedTickerPositions,
      }) {
        // Debug: Log props received
        React.useEffect(() => {
          console.log(`[BUBBLE CHART] Props received:`, {
            selectedTicker,
            hasSelectedTrail: !!selectedTrail,
            selectedTrailLength: Array.isArray(selectedTrail)
              ? selectedTrail.length
              : 0,
            tickersCount: tickers ? tickers.length : 0,
          });
        }, [selectedTicker, selectedTrail, tickers]);

        // Filter tickers to only show selected one if a ticker is selected
        const displayTickers = React.useMemo(() => {
          console.log(
            `[DISPLAY TICKERS] Computing with selectedTicker:`,
            selectedTicker,
            {
              hasSelectedTicker: !!selectedTicker,
              tickersCount: tickers ? tickers.length : 0,
            }
          );
          if (selectedTicker) {
            // Only show the selected ticker
            const filtered = tickers.filter((t) => {
              if (!t || typeof t !== "object") return false;
              const tTicker = String(t.ticker || "").toUpperCase();
              return tTicker === String(selectedTicker).toUpperCase();
            });
            console.log(
              `[BUBBLE FILTER] selectedTicker=${selectedTicker}, filtered from ${tickers.length} to ${filtered.length} tickers`,
              { filteredTickers: filtered.map((t) => t.ticker) }
            );
            return filtered;
          }
          // Show all tickers when nothing is selected
          console.log(
            `[BUBBLE FILTER] No selectedTicker, showing all ${tickers.length} tickers`
          );
          return tickers;
        }, [tickers, selectedTicker]);

        // Time Travel mode is snapshot-only: BubbleChart does NOT render trails for all bubbles.
        // The only trail we render is `selectedTrail` (Selected Ticker mode).
        // Debug: Log what BubbleChart receives
        React.useEffect(() => {
          if (!window._bubbleChartPropsLogged) {
            window._bubbleChartPropsLogged = true;
            console.log(`[BUBBLE CHART PROPS] Received:`, {
              tickersCount: tickers ? tickers.length : 0,
              hasTickers: !!tickers,
              isArray: Array.isArray(tickers),
              firstTicker:
                tickers && tickers.length > 0
                  ? {
                      ticker: tickers[0].ticker,
                      hasPhasePct: "phase_pct" in (tickers[0] || {}),
                      hasCompletion: "completion" in (tickers[0] || {}),
                      hasRR: "rr" in (tickers[0] || {}),
                      keys: Object.keys(tickers[0] || {}).slice(0, 15),
                    }
                  : null,
              hasAllData: !!allData,
              allDataKeys: allData ? Object.keys(allData).slice(0, 10) : [],
            });
          }
        }, [tickers, allData]);

        const [tooltip, setTooltip] = useState(null);
        const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
        const [showLabels, setShowLabels] = useState(true);
        const [crosshairPos, setCrosshairPos] = useState(null); // { x, y, ltfValue, htfValue }
        const containerRef = React.useRef(null);

        // Calculate #1 ranked ticker using SAME data source as Ranked List
        const topRankedTicker = React.useMemo(() => {
          if (rankedTickers && rankedTickers.length > 0) {
            return rankedTickers[0].ticker;
          }
          if (!allData || typeof allData !== "object") return null;
          const sorted = getRankedTickers(allData);
          return sorted.length > 0 ? sorted[0].ticker : null;
        }, [rankedTickers, allData]);
        const [dimensions, setDimensions] = React.useState({
          width: 1600,
          height: 1000,
        });

        // Update dimensions on mount and resize to use full container space
        React.useEffect(() => {
          const updateDimensions = () => {
            if (containerRef.current) {
              const rect = containerRef.current.getBoundingClientRect();
              // Use actual container size, with minimums
              setDimensions({
                width: Math.max(rect.width - 16, 1200), // Account for padding
                height: Math.max(rect.height - 16, 800),
              });
            }
          };
          // Initial update
          const timeoutId = setTimeout(updateDimensions, 100);
          window.addEventListener("resize", updateDimensions);
          return () => {
            clearTimeout(timeoutId);
            window.removeEventListener("resize", updateDimensions);
          };
        }, []);

        // Check Recharts availability (may load later)
        // Re-check inside component in case Recharts loaded after initial script execution
        let currentRechartsComponents = RechartsComponents;
        if (!currentRechartsComponents && typeof Recharts !== "undefined") {
          currentRechartsComponents = {
            ScatterChart: Recharts.ScatterChart,
            Scatter: Recharts.Scatter,
            XAxis: Recharts.XAxis,
            YAxis: Recharts.YAxis,
            CartesianGrid: Recharts.CartesianGrid,
            Tooltip: Recharts.Tooltip,
            ResponsiveContainer: Recharts.ResponsiveContainer,
            ReferenceLine: Recharts.ReferenceLine,
            ReferenceArea: Recharts.ReferenceArea,
          };
        }

        // TEMP: force Native SVG rendering (selection + trail lives here)
        const FORCE_NATIVE_SVG = true;
        if (FORCE_NATIVE_SVG) currentRechartsComponents = null;

        // Debug: Log which path we're taking
        console.log(
          `[BUBBLE CHART RENDER] Using ${
            currentRechartsComponents ? "Recharts" : "Native SVG"
          } mode`,
          {
            selectedTicker,
            hasSelectedTrail: !!selectedTrail,
            selectedTrailLength: Array.isArray(selectedTrail)
              ? selectedTrail.length
              : 0,
          }
        );

        // Fallback: Native SVG chart (works without Recharts)
        if (!currentRechartsComponents) {
          const chartWidth = dimensions.width;
          const chartHeight = dimensions.height;
          const margin = 50; // Reduced margin for more plot space
          const plotWidth = chartWidth - 2 * margin;
          const plotHeight = chartHeight - 2 * margin;

          // More precise scaling for better granularity
          const scaleX = plotWidth / 100; // -50 to 50 range
          const scaleY = plotHeight / 100;
          const offsetX = margin;
          const offsetY = margin;

          const handlePointerMove = (clientX, clientY, targetEl) => {
            const rect = targetEl.getBoundingClientRect();

            // CSS pixels within the rendered SVG element (used for HTML tooltip positioning)
            const cssX = clientX - rect.left;
            const cssY = clientY - rect.top;
            setTooltipPos({ x: cssX, y: cssY });

            // Convert screen coords → SVG viewBox units using the SVG's actual transform.
            // This accounts for preserveAspectRatio letterboxing and any scaling caused by layout changes.
            let svgX;
            let svgY;
            try {
              if (targetEl && typeof targetEl.createSVGPoint === "function") {
                const pt = targetEl.createSVGPoint();
                pt.x = clientX;
                pt.y = clientY;
                const ctm = targetEl.getScreenCTM && targetEl.getScreenCTM();
                if (ctm && typeof ctm.inverse === "function") {
                  const p = pt.matrixTransform(ctm.inverse());
                  svgX = p.x;
                  svgY = p.y;
                }
              }
            } catch {}

            // Fallback if CTM isn't available
            if (!Number.isFinite(svgX) || !Number.isFinite(svgY)) {
              const sx = rect.width ? chartWidth / rect.width : 1;
              const sy = rect.height ? chartHeight / rect.height : 1;
              svgX = cssX * sx;
              svgY = cssY * sy;
            }

            // Convert SVG position to plot-area coordinates
            const chartX = svgX - offsetX;
            const chartY = svgY - offsetY;

            // Check if mouse is within plot area
            if (
              chartX >= 0 &&
              chartX <= plotWidth &&
              chartY >= 0 &&
              chartY <= plotHeight
            ) {
              // Convert to LTF/HTF scores
              const ltfValue = chartX / scaleX - 50; // -50 to 50 range
              const htfValue = 50 - chartY / scaleY; // Inverted: top is +50, bottom is -50

              setCrosshairPos({
                x: svgX,
                y: svgY,
                ltfValue: ltfValue,
                htfValue: htfValue,
                chartX: chartX,
                chartY: chartY,
              });
            } else {
              setCrosshairPos(null);
            }
          };

          const handleMouseMove = (e) => {
            handlePointerMove(e.clientX, e.clientY, e.currentTarget);
          };

          const handleMouseLeave = () => {
            setTooltip(null);
            setCrosshairPos(null);
          };

          return (
            <div
              ref={containerRef}
              className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-2 relative"
            >
              {/* Label toggle */}
              <div className="absolute top-2 right-2 z-10">
                <button
                  onClick={() => setShowLabels(!showLabels)}
                  className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f] text-xs text-[#93a4d6] hover:bg-[#1a2550] transition-colors"
                >
                  {showLabels ? "Hide Labels" : "Show Labels"}
                </button>
              </div>
              <svg
                width="100%"
                height="100%"
                viewBox={`0 0 ${chartWidth} ${chartHeight}`}
                preserveAspectRatio="xMidYMid meet"
                onMouseMove={handleMouseMove}
                onMouseLeave={handleMouseLeave}
                onTouchMove={(e) => {
                  // Convert touch event to mouse-like coordinates for mobile
                  const touch = e.touches[0];
                  if (touch) {
                    handlePointerMove(
                      touch.clientX,
                      touch.clientY,
                      e.currentTarget
                    );
                  }
                }}
                onTouchEnd={handleMouseLeave}
                className="w-full h-full touch-none"
              >
                {/* Grid with better styling */}
                <defs>
                  <pattern
                    id="grid"
                    width="50"
                    height="50"
                    patternUnits="userSpaceOnUse"
                  >
                    <path
                      d="M 50 0 L 0 0 0 50"
                      fill="none"
                      stroke="#26325f"
                      strokeWidth="0.5"
                      opacity="0.5"
                    />
                  </pattern>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                      <feMergeNode in="coloredBlur" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>

                  {/* Arrowhead marker for the Bubble Trail path */}
                  <marker
                    id="trailArrow"
                    viewBox="0 0 10 10"
                    refX="9"
                    refY="5"
                    markerWidth="6"
                    markerHeight="6"
                    orient="auto"
                  >
                    <path
                      d="M 0 0 L 10 5 L 0 10 z"
                      fill="#00ffff"
                      opacity="0.8"
                    />
                  </marker>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />

                {/* Axes - Zero lines (X=0 and Y=0) - Make them very visible */}
                {/* Vertical center line (X=0) */}
                <line
                  x1={offsetX + 50 * scaleX}
                  y1={offsetY}
                  x2={offsetX + 50 * scaleX}
                  y2={offsetY + plotHeight}
                  stroke="#ffffff"
                  strokeWidth="2"
                  opacity="1"
                />
                {/* Horizontal center line (Y=0) */}
                <line
                  x1={offsetX}
                  y1={offsetY + plotHeight / 2}
                  x2={offsetX + plotWidth}
                  y2={offsetY + plotHeight / 2}
                  stroke="#ffffff"
                  strokeWidth="2"
                  opacity="1"
                />
                {/* Vertical axis line (y-axis) */}
                <line
                  x1={offsetX}
                  y1={offsetY}
                  x2={offsetX}
                  y2={offsetY + plotHeight}
                  stroke="#93a4d6"
                  strokeWidth="2"
                  opacity="0.6"
                />

                {/* Axis labels */}
                <text
                  x={offsetX - 50}
                  y={offsetY + plotHeight / 2}
                  fill="#93a4d6"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                  transform={`rotate(-90 ${offsetX - 50} ${
                    offsetY + plotHeight / 2
                  })`}
                >
                  HTF Score
                </text>
                <text
                  x={offsetX + plotWidth / 2}
                  y={offsetY + plotHeight + 40}
                  fill="#93a4d6"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                >
                  LTF Score
                </text>

                {/* Axis scale markers */}
                {[-50, -25, 0, 25, 50].map((val) => {
                  const x = offsetX + (val + 50) * scaleX;
                  const y = offsetY + plotHeight / 2;
                  return (
                    <g key={`x-${val}`}>
                      <line
                        x1={x}
                        y1={y - 5}
                        x2={x}
                        y2={y + 5}
                        stroke="#93a4d6"
                        strokeWidth="2"
                      />
                      <text
                        x={x}
                        y={y + 20}
                        fill="#93a4d6"
                        textAnchor="middle"
                        fontSize="10"
                      >
                        {val}
                      </text>
                    </g>
                  );
                })}
                {[-50, -25, 0, 25, 50].map((val) => {
                  const x = offsetX;
                  const y = offsetY + plotHeight - (val + 50) * scaleY;
                  return (
                    <g key={`y-${val}`}>
                      <line
                        x1={x - 5}
                        y1={y}
                        x2={x + 5}
                        y2={y}
                        stroke="#93a4d6"
                        strokeWidth="2"
                      />
                      <text
                        x={x - 15}
                        y={y + 4}
                        fill="#93a4d6"
                        textAnchor="end"
                        fontSize="10"
                      >
                        {val}
                      </text>
                    </g>
                  );
                })}

                {/* Quadrant labels - moved further from center for more bubble space */}
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + 20}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q1 Prep
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + 20}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q2 Bull
                </text>
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + plotHeight - 5}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q3 Bear
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + plotHeight - 5}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q4 Pullback
                </text>

                {/* Corridors - More pronounced */}
                <rect
                  x={offsetX + (LONG_CORRIDOR.ltfMin + 50) * scaleX}
                  y={offsetY}
                  width={(LONG_CORRIDOR.ltfMax - LONG_CORRIDOR.ltfMin) * scaleX}
                  height={plotHeight / 2}
                  fill="rgba(46,204,113,0.25)"
                  stroke="rgba(46,204,113,0.6)"
                  strokeWidth="2"
                  strokeDasharray="4 4"
                />
                <rect
                  x={offsetX + (SHORT_CORRIDOR.ltfMin + 50) * scaleX}
                  y={offsetY + plotHeight / 2}
                  width={
                    (SHORT_CORRIDOR.ltfMax - SHORT_CORRIDOR.ltfMin) * scaleX
                  }
                  height={plotHeight / 2}
                  fill="rgba(231,76,60,0.25)"
                  stroke="rgba(231,76,60,0.6)"
                  strokeWidth="2"
                  strokeDasharray="4 4"
                />

                {/* Crosshair - Vertical line */}
                {crosshairPos &&
                  crosshairPos.chartX >= 0 &&
                  crosshairPos.chartX <= plotWidth && (
                    <line
                      x1={offsetX + crosshairPos.chartX}
                      y1={offsetY}
                      x2={offsetX + crosshairPos.chartX}
                      y2={offsetY + plotHeight}
                      stroke="#00ffff"
                      strokeWidth="1"
                      strokeDasharray="4 4"
                      opacity="0.7"
                      pointerEvents="none"
                    />
                  )}

                {/* Crosshair - Horizontal line */}
                {crosshairPos &&
                  crosshairPos.chartY >= 0 &&
                  crosshairPos.chartY <= plotHeight && (
                    <line
                      x1={offsetX}
                      y1={offsetY + crosshairPos.chartY}
                      x2={offsetX + plotWidth}
                      y2={offsetY + crosshairPos.chartY}
                      stroke="#00ffff"
                      strokeWidth="1"
                      strokeDasharray="4 4"
                      opacity="0.7"
                      pointerEvents="none"
                    />
                  )}

                {/* Crosshair value labels - Always show when crosshair is active */}
                {crosshairPos && (
                  <>
                    {/* LTF value at bottom - show if crosshair is in plot area */}
                    {crosshairPos.chartX >= 0 &&
                      crosshairPos.chartX <= plotWidth && (
                        <g>
                          <rect
                            x={offsetX + crosshairPos.chartX - 30}
                            y={offsetY + plotHeight + 5}
                            width="60"
                            height="20"
                            fill="#0b1020"
                            stroke="#00ffff"
                            strokeWidth="1.5"
                            opacity="0.95"
                            rx="3"
                          />
                          <text
                            x={offsetX + crosshairPos.chartX}
                            y={offsetY + plotHeight + 18}
                            fill="#00ffff"
                            textAnchor="middle"
                            fontSize="12"
                            fontWeight="700"
                          >
                            LTF: {crosshairPos.ltfValue.toFixed(1)}
                          </text>
                        </g>
                      )}

                    {/* HTF value on left - show if crosshair is in plot area */}
                    {crosshairPos.chartY >= 0 &&
                      crosshairPos.chartY <= plotHeight && (
                        <g>
                          <rect
                            x={offsetX - 55}
                            y={offsetY + crosshairPos.chartY - 10}
                            width="50"
                            height="20"
                            fill="#0b1020"
                            stroke="#00ffff"
                            strokeWidth="1.5"
                            opacity="0.95"
                            rx="3"
                          />
                          <text
                            x={offsetX - 30}
                            y={offsetY + crosshairPos.chartY + 5}
                            fill="#00ffff"
                            textAnchor="middle"
                            fontSize="12"
                            fontWeight="700"
                          >
                            HTF: {crosshairPos.htfValue.toFixed(1)}
                          </text>
                        </g>
                      )}
                  </>
                )}

                {/* Bubbles - Show only selected ticker with trail if selected, otherwise show all */}
                {(() => {
                  // Debug: Log which branch we're taking (always log, not just once)
                  console.log(`[BUBBLE BRANCH]`, {
                    hasSelectedTicker: !!selectedTicker,
                    selectedTickerValue: selectedTicker,
                    hasSelectedTrail: !!selectedTrail,
                    selectedTrailLength: selectedTrail
                      ? selectedTrail.length
                      : 0,
                    tickersCount: tickers ? tickers.length : 0,
                    willShowSelected: !!selectedTicker,
                    willShowAll: !selectedTicker,
                  });
                  return null;
                })()}
                {selectedTicker ? (
                  <>
                    {console.log(
                      `[SELECTED BRANCH] Rendering selected ticker: ${selectedTicker}`
                    )}
                    {/* Trail path - comet effect */}
                    {selectedTrail && selectedTrail.length > 1 && (() => {
                      const GAP_MS = 30 * 60 * 1000; // break across big gaps (e.g., overnight)
                      const segments = splitTrailByGaps(selectedTrail, GAP_MS);
                      return segments
                        .filter((seg) => Array.isArray(seg) && seg.length > 1)
                        .map((seg, segIdx) => {
                          const pts = seg.map((p) => ({
                            x:
                              (Number(p?.ltf_score) || 0) * scaleX +
                              offsetX +
                              50 * scaleX,
                            y:
                              (Number(p?.htf_score) || 0) * -scaleY +
                              offsetY +
                              plotHeight -
                              50 * scaleY,
                          }));
                          const d = catmullRomPath(pts);
                          if (!d) return null;
                          const isLast =
                            segIdx === segments.length - 1 &&
                            seg &&
                            seg.length > 1;
                          // Keep the path readable (less “busy” than animated dashes).
                          const opacity = 0.35 + (segIdx / Math.max(1, segments.length - 1)) * 0.25;
                          return (
                            <path
                              key={`trail-path-${segIdx}`}
                              d={d}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity={opacity}
                              className="trail-path"
                              markerEnd={isLast ? "url(#trailArrow)" : undefined}
                              pointerEvents="none"
                            />
                          );
                        });
                    })()}
                    {/* Trail points (smaller bubbles) - show historical positions */}
                    {selectedTrail &&
                      selectedTrail.length > 1 &&
                      selectedTrail.slice(0, -1).map((point, idx) => {
                        // Create a ticker-like object from trail point
                        const tickerData = {
                          ticker: selectedTicker,
                          htf_score: point.htf_score || 0,
                          ltf_score: point.ltf_score || 0,
                          phase_pct: point.phase_pct || 0,
                          completion: point.completion || 0,
                          flags: {},
                          state: point.state || "",
                        };
                        const x =
                          (Number(tickerData.ltf_score) || 0) * scaleX +
                          offsetX +
                          50 * scaleX;
                        const y =
                          (Number(tickerData.htf_score) || 0) * -scaleY +
                          offsetY +
                          plotHeight -
                          50 * scaleY;
                        const visual = bubbleVisualForTrailPoint(
                          point,
                          selectedTicker
                        );
                        const size = visual.radius; // historical size (scaled down, proportional)
                        const opacity =
                          0.3 + (idx / selectedTrail.length) * 0.4; // Fade in from past to present

                        return (
                          <circle
                            key={`trail-point-${idx}`}
                            cx={x}
                            cy={y}
                            r={size}
                            fill={visual.color}
                            fillOpacity={opacity}
                            stroke={visual.color}
                            strokeWidth="1"
                            strokeOpacity={opacity * 0.5}
                          />
                        );
                      })}
                    {/* Highlight a specific historical point (from Bubble Journey hover/click) */}
                    {highlightTrailPoint &&
                      Number.isFinite(Number(highlightTrailPoint?.ltf_score)) &&
                      Number.isFinite(Number(highlightTrailPoint?.htf_score)) &&
                      (() => {
                        const hx =
                          (Number(highlightTrailPoint.ltf_score) || 0) * scaleX +
                          offsetX +
                          50 * scaleX;
                        const hy =
                          (Number(highlightTrailPoint.htf_score) || 0) *
                            -scaleY +
                          offsetY +
                          plotHeight -
                          50 * scaleY;
                        const visual = bubbleVisualForTrailPoint(
                          highlightTrailPoint,
                          selectedTicker
                        );
                        const r = Math.max(3, Number(visual?.radius) || 6);
                        return (
                          <g
                            key={`trail-highlight-${String(
                              highlightTrailPoint?.ts ?? ""
                            )}`}
                            pointerEvents="none"
                          >
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 3}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity="0.9"
                            >
                              <animate
                                attributeName="r"
                                values={`${r + 2};${r + 10};${r + 2}`}
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                              <animate
                                attributeName="opacity"
                                values="0.95;0.25;0.95"
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                            </circle>
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 1}
                              fill="none"
                              stroke={visual?.color || "#00ffff"}
                              strokeWidth="1.5"
                              opacity="0.8"
                            />
                          </g>
                        );
                      })()}
                    {/* Current position (larger, highlighted) */}
                    {(() => {
                      console.log(
                        `[SELECTED BRANCH] Looking for ticker: ${selectedTicker} in tickers array (${
                          tickers ? tickers.length : 0
                        } items)`
                      );
                      // Try to find ticker in filtered list first
                      let currentTicker = displayTickers.find((t) => {
                        if (!t || typeof t !== "object") return false;
                        const tTicker = String(t.ticker || "").toUpperCase();
                        return tTicker === String(selectedTicker).toUpperCase();
                      });
                      console.log(
                        `[SELECTED BRANCH] Found in tickers array:`,
                        !!currentTicker
                      );

                      // If not in filtered list, try to get from allData (for tickers filtered out but selected)
                      if (
                        !currentTicker &&
                        allData &&
                        typeof allData === "object"
                      ) {
                        const tickerUpper =
                          String(selectedTicker).toUpperCase();
                        if (allData[tickerUpper]) {
                          currentTicker = allData[tickerUpper];
                        } else {
                          // Search through values
                          const dataArray = Object.values(allData);
                          currentTicker = dataArray.find((t) => {
                            if (!t || typeof t !== "object") return false;
                            const tTicker = String(
                              t.ticker || ""
                            ).toUpperCase();
                            return tTicker === tickerUpper;
                          });
                        }
                      }

                      // Only render if we have valid scores to position the bubble
                      if (
                        currentTicker &&
                        (currentTicker.htf_score !== undefined ||
                          currentTicker.ltf_score !== undefined)
                      ) {
                        return (
                          <SVGBubble
                            key={selectedTicker}
                            ticker={currentTicker}
                            onClick={() => {}}
                            onHover={() => {}}
                            isHovered={true}
                            scaleX={scaleX}
                            scaleY={-scaleY}
                            offsetX={offsetX + 50 * scaleX}
                            offsetY={offsetY + plotHeight - 50 * scaleY}
                            showLabels={true}
                            isTopRanked={topRankedTicker === selectedTicker}
                          />
                        );
                      }
                      return null;
                    })()}
                  </>
                ) : (
                  (() => {
                    // CRITICAL DEBUG: Log what we're about to render
                    console.log(`[ALL BUBBLES BRANCH] Rendering all bubbles`, {
                      hasTickers: !!tickers,
                      tickersLength: tickers ? tickers.length : 0,
                      isArray: Array.isArray(tickers),
                      selectedTicker: selectedTicker,
                      selectedTrail: selectedTrail,
                      willRenderAll: !selectedTicker,
                    });

                    if (!tickers || tickers.length === 0) {
                      console.error(`[BUBBLE ERROR] No tickers to render!`, {
                        tickers,
                        selectedTicker,
                        selectedTrail,
                      });
                      return null;
                    }

                    return (
                      <>
                        {/* Current bubbles */}
                        {displayTickers.map((ticker, index) => {
                          // Log first few bubbles
                          if (index < 5) {
                            console.log(
                              `[BUBBLE RENDER] ${ticker.ticker} (${index}):`,
                              {
                                hasTicker: !!ticker,
                                tickerKeys: ticker
                                  ? Object.keys(ticker).slice(0, 15)
                                  : [],
                                hasPhasePct: ticker
                                  ? "phase_pct" in ticker
                                  : false,
                                phasePct: ticker ? ticker.phase_pct : undefined,
                                hasCompletion: ticker
                                  ? "completion" in ticker
                                  : false,
                                hasRR: ticker ? "rr" in ticker : false,
                              }
                            );
                          }
                          return (
                            <SVGBubble
                              key={ticker.ticker}
                              ticker={ticker}
                              onClick={onBubbleClick}
                              onHover={(t) => {
                                onHover(t);
                                if (t)
                                  setTooltip(
                                    tickers.find((tt) => tt.ticker === t)
                                  );
                              }}
                              isHovered={hoveredTicker === ticker.ticker}
                              scaleX={scaleX}
                              scaleY={-scaleY}
                              offsetX={offsetX + 50 * scaleX}
                              offsetY={offsetY + plotHeight - 50 * scaleY}
                              showLabels={showLabels}
                              isTopRanked={topRankedTicker === ticker.ticker}
                            />
                          );
                        })}
                      </>
                    );
                  })()
                )}
              </svg>

              {/* Legend Overlay - Bottom Right */}
              <div className="absolute bottom-2 right-2 z-10 p-2 bg-[#0f1630]/95 backdrop-blur-sm border border-[#26325f] rounded-lg text-xs shadow-lg">
                <div className="font-semibold text-white mb-1.5 text-[11px]">
                  📊 Legend
                </div>
                <div className="flex gap-4">
                  {/* #1 Ranked Indicator */}
                  {topRankedTicker && (
                    <div className="bg-[#ffd700]/10 border border-[#ffd700]/30 rounded p-1.5">
                      <div className="text-[#ffd700] font-bold mb-1 text-[11px] flex items-center gap-1">
                        <span className="text-xl">👑</span>
                        <span>#1 Ranked</span>
                      </div>
                      <div className="text-[#ffd700] text-[10px] font-semibold">
                        {topRankedTicker}
                      </div>
                    </div>
                  )}
                  {/* Colors */}
                  <div>
                    <div className="text-[#93a4d6] font-semibold mb-1 text-[10px]">
                      Colors:
                    </div>
                    <div className="space-y-0.5">
                      <div className="flex items-center gap-1.5">
                        <div
                          className="w-3 h-3 rounded-full border border-white"
                          style={{
                            backgroundColor: phaseCompletionToColor(0.1),
                            opacity: 0.7,
                          }}
                        ></div>
                        <span className="text-[#93a4d6] text-[10px]">
                          Green: 0-30%
                        </span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div
                          className="w-3 h-3 rounded-full border border-white"
                          style={{
                            backgroundColor: phaseCompletionToColor(0.45),
                            opacity: 0.7,
                          }}
                        ></div>
                        <span className="text-[#93a4d6] text-[10px]">
                          Yellow: 30-60%
                        </span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div
                          className="w-3 h-3 rounded-full border border-white"
                          style={{
                            backgroundColor: phaseCompletionToColor(0.8),
                            opacity: 0.7,
                          }}
                        ></div>
                        <span className="text-[#93a4d6] text-[10px]">
                          Red: 60-100%
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Sizes */}
                  <div>
                    <div className="text-[#93a4d6] font-semibold mb-1 text-[10px]">
                      Sizes:
                    </div>
                    <div className="space-y-0.5">
                      <div className="flex items-center gap-1.5">
                        <div
                          className="w-2.5 h-2.5 rounded-full border border-white bg-[#93a4d6]"
                          style={{ opacity: 0.7 }}
                        ></div>
                        <span className="text-[#93a4d6] text-[10px]">
                          Small
                        </span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div
                          className="w-4 h-4 rounded-full border border-white bg-[#93a4d6]"
                          style={{ opacity: 0.7 }}
                        ></div>
                        <span className="text-[#93a4d6] text-[10px]">
                          Medium
                        </span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div
                          className="w-5 h-5 rounded-full border border-white bg-[#93a4d6]"
                          style={{ opacity: 0.7 }}
                        ></div>
                        <span className="text-[#93a4d6] text-[10px]">
                          Large
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Tooltip */}
              {tooltip &&
                (() => {
                  // Calculate rank position using worker's rank field (stored at worker level)
                  // This matches the ranking system used throughout the platform
                  let rankPosition = null;
                  let totalTickers = 0;
                  const sortedByRank =
                    rankedTickers && rankedTickers.length > 0
                      ? rankedTickers
                      : getRankedTickers(allData);
                  totalTickers = sortedByRank.length;
                  rankPosition =
                    getRankPositionFromMap(
                      rankedTickerPositions,
                      tooltip.ticker
                    ) ?? getRankPosition(sortedByRank, tooltip.ticker);
                  const rankTotal =
                    Number.isFinite(Number(tooltip.rank_total)) &&
                    Number(tooltip.rank_total) > 0
                      ? Number(tooltip.rank_total)
                      : totalTickers;
                  totalTickers = rankTotal;
                  return (
                    <div
                      className="absolute bg-[#121a33] border-2 border-[#26325f] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl fade-in"
                      style={{
                        left: tooltipPos.x + 10,
                        top: tooltipPos.y - 10,
                        minWidth: "200px",
                      }}
                    >
                      <div className="font-bold text-base mb-2">
                        {tooltip.ticker}
                        {tooltip.price && (
                          <span className="ml-2 text-sm font-normal text-white">
                            ${Number(tooltip.price).toFixed(2)}
                          </span>
                        )}
                      </div>
                      {(() => {
                        // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                        const ingestTime =
                          tooltip.ingest_ts ||
                          tooltip.ingest_time ||
                          tooltip.ts;
                        if (ingestTime) {
                          try {
                            const timeValue =
                              typeof ingestTime === "string"
                                ? new Date(ingestTime)
                                : new Date(Number(ingestTime));
                            if (!isNaN(timeValue.getTime())) {
                              const ageMs = Date.now() - timeValue.getTime();
                              const ageMinutes = Math.floor(ageMs / 60000);
                              const ageHours = Math.floor(ageMinutes / 60);

                              // Warn if data is stale (older than 30 minutes)
                              const isStale = ageMinutes > 30;

                              const displayTime = timeValue.toLocaleTimeString(
                                "en-US",
                                {
                                  hour: "numeric",
                                  minute: "2-digit",
                                  hour12: true,
                                }
                              );
                              const displayDate = timeValue.toLocaleDateString(
                                "en-US",
                                {
                                  month: "short",
                                  day: "numeric",
                                }
                              );
                              return (
                                <div
                                  className={`text-[10px] mb-2 ${
                                    isStale
                                      ? "text-yellow-400"
                                      : "text-[#93a4d6]"
                                  }`}
                                >
                                  {displayDate} {displayTime}
                                  {isStale && (
                                    <span
                                      className="ml-1"
                                      title={`Data is ${
                                        ageHours > 0 ? `${ageHours}h ` : ""
                                      }${ageMinutes % 60}m old`}
                                    >
                                      ⚠️
                                    </span>
                                  )}
                                </div>
                              );
                            }
                          } catch (e) {}
                        }
                        return null;
                      })()}
                      {isPrimeBubble(tooltip) && (
                        <div className="mb-2 px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold text-center">
                          ⭐ PRIME SETUP
                        </div>
                      )}
                      <div className="space-y-1">
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">Score</span>
                          <span className="font-semibold">
                            {tooltip.rank || "—"}
                          </span>
                        </div>
                        {rankPosition !== null && totalTickers > 0 && (
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Rank</span>
                            <span className="font-semibold">
                              {rankPosition} / {totalTickers}
                            </span>
                          </div>
                        )}
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">RR</span>
                          <span className="font-semibold">
                            {tooltip.rr ? Number(tooltip.rr).toFixed(2) : "—"}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">State</span>
                          <span className="font-semibold">
                            {tooltip.state || "—"}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">Phase</span>
                          <span
                            className="font-semibold"
                            style={{
                              color: phaseToColor(
                                Number(tooltip.phase_pct) || 0
                              ),
                            }}
                          >
                            {Math.round((Number(tooltip.phase_pct) || 0) * 100)}
                            %{tooltip.phase_zone && ` (${tooltip.phase_zone})`}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-[#93a4d6]">Completion</span>
                          <span className="font-semibold">
                            {Math.round(completionForSize(tooltip) * 100)}%
                          </span>
                        </div>
                      </div>
                    </div>
                  );
                })()}
            </div>
          );
        }

        // Recharts version (if loaded) - use currentRechartsComponents
        const {
          ScatterChart,
          Scatter,
          XAxis,
          YAxis,
          CartesianGrid,
          Tooltip,
          ResponsiveContainer,
          ReferenceLine,
          ReferenceArea,
        } = currentRechartsComponents;

        const [rechartsCrosshair, setRechartsCrosshair] = useState(null);
        const chartContainerRef = React.useRef(null);

        // Store ranked tickers for tooltip access
        const allTickersForRanking = rankedTickers;

        // Filter data based on selectedTicker - if selected, only show that ticker
        const data = useMemo(() => {
          const tickersToUse = selectedTicker
            ? tickers.filter((t) => {
                if (!t || typeof t !== "object") return false;
                const tTicker = String(t.ticker || "").toUpperCase();
                return tTicker === String(selectedTicker).toUpperCase();
              })
            : tickers;

          console.log(
            `[RECHARTS DATA] selectedTicker=${selectedTicker}, using ${tickersToUse.length} of ${tickers.length} tickers`
          );

          return tickersToUse.map((t) => ({
            x: Number(t.ltf_score) || 0,
            y: Number(t.htf_score) || 0,
            ticker: t,
          }));
        }, [tickers, selectedTicker]);

        // Recharts shape renderer - receives cx, cy, payload from Recharts
        const BubbleShape = React.useCallback(
          (props) => {
            const { cx, cy, payload } = props;
            const ticker = payload?.ticker;
            if (!ticker) return null;

            const comp =
              ticker.completion != null ? Number(ticker.completion) : 0;
            const phasePct =
              ticker.phase_pct != null ? Number(ticker.phase_pct) : 0;
            const rr = ticker.rr != null ? Number(ticker.rr) : 0;
            const waitingForData = ticker.waitingForData === true;

            const validComp = Number.isFinite(comp)
              ? Math.max(0, Math.min(1, comp))
              : 0;
            const validPhase = Number.isFinite(phasePct)
              ? Math.max(0, Math.min(1, phasePct))
              : 0.1;
            const validRR = Number.isFinite(rr) && rr > 0 ? rr : 0.5;

            const cappedRR = Math.min(validRR, 5);
            const baseSize = 4; // Further reduced for less overlap
            const rrMultiplier = 2; // Further reduced for smaller bubbles
            const size = waitingForData
              ? baseSize * 0.7
              : baseSize + cappedRR * rrMultiplier * (1 - validComp);

            // Add size variation for better visual distinction
            const tickerHash = (ticker.ticker || "")
              .split("")
              .reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const sizeVariation = (tickerHash % 5) * 0.8;
            const finalSize = Math.max(baseSize, size + sizeVariation);

            // Color based on phase
            let color = "#2ecc71"; // Green default
            if (waitingForData) {
              color = "#6b7a9f"; // Gray for waiting
            } else if (validPhase >= 0.6) {
              color = "#e74c3c"; // Red: 60-100%
            } else if (validPhase >= 0.3) {
              color = "#f39c12"; // Yellow: 30-60%
            }

            const flags = ticker.flags || {};
            const prime = isPrimeBubble(ticker);
            const isTopRanked = topRankedTicker === ticker.ticker;
            const isBubbleHovered = hoveredTicker === ticker.ticker;
            const hasSqueeze = flags.sq30_release || flags.sq30_on;

            // Determine emoji
            const emoji = isTopRanked
              ? "👑"
              : waitingForData
              ? "⏳"
              : prime
              ? "⭐"
              : flags.sq30_release
              ? "⚡"
              : flags.sq30_on
              ? "🧨"
              : "";

            const borderColor = waitingForData
              ? "#93a4d6"
              : prime
              ? "#2ecc71"
              : flags.sq30_release
              ? "#00ffff"
              : flags.sq30_on
              ? "#ffd700"
              : "#ffffff";

            const opacity = waitingForData
              ? 0.6
              : isBubbleHovered
              ? 1
              : prime
              ? 0.95
              : 0.85;
            const borderWidth = waitingForData
              ? 2
              : prime
              ? 3
              : flags.sq30_release || flags.sq30_on
              ? 2
              : 1.5;
            const bubbleSize = isBubbleHovered ? finalSize * 1.2 : finalSize;
            const labelY =
              cy - bubbleSize - (emoji ? (isTopRanked ? 20 : 12) : 8);

            return (
              <g
                onClick={() => {
                  console.log(
                    `[BUBBLE CLICK] Direct click on ticker: ${ticker.ticker}`
                  );
                  onBubbleClick(ticker.ticker);
                }}
                onMouseEnter={() => onHover(ticker.ticker)}
                onMouseLeave={() => onHover(null)}
                onTouchStart={(e) => {
                  e.preventDefault();
                  onHover(ticker.ticker);
                  console.log(
                    `[BUBBLE CLICK] Touch on ticker: ${ticker.ticker}`
                  );
                  onBubbleClick(ticker.ticker);
                }}
                onTouchEnd={(e) => {
                  e.preventDefault();
                  onHover(null);
                }}
                style={{
                  cursor: "pointer",
                  transition: "all 0.2s ease-out",
                  touchAction: "manipulation",
                }}
              >
                {/* Glow effect for prime */}
                {prime && (
                  <circle
                    cx={cx}
                    cy={cy}
                    r={bubbleSize + 2}
                    fill="none"
                    stroke="#2ecc71"
                    strokeWidth="1"
                    opacity="0.3"
                  />
                )}
                {/* Additional glow effects for #1 ranked - reduced size */}
                {isTopRanked && (
                  <>
                    <circle
                      cx={cx}
                      cy={cy}
                      r={bubbleSize + 4}
                      fill="none"
                      stroke="#ffd700"
                      strokeWidth="2"
                      opacity="0.6"
                    >
                      <animate
                        attributeName="opacity"
                        values="0.3;0.9;0.3"
                        dur="2s"
                        repeatCount="indefinite"
                      />
                      <animate
                        attributeName="r"
                        values={`${bubbleSize + 3};${bubbleSize + 6};${
                          bubbleSize + 3
                        }`}
                        dur="2s"
                        repeatCount="indefinite"
                      />
                    </circle>
                    <circle
                      cx={cx}
                      cy={cy}
                      r={bubbleSize + 6}
                      fill="none"
                      stroke="#ffd700"
                      strokeWidth="1.5"
                      opacity="0.3"
                    >
                      <animate
                        attributeName="opacity"
                        values="0.1;0.5;0.1"
                        dur="2s"
                        repeatCount="indefinite"
                      />
                    </circle>
                  </>
                )}
                <circle
                  cx={cx}
                  cy={cy}
                  r={Math.max(3, bubbleSize)}
                  fill={color}
                  fillOpacity={opacity}
                  stroke={borderColor}
                  strokeWidth={borderWidth}
                />
                {/* Emoji above bubble */}
                {emoji && (
                  <g style={{ pointerEvents: "none" }}>
                    {/* Background circle for #1 ranked - reduced size */}
                    {isTopRanked && (
                      <circle
                        cx={cx}
                        cy={labelY - 5}
                        r="18"
                        fill="#ffd700"
                        fillOpacity="0.3"
                      >
                        <animate
                          attributeName="fillOpacity"
                          values="0.2;0.5;0.2"
                          dur="1.5s"
                          repeatCount="indefinite"
                        />
                      </circle>
                    )}
                    {/* Outer glow ring for #1 - reduced size */}
                    {isTopRanked && (
                      <>
                        <circle
                          cx={cx}
                          cy={labelY - 5}
                          r="22"
                          fill="none"
                          stroke="#ffd700"
                          strokeWidth="2"
                          opacity="0.6"
                        >
                          <animate
                            attributeName="r"
                            values="20;24;20"
                            dur="2s"
                            repeatCount="indefinite"
                          />
                          <animate
                            attributeName="opacity"
                            values="0.4;0.8;0.4"
                            dur="2s"
                            repeatCount="indefinite"
                          />
                        </circle>
                      </>
                    )}
                    {/* Main emoji text */}
                    <text
                      x={cx}
                      y={labelY}
                      textAnchor="middle"
                      dominantBaseline="middle"
                      fontSize={
                        isTopRanked
                          ? "24"
                          : waitingForData
                          ? "10"
                          : prime
                          ? "14"
                          : "12"
                      }
                      fill={
                        isTopRanked
                          ? "#ffd700"
                          : waitingForData
                          ? "#93a4d6"
                          : prime
                          ? "#2ecc71"
                          : flags.sq30_release
                          ? "#00ffff"
                          : "#ffd700"
                      }
                      fontWeight="bold"
                      style={{
                        textShadow: isTopRanked
                          ? "0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.8)"
                          : "0 0 3px rgba(0,0,0,0.8)",
                        filter: isTopRanked
                          ? "drop-shadow(0 0 15px rgba(255, 215, 0, 1))"
                          : "none",
                        pointerEvents: "none",
                      }}
                    >
                      {emoji}
                    </text>
                    {/* Sparkle effects for #1 - reduced size */}
                    {isTopRanked && (
                      <>
                        <text
                          x={cx - 15}
                          y={labelY - 10}
                          textAnchor="middle"
                          dominantBaseline="middle"
                          fontSize="12"
                          fill="#ffd700"
                          opacity="0.9"
                          style={{ pointerEvents: "none" }}
                        >
                          ✨
                        </text>
                        <text
                          x={cx + 15}
                          y={labelY - 10}
                          textAnchor="middle"
                          dominantBaseline="middle"
                          fontSize="12"
                          fill="#ffd700"
                          opacity="0.9"
                          style={{ pointerEvents: "none" }}
                        >
                          ✨
                        </text>
                      </>
                    )}
                  </g>
                )}
                {/* Ticker label */}
                {(showLabels || isBubbleHovered) && (
                  <text
                    x={cx}
                    y={labelY - (emoji ? 14 : 8)}
                    textAnchor="middle"
                    fontSize="10"
                    fill={waitingForData ? "#93a4d6" : "#e7ecff"}
                    fontWeight="600"
                    style={{
                      textShadow: "0 0 4px rgba(0,0,0,0.9)",
                      pointerEvents: "none",
                    }}
                  >
                    {ticker.ticker}
                  </text>
                )}
              </g>
            );
          },
          [onBubbleClick, onHover, hoveredTicker, topRankedTicker, showLabels]
        );

        const handleRechartsMouseMove = (e) => {
          if (
            e &&
            e.activeCoordinate &&
            e.chartX !== undefined &&
            e.chartY !== undefined
          ) {
            // Calculate values from chart coordinates
            // Domain is [-50, 50] for both axes
            // activeCoordinate gives us pixel position, we need to convert to data values
            const chart = e.chart;
            if (chart && chartContainerRef.current) {
              const rect = chartContainerRef.current.getBoundingClientRect();
              const margin = { top: 20, right: 20, bottom: 20, left: 20 };
              const plotWidth = rect.width - margin.left - margin.right;
              const plotHeight = rect.height - margin.top - margin.bottom;

              // Convert pixel coordinates to data values
              const ltfValue =
                ((e.chartX - margin.left) / plotWidth) * 100 - 50;
              const htfValue =
                50 - ((e.chartY - margin.top) / plotHeight) * 100;

              setRechartsCrosshair({
                x: e.chartX,
                y: e.chartY,
                ltfValue: ltfValue,
                htfValue: htfValue,
              });
            } else if (e.activePayload && e.activePayload[0]) {
              // Fallback: use payload data if available
              const payload = e.activePayload[0].payload;
              setRechartsCrosshair({
                x: e.activeCoordinate.x,
                y: e.activeCoordinate.y,
                ltfValue: payload.x,
                htfValue: payload.y,
              });
            }
          }
        };

        const handleRechartsMouseLeave = () => {
          setRechartsCrosshair(null);
        };

        return (
          <div
            ref={chartContainerRef}
            className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-4 relative"
          >
            <ResponsiveContainer width="100%" height="100%">
              <ScatterChart
                margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
                onMouseMove={handleRechartsMouseMove}
                onMouseLeave={handleRechartsMouseLeave}
                onTouchMove={(e) => {
                  // Recharts handles touch events, but we need to ensure they work
                  if (e.activeCoordinate) {
                    handleRechartsMouseMove(e);
                  }
                }}
                onTouchEnd={handleRechartsMouseLeave}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#26325f" />
                <XAxis
                  type="number"
                  dataKey="x"
                  name="LTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <YAxis
                  type="number"
                  dataKey="y"
                  name="HTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                {/* Corridors - Long corridor (top half, LTF: -8 to +12) - More pronounced */}
                <ReferenceArea
                  x1={LONG_CORRIDOR.ltfMin}
                  x2={LONG_CORRIDOR.ltfMax}
                  y1={0}
                  y2={50}
                  fill="rgba(46,204,113,0.25)"
                  stroke="rgba(46,204,113,0.6)"
                  strokeWidth={2}
                  strokeDasharray="4 4"
                />
                {/* Corridors - Short corridor (bottom half, LTF: -12 to +8) - More pronounced */}
                <ReferenceArea
                  x1={SHORT_CORRIDOR.ltfMin}
                  x2={SHORT_CORRIDOR.ltfMax}
                  y1={-50}
                  y2={0}
                  fill="rgba(231,76,60,0.25)"
                  stroke="rgba(231,76,60,0.6)"
                  strokeWidth={2}
                  strokeDasharray="4 4"
                />
                {/* Zero lines - X=0 and Y=0 */}
                <ReferenceLine
                  x={0}
                  stroke="#ffffff"
                  strokeWidth={2}
                  opacity={1}
                />
                <ReferenceLine
                  y={0}
                  stroke="#ffffff"
                  strokeWidth={2}
                  opacity={1}
                />
                {/* Crosshair - Vertical line */}
                {rechartsCrosshair && rechartsCrosshair.ltfValue !== null && (
                  <ReferenceLine
                    x={rechartsCrosshair.ltfValue}
                    stroke="#00ffff"
                    strokeWidth={1}
                    strokeDasharray="4 4"
                    opacity={0.7}
                  />
                )}
                {/* Crosshair - Horizontal line */}
                {rechartsCrosshair && rechartsCrosshair.htfValue !== null && (
                  <ReferenceLine
                    y={rechartsCrosshair.htfValue}
                    stroke="#00ffff"
                    strokeWidth={1}
                    strokeDasharray="4 4"
                    opacity={0.7}
                  />
                )}
                <Tooltip
                  content={({ active, payload }) => {
                    if (!active || !payload?.[0]) return null;
                    const t = payload[0].payload.ticker;

                    // Calculate rank position (same logic as native SVG tooltip)
                    let rankPosition = null;
                    let totalTickers = 0;
                    const sortedByRank =
                      allTickersForRanking && Array.isArray(allTickersForRanking)
                        ? allTickersForRanking
                        : getRankedTickers(allData);
                    totalTickers = sortedByRank.length;
                    rankPosition =
                      getRankPositionFromMap(
                        rankedTickerPositions,
                        t.ticker
                      ) ?? getRankPosition(sortedByRank, t.ticker);
                    const rankTotal =
                      Number.isFinite(Number(t.rank_total)) &&
                      Number(t.rank_total) > 0
                        ? Number(t.rank_total)
                        : totalTickers;
                    totalTickers = rankTotal;

                    return (
                      <div className="bg-[#121a33] border-2 border-[#26325f] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl">
                        <div className="font-bold text-base mb-2">
                          {t.ticker}
                          {t.price && (
                            <span className="ml-2 text-sm font-normal text-white">
                              ${Number(t.price).toFixed(2)}
                            </span>
                          )}
                        </div>
                        {(() => {
                          // Show ingest time (same logic as native SVG tooltip)
                          const ingestTime =
                            t.ingest_ts || t.ingest_time || t.ts;
                          if (ingestTime) {
                            try {
                              const timeValue =
                                typeof ingestTime === "string"
                                  ? new Date(ingestTime)
                                  : new Date(Number(ingestTime));
                              if (!isNaN(timeValue.getTime())) {
                                const ageMs = Date.now() - timeValue.getTime();
                                const ageMinutes = Math.floor(ageMs / 60000);
                                const ageHours = Math.floor(ageMinutes / 60);
                                const isStale = ageMinutes > 30;

                                const displayTime =
                                  timeValue.toLocaleTimeString("en-US", {
                                    hour: "numeric",
                                    minute: "2-digit",
                                    hour12: true,
                                  });
                                const displayDate =
                                  timeValue.toLocaleDateString("en-US", {
                                    month: "short",
                                    day: "numeric",
                                  });
                                return (
                                  <div
                                    className={`text-[10px] mb-2 ${
                                      isStale
                                        ? "text-yellow-400"
                                        : "text-[#93a4d6]"
                                    }`}
                                  >
                                    {displayDate} {displayTime}
                                    {isStale && (
                                      <span
                                        className="ml-1"
                                        title={`Data is ${
                                          ageHours > 0 ? `${ageHours}h ` : ""
                                        }${ageMinutes % 60}m old`}
                                      >
                                        ⚠️
                                      </span>
                                    )}
                                  </div>
                                );
                              }
                            } catch (e) {}
                          }
                          return null;
                        })()}
                        {isPrimeBubble(t) && (
                          <div className="mb-2 px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold text-center">
                            ⭐ PRIME SETUP
                          </div>
                        )}
                        <div className="space-y-1">
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Score</span>
                            <span className="font-semibold">
                              {t.rank || "—"}
                            </span>
                          </div>
                          {rankPosition !== null && totalTickers > 0 && (
                            <div className="flex justify-between">
                              <span className="text-[#93a4d6]">Rank</span>
                              <span className="font-semibold">
                                {rankPosition} / {totalTickers}
                              </span>
                            </div>
                          )}
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">RR</span>
                            <span className="font-semibold">
                              {t.rr ? Number(t.rr).toFixed(2) : "—"}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">State</span>
                            <span className="font-semibold">
                              {t.state || "—"}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Phase</span>
                            <span
                              className="font-semibold"
                              style={{
                                color: phaseToColor(Number(t.phase_pct) || 0),
                              }}
                            >
                              {Math.round((Number(t.phase_pct) || 0) * 100)}%
                              {t.phase_zone && ` (${t.phase_zone})`}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Completion</span>
                            <span className="font-semibold">
                              {Math.round(completionForSize(t) * 100)}%
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Horizon</span>
                            <span className="font-semibold">
                              {(() => {
                                const eta = computeEtaDays(t);
                                const bucket = String(
                                  t.horizon_bucket || ""
                                )
                                  .trim()
                                  .toUpperCase();
                                if (bucket) return bucket.replace("_", " ");
                                if (!Number.isFinite(eta)) return "—";
                                if (eta <= 7) return "SHORT TERM";
                                if (eta <= 30) return "SWING";
                                return "POSITIONAL";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">ETA</span>
                            <span className="font-semibold">
                              {(() => {
                                const eta = computeEtaDays(t);
                                return Number.isFinite(eta)
                                  ? `${eta.toFixed(1)}d`
                                  : "—";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Return %</span>
                            <span className="font-semibold">
                              {(() => {
                                const ret = computeReturnPct(t);
                                return Number.isFinite(ret)
                                  ? `${ret.toFixed(1)}%`
                                  : "—";
                              })()}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-[#93a4d6]">Risk %</span>
                            <span className="font-semibold">
                              {(() => {
                                const risk = computeRiskPct(t);
                                return Number.isFinite(risk)
                                  ? `${risk.toFixed(1)}%`
                                  : "—";
                              })()}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  }}
                />
                <Scatter data={data} shape={BubbleShape} />
              </ScatterChart>
            </ResponsiveContainer>

            {/* Trail rendering overlay for selected ticker (Recharts mode) */}
            {selectedTicker &&
              selectedTrail &&
              Array.isArray(selectedTrail) &&
              selectedTrail.length > 1 && (
                <svg
                  className="absolute inset-0 pointer-events-none z-10"
                  style={{ width: "100%", height: "100%" }}
                >
                  <defs>
                    <linearGradient
                      id="trailGradient"
                      x1="0%"
                      y1="0%"
                      x2="100%"
                      y2="100%"
                    >
                      <stop offset="0%" stopColor="#00ffff" stopOpacity="0.3" />
                      <stop
                        offset="100%"
                        stopColor="#00ffff"
                        stopOpacity="0.6"
                      />
                    </linearGradient>

                    {/* Arrowhead marker for the Bubble Trail path */}
                    <marker
                      id="trailArrowRecharts"
                      viewBox="0 0 10 10"
                      refX="9"
                      refY="5"
                      markerWidth="6"
                      markerHeight="6"
                      orient="auto"
                    >
                      <path
                        d="M 0 0 L 10 5 L 0 10 z"
                        fill="#00ffff"
                        opacity="0.8"
                      />
                    </marker>
                  </defs>
                  <g>
                    {/* Trail lines */}
                    {(() => {
                      const chartWidth =
                        chartContainerRef.current?.clientWidth || 1200;
                      const chartHeight =
                        chartContainerRef.current?.clientHeight || 800;
                      const margin = 20;
                      const plotWidth = chartWidth - 2 * margin;
                      const plotHeight = chartHeight - 2 * margin;

                      const GAP_MS = 30 * 60 * 1000;
                      const segments = splitTrailByGaps(selectedTrail, GAP_MS);

                      return segments
                        .filter((seg) => Array.isArray(seg) && seg.length > 1)
                        .map((seg, segIdx) => {
                          const pts = seg.map((p) => ({
                            x:
                              (((Number(p?.ltf_score) || 0) + 50) / 100) *
                                plotWidth +
                              margin,
                            y:
                              ((50 - (Number(p?.htf_score) || 0)) / 100) *
                                plotHeight +
                              margin,
                          }));
                          const d = catmullRomPath(pts);
                          if (!d) return null;
                          const isLast = segIdx === segments.length - 1;
                          const opacity =
                            0.35 +
                            (segIdx / Math.max(1, segments.length - 1)) * 0.25;
                          return (
                            <path
                              key={`trail-path-recharts-${segIdx}`}
                              d={d}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity={opacity}
                              className="trail-path"
                              markerEnd={
                                isLast ? "url(#trailArrowRecharts)" : undefined
                              }
                            />
                          );
                        });
                    })()}
                    {/* Trail points (historical bubbles) */}
                    {selectedTrail.slice(0, -1).map((point, idx) => {
                      const chartWidth =
                        chartContainerRef.current?.clientWidth || 1200;
                      const chartHeight =
                        chartContainerRef.current?.clientHeight || 800;
                      const margin = 20;
                      const plotWidth = chartWidth - 2 * margin;
                      const plotHeight = chartHeight - 2 * margin;

                      const cx =
                        (((Number(point.ltf_score) || 0) + 50) / 100) *
                          plotWidth +
                        margin;
                      const cy =
                        ((50 - (Number(point.htf_score) || 0)) / 100) *
                          plotHeight +
                        margin;
                      const visual = bubbleVisualForTrailPoint(
                        point,
                        selectedTicker
                      );
                      const size = visual.radius;
                      const opacity = 0.3 + (idx / selectedTrail.length) * 0.4;
                      const color = visual.color;

                      return (
                        <circle
                          key={`trail-point-${idx}`}
                          cx={cx}
                          cy={cy}
                          r={size}
                          fill={color}
                          fillOpacity={opacity}
                          stroke={color}
                          strokeWidth="1"
                          strokeOpacity={opacity * 0.5}
                        />
                      );
                    })}
                    {/* Highlight a specific historical point (from Bubble Journey hover/click) */}
                    {highlightTrailPoint &&
                      Number.isFinite(Number(highlightTrailPoint?.ltf_score)) &&
                      Number.isFinite(Number(highlightTrailPoint?.htf_score)) &&
                      (() => {
                        const chartWidth =
                          chartContainerRef.current?.clientWidth || 1200;
                        const chartHeight =
                          chartContainerRef.current?.clientHeight || 800;
                        const margin = 20;
                        const plotWidth = chartWidth - 2 * margin;
                        const plotHeight = chartHeight - 2 * margin;

                        const hx =
                          (((Number(highlightTrailPoint.ltf_score) || 0) + 50) /
                            100) *
                            plotWidth +
                          margin;
                        const hy =
                          ((50 - (Number(highlightTrailPoint.htf_score) || 0)) /
                            100) *
                            plotHeight +
                          margin;

                        const visual = bubbleVisualForTrailPoint(
                          highlightTrailPoint,
                          selectedTicker
                        );
                        const r = Math.max(3, Number(visual?.radius) || 6);

                        return (
                          <g
                            key={`trail-highlight-recharts-${String(
                              highlightTrailPoint?.ts ?? ""
                            )}`}
                            pointerEvents="none"
                          >
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 3}
                              fill="none"
                              stroke="#00ffff"
                              strokeWidth="2.25"
                              opacity="0.9"
                            >
                              <animate
                                attributeName="r"
                                values={`${r + 2};${r + 10};${r + 2}`}
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                              <animate
                                attributeName="opacity"
                                values="0.95;0.25;0.95"
                                dur="1.4s"
                                repeatCount="indefinite"
                              />
                            </circle>
                            <circle
                              cx={hx}
                              cy={hy}
                              r={r + 1}
                              fill="none"
                              stroke={visual?.color || "#00ffff"}
                              strokeWidth="1.5"
                              opacity="0.8"
                            />
                          </g>
                        );
                      })()}
                  </g>
                </svg>
              )}

            {/* Crosshair value labels for Recharts */}
            {rechartsCrosshair && (
              <>
                {rechartsCrosshair.ltfValue !== null && (
                  <div
                    className="absolute bg-[#0b1020] border border-[#00ffff] rounded px-2 py-1 text-[#00ffff] text-xs font-semibold pointer-events-none z-20"
                    style={{
                      left: `${rechartsCrosshair.x + 20}px`,
                      bottom: "20px",
                      transform: "translateX(-50%)",
                    }}
                  >
                    LTF: {rechartsCrosshair.ltfValue.toFixed(1)}
                  </div>
                )}
                {rechartsCrosshair.htfValue !== null && (
                  <div
                    className="absolute bg-[#0b1020] border border-[#00ffff] rounded px-2 py-1 text-[#00ffff] text-xs font-semibold pointer-events-none z-20"
                    style={{
                      left: "20px",
                      top: `${rechartsCrosshair.y + 20}px`,
                      transform: "translateY(-50%)",
                    }}
                  >
                    HTF: {rechartsCrosshair.htfValue.toFixed(1)}
                  </div>
                )}
              </>
            )}
          </div>
        );
      }

      // Format date/time from timestamp
      function formatTriggerDateTime(ts) {
        if (!ts || typeof ts !== "number") return "—";
        const date = new Date(ts);
        return {
          date: date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          }),
          time: date.toLocaleTimeString("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          }),
        };
      }

      // Get "Why" reason from ticker data
      function getWhyReason(ticker) {
        const reasons = ticker.reasons || [];
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        if (flags.sq30_release) return "Squeeze Release";
        if (flags.phase_zone_change) return "Phase Zone Change";
        if (state.includes("BULL") && state.includes("BULL"))
          return "Both Timeframes Bullish";
        if (state.includes("BEAR") && state.includes("BEAR"))
          return "Both Timeframes Bearish";
        if (reasons.length > 0) return reasons[0];
        return "Setup Active";
      }

      const ENTRY_DECISION_LABELS = {
        futures_disabled: "Futures excluded",
        missing_levels: "Missing price/SL/TP",
        not_in_corridor: "Not in entry corridor",
        corridor_misaligned: "Corridor misaligned",
        no_trigger: "No trigger/squeeze",
        rr_below_min: "RR below minimum",
        completion_high: "Completion too high",
        phase_high: "Phase too high",
        rank_low: "Rank too low",
        stale_data: "Data delayed",
      };

      function summarizeEntryDecision(ticker) {
        const decision = ticker?.entry_decision;
        if (!decision || typeof decision !== "object") return null;
        const blockers = Array.isArray(decision.blockers)
          ? decision.blockers
          : [];
        const warnings = Array.isArray(decision.warnings)
          ? decision.warnings
          : [];
        const label = (code) =>
          ENTRY_DECISION_LABELS[code] || String(code || "").replace(/_/g, " ");
        if (decision.ok) {
          return {
            status: "Eligible",
            detail: "All entry checks passed",
            tone: "text-green-400",
            bg: "bg-green-500/20",
            blockers: [],
            warnings: warnings.map(label),
          };
        }
        if (blockers.length === 0) {
          return {
            status: "Waiting",
            detail: "Setup not confirmed yet",
            tone: "text-[#93a4d6]",
            bg: "bg-[#26325f]",
            blockers: [],
            warnings: warnings.map(label),
          };
        }
        const shown = blockers.slice(0, 3).map(label);
        const extra = blockers.length > 3 ? ` +${blockers.length - 3} more` : "";
        return {
          status: "Blocked",
          detail: `${shown.join(", ")}${extra}`,
          tone: "text-yellow-400",
          bg: "bg-yellow-500/20",
          blockers: blockers.map(label),
          warnings: warnings.map(label),
        };
      }

      // Get direction from state
      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL"))
          return {
            text: "LONG",
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        if (state.includes("BEAR"))
          return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: "—", color: "text-[#93a4d6]", bg: "bg-[#26325f]" };
      }

      function SetupCard({ ticker, isSelected, onClick }) {
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const momentumElite = !!flags.momentum_elite;
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const dir = getDirection(ticker);
        const why = getWhyReason(ticker);
        const triggerDT = formatTriggerDateTime(ticker.trigger_ts);
        const tpLevels = ticker.tp_levels || [];
        const comp = completionForSize(ticker);
        const decision = summarizeEntryDecision(ticker);

        return (
          <div
            className={`p-1.5 rounded-lg border cursor-pointer transition-all ${
              isSelected
                ? "border-blue-500 bg-blue-500/10 shadow-lg"
                : momentumElite
                ? "border-purple-500 bg-purple-500/15 momentum-elite-glow border-2"
                : prime
                ? "border-green-500 bg-green-500/10 prime-glow"
                : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0]"
            }`}
            onClick={onClick}
          >
            {/* Header */}
            <div className="flex items-center justify-between mb-1">
              <div className="flex items-center gap-1.5">
                <span className="font-bold text-sm">{ticker.ticker}</span>
                {momentumElite && (
                  <span
                    className="text-purple-400 text-xs font-bold"
                    title="Momentum Elite"
                  >
                    🚀
                  </span>
                )}
                {prime && <span className="text-green-500 text-xs">⭐</span>}
                {flags.sq30_release && (
                  <span className="text-cyan-400 text-xs">⚡</span>
                )}
                {flags.sq30_on && (
                  <span className="text-yellow-400 text-xs">🧨</span>
                )}
              </div>
              <div className="flex items-center gap-1.5">
                {ticker.price && (
                  <div className="text-right">
                    <span className="text-xs font-semibold text-white">
                      ${Number(ticker.price).toFixed(2)}
                    </span>
                    {(() => {
                      // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                      const ingestTime =
                        ticker.ingest_ts || ticker.ingest_time || ticker.ts;
                      if (ingestTime) {
                        try {
                          const timeValue =
                            typeof ingestTime === "string"
                              ? new Date(ingestTime)
                              : new Date(Number(ingestTime));
                          if (!isNaN(timeValue.getTime())) {
                            const ageMs = Date.now() - timeValue.getTime();
                            const ageMinutes = Math.floor(ageMs / 60000);
                            const ageHours = Math.floor(ageMinutes / 60);

                            // Warn if data is stale (older than 30 minutes)
                            const isStale = ageMinutes > 30;

                            const displayTime = timeValue.toLocaleTimeString(
                              "en-US",
                              {
                                hour: "numeric",
                                minute: "2-digit",
                                hour12: true,
                              }
                            );
                            const displayDate = timeValue.toLocaleDateString(
                              "en-US",
                              {
                                month: "short",
                                day: "numeric",
                              }
                            );
                            return (
                              <div
                                className={`text-[9px] mt-0.5 ${
                                  isStale ? "text-yellow-400" : "text-[#93a4d6]"
                                }`}
                              >
                                {displayDate} {displayTime}
                                {isStale && (
                                  <span
                                    className="ml-0.5"
                                    title={`Data is ${
                                      ageHours > 0 ? `${ageHours}h ` : ""
                                    }${ageMinutes % 60}m old`}
                                  >
                                    ⚠️
                                  </span>
                                )}
                              </div>
                            );
                          }
                        } catch (e) {}
                      }
                      return null;
                    })()}
                  </div>
                )}
                <div
                  className={`px-1.5 py-0.5 rounded font-bold text-[10px] ${dir.bg} ${dir.color}`}
                >
                  {dir.text}
                </div>
              </div>
            </div>

            {/* Why and Action - Compact */}
            <div className="mb-1">
              <div className="text-[8px] text-[#93a4d6] mb-0.5">
                Why:{" "}
                <span className="text-white font-semibold text-[9px]">
                  {why}
                </span>
              </div>
              {(() => {
                const actionInfo = getActionDescription(ticker);
                return (
                  <div
                    className={`text-[8px] ${actionInfo.color} font-semibold`}
                  >
                    {actionInfo.action}
                  </div>
                );
              })()}
            </div>

            {/* Price, SL, TP - Compact inline */}
            <div className="grid grid-cols-3 gap-1 mb-1 text-[8px]">
              {ticker.price && (
                <div>
                  <div className="text-[8px] text-[#93a4d6]">Price</div>
                  <div className="font-semibold text-white">
                    ${Number(ticker.price).toFixed(2)}
                  </div>
                </div>
              )}
              <div>
                <div className="text-[8px] text-[#93a4d6]">SL</div>
                <div className="font-semibold text-red-400">
                  {ticker.sl ? `$${Number(ticker.sl).toFixed(2)}` : "—"}
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6]">TP</div>
                <div className="font-semibold text-green-400">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "—"}
                </div>
              </div>
            </div>

            {/* Trigger Info - Compact */}
            {ticker.trigger_price && (
              <div className="mb-1 text-[8px]">
                <span className="text-[#93a4d6]">Trigger: </span>
                <span className="text-white font-semibold">
                  ${Number(ticker.trigger_price).toFixed(2)}
                </span>
                {ticker.trigger_ts && (
                  <>
                    <span className="text-[#93a4d6] ml-1.5">@ </span>
                    <span className="text-white text-[7px]">
                      {triggerDT.date} {triggerDT.time}
                    </span>
                  </>
                )}
              </div>
            )}

            {/* Phase and Completion - Compact */}
            <div className="grid grid-cols-2 gap-1 mb-1">
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Phase</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full transition-all"
                    style={{
                      width: `${phase * 100}%`,
                      backgroundColor: phaseColor,
                    }}
                  />
                </div>
                <div
                  className="text-[9px] mt-0.5"
                  style={{ color: phaseColor }}
                >
                  {Math.round(phase * 100)}%
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Complete</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full bg-blue-500 transition-all"
                    style={{ width: `${comp * 100}%` }}
                  />
                </div>
                <div className="text-[9px] mt-0.5 text-blue-400">
                  {Math.round(comp * 100)}%
                </div>
              </div>
            </div>

            {/* TP Levels - Compact */}
            {tpLevels.length > 1 && (
              <div className="mb-1">
                <div className="flex flex-wrap gap-0.5">
                  {tpLevels.slice(0, 2).map((tp, idx) => (
                    <span
                      key={idx}
                      className="px-0.5 py-0 rounded bg-green-500/20 text-green-400 text-[7px] font-mono"
                    >
                      TP{idx + 1}: ${Number(tp).toFixed(2)}
                    </span>
                  ))}
                  {tpLevels.length > 2 && (
                    <span className="px-0.5 py-0 rounded bg-[#26325f] text-[#93a4d6] text-[7px]">
                      +{tpLevels.length - 2}
                    </span>
                  )}
                </div>
              </div>
            )}

            {/* Additional Info - Compact */}
            <div className="flex items-center justify-between text-[8px] pt-0.5 border-t border-[#26325f]/50">
              <div className="flex gap-1">
                <span className="px-1 py-0.5 rounded bg-[#26325f]">
                  R{ticker.rank || "—"}
                </span>
                {ticker.rr && (
                  <span className="px-1 py-0.5 rounded bg-[#26325f]">
                    RR{Number(ticker.rr).toFixed(1)}
                  </span>
                )}
              </div>
              {ent.corridor && (
                <span
                  className={`px-1 py-0.5 rounded text-[8px] font-semibold ${dir.bg} ${dir.color}`}
                >
                  {ent.side}
                </span>
              )}
            </div>
            {decision && (
              <div className="mt-1 text-[8px] text-[#93a4d6]">
                <span
                  className={`px-1 py-0.5 rounded ${decision.bg} ${decision.tone}`}
                  title={
                    decision.blockers && decision.blockers.length > 0
                      ? `Blocked: ${decision.blockers.join(", ")}`
                      : decision.warnings && decision.warnings.length > 0
                      ? `Warnings: ${decision.warnings.join(", ")}`
                      : ""
                  }
                >
                  {decision.status}
                </span>
                <span className="ml-1">{decision.detail}</span>
                {decision.warnings && decision.warnings.length > 0 && (
                  <span className="ml-1 text-yellow-300">
                    • {decision.warnings[0]}
                  </span>
                )}
              </div>
            )}
          </div>
        );
      }

      // Generate plain English action description
      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const momentumPct = ticker.momentum_pct || {};

        const isAligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;

        // High completion = near target, consider exit/trim
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(
              0
            )}% completion, indicating the move is near its target. ${
              momentumElite ? "Despite Momentum Elite status, " : ""
            }Consider taking profits or trimming 50-75% of position to lock in gains while allowing runners to continue. Monitor for signs of reversal or continuation beyond TP levels.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // High phase = late in cycle, be cautious
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(
              0
            )}% indicates late-cycle conditions. ${
              momentumElite
                ? "While Momentum Elite suggests continued strength, "
                : ""
            }Market is approaching exhaustion zone. Wait for pullback to better entry or trim existing positions by 30-50% to reduce risk. Look for phase reset or continuation signals before adding size.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20",
          };
        }

        // Momentum Elite + Prime setup = strongest signal
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          const momentumStr =
            momentumPct.month != null
              ? ` with ${Number(momentumPct.month).toFixed(
                  0
                )}% monthly momentum`
              : "";
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock${momentumStr} showing Prime setup with exceptional alignment. Both HTF and LTF are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2
            )}:1). This represents a high-probability setup with strong fundamentals backing the technical signal. Consider entering with full position size, using TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Momentum Elite + Squeeze release = strong momentum signal
        if (momentumElite && sqRelease && inCorridor && isAligned) {
          const momentumStr =
            momentumPct.week != null
              ? ` (${Number(momentumPct.week).toFixed(0)}% weekly)`
              : "";
          return {
            action: "Initiate Position - Momentum Breakout",
            description: `Momentum Elite stock${momentumStr} experiencing squeeze release with timeframe alignment. This indicates pent-up energy being released in the direction of the trend. The combination of Momentum Elite fundamentals and technical squeeze release creates a high-probability momentum continuation setup. Enter on pullback to corridor or on break of squeeze high/low, targeting TP levels.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Prime setup with good conditions = initiate
        if (isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - Prime Setup",
            description: `Prime setup detected with strong technical alignment. Both timeframes are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2
            )}:1). ${
              momentumElite
                ? "Momentum Elite status adds fundamental strength to this technical setup. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) with low completion (${(
              comp * 100
            ).toFixed(
              0
            )}%) suggests room to run. Consider entering position, using SL for risk management and TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Momentum Elite + In corridor = quality momentum play
        if (
          momentumElite &&
          inCorridor &&
          isAligned &&
          comp < 0.5 &&
          phase < 0.6
        ) {
          return {
            action: "Consider Entry - Momentum Elite Setup",
            description: `Momentum Elite stock in favorable technical setup. Price is in entry corridor with both timeframes aligned, early phase (${(
              phase * 100
            ).toFixed(0)}%), and low completion (${(comp * 100).toFixed(
              0
            )}%) indicating room for continuation. ${
              sqRelease
                ? "Squeeze release adds momentum confirmation. "
                : sqOn
                ? "Squeeze building suggests potential breakout. "
                : ""
            }The combination of strong fundamentals (Momentum Elite) and favorable technicals creates a quality setup. Enter on confirmation or pullback, targeting TP levels.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Squeeze release in corridor = strong signal
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. This indicates pent-up energy being released in the direction of the trend. ${
              momentumElite
                ? "Momentum Elite status adds fundamental backing to this technical signal. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(
              comp * 100
            ).toFixed(
              0
            )}%) suggest continuation potential. Enter on pullback or break, using SL for protection and TP levels as targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // In corridor and aligned = good setup
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase (${(
              phase * 100
            ).toFixed(0)}%) and low completion (${(comp * 100).toFixed(
              0
            )}%) suggest room to run. ${
              momentumElite
                ? "Momentum Elite status adds quality to this setup. "
                : ""
            }${
              sqOn ? "Squeeze building suggests potential momentum. " : ""
            }Rank is ${
              rank >= 70 ? "strong" : "moderate"
            } (${rank}) with RR of ${rr.toFixed(
              2
            )}:1. Monitor for entry confirmation or wait for squeeze release signal before initiating position.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Pullback setup = wait for confirmation
        if (isPullback && !inCorridor) {
          return {
            action: "Wait for Entry - Pullback Setup",
            description: `Pullback detected (${state}) but price not yet in entry corridor. ${
              momentumElite
                ? "Momentum Elite status suggests this pullback may be shallow and could present a quality entry. "
                : ""
            }Wait for price to enter corridor (Q1→Q2 for LONG, Q4→Q3 for SHORT) before considering entry. ${
              sqOn
                ? "Squeeze building suggests potential momentum when released. "
                : ""
            }Monitor for corridor entry and confirmation signals before initiating position.`,
            color: "text-cyan-400",
            bg: "bg-cyan-500/20",
          };
        }

        // Squeeze on but not released = building pressure
        if (sqOn && !sqRelease) {
          return {
            action: "Monitor Closely - Squeeze Building",
            description: `Squeeze building but not yet released, indicating pressure is accumulating. ${
              momentumElite
                ? "Momentum Elite status suggests when released, the move could be significant. "
                : ""
            }${
              inCorridor
                ? "Price is in entry corridor, making this a high-probability setup when squeeze releases. "
                : "Wait for price to enter corridor and squeeze to release before entering. "
            }Monitor closely for squeeze release signal, which typically provides strong directional momentum.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // Default: wait
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. ${
            momentumElite ? "Momentum Elite status is positive, but " : ""
          }Technical conditions need improvement. ${
            !inCorridor ? "Price needs to enter entry corridor. " : ""
          }${!isAligned ? "Timeframes need better alignment. " : ""}${
            comp > 0.5
              ? `Completion is high (${(comp * 100).toFixed(
                  0
                )}%), reducing upside potential. `
              : ""
          }Wait for better conditions, confirmation signals, or entry corridor alignment before considering position.`,
          color: "text-[#93a4d6]",
          bg: "bg-[#26325f]",
        };
      }

      // ─────────────────────────────────────────────────────────────
      // Activity Feed Component
      // ─────────────────────────────────────────────────────────────
      function ActivityFeed({ onTickerClick, tickerData }) {
        const [events, setEvents] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [searchQuery, setSearchQuery] = useState("");
        const [activeFilter, setActiveFilter] = React.useState(null);
        const feedRef = React.useRef(null);

        // Helper to get latest ticker data and merge with event
        // IMPORTANT: Always use latest RR from tickerData to match Bubble Chart (which recomputes RR)
        // This ensures Activity Feed RR matches Bubble Chart RR (both use recomputed values from /timed/all)
        const getEventWithTickerData = useCallback(
          (event) => {
            const latestData = tickerData?.[event.ticker] || {};
            // Merge event data with latest ticker data, preferring latest data for RR (matches Bubble Chart computation)
            // Use event data for historical snapshots (price, sl, tp at event time) but latest RR for consistency
            return {
              ...event,
              price: event.price || latestData.price,
              sl: event.sl !== undefined ? event.sl : latestData.sl,
              tp: event.tp !== undefined ? event.tp : latestData.tp,
              tp_levels: event.tp_levels || latestData.tp_levels,
              // Always use latest RR to match Bubble Chart (which uses recomputed RR from /timed/all)
              // This ensures consistency since worker recomputes RR using fused SL levels
              rr: latestData.rr !== undefined ? latestData.rr : event.rr,
              phase_pct:
                event.phase_pct !== undefined
                  ? event.phase_pct
                  : latestData.phase_pct,
              completion:
                event.completion !== undefined
                  ? event.completion
                  : latestData.completion,
              // Include momentum_pct from latest data if available
              momentum_pct: latestData.momentum_pct || event.momentum_pct,
            };
          },
          [tickerData]
        );

        const fetchActivity = React.useCallback(async (isRetry = false) => {
          try {
            setLoading(true);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // Increased timeout to 10s

            // Add timestamp to URL to prevent caching on hard refresh
            const timestamp = Date.now();
            const res = await fetch(
              `https://timed-trading-ingest.shashant.workers.dev/timed/activity?limit=50&_t=${timestamp}`,
              {
                signal: controller.signal,
                cache: "no-store", // Prevent caching issues on hard refresh
                headers: {
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                  "X-Request-ID": `activity-${timestamp}`, // Additional cache busting header
                },
              }
            );
            clearTimeout(timeoutId);

            if (!res.ok) {
              throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }

            const data = await res.json();

            if (data.ok && Array.isArray(data.events)) {
              setEvents(data.events);
              setError(null); // Clear any previous errors
            } else {
              // Log error for debugging
              console.warn("Activity feed response:", {
                status: res.status,
                ok: res.ok,
                dataOk: data.ok,
                error: data.error,
                eventsCount: data.events?.length || 0,
              });

              // Handle rate limit error
              if (res.status === 429) {
                setError(
                  "Rate limit exceeded. Please wait a moment and refresh."
                );
              } else if (data.error) {
                setError(data.error);
              } else {
                setError(null);
              }

              // Still set events if it's an empty array (no error, just no data)
              if (Array.isArray(data.events)) {
                setEvents(data.events);
              }
            }
          } catch (err) {
            if (err.name !== "AbortError") {
              console.error("Activity feed fetch error:", err);
              setError("Failed to load activity feed");
              // Retry after a short delay on first load failure (only once)
              if (!isRetry) {
                setTimeout(() => {
                  fetchActivity(true);
                }, 2000);
              }
            }
          } finally {
            setLoading(false);
          }
        }, []);

        // Initial fetch and periodic refresh - ensure it runs on mount
        React.useEffect(() => {
          // Use a small delay to ensure component is fully mounted
          const initialTimeout = setTimeout(() => {
            fetchActivity();
          }, 100);

          const interval = setInterval(fetchActivity, 5 * 60 * 1000); // Refresh every 5 minutes to align with data updates

          return () => {
            clearTimeout(initialTimeout);
            clearInterval(interval);
          };
        }, [fetchActivity]);

        // Auto-scroll to top when new events arrive
        React.useEffect(() => {
          if (feedRef.current && events.length > 0) {
            feedRef.current.scrollTop = 0;
          }
        }, [events.length]);

        const formatTime = (ts) => {
          const date = new Date(ts);
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / 60000);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);

          if (diffMins < 1) return "just now";
          if (diffMins < 60) return `${diffMins}m ago`;
          if (diffHours < 24) return `${diffHours}h ago`;
          if (diffDays < 7) return `${diffDays}d ago`;
          return date.toLocaleDateString();
        };

        const getEventIcon = (type) => {
          switch (type) {
            case "corridor_entry":
              return "🚪";
            case "squeeze_start":
              return "⚡";
            case "squeeze_release":
              return "💥";
            case "state_aligned":
              return "🎯";
            case "momentum_elite":
              return "🚀";
            case "td9_exit":
              return "🔢";
            case "td9_entry":
              return "🔢";
            case "discord_alert":
              return "📢";
            case "trade_entry":
              return "✅";
            case "ingest_missing":
              return "⏱️";
            default:
              return "📊";
          }
        };

        const getEventColor = (type) => {
          switch (type) {
            case "corridor_entry":
              return "text-blue-400";
            case "squeeze_start":
              return "text-yellow-400";
            case "squeeze_release":
              return "text-green-400";
            case "state_aligned":
              return "text-purple-400";
            case "momentum_elite":
              return "text-pink-400";
            case "td9_exit":
              return "text-orange-400";
            case "td9_entry":
              return "text-cyan-400";
            case "discord_alert":
              return "text-indigo-400";
            case "trade_entry":
              return "text-green-400";
            case "ingest_missing":
              return "text-red-400";
            default:
              return "text-gray-400";
          }
        };

        const getEventLabel = (event) => {
          switch (event.type) {
            case "corridor_entry":
              return `${event.ticker} entered ${event.side || "corridor"}`;
            case "squeeze_start":
              return `${event.ticker} squeeze started`;
            case "squeeze_release":
              return `${event.ticker} squeeze released${
                event.side ? ` (${event.side})` : ""
              }`;
            case "state_aligned":
              return `${event.ticker} aligned ${event.side || ""}`;
            case "momentum_elite":
              return `${event.ticker} Momentum Elite`;
            case "td9_exit":
              return `${event.ticker} TD9 Exit ${event.direction || ""}`;
            case "td9_entry":
              return `${event.ticker} TD9 Entry ${event.direction || ""}`;
            case "discord_alert":
              return `📢 Alert Fired: ${event.ticker} ${
                event.direction || event.action || ""
              } ${event.action === "entry" ? "Entry" : ""}`;
            case "trade_entry":
              return `✅ Trade Entered: ${event.ticker} ${
                event.direction || ""
              }`;
            case "ingest_missing":
              return `⏱️ Missing ingest: ${event.ticker} ${
                event.age_min != null ? `(${event.age_min}m)` : ""
              }`;
            default:
              return `${event.ticker} event`;
          }
        };

        // Filter events by search query and active filter
        const filteredEvents = useMemo(() => {
          let filtered = events;

          // Apply type filter
          if (activeFilter) {
            filtered = filtered.filter((event) => event.type === activeFilter);
          }

          // Apply search query
          if (searchQuery.trim()) {
            const query = searchQuery.toLowerCase();
            filtered = filtered.filter((event) => {
              const ticker = (event.ticker || "").toLowerCase();
              const type = (event.type || "").toLowerCase();
              const direction = (event.direction || "").toLowerCase();
              const side = (event.side || "").toLowerCase();
              return (
                ticker.includes(query) ||
                type.includes(query) ||
                direction.includes(query) ||
                side.includes(query)
              );
            });
          }

          return filtered;
        }, [events, searchQuery, activeFilter]);

        return (
          <div className="w-80 bg-[#0f1630] border border-[#26325f] rounded-xl p-4 flex flex-col">
            <div className="flex items-center justify-between mb-3 pb-2 border-b border-[#26325f]">
              <h3 className="text-lg font-semibold text-white">
                Activity Feed
              </h3>
              <button
                onClick={fetchActivity}
                className="text-xs text-[#93a4d6] hover:text-white transition-colors"
                title="Refresh"
              >
                ↻
              </button>
            </div>

            {/* Search Bar and Filter Tags */}
            <div className="mb-3 space-y-2">
              <input
                type="text"
                placeholder="Search events..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full px-3 py-1.5 text-xs bg-[#121a33] border border-[#26325f] rounded text-white placeholder-[#6b7a9f] focus:outline-none focus:border-[#3a4a7a]"
              />
              {/* Filter Tags */}
              <div className="flex flex-wrap gap-1.5">
                {[
                  { label: "All", type: null },
                  { label: "Trade Entered", type: "trade_entry" },
                  { label: "Alerts", type: "discord_alert" },
                  { label: "Squeeze", type: "squeeze_release" },
                  { label: "Ingest Missing", type: "ingest_missing" },
                ].map((filter) => (
                  <button
                    key={filter.label}
                    onClick={() =>
                      setActiveFilter(
                        activeFilter === filter.type ? null : filter.type
                      )
                    }
                    className={`px-2 py-0.5 text-[10px] rounded border transition-colors ${
                      activeFilter === filter.type
                        ? "bg-blue-500/20 border-blue-500 text-blue-400"
                        : "bg-[#121a33] border-[#26325f] text-[#93a4d6] hover:border-[#3a4a7a]"
                    }`}
                  >
                    {filter.label}
                  </button>
                ))}
              </div>
            </div>

            <div
              ref={feedRef}
              className="flex-1 overflow-y-auto space-y-2 pr-2"
              style={{ maxHeight: "760px" }}
            >
              {loading && events.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  <div className="loading-spinner mx-auto mb-2"></div>
                  Loading events...
                </div>
              ) : error ? (
                <div className="text-center text-yellow-400 py-8 px-2">
                  <div className="text-sm mb-2">{error}</div>
                  <button
                    onClick={fetchActivity}
                    className="text-xs text-[#93a4d6] hover:text-white underline"
                  >
                    Retry
                  </button>
                </div>
              ) : filteredEvents.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  {searchQuery.trim()
                    ? "No events match your search"
                    : "No recent activity"}
                </div>
              ) : (
                filteredEvents.map((event) => {
                  const eventData = getEventWithTickerData(event);
                  // Calculate Max TP from tp_levels array
                  let maxTP = eventData.tp;
                  if (
                    eventData.tp_levels &&
                    Array.isArray(eventData.tp_levels) &&
                    eventData.tp_levels.length > 0
                  ) {
                    const tpPrices = eventData.tp_levels
                      .map((tpItem) => {
                        if (
                          typeof tpItem === "object" &&
                          tpItem !== null &&
                          tpItem.price != null
                        ) {
                          return Number(tpItem.price);
                        }
                        return typeof tpItem === "number"
                          ? tpItem
                          : Number(tpItem);
                      })
                      .filter((p) => Number.isFinite(p));
                    if (tpPrices.length > 0) {
                      maxTP = Math.max(...tpPrices);
                    }
                  }

                  return (
                    <div
                      key={event.id || `${event.ticker}-${event.ts}`}
                      onClick={() =>
                        onTickerClick && onTickerClick(event.ticker)
                      }
                      className="bg-[#121a33] border border-[#26325f] rounded p-2 text-xs hover:border-[#3a4a7a] hover:bg-[#1a2440] transition-colors cursor-pointer"
                    >
                      <div className="flex items-start justify-between gap-2 mb-1.5">
                        <div className="flex items-center gap-1.5 flex-1 min-w-0">
                          <span className="text-base">
                            {getEventIcon(event.type)}
                          </span>
                          <div className="flex-1 min-w-0">
                            <span
                              className={`font-semibold ${getEventColor(
                                event.type
                              )} truncate block`}
                            >
                              {getEventLabel(event)}
                            </span>
                            {eventData.price && (
                              <div className="text-[10px] text-white mt-0.5">
                                ${Number(eventData.price).toFixed(2)}
                                {(() => {
                                  // Prioritize ingest_ts (when data was ingested) over ts (TradingView timestamp)
                                  const ingestTime =
                                    eventData.ingest_ts ||
                                    eventData.ingest_time ||
                                    eventData.ts ||
                                    event.ts;
                                  if (ingestTime) {
                                    try {
                                      const timeValue =
                                        typeof ingestTime === "string"
                                          ? new Date(ingestTime)
                                          : new Date(Number(ingestTime));
                                      if (!isNaN(timeValue.getTime())) {
                                        const ageMs =
                                          Date.now() - timeValue.getTime();
                                        const ageMinutes = Math.floor(
                                          ageMs / 60000
                                        );
                                        const ageHours = Math.floor(
                                          ageMinutes / 60
                                        );

                                        // Warn if data is stale (older than 30 minutes)
                                        const isStale = ageMinutes > 30;

                                        const displayTime =
                                          timeValue.toLocaleTimeString(
                                            "en-US",
                                            {
                                              hour: "numeric",
                                              minute: "2-digit",
                                              hour12: true,
                                            }
                                          );
                                        const displayDate =
                                          timeValue.toLocaleDateString(
                                            "en-US",
                                            {
                                              month: "short",
                                              day: "numeric",
                                            }
                                          );
                                        return (
                                          <span
                                            className={`ml-1.5 ${
                                              isStale
                                                ? "text-yellow-400"
                                                : "text-[#93a4d6]"
                                            }`}
                                          >
                                            {displayDate} {displayTime}
                                            {isStale && (
                                              <span
                                                className="ml-0.5"
                                                title={`Data is ${
                                                  ageHours > 0
                                                    ? `${ageHours}h `
                                                    : ""
                                                }${ageMinutes % 60}m old`}
                                              >
                                                ⚠️
                                              </span>
                                            )}
                                          </span>
                                        );
                                      }
                                    } catch (e) {}
                                  }
                                  return null;
                                })()}
                              </div>
                            )}
                          </div>
                        </div>
                        <span className="text-[#6b7a9f] text-[10px] whitespace-nowrap">
                          {formatTime(event.ts)}
                        </span>
                      </div>

                      {/* Standardized Fields - Always Show */}
                      <div className="space-y-1.5 border-t border-[#26325f]/50 pt-1.5 mt-1.5">
                        {/* SL Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            SL:
                          </span>
                          <span className="text-red-400 font-mono text-[10px]">
                            {eventData.sl != null
                              ? `$${Number(eventData.sl).toFixed(2)}`
                              : "—"}
                          </span>
                        </div>

                        {/* Max TP Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            Max TP:
                          </span>
                          <span className="text-green-400 font-mono text-[10px]">
                            {maxTP != null
                              ? `$${Number(maxTP).toFixed(2)}`
                              : "—"}
                          </span>
                        </div>

                        {/* RR Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            RR:
                          </span>
                          <span className="text-blue-400 font-mono text-[10px]">
                            {eventData.rr != null
                              ? Number(eventData.rr).toFixed(2)
                              : "—"}
                          </span>
                        </div>

                        {/* Phase Complete Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            Phase:
                          </span>
                          <div className="flex items-center gap-1.5">
                            <div className="w-16 h-1 bg-[#26325f] rounded-full overflow-hidden">
                              <div
                                className="h-full rounded-full transition-all"
                                style={{
                                  width: `${
                                    (Number(eventData.phase_pct) || 0) * 100
                                  }%`,
                                  backgroundColor: (() => {
                                    const phase =
                                      Number(eventData.phase_pct) || 0;
                                    if (phase < 0.3) return "#2ecc71";
                                    if (phase < 0.6) return "#f39c12";
                                    return "#e74c3c";
                                  })(),
                                }}
                              />
                            </div>
                            <span className="text-white font-mono text-[10px] min-w-[2.5rem]">
                              {eventData.phase_pct != null
                                ? `${Math.round(
                                    Number(eventData.phase_pct) * 100
                                  )}%`
                                : "—"}
                            </span>
                          </div>
                        </div>
                      </div>

                      {/* Additional Info - Compact */}
                      {(event.rank || event.state || event.trigger_dir) && (
                        <div className="flex items-center gap-2 text-[#6b7a9f] text-[10px] mt-1.5 pt-1.5 border-t border-[#26325f]/30">
                          {event.rank && <span>Rank {event.rank}</span>}
                          {event.state && (
                            <span className="truncate" title={event.state}>
                              {event.state.split("_").pop()}
                            </span>
                          )}
                          {event.trigger_dir && (
                            <span>Dir: {event.trigger_dir}</span>
                          )}
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      // Welcome Modal Component - Dashboard Guide (Trading Concepts)
      function DashboardWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Timed Trading! 🎯",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  This dashboard helps you find high-quality trading setups by
                  combining multiple timeframes and technical indicators.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎓 How to Use This Guide
                  </h3>
                  <p className="text-sm text-[#93a4d6]">
                    Click "Next" to learn about each concept, or use the
                    navigation dots to jump to any section. You can always
                    reopen this guide from the navigation bar.
                  </p>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ✨ Quick Start
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">green zones</strong> (Q1 &
                      Q2) for LONG setups
                    </li>
                    <li>
                      Look for bubbles in the{" "}
                      <strong className="text-white">red zones</strong> (Q3 &
                      Q4) for SHORT setups
                    </li>
                    <li>Click on any bubble to see detailed information</li>
                    <li>Use filters to narrow down the best opportunities</li>
                  </ol>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding the Quadrants 📊",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The chart is divided into <strong>4 quadrants</strong> based
                  on two scores:
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                    <h3 className="text-green-400 font-semibold mb-2">
                      HTF Score (Y-axis)
                    </h3>
                    <p className="text-sm text-[#93a4d6]">
                      <strong className="text-white">Higher Timeframe</strong> -
                      Shows the overall trend direction.
                      <br />• Positive = Bullish trend
                      <br />• Negative = Bearish trend
                    </p>
                  </div>
                  <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                    <h3 className="text-blue-400 font-semibold mb-2">
                      LTF Score (X-axis)
                    </h3>
                    <p className="text-sm text-[#93a4d6]">
                      <strong className="text-white">Lower Timeframe</strong> -
                      Shows entry timing.
                      <br />• Positive = Momentum/Continuation
                      <br />• Negative = Pullback/Setup
                    </p>
                  </div>
                </div>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-3">
                    The 4 Quadrants:
                  </h3>
                  <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q1: Long Setup 📈
                      </div>
                      <div className="text-[#93a4d6]">
                        HTF Bull + LTF Pullback
                      </div>
                      <div className="text-xs text-[#93a4d6] mt-1">
                        Best entry zone for LONG trades
                      </div>
                    </div>
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Q2: Long Momentum 🚀
                      </div>
                      <div className="text-[#93a4d6]">HTF Bull + LTF Bull</div>
                      <div className="text-xs text-[#93a4d6] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q3: Short Momentum 📉
                      </div>
                      <div className="text-[#93a4d6]">HTF Bear + LTF Bear</div>
                      <div className="text-xs text-[#93a4d6] mt-1">
                        Strong momentum, already moving
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Q4: Short Setup 🔻
                      </div>
                      <div className="text-[#93a4d6]">
                        HTF Bear + LTF Pullback
                      </div>
                      <div className="text-xs text-[#93a4d6] mt-1">
                        Best entry zone for SHORT trades
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Prime Setups ⭐",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  <strong className="text-yellow-400">Prime Setups</strong> are
                  the highest-quality opportunities. They have a ⭐ icon and
                  appear with a green glow.
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    Prime Setup Criteria:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Rank ≥ 75</strong> - High
                      overall quality score
                    </li>
                    <li>
                      <strong className="text-white">Risk/Reward ≥ 1.5</strong>{" "}
                      - Good profit potential vs risk
                    </li>
                    <li>
                      <strong className="text-white">Completion ≤ 40%</strong> -
                      Still early in the move
                    </li>
                    <li>
                      <strong className="text-white">In Corridor</strong> -
                      Valid entry zone
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    💡 How to Find Prime Setups:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"Prime Only"</strong>{" "}
                      filter button
                    </li>
                    <li>Look for bubbles with ⭐ icons and green borders</li>
                    <li>Click on a bubble to see detailed entry/exit levels</li>
                    <li>Check the Risk/Reward ratio - higher is better!</li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Tip:</strong> Prime
                    setups are rare but offer the best risk/reward. Focus on Q1
                    (Long Setup) and Q4 (Short Setup) quadrants for the best
                    entries.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "In Corridor 🎯",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The <strong className="text-cyan-400">Corridor</strong> is a
                  specific zone where entries are considered valid and safe.
                </p>
                <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                  <h3 className="text-cyan-400 font-semibold mb-2">
                    What is a Corridor?
                  </h3>
                  <p className="text-sm text-[#93a4d6] mb-3">
                    A corridor is a narrow band on the chart where price action
                    is optimal for entry. Think of it as a "sweet spot" where
                    the setup is most likely to succeed.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        Long Corridor 📈
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        HTF Score &gt; 0<br />
                        LTF Score: -8 to +12
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        Short Corridor 📉
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        HTF Score &lt; 0<br />
                        LTF Score: -12 to +8
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How to Use Corridor Filter:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"In Corridor"</strong>{" "}
                      filter button
                    </li>
                    <li>This shows only tickers in valid entry zones</li>
                    <li>These are the safest setups to trade</li>
                    <li>
                      Combine with "Prime Only" for the best opportunities
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">
                      Why Corridors Matter:
                    </strong>{" "}
                    Tickers outside corridors may be too early, too late, or in
                    unfavorable conditions. Corridor entries have the highest
                    probability of success.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "TD Sequential (TD9) 🔢",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  <strong className="text-purple-400">TD Sequential</strong> is
                  a powerful indicator that identifies potential reversal
                  points.
                </p>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    What is TD9?
                  </h3>
                  <p className="text-sm text-[#93a4d6] mb-3">
                    TD Sequential counts consecutive bars in one direction. When
                    it reaches <strong className="text-white">9</strong>, it
                    signals potential exhaustion and reversal.
                  </p>
                  <div className="grid grid-cols-2 gap-3">
                    <div className="bg-green-500/10 border border-green-500/30 rounded p-3">
                      <div className="font-bold text-green-400 mb-1">
                        TD9 Bullish 📈
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        Signals potential <strong>bottom</strong> and upward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for LONG entries
                      </div>
                    </div>
                    <div className="bg-red-500/10 border border-red-500/30 rounded p-3">
                      <div className="font-bold text-red-400 mb-1">
                        TD9 Bearish 📉
                      </div>
                      <div className="text-xs text-[#93a4d6]">
                        Signals potential <strong>top</strong> and downward
                        reversal
                        <br />
                        <br />
                        <strong>Action:</strong> Look for SHORT entries or exit
                        LONGs
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🔢 How to Use TD9 Filter:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      Click the{" "}
                      <strong className="text-white">"TD9 Setup"</strong> filter
                      button
                    </li>
                    <li>This shows only tickers with active TD9 signals</li>
                    <li>
                      TD9 signals are strongest when combined with other
                      factors:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>
                          In the correct quadrant (Q1 for bullish, Q4 for
                          bearish)
                        </li>
                        <li>In corridor</li>
                        <li>With good Risk/Reward</li>
                      </ul>
                    </li>
                  </ol>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Pro Tip:</strong> TD9
                    signals are most powerful at extremes. If you see a TD9
                    signal in Q1 (Long Setup) or Q4 (Short Setup), it's a strong
                    confirmation of a reversal setup.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Squeeze Indicators 🧨⚡",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The <strong className="text-yellow-400">Squeeze</strong>{" "}
                  indicator shows when volatility is building up, like a spring
                  being compressed before release.
                </p>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                    <h3 className="text-yellow-400 font-semibold mb-2 flex items-center gap-2">
                      🧨 In Squeeze
                    </h3>
                    <p className="text-sm text-[#93a4d6] mb-3">
                      Volatility is{" "}
                      <strong className="text-white">compressed</strong> - price
                      is consolidating.
                    </p>
                    <div className="text-xs text-[#93a4d6] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        Energy is building up
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Watch
                        closely - a big move is coming
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Wait for squeeze release
                      </div>
                    </div>
                  </div>
                  <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                    <h3 className="text-cyan-400 font-semibold mb-2 flex items-center gap-2">
                      ⚡ Squeeze Release
                    </h3>
                    <p className="text-sm text-[#93a4d6] mb-3">
                      Volatility has{" "}
                      <strong className="text-white">exploded</strong> - price
                      is breaking out.
                    </p>
                    <div className="text-xs text-[#93a4d6] space-y-1">
                      <div>
                        <strong className="text-white">What it means:</strong>{" "}
                        The spring has released!
                      </div>
                      <div>
                        <strong className="text-white">Action:</strong> Strong
                        momentum signal
                      </div>
                      <div>
                        <strong className="text-white">When to enter:</strong>{" "}
                        Enter on pullback or breakout
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How to Use Squeeze Filters:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">
                        "In Squeeze" Filter:
                      </strong>{" "}
                      Shows tickers where volatility is building. These are good
                      to watch but wait for release before entering.
                    </div>
                    <div>
                      <strong className="text-white">
                        "Squeeze Release" Filter:
                      </strong>{" "}
                      Shows tickers where the squeeze has fired. These often
                      have strong momentum - combine with Prime filter for best
                      results.
                    </div>
                  </div>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    💡 Best Practices:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">
                        Squeeze Release + Prime Setup
                      </strong>{" "}
                      = Very strong signal
                    </li>
                    <li>
                      <strong className="text-white">
                        Squeeze Release + In Corridor
                      </strong>{" "}
                      = High probability entry
                    </li>
                    <li>
                      <strong className="text-white">In Squeeze</strong> =
                      Prepare but don't enter yet
                    </li>
                    <li>
                      Look for squeeze release in the direction of the HTF trend
                    </li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together 🎓",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Now that you understand the concepts, here's a{" "}
                  <strong className="text-yellow-400">
                    step-by-step workflow
                  </strong>{" "}
                  to find great setups:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    📋 Your Trading Workflow:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Step 1: Choose Your Direction
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • For LONG trades: Focus on Q1 (Long Setup) quadrant
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • For SHORT trades: Focus on Q4 (Short Setup) quadrant
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 2: Apply Quality Filters
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Click "Prime Only" to see only high-quality setups
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Click "In Corridor" to ensure valid entry zones
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 3: Look for Confirmation Signals
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • TD9 Setup: Strong reversal signal
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Squeeze Release ⚡: Strong momentum
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Momentum Elite 🚀: Best fundamentals
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 4: Analyze the Setup
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Click on a bubble to see details
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Check Risk/Reward ratio (aim for ≥ 1.5)
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Verify entry price, stop loss, and take profit levels
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Step 5: Execute Your Trade
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Enter at the suggested entry price
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Set stop loss at the SL level
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Target the TP levels (consider trimming at first TP)
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ⭐ The Perfect Setup Checklist:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-1">
                    <div>
                      ✅ In the correct quadrant (Q1 for LONG, Q4 for SHORT)
                    </div>
                    <div>✅ Prime Setup (⭐ icon)</div>
                    <div>✅ In Corridor</div>
                    <div>✅ Risk/Reward ≥ 1.5</div>
                    <div>✅ Completion ≤ 40% (still early)</div>
                    <div>
                      ✅ TD9 signal OR Squeeze Release (bonus confirmation)
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Remember:</strong> Not
                    every setup will have all these factors. Use your judgment
                    and risk management. Start with paper trading if you're new!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[#0b1020] border-2 border-[#26325f] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              {/* Header */}
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[#26325f] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                            ? "bg-green-400"
                            : "bg-[#26325f]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[#93a4d6] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[#26325f] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>

              {/* Content */}
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>

              {/* Footer */}
              <div className="border-t border-[#26325f] p-4 flex items-center justify-between bg-[#0f1630]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[#26325f] text-[#93a4d6] opacity-50 cursor-not-allowed"
                      : "border-[#26325f] bg-[#1a2550] hover:bg-[#26325f] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[#93a4d6]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Trading! 🚀
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Welcome Modal Component - Trade Tracker Guide (Simulated Trades)
      function TrackerWelcomeModal({ onClose }) {
        const [currentStep, setCurrentStep] = useState(0);

        const steps = [
          {
            title: "Welcome to Trade Tracker! 📊",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  The Trade Tracker automatically simulates trades based on
                  alerts from the main dashboard, helping you learn which setups
                  work best.
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🎯 How It Works:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-1">
                    <li>
                      When an alert fires from TradingView, a simulated trade is
                      automatically created
                    </li>
                    <li>
                      Each trade uses a{" "}
                      <strong className="text-white">
                        $1,000 position size
                      </strong>
                    </li>
                    <li>
                      Trades are tracked in real-time with live P&L updates
                    </li>
                    <li>
                      When price hits Stop Loss or Take Profit, the trade closes
                      automatically
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ✨ What You'll Learn:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>Which setups have the best win rate</li>
                    <li>How different Risk/Reward ratios perform</li>
                    <li>Which model versions work best</li>
                    <li>Performance by rank, sector, and other factors</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Note:</strong> These are
                    simulated trades for learning purposes only. Always do your
                    own research before making real trades!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Understanding Trade Statuses 🏷️",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  Each trade has a <strong>status</strong> that tells you its
                  current state:
                </p>
                <div className="grid grid-cols-1 gap-3">
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>🟢 OPEN</span>
                    </div>
                    <p className="text-sm text-[#93a4d6]">
                      Trade is active and being tracked. P&L updates in
                      real-time as price moves. The trade will close when it
                      hits Stop Loss or Take Profit.
                    </p>
                  </div>
                  <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                    <div className="font-bold text-blue-400 mb-2 flex items-center gap-2">
                      <span>🔵 TP_HIT_TRIM</span>
                    </div>
                    <p className="text-sm text-[#93a4d6]">
                      First Take Profit level was hit! The system automatically
                      trimmed (sold) part of the position to lock in profits.
                      The remaining position stays open to target higher TP
                      levels.
                    </p>
                  </div>
                  <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                    <div className="font-bold text-green-400 mb-2 flex items-center gap-2">
                      <span>✅ WIN</span>
                    </div>
                    <p className="text-sm text-[#93a4d6]">
                      Trade closed profitably! Either hit a Take Profit level or
                      was manually closed in profit. Check the trade history to
                      see the exit details.
                    </p>
                  </div>
                  <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                    <div className="font-bold text-red-400 mb-2 flex items-center gap-2">
                      <span>❌ LOSS</span>
                    </div>
                    <p className="text-sm text-[#93a4d6]">
                      Trade hit Stop Loss and closed at a loss. This is normal -
                      not every trade wins! Review what went wrong to improve
                      future setups.
                    </p>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Tip:</strong> Click on
                    any trade row to see detailed information including entry
                    price, stop loss, take profit levels, and full trade
                    history.
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Reading the Trade Table 📋",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The trade table shows all your simulated trades. Here's what
                  each column means:
                </p>
                <div className="bg-[#0f1630] border border-[#26325f] rounded-lg p-4">
                  <div className="space-y-3 text-sm">
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Ticker
                      </span>
                      <span className="text-[#93a4d6]">
                        The stock or futures contract symbol
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Direction
                      </span>
                      <span className="text-[#93a4d6]">
                        LONG (buy) or SHORT (sell)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Entry Price
                      </span>
                      <span className="text-[#93a4d6]">
                        Price when the trade was opened
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Current Price
                      </span>
                      <span className="text-[#93a4d6]">
                        Live market price (updates every 30 seconds)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L
                      </span>
                      <span className="text-[#93a4d6]">
                        Profit or Loss in dollars.{" "}
                        <span className="text-green-400">Green = profit</span>,
                        <span className="text-red-400"> red = loss</span>
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        P&L %
                      </span>
                      <span className="text-[#93a4d6]">
                        Profit or Loss as a percentage
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Shares/Contracts
                      </span>
                      <span className="text-[#93a4d6]">
                        For stocks: number of shares (based on $1,000 position).
                        For futures: number of contracts (usually 1)
                      </span>
                    </div>
                    <div className="flex items-start gap-3">
                      <span className="font-bold text-white min-w-[120px]">
                        Status
                      </span>
                      <span className="text-[#93a4d6]">
                        Current trade status (OPEN, WIN, LOSS, etc.)
                      </span>
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    💡 Pro Tips:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      Click any trade row to see detailed information and trade
                      history
                    </li>
                    <li>
                      Use the version filter to compare different model versions
                    </li>
                    <li>
                      Open trades show live P&L that updates automatically
                    </li>
                    <li>Closed trades show final P&L and exit reason</li>
                  </ul>
                </div>
              </div>
            ),
          },
          {
            title: "How P&L is Calculated 💰",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  Understanding how profit and loss is calculated helps you
                  interpret the results:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    📈 For Stocks:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">Position Size:</strong>{" "}
                      $1,000 per trade
                    </div>
                    <div>
                      <strong className="text-white">Shares:</strong> $1,000 ÷
                      Entry Price
                    </div>
                    <div>
                      <strong className="text-white">P&L (LONG):</strong>{" "}
                      (Current Price - Entry Price) × Shares
                    </div>
                    <div>
                      <strong className="text-white">P&L (SHORT):</strong>{" "}
                      (Entry Price - Current Price) × Shares
                    </div>
                  </div>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    📊 For Futures:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-2">
                    <div>
                      <strong className="text-white">Contracts:</strong> Usually
                      1 contract per trade
                    </div>
                    <div>
                      <strong className="text-white">Point Value:</strong> Each
                      futures contract has a point value:
                      <ul className="list-disc list-inside ml-4 mt-1">
                        <li>NQ1! (Nasdaq): $20 per point</li>
                        <li>ES1! (S&P 500): $50 per point</li>
                        <li>Other futures vary</li>
                      </ul>
                    </div>
                    <div>
                      <strong className="text-white">P&L:</strong> (Price
                      Change) × Contracts × Point Value
                    </div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <h3 className="text-yellow-400 font-semibold mb-2">
                    🎯 Example:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-1">
                    <div>
                      <strong className="text-white">Stock Trade:</strong> AAPL
                      at $150 entry, $155 current
                    </div>
                    <div className="ml-4">
                      Shares: $1,000 ÷ $150 = 6.67 shares
                    </div>
                    <div className="ml-4">
                      P&L: ($155 - $150) × 6.67 ={" "}
                      <span className="text-green-400">+$33.35</span>
                    </div>
                    <div className="mt-2">
                      <strong className="text-white">Futures Trade:</strong>{" "}
                      NQ1! at 15,000 entry, 15,100 current
                    </div>
                    <div className="ml-4">
                      Price Change: 15,100 - 15,000 = 100 points
                    </div>
                    <div className="ml-4">
                      P&L: 100 × 1 × $20 ={" "}
                      <span className="text-green-400">+$2,000</span>
                    </div>
                  </div>
                </div>
              </div>
            ),
          },
          {
            title: "Tracking & Analytics 📊",
            content: (
              <div className="space-y-4">
                <p className="text-[#e7ecff]">
                  The Trade Tracker provides powerful analytics to help you
                  learn:
                </p>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    📈 Performance Metrics:
                  </h3>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1">
                    <li>
                      <strong className="text-white">Win Rate:</strong>{" "}
                      Percentage of winning trades
                    </li>
                    <li>
                      <strong className="text-white">Total P&L:</strong> Sum of
                      all profits and losses
                    </li>
                    <li>
                      <strong className="text-white">Average Win/Loss:</strong>{" "}
                      Average profit per win vs loss
                    </li>
                    <li>
                      <strong className="text-white">Best/Worst Trade:</strong>{" "}
                      Your biggest winners and losers
                    </li>
                  </ul>
                </div>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-2">
                    🔍 Filter by Version:
                  </h3>
                  <p className="text-sm text-[#93a4d6] mb-2">
                    Use the "Model Version" dropdown to compare performance
                    across different versions of the trading model. This helps
                    you see which improvements work best.
                  </p>
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-white">Tip:</strong> Newer versions
                    often include improvements, but older versions may have
                    proven track records.
                  </p>
                </div>
                <div className="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                  <h3 className="text-purple-400 font-semibold mb-2">
                    📊 Daily Summary:
                  </h3>
                  <p className="text-sm text-[#93a4d6]">
                    Click "View Daily Summary" to see performance breakdowns by:
                  </p>
                  <ul className="text-sm text-[#93a4d6] list-disc list-inside space-y-1 mt-2">
                    <li>Rank ranges (which ranked setups perform best)</li>
                    <li>Risk/Reward ratios (which RR ratios win more)</li>
                    <li>Quadrants (which chart zones are most profitable)</li>
                    <li>Overall statistics and insights</li>
                  </ul>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">Remember:</strong> The
                    goal is to learn which setups work best. Review your wins
                    and losses regularly to improve your trading strategy!
                  </p>
                </div>
              </div>
            ),
          },
          {
            title: "Putting It All Together 🎓",
            content: (
              <div className="space-y-4">
                <p className="text-lg text-[#e7ecff]">
                  Here's your{" "}
                  <strong className="text-yellow-400">workflow</strong> for
                  using the Trade Tracker:
                </p>
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                  <h3 className="text-blue-400 font-semibold mb-3">
                    📋 Daily Workflow:
                  </h3>
                  <ol className="text-sm text-[#93a4d6] list-decimal list-inside space-y-3">
                    <li>
                      <strong className="text-white">
                        Monitor Open Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check the "Open Trades" section regularly
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Watch P&L update in real-time
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Click trades to see detailed information
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Review Closed Trades
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Check "Closed Trades" to see final results
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Review trade history to understand what happened
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Learn from both wins and losses
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Analyze Performance
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Use the version filter to compare models
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Check daily summary for insights
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Look for patterns in winning vs losing trades
                      </span>
                    </li>
                    <li>
                      <strong className="text-white">
                        Improve Your Strategy
                      </strong>
                      <br />
                      <span className="text-xs ml-4">
                        • Focus on setups with high win rates
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Avoid setups that consistently lose
                      </span>
                      <br />
                      <span className="text-xs ml-4">
                        • Adjust filters on the main dashboard based on results
                      </span>
                    </li>
                  </ol>
                </div>
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                  <h3 className="text-green-400 font-semibold mb-2">
                    ⭐ Key Takeaways:
                  </h3>
                  <div className="text-sm text-[#93a4d6] space-y-1">
                    <div>✅ Trades are created automatically from alerts</div>
                    <div>✅ Each trade uses $1,000 position size</div>
                    <div>✅ P&L updates in real-time for open trades</div>
                    <div>✅ Trades close automatically at SL or TP</div>
                    <div>✅ Use analytics to learn which setups work best</div>
                  </div>
                </div>
                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                  <p className="text-sm text-[#93a4d6]">
                    <strong className="text-yellow-400">
                      Ready to start tracking?
                    </strong>{" "}
                    The Trade Tracker refreshes every 30 seconds to show the
                    latest trades and updates. Click "Start Tracking!" to begin!
                  </p>
                </div>
              </div>
            ),
          },
        ];

        const nextStep = () => {
          if (currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
          }
        };

        const prevStep = () => {
          if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
          }
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-[#0b1020] border-2 border-[#26325f] rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
              <div className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 border-b border-[#26325f] p-6 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {steps[currentStep].title}
                  </h2>
                  <div className="flex gap-1">
                    {steps.map((_, i) => (
                      <div
                        key={i}
                        className={`h-2 w-2 rounded-full transition-all ${
                          i === currentStep
                            ? "bg-blue-400 w-8"
                            : i < currentStep
                            ? "bg-green-400"
                            : "bg-[#26325f]"
                        }`}
                      />
                    ))}
                  </div>
                </div>
                <button
                  onClick={onClose}
                  className="text-[#93a4d6] hover:text-white text-2xl font-bold w-8 h-8 flex items-center justify-center rounded hover:bg-[#26325f] transition-colors"
                  title="Close Welcome Guide"
                >
                  ×
                </button>
              </div>
              <div className="flex-1 overflow-y-auto p-6">
                {steps[currentStep].content}
              </div>
              <div className="border-t border-[#26325f] p-4 flex items-center justify-between bg-[#0f1630]">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className={`px-4 py-2 rounded-lg border transition-all ${
                    currentStep === 0
                      ? "border-[#26325f] text-[#93a4d6] opacity-50 cursor-not-allowed"
                      : "border-[#26325f] bg-[#1a2550] hover:bg-[#26325f] text-white"
                  }`}
                >
                  ← Previous
                </button>
                <div className="text-sm text-[#93a4d6]">
                  Step {currentStep + 1} of {steps.length}
                </div>
                {currentStep < steps.length - 1 ? (
                  <button
                    onClick={nextStep}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-semibold transition-all"
                  >
                    Next →
                  </button>
                ) : (
                  <button
                    onClick={onClose}
                    className="px-6 py-2 rounded-lg bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-semibold transition-all"
                  >
                    Start Tracking! 🚀
                  </button>
                )}
              </div>
            </div>
          </div>
        );
      }

      // Time Travel Slider Component
      function TimeTravelSlider({
        tickers,
        allTickers,
        data,
        onTimeChange,
        tickerFilter,
      }) {
        const [isActive, setIsActive] = useState(false);
        const [selectedTimestamp, setSelectedTimestamp] = useState(null);
        const [trailData, setTrailData] = useState({});
        const [loadingTrails, setLoadingTrails] = useState(false);
        const [trailLoadProgress, setTrailLoadProgress] = useState({
          total: 0,
          done: 0,
        });
        const [isPlaying, setIsPlaying] = useState(false);
        const [playSpeedMs, setPlaySpeedMs] = useState(600); // ms per 5-min step
        const [loopPlayback, setLoopPlayback] = useState(true);

        // Prevent render loops when parent passes unstable callbacks/arrays.
        // (This was causing "Maximum update depth exceeded" and breaking Play.)
        const onTimeChangeRef = React.useRef(onTimeChange);
        useEffect(() => {
          onTimeChangeRef.current = onTimeChange;
        }, [onTimeChange]);

        const tickersRef = React.useRef(tickers);
        tickersRef.current = tickers;

        // Round timestamp to nearest 5 minutes (stable reference for effects)
        const roundTo5Minutes = React.useCallback((ts) => {
          const date = new Date(ts);
          const minutes = date.getMinutes();
          const roundedMinutes = Math.floor(minutes / 5) * 5;
          date.setMinutes(roundedMinutes);
          date.setSeconds(0);
          date.setMilliseconds(0);
          return date.getTime();
        }, []);

        // Get available timestamps from ALL tickers (not just filtered) for stable range
        // This prevents the slider from jumping around when search filters change
        const availableTimestamps = useMemo(() => {
          const timestamps = new Set();
          const sourceTickers =
            allTickers && typeof allTickers === "object"
              ? Array.isArray(allTickers)
                ? allTickers
                : Object.values(allTickers)
              : tickers;

          sourceTickers.forEach((t) => {
            if (!t || typeof t !== "object") return;
            if (t.ts) {
              const rounded = roundTo5Minutes(Number(t.ts));
              timestamps.add(rounded);
            }
            if (t.ingest_ts) {
              const ts =
                typeof t.ingest_ts === "string"
                  ? new Date(t.ingest_ts).getTime()
                  : Number(t.ingest_ts);
              if (ts) {
                const rounded = roundTo5Minutes(ts);
                timestamps.add(rounded);
              }
            }
          });
          return Array.from(timestamps).sort((a, b) => a - b);
        }, [allTickers, tickers, roundTo5Minutes]);

        const minTimestamp =
          availableTimestamps.length > 0
            ? availableTimestamps[0]
            : roundTo5Minutes(Date.now() - 7 * 24 * 60 * 60 * 1000);
        const maxTimestamp =
          availableTimestamps.length > 0
            ? availableTimestamps[availableTimestamps.length - 1]
            : roundTo5Minutes(Date.now());

        const STEP_MS = 5 * 60 * 1000;

        const buildSnapshotTickers = React.useCallback(
          (sourceTickers, trails, roundedTimestamp) => {
            if (!Array.isArray(sourceTickers)) return [];
            return sourceTickers
              .map((ticker) => {
                const symbol = ticker?.ticker;
                if (!symbol) return null;

                const trail = trails?.[symbol] || [];
                const pointsWithTs = Array.isArray(trail)
                  ? trail
                      .map((point) => {
                        const pointTs =
                          point.ts ||
                          (point.timestamp
                            ? new Date(point.timestamp).getTime()
                            : null);
                        if (!pointTs) return null;
                        return {
                          point,
                          pointTs,
                          roundedPointTs: roundTo5Minutes(pointTs),
                        };
                      })
                      .filter(Boolean)
                  : [];

                // Snapshot: use closest known point. If missing data, keep visible using latest values.
                if (pointsWithTs.length > 0) {
                  const closest = pointsWithTs.reduce((best, cur) => {
                    if (!best) return cur;
                    const bestDist = Math.abs(
                      best.roundedPointTs - roundedTimestamp
                    );
                    const curDist = Math.abs(
                      cur.roundedPointTs - roundedTimestamp
                    );
                    return curDist < bestDist ? cur : best;
                  }, null);

                  const closestPoint = closest.point;
                  return {
                    ...ticker,
                    htf_score:
                      closestPoint.htf_score !== undefined
                        ? closestPoint.htf_score
                        : ticker.htf_score,
                    ltf_score:
                      closestPoint.ltf_score !== undefined
                        ? closestPoint.ltf_score
                        : ticker.ltf_score,
                    price:
                      closestPoint.price !== undefined
                        ? closestPoint.price
                        : ticker.price,
                    state: closestPoint.state || ticker.state,
                    rank:
                      closestPoint.rank !== undefined
                        ? closestPoint.rank
                        : ticker.rank,
                    rr:
                      closestPoint.rr !== undefined
                        ? closestPoint.rr
                        : ticker.rr,
                    completion:
                      closestPoint.completion !== undefined
                        ? closestPoint.completion
                        : ticker.completion,
                    phase_pct:
                      closestPoint.phase_pct !== undefined
                        ? closestPoint.phase_pct
                        : ticker.phase_pct,
                    ts: closest.pointTs,
                    _isTimeTravel: true,
                    _timeTravelMissing: false,
                  };
                }

                return {
                  ...ticker,
                  _isTimeTravel: true,
                  _timeTravelMissing: true,
                  ts: ticker.ts || ticker.ingest_ts || null,
                };
              })
              .filter(Boolean);
          },
          [roundTo5Minutes]
        );

        // Fetch trail data and filter by timestamp
        // Use a ref to track if we're currently fetching to prevent race conditions
        const fetchingRef = React.useRef(false);
        const lastFetchedSymbolsRef = React.useRef("");

        // Memoize ticker symbols to prevent unnecessary re-fetches
        const tickerSymbols = useMemo(() => {
          return tickers
            .map((t) => t.ticker)
            .sort()
            .join(",");
        }, [tickers]);

        // Fetch trails ONCE when activating (or when ticker set changes).
        // Snapshot updates (including animation) should NOT refetch trails.
        useEffect(() => {
          let cancelled = false;

          if (!isActive) {
            setIsPlaying(false);
            setTrailData({});
            setTrailLoadProgress({ total: 0, done: 0 });
            lastFetchedSymbolsRef.current = "";
            onTimeChangeRef.current?.(null);
            return () => {
              cancelled = true;
            };
          }

          if (tickersRef.current.length === 0) {
            onTimeChangeRef.current?.([]);
            return () => {
              cancelled = true;
            };
          }

          // Prevent concurrent fetches
          if (fetchingRef.current) return;

          // Avoid refetch if we already fetched this exact ticker set
          if (lastFetchedSymbolsRef.current === tickerSymbols) {
            return;
          }

          const fetchTrails = async () => {
            fetchingRef.current = true;
            setLoadingTrails(true);
            lastFetchedSymbolsRef.current = tickerSymbols;
            try {
              const trails = {};
              const tickerSymbolsArray = tickersRef.current.map(
                (t) => t.ticker
              );
              setTrailLoadProgress({
                total: tickerSymbolsArray.length,
                done: 0,
              });

              const MAX_CONCURRENT = 5;
              for (
                let i = 0;
                i < tickerSymbolsArray.length;
                i += MAX_CONCURRENT
              ) {
                const batch = tickerSymbolsArray.slice(i, i + MAX_CONCURRENT);
                const batchResults = await Promise.all(
                  batch.map(async (ticker) => {
                    try {
                      const res = await fetch(
                        `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                          ticker
                        )}`
                      );
                      if (res.ok) {
                        const json = await res.json();
                        if (
                          json.ok &&
                          json.trail &&
                          Array.isArray(json.trail)
                        ) {
                          return { ticker, trail: json.trail };
                        }
                      }
                      return { ticker, trail: [] };
                    } catch (err) {
                      return { ticker, trail: [] };
                    }
                  })
                );

                batchResults.forEach(({ ticker, trail }) => {
                  if (Array.isArray(trail) && trail.length > 0) {
                    trails[ticker] = trail;
                  }
                });

                if (!cancelled) {
                  setTrailLoadProgress((p) => ({
                    total: p.total || tickerSymbolsArray.length,
                    done: Math.min(
                      (p.done || 0) + batch.length,
                      tickerSymbolsArray.length
                    ),
                  }));
                }

                // Small delay between batches to avoid spikes
                await new Promise((r) => setTimeout(r, 250));
              }

              if (!cancelled) setTrailData(trails);
            } catch (err) {
              console.error("Failed to fetch trails:", err);
              if (!cancelled) setTrailData({});
            } finally {
              if (!cancelled) setLoadingTrails(false);
              fetchingRef.current = false;
            }
          };

          fetchTrails();
          return () => {
            cancelled = true;
          };
        }, [isActive, tickerSymbols]);

        // Compute snapshot whenever timestamp changes or new trails arrive.
        useEffect(() => {
          if (!isActive) return;
          if (!selectedTimestamp) return;
          const roundedTimestamp = roundTo5Minutes(selectedTimestamp);
          const snapshot = buildSnapshotTickers(
            tickersRef.current,
            trailData,
            roundedTimestamp
          );
          onTimeChangeRef.current?.(snapshot);
        }, [
          isActive,
          selectedTimestamp,
          trailData,
          tickerSymbols,
          buildSnapshotTickers,
          roundTo5Minutes,
        ]);

        // Animation: advance by 5 minutes at a configurable speed.
        useEffect(() => {
          if (!isActive || !isPlaying) return;

          const id = setInterval(() => {
            setSelectedTimestamp((prev) => {
              const cur =
                prev !== null && prev !== undefined
                  ? roundTo5Minutes(prev)
                  : roundTo5Minutes(maxTimestamp);
              const next = cur + STEP_MS;
              if (next > maxTimestamp) {
                if (loopPlayback) {
                  return roundTo5Minutes(minTimestamp);
                }
                setIsPlaying(false);
                return cur;
              }
              return next;
            });
          }, playSpeedMs);

          return () => clearInterval(id);
        }, [
          isActive,
          isPlaying,
          playSpeedMs,
          loopPlayback,
          minTimestamp,
          maxTimestamp,
          roundTo5Minutes,
        ]);

        const handleTimestampChange = (e) => {
          const ts = Number(e.target.value);
          // Round to nearest 5 minutes
          const rounded = roundTo5Minutes(ts);
          setSelectedTimestamp(rounded);
          setIsPlaying(false);
        };

        const formatTimestamp = (ts) => {
          if (!ts) return "Now";
          const date = new Date(ts);
          return date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          });
        };

        const currentValue = selectedTimestamp
          ? roundTo5Minutes(selectedTimestamp)
          : roundTo5Minutes(maxTimestamp);
        const progress =
          maxTimestamp > minTimestamp
            ? ((currentValue - minTimestamp) / (maxTimestamp - minTimestamp)) *
              100
            : 100;

        // Parse ticker filter to show which tickers are being tracked
        const trackedTickers = useMemo(() => {
          if (!tickerFilter || typeof tickerFilter !== "string") return [];
          return tickerFilter
            .split(",")
            .map((t) => t.trim().toUpperCase())
            .filter(Boolean);
        }, [tickerFilter]);

        return (
          <div className="mb-4 bg-[#121a33] border border-[#26325f] rounded-xl p-4">
            <div className="flex items-center justify-between mb-3 flex-wrap gap-2">
              <div className="flex items-center gap-3 flex-wrap">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={isActive}
                    onChange={(e) => {
                      setIsActive(e.target.checked);
                      if (!e.target.checked) {
                        setIsPlaying(false);
                        setSelectedTimestamp(null);
                        onTimeChangeRef.current?.(null);
                      } else {
                        // Round to 5 minutes when activating
                        setSelectedTimestamp(roundTo5Minutes(maxTimestamp));
                      }
                    }}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-semibold text-white">
                    ⏱️ Time Travel
                  </span>
                </label>
                {isActive && (
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => {
                        // Ensure we have a starting timestamp before playing
                        if (!isPlaying) {
                          setSelectedTimestamp((prev) =>
                            prev !== null && prev !== undefined
                              ? prev
                              : maxTimestamp
                          );
                        }
                        setIsPlaying((p) => !p);
                      }}
                      className="px-2 py-1 bg-[#26325f] hover:bg-[#3a4aa0] rounded text-xs text-white"
                      title="Play / Pause"
                    >
                      {isPlaying ? "⏸ Pause" : "▶️ Play"}
                    </button>
                    <select
                      value={playSpeedMs}
                      onChange={(e) => setPlaySpeedMs(Number(e.target.value))}
                      className="bg-[#0f1630] border border-[#26325f] rounded px-2 py-1 text-xs text-[#e7ecff]"
                      title="Playback speed"
                    >
                      <option value={300}>Fast</option>
                      <option value={600}>Normal</option>
                      <option value={1200}>Slow</option>
                    </select>
                    <label className="flex items-center gap-1 text-xs text-[#93a4d6]">
                      <input
                        type="checkbox"
                        checked={loopPlayback}
                        onChange={(e) => setLoopPlayback(e.target.checked)}
                      />
                      Loop
                    </label>
                  </div>
                )}
                {trackedTickers.length > 0 && (
                  <div className="flex items-center gap-2 text-xs text-[#93a4d6]">
                    <span className="text-[#00ffff]">Tracking:</span>
                    <div className="flex flex-wrap gap-1">
                      {trackedTickers.slice(0, 5).map((ticker, idx) => (
                        <span
                          key={idx}
                          className="px-2 py-0.5 bg-[#0f1630] border border-[#26325f] rounded text-[#00ffff]"
                        >
                          {ticker}
                        </span>
                      ))}
                      {trackedTickers.length > 5 && (
                        <span className="px-2 py-0.5 bg-[#0f1630] border border-[#26325f] rounded text-[#93a4d6]">
                          +{trackedTickers.length - 5}
                        </span>
                      )}
                    </div>
                  </div>
                )}
                {tickers.length > 0 && trackedTickers.length === 0 && (
                  <div className="text-xs text-[#93a4d6]">
                    Showing {tickers.length} ticker
                    {tickers.length !== 1 ? "s" : ""}
                  </div>
                )}
              </div>
              {isActive && selectedTimestamp && (
                <div className="text-xs text-[#00ffff] font-semibold">
                  {formatTimestamp(selectedTimestamp)}
                </div>
              )}
            </div>

            {isActive && (
              <div className="space-y-2">
                <input
                  type="range"
                  min={minTimestamp}
                  max={maxTimestamp}
                  step={5 * 60 * 1000}
                  value={currentValue}
                  onChange={handleTimestampChange}
                  className="w-full h-2 bg-[#0f1630] rounded-lg appearance-none cursor-pointer slider-thumb"
                  style={{
                    background: `linear-gradient(to right, #00ffff 0%, #00ffff ${progress}%, #26325f ${progress}%, #26325f 100%)`,
                  }}
                />
                <div className="flex justify-between text-xs text-[#93a4d6]">
                  <span>{formatTimestamp(minTimestamp)}</span>
                  <span>{formatTimestamp(maxTimestamp)}</span>
                </div>
                {loadingTrails && (
                  <div className="text-xs text-[#93a4d6]">
                    <div className="flex items-center justify-between mb-1">
                      <span>Loading historical data…</span>
                      <span className="tabular-nums">
                        {trailLoadProgress.done}/{trailLoadProgress.total || 0}
                      </span>
                    </div>
                    <div className="w-full h-2 bg-[#0f1630] border border-[#26325f] rounded overflow-hidden">
                      <div
                        className="h-full bg-[#00ffff]"
                        style={{
                          width: `${
                            trailLoadProgress.total > 0
                              ? Math.round(
                                  (trailLoadProgress.done /
                                    trailLoadProgress.total) *
                                    100
                                )
                              : 0
                          }%`,
                          transition: "width 200ms ease",
                        }}
                      />
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }

      function QuickFilters({ filters, onFilterChange, sectors = [] }) {
        // Groups (seed list) - one row
        const groupPresets = [
          {
            label: "Upticks",
            filter: { group: "UPTICKS" },
            icon: "📊",
          },
          {
            label: "Super Granny",
            filter: { group: "SuperGranny" },
            icon: "⭐",
          },
          {
            label: "GRNI",
            filter: { group: "GRNI" },
            icon: "🔵",
          },
          {
            label: "GRNJ",
            filter: { group: "GRNJ" },
            icon: "🟢",
          },
          {
            label: "GRNY",
            filter: { group: "GRNY" },
            icon: "🟡",
          },
          {
            label: "Social",
            filter: { group: "Social" },
            icon: "💬",
          },
          {
            label: "SP Sectors",
            filter: { group: "SP_Sectors" },
            icon: "📈",
          },
          {
            label: "Futures",
            filter: { group: "Futures" },
            icon: "⚡",
          },
          {
            label: "No Group",
            filter: { group: "No Group" },
            icon: "📋",
          },
        ];

        // Filters - one row
        const filterPresets = [
          {
            label: "Short-Term",
            filter: { horizonBucket: "SHORT_TERM" },
            icon: "⏱️",
          },
          {
            label: "Swing",
            filter: { horizonBucket: "SWING" },
            icon: "🎢",
          },
          {
            label: "Positional",
            filter: { horizonBucket: "POSITIONAL" },
            icon: "🏔️",
          },
          {
            label: "Prime Only",
            filter: { minRank: 75, minRR: 1.5, maxCompletion: 0.4 },
            icon: "⭐",
          },
          {
            label: "In Corridor",
            filter: { inCorridor: true },
            icon: "🎯",
          },
          {
            label: "Squeeze Release",
            filter: { squeezeRelease: true },
            icon: "⚡",
          },
          {
            label: "In Squeeze",
            filter: { inSqueeze: true },
            icon: "🧨",
          },
          {
            label: "Momentum Elite",
            filter: { momentumElite: true },
            icon: "🚀",
          },
          {
            label: "Q1: Bull Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "📈",
          },
          {
            label: "Q2: Bull Momentum",
            filter: { quadrants: ["HTF_BULL_LTF_BULL"] },
            icon: "🚀",
          },
          {
            label: "Q3: Bear Momentum",
            filter: { quadrants: ["HTF_BEAR_LTF_BEAR"] },
            icon: "📉",
          },
          {
            label: "Q4: Bear Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "🔻",
          },
          {
            label: "Ranked",
            filter: { top40: true },
            icon: "📊",
          },
          {
            label: "Top Long Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "📈",
          },
          {
            label: "Top Short Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "📉",
          },
          {
            label: "Trades",
            filter: { hasTrades: true },
            icon: "💼",
          },
          {
            label: "TD9 Setup",
            filter: { td9Setup: "any" },
            icon: "🔢",
          },
        ];

        const isActive = (preset) => {
          if (preset.label === "Prime Only") {
            return (
              filters.minRank === 75 &&
              filters.minRR === 1.5 &&
              filters.maxCompletion === 0.4
            );
          }
          if (preset.label === "Short-Term") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "SHORT_TERM"
            );
          }
          if (preset.label === "Swing") {
            return String(filters.horizonBucket || "").toUpperCase() === "SWING";
          }
          if (preset.label === "Positional") {
            return (
              String(filters.horizonBucket || "").toUpperCase() === "POSITIONAL"
            );
          }
          if (preset.label === "In Corridor") {
            return filters.inCorridor === true;
          }
          if (preset.label === "Squeeze Release") {
            return filters.squeezeRelease === true;
          }
          if (preset.label === "In Squeeze") {
            return filters.inSqueeze === true;
          }
          if (preset.label === "Momentum Elite") {
            return filters.momentumElite === true;
          }
          // Check for "Top Long Setup" and "Top Short Setup" specifically
          if (preset.label === "Top Long Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
            );
          }
          if (preset.label === "Top Short Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
            );
          }
          // Check if quadrant filter matches (for Q1, Q2, Q3, Q4 labels)
          if (preset.label.startsWith("Q")) {
            const presetQuadrants = preset.filter.quadrants || [];
            const currentQuadrants = filters.quadrants || [];
            // Check if preset quadrants are the only ones selected
            if (presetQuadrants.length === 1 && currentQuadrants.length === 1) {
              return presetQuadrants[0] === currentQuadrants[0];
            }
            // Check if preset quadrants are subset of current (and no others)
            if (
              presetQuadrants.length === 1 &&
              currentQuadrants.includes(presetQuadrants[0])
            ) {
              return currentQuadrants.length === 1;
            }
          }
          // Check if group filter matches
          if (preset.filter.group) {
            return filters.group === preset.filter.group;
          }
          // Check if Top 40 filter matches
          if (preset.filter.top40) {
            return filters.top40 === true;
          }
          // Check if Trades filter matches
          if (preset.filter.hasTrades) {
            return filters.hasTrades === true;
          }
          // Check if TD9 Setup filter matches
          if (preset.filter.td9Setup) {
            return filters.td9Setup === "any";
          }
          return false;
        };

        const handlePresetClick = (preset) => {
          const active = isActive(preset);
          if (active) {
            // Toggle off - remove this specific filter, keep others
            const newFilters = { ...filters };

            if (preset.label === "Prime Only") {
              // Reset Prime Only filters to defaults
              newFilters.minRank = 0;
              newFilters.minRR = 0;
              newFilters.maxCompletion = 1.01;
            } else if (
              preset.label === "Short-Term" ||
              preset.label === "Swing" ||
              preset.label === "Positional"
            ) {
              delete newFilters.horizonBucket;
            } else if (preset.label === "In Corridor") {
              delete newFilters.inCorridor;
            } else if (preset.label === "Squeeze Release") {
              delete newFilters.squeezeRelease;
            } else if (preset.label === "In Squeeze") {
              delete newFilters.inSqueeze;
            } else if (preset.label === "Momentum Elite") {
              // Explicitly delete to ensure it's removed
              delete newFilters.momentumElite;
              // Set to undefined so handleFilterChange properly removes it
              newFilters.momentumElite = undefined;
            } else if (preset.label === "Top Long Setup") {
              // Restore all quadrants if Top Long Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label === "Top Short Setup") {
              // Restore all quadrants if Top Short Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label.startsWith("Q")) {
              // For Q1-Q4, restore all quadrants if this was the only one
              const presetQuadrants = preset.filter.quadrants || [];
              const currentQuadrants = filters.quadrants || [];
              if (
                presetQuadrants.length === 1 &&
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === presetQuadrants[0]
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.filter.group) {
              // Reset group filter
              newFilters.group = "ALL";
            } else if (preset.filter.top40) {
              delete newFilters.top40;
            } else if (preset.filter.hasTrades) {
              delete newFilters.hasTrades;
            } else if (preset.filter.td9Setup) {
              delete newFilters.td9Setup;
              newFilters.td9Setup = undefined; // Ensure it's cleared
            }

            // Ensure all deleted filters are explicitly set to undefined for proper cleanup
            onFilterChange(newFilters);
          } else {
            // Toggle on - apply filter, merge with existing filters
            const mergedFilters = { ...filters, ...preset.filter };

            // Special handling for quadrant filters - replace, don't merge arrays
            if (preset.filter.quadrants) {
              mergedFilters.quadrants = preset.filter.quadrants;
            }

            onFilterChange(mergedFilters);
          }
        };

        const resetAllFilters = () => {
          // Explicitly reset all filters including boolean flags
          // Use onFilterChange to ensure proper state updates
          const defaultFilters = {
            search: "",
            quadrants: [
              "HTF_BULL_LTF_PULLBACK",
              "HTF_BULL_LTF_BULL",
              "HTF_BEAR_LTF_BEAR",
              "HTF_BEAR_LTF_PULLBACK",
            ],
            minRank: 0,
            minRR: 0,
            maxCompletion: 1.01,
            group: "ALL",
          };
          // Explicitly clear all boolean filters by setting to undefined
          // handleFilterChange will delete undefined values
          onFilterChange({
            ...defaultFilters,
            horizonBucket: undefined,
            inCorridor: undefined,
            squeezeRelease: undefined,
            inSqueeze: undefined,
            momentumElite: undefined,
            top40: undefined,
            hasTrades: undefined,
            td9Setup: undefined,
            sector: undefined,
          });
        };

        const renderPresetButton = (preset, i) => {
          const active = isActive(preset);
          return (
            <button
              key={i}
              className={`px-4 py-2 rounded-lg border text-sm font-semibold transition-all ${
                active
                  ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                  : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
              }`}
              onClick={() => handlePresetClick(preset)}
            >
              {preset.icon} {preset.label}
            </button>
          );
        };

        return (
          <div className="space-y-3 mb-4">
            {/* Groups Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {groupPresets.map((preset, i) => renderPresetButton(preset, i))}
            </div>
            {/* Filters Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {filterPresets.map((preset, i) => renderPresetButton(preset, i))}
              {/* Reset Filters Button */}
              <button
                onClick={resetAllFilters}
                className="px-4 py-2 rounded-lg border border-red-500/50 bg-red-500/10 hover:bg-red-500/20 text-red-400 text-sm font-semibold transition-all"
                title="Reset all filters to defaults"
              >
                🔄 Reset Filters
              </button>
            </div>
            {/* Sectors Row */}
            {sectors.length > 0 && (
              <div className="flex gap-2 flex-wrap items-center">
                <span className="text-xs text-[#93a4d6] font-semibold mr-1">
                  Sectors:
                </span>
                {sectors.map((sectorData) => {
                  const sectorName = sectorData.sector || sectorData.name;
                  const rating = sectorData.rating || "neutral";
                  const emoji =
                    rating === "overweight"
                      ? "💪"
                      : rating === "underweight"
                      ? "👎"
                      : "😒";
                  const isActive = filters.sector === sectorName;
                  return (
                    <button
                      key={sectorName}
                      onClick={() => {
                        if (isActive) {
                          // Toggle off - clear sector filter
                          onFilterChange({
                            ...filters,
                            sector: undefined,
                          });
                        } else {
                          // Toggle on - set sector filter
                          onFilterChange({
                            ...filters,
                            sector: sectorName,
                          });
                        }
                      }}
                      className={`px-2 py-1 rounded-lg border text-xs font-semibold transition-all ${
                        isActive
                          ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                          : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
                      }`}
                      title={`${sectorName} - ${
                        rating.charAt(0).toUpperCase() + rating.slice(1)
                      }`}
                    >
                      {emoji} {sectorName}
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Viewport Filter Tags (controls Viewport + Bubble Chart)
      // ─────────────────────────────────────────────────────────────
      function ViewportFilterTags({ filters, onChange, sectors = [] }) {
        const group = String(filters.group || "ALL");
        const horizon = String(filters.horizonBucket || "ALL");
        const opp = String(filters.opportunities || "ALL");
        const quadrants = Array.isArray(filters.quadrants) ? filters.quadrants : null;
        const sector = String(filters.sector || "ALL");
        const guidance = String(filters.guidanceCategory || "ALL");

        const sectorRatingMap = React.useMemo(() => {
          const map = {};
          if (Array.isArray(sectors)) {
            sectors.forEach((s) => {
              const name = s?.sector || s?.name;
              if (!name) return;
              map[String(name)] = String(s?.rating || "neutral").toLowerCase();
            });
          }
          return map;
        }, [sectors]);

        const sectorEmoji = (sectorName) => {
          const rating = sectorRatingMap[String(sectorName)] || "neutral";
          return rating === "overweight" ? "💪" : rating === "underweight" ? "👎" : "😒";
        };

        const QUAD = {
          Q1: "HTF_BULL_LTF_BULL",
          Q2: "HTF_BULL_LTF_PULLBACK",
          Q3: "HTF_BEAR_LTF_PULLBACK",
          Q4: "HTF_BEAR_LTF_BEAR",
        };
        const ALL_QUADS = Object.values(QUAD);

        const isQuadActive = (qKey) => {
          const s = QUAD[qKey];
          if (!s) return false;
          if (!quadrants) return false;
          return quadrants.includes(s);
        };

        const toggleQuadrant = (qKey) => {
          const s = QUAD[qKey];
          if (!s) return;
          const current = Array.isArray(quadrants) ? quadrants.slice() : ALL_QUADS.slice();
          const has = current.includes(s);
          const next = has ? current.filter((x) => x !== s) : current.concat([s]);
          // If empty or all selected, clear quadrants filter (show all)
          const normalized =
            next.length === 0 || next.length === ALL_QUADS.length ? undefined : next;
          onChange({ quadrants: normalized });
        };

        const pill = (label, active, onClick) => (
          <button
            onClick={onClick}
            className={`px-3 py-1.5 rounded-lg border text-xs font-semibold transition-all ${
              active
                ? "border-blue-400 bg-blue-500/20 text-blue-200"
                : "border-[#26325f] bg-[#0f1630] text-[#93a4d6] hover:text-white"
            }`}
          >
            {label}
          </button>
        );

        const toggleBool = (key) => {
          const cur = filters[key] === true;
          onChange({ [key]: cur ? undefined : true });
        };

        return (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-4">
            <div className="space-y-2">
              <div className="text-[10px] text-[#6b7a9f] font-semibold">Guidance</div>
              <div className="flex gap-2 flex-wrap items-center">
                {pill("All", guidance === "ALL", () => onChange({ guidanceCategory: undefined }))}
                {pill("Initiate", guidance === "INITIATE", () => onChange({ guidanceCategory: "INITIATE" }))}
                {pill("Consider Entry", guidance === "CONSIDER", () => onChange({ guidanceCategory: "CONSIDER" }))}
                {pill("Monitor Closely", guidance === "MONITOR", () => onChange({ guidanceCategory: "MONITOR" }))}
                {pill("Wait", guidance === "WAIT", () => onChange({ guidanceCategory: "WAIT" }))}
                {pill("Exit/Trim", guidance === "EXIT_TRIM", () => onChange({ guidanceCategory: "EXIT_TRIM" }))}
                {pill("Other", guidance === "OTHER", () => onChange({ guidanceCategory: "OTHER" }))}
              </div>

              <div className="text-[10px] text-[#6b7a9f] font-semibold">Horizon</div>
              <div className="flex gap-2 flex-wrap items-center">
                {pill("All", horizon === "ALL", () => onChange({ horizonBucket: undefined }))}
                {pill("Short-Term", horizon === "SHORT_TERM", () => onChange({ horizonBucket: "SHORT_TERM" }))}
                {pill("Swing", horizon === "SWING", () => onChange({ horizonBucket: "SWING" }))}
                {pill("Positional", horizon === "POSITIONAL", () => onChange({ horizonBucket: "POSITIONAL" }))}
              </div>

              <div className="text-[10px] text-[#6b7a9f] font-semibold mt-1">Opportunities</div>
              <div className="flex gap-2 flex-wrap items-center">
                {pill("All", opp === "ALL", () => onChange({ opportunities: undefined }))}
                {pill("Eligible", opp === "ELIGIBLE", () => onChange({ opportunities: "ELIGIBLE" }))}
                {pill("Prime", opp === "PRIME", () => onChange({ opportunities: "PRIME" }))}
                {pill("Watch", opp === "WATCH", () => onChange({ opportunities: "WATCH" }))}
                {pill("Q1", isQuadActive("Q1"), () => toggleQuadrant("Q1"))}
                {pill("Q2", isQuadActive("Q2"), () => toggleQuadrant("Q2"))}
                {pill("Q3", isQuadActive("Q3"), () => toggleQuadrant("Q3"))}
                {pill("Q4", isQuadActive("Q4"), () => toggleQuadrant("Q4"))}
              </div>

              <div className="text-[10px] text-[#6b7a9f] font-semibold mt-1">Specials</div>
              <div className="flex gap-2 flex-wrap items-center">
                {pill("In Squeeze", filters.inSqueeze === true, () => toggleBool("inSqueeze"))}
                {pill("Squeeze Release", filters.squeezeRelease === true, () => toggleBool("squeezeRelease"))}
                {pill("Momentum Elite", filters.momentumElite === true, () => toggleBool("momentumElite"))}
              </div>
            </div>

            <div className="space-y-2">
              <div className="text-[10px] text-[#6b7a9f] font-semibold">Groups</div>
              <div className="flex gap-2 flex-wrap items-center">
                {pill("All", group === "ALL", () => onChange({ group: "ALL" }))}
                {pill("Upticks", group === "UPTICKS", () => onChange({ group: "UPTICKS" }))}
                {pill("Super Granny", group === "SuperGranny", () => onChange({ group: "SuperGranny" }))}
                {pill("GRNY", group === "GRNY", () => onChange({ group: "GRNY" }))}
                {pill("GRNJ", group === "GRNJ", () => onChange({ group: "GRNJ" }))}
                {pill("GRNI", group === "GRNI", () => onChange({ group: "GRNI" }))}
                {pill("Social", group === "Social", () => onChange({ group: "Social" }))}
                {pill("No Group", group === "UNGROUPED", () => onChange({ group: "UNGROUPED" }))}
              </div>

              <div className="text-[10px] text-[#6b7a9f] font-semibold mt-1">S&amp;P Sectors</div>
              <div className="flex gap-2 flex-wrap items-center">
                {pill("All", sector === "ALL", () => onChange({ sector: undefined }))}
                {pill("S&P Sectors", group === "SP_Sectors", () => onChange({ group: "SP_Sectors" }))}
                {pill(`${sectorEmoji("Communication Services")} Comm`, sector === "Communication Services", () => onChange({ sector: "Communication Services" }))}
                {pill(`${sectorEmoji("Consumer Discretionary")} Cons Disc`, sector === "Consumer Discretionary", () => onChange({ sector: "Consumer Discretionary" }))}
                {pill(`${sectorEmoji("Consumer Staples")} Cons Staples`, sector === "Consumer Staples", () => onChange({ sector: "Consumer Staples" }))}
                {pill(`${sectorEmoji("Energy")} Energy`, sector === "Energy", () => onChange({ sector: "Energy" }))}
                {pill(`${sectorEmoji("Financials")} Financials`, sector === "Financials", () => onChange({ sector: "Financials" }))}
                {pill(`${sectorEmoji("Health Care")} Health`, sector === "Health Care", () => onChange({ sector: "Health Care" }))}
                {pill(`${sectorEmoji("Industrials")} Industrials`, sector === "Industrials", () => onChange({ sector: "Industrials" }))}
                {pill(`${sectorEmoji("Information Technology")} Tech`, sector === "Information Technology", () => onChange({ sector: "Information Technology" }))}
                {pill(`${sectorEmoji("Materials")} Materials`, sector === "Materials", () => onChange({ sector: "Materials" }))}
                {pill(`${sectorEmoji("Real Estate")} Real Estate`, sector === "Real Estate", () => onChange({ sector: "Real Estate" }))}
                {pill(`${sectorEmoji("Utilities")} Utilities`, sector === "Utilities", () => onChange({ sector: "Utilities" }))}
              </div>

            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Opportunities Panel: unified (Prime/Eligible/Watch)
      // ─────────────────────────────────────────────────────────────
      function OpportunitiesPanel({
        tickers = [],
        rankPositions = null,
        onSelectTicker,
        defaultView = "prime",
        title = "✨ Opportunities",
        maxHeightClass = "max-h-[520px]",
        onFilteredTickersChange = null,
        showControls = true,
      }) {
        const [view, setView] = React.useState(defaultView); // prime | eligible | watch | all
        const [dir, setDir] = React.useState("ALL"); // ALL | LONG | SHORT
        const [horizon, setHorizon] = React.useState("ALL"); // ALL | SHORT_TERM | SWING | POSITIONAL
        const [query, setQuery] = React.useState("");

        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isEligible = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);
          const ent = entryType(t);

          // corridor is a core requirement for entry-readiness
          if (!ent?.corridor) return false;
          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (Number.isFinite(completion) && completion > ACTION_GATES.maxCompletion) return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct) return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct) return false;
          if (Number.isFinite(etaConf) && etaConf < ACTION_GATES.minEtaConf) return false;
          if (staleness && staleness !== "FRESH") return false;
          if (Number.isFinite(avgCorr) && avgCorr > ACTION_GATES.maxAvgCorr) return false;
          if (Number.isFinite(diversity) && diversity < ACTION_GATES.minDiversityScore) return false;
          return true;
        };

        const toBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const classify = (t) => {
          const prime = isPrimeBubble(t);
          const eligible = isEligible(t);
          return {
            prime,
            eligible,
            bucket: toBucket(t),
            dir: getDirection(t)?.text || "NEUTRAL",
          };
        };

        const counts = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          let prime = 0;
          let eligible = 0;
          for (const t of list) {
            const c = classify(t);
            if (c.prime) prime++;
            if (c.eligible) eligible++;
          }
          return { prime, eligible, all: list.length };
        }, [tickers]);

        const filtered = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const q = String(query || "").trim().toUpperCase();

          const items = list
            .map((t) => {
              const c = classify(t);
              const status = c.prime ? "prime" : c.eligible ? "eligible" : "watch";
              const score = Number(rankScoreForTicker(t) || 0);
              const rp =
                getRankPositionFromMap(rankPositions, String(t?.ticker || "").toUpperCase()) ??
                Number(t?.rank_position);
              return { t, c, status, score, rp: Number.isFinite(rp) ? rp : null };
            })
            .filter(({ t, c, status }) => {
              if (!t?.ticker) return false;
              if (!showControls) return true;
              if (view !== "all" && status !== view) return false;
              if (dir !== "ALL" && c.dir !== dir) return false;
              if (horizon !== "ALL" && c.bucket !== horizon) return false;
              if (q && !String(t.ticker).toUpperCase().includes(q)) return false;
              return true;
            })
            .sort((a, b) => {
              const pri = (x) => (x.status === "prime" ? 0 : x.status === "eligible" ? 1 : 2);
              const dp = pri(a) - pri(b);
              if (dp !== 0) return dp;
              const ds = (b.score || 0) - (a.score || 0);
              if (ds !== 0) return ds;
              // prefer better (lower) rank position if present
              if (a.rp != null && b.rp != null) return a.rp - b.rp;
              return String(a.t.ticker).localeCompare(String(b.t.ticker));
            });

          return items;
        }, [tickers, view, dir, horizon, query, rankPositions]);

        React.useEffect(() => {
          if (!onFilteredTickersChange) return;
          try {
            onFilteredTickersChange(
              filtered.map((x) => x.t),
              { view, dir, horizon, query, count: filtered.length }
            );
          } catch (e) {
            console.warn("[Viewport] onFilteredTickersChange failed", e);
          }
        }, [filtered, view, dir, horizon, query, onFilteredTickersChange]);

        const Row = ({ item }) => {
          const t = item.t;
          const c = item.c;
          const actionInfo = getActionDescription(t);
          const price = Number(t?.price);
          const rr = Number(t?.rr);
          const eta = computeEtaDays(t);
          const ingestText = formatIngestTime(t);
          const sl = Number(t?.sl ?? t?.sl_price);
          const tpTarget = computeTpTargetPrice(t);
          const tpMax = computeTpMaxPrice(t);
          const tpDisplay =
            Number.isFinite(tpTarget) && tpTarget > 0
              ? tpTarget
              : Number.isFinite(tpMax) && tpMax > 0
              ? tpMax
              : null;

          const pickNum = (obj, keys) => {
            for (const k of keys) {
              const v = Number(obj?.[k]);
              if (Number.isFinite(v)) return v;
            }
            return null;
          };
          let dayChg = pickNum(t, [
            "day_change",
            "daily_change",
            "change",
            "session_change",
            "chg",
            "ch",
          ]);
          let dayPct = pickNum(t, [
            "day_change_pct",
            "daily_change_pct",
            "change_pct",
            "pct_change",
            "session_change_pct",
            "chp",
          ]);

          // If only one of (abs, pct) is present, compute the other using current price
          if (!Number.isFinite(dayChg) && Number.isFinite(dayPct) && Number.isFinite(price) && price > 0) {
            const p = dayPct / 100;
            if (Number.isFinite(p) && Math.abs(p) < 5) {
              const prev = price / (1 + p);
              const abs = price - prev;
              dayChg = Number.isFinite(abs) ? abs : null;
            }
          }
          if (!Number.isFinite(dayPct) && Number.isFinite(dayChg) && Number.isFinite(price) && price > 0) {
            const prev = price - dayChg;
            if (Number.isFinite(prev) && Math.abs(prev) > 1e-9) {
              dayPct = (dayChg / prev) * 100;
            }
          }
          const chgColor = Number(dayChg || dayPct || 0) >= 0 ? "text-green-400" : "text-red-400";

          const statusPill =
            item.status === "prime"
              ? { label: "Prime", cls: "bg-yellow-500/15 text-yellow-300 border-yellow-500/40" }
              : item.status === "eligible"
              ? { label: "Eligible", cls: "bg-green-500/15 text-green-400 border-green-500/40" }
              : { label: "Watch", cls: "bg-[#26325f] text-[#93a4d6] border-[#26325f]" };

          const dirPill =
            c.dir === "LONG"
              ? { label: "LONG", cls: "bg-green-500/10 text-green-400 border-green-500/30" }
              : c.dir === "SHORT"
              ? { label: "SHORT", cls: "bg-red-500/10 text-red-400 border-red-500/30" }
              : { label: c.dir, cls: "bg-[#26325f] text-[#93a4d6] border-[#26325f]" };

          return (
            <button
              key={t.ticker}
              onClick={() => onSelectTicker && onSelectTicker(t.ticker)}
              className="w-full text-left px-3 py-2 rounded-lg border border-[#26325f] bg-[#121a33] hover:bg-[#16224a] hover:border-[#3a4aa0] transition-all"
              title="Open in right rail"
            >
              <div className="flex items-start justify-between gap-2">
                <div className="min-w-0">
                  <div className="flex items-center gap-2 flex-wrap">
                    <div className="font-bold text-white">{t.ticker}</div>
                    <span className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${statusPill.cls}`}>
                      {statusPill.label}
                    </span>
                    <span className={`px-2 py-0.5 rounded border text-[10px] font-semibold ${dirPill.cls}`}>
                      {dirPill.label}
                    </span>
                    {c.bucket && c.bucket !== "UNKNOWN" && (
                      <span className="px-2 py-0.5 rounded border border-[#26325f] bg-[#0f1630] text-[10px] text-[#93a4d6]">
                        {c.bucket === "SHORT_TERM" ? "≤7d" : c.bucket === "SWING" ? "8–30d" : "31d+"}
                      </span>
                    )}
                  </div>
                  <div className="mt-0.5 text-[11px] text-[#93a4d6] whitespace-nowrap overflow-hidden text-ellipsis">
                    <span className="text-[#6b7a9f]">{actionInfo.action}</span>
                  </div>
                </div>

                <div className="flex-shrink-0 text-right text-[11px]">
                  <div className="text-white">
                    {Number.isFinite(price) ? `$${price.toFixed(2)}` : "—"}
                  </div>
                  <div className={`mt-0.5 ${chgColor}`}>
                    {Number.isFinite(dayPct) ? `${dayPct >= 0 ? "+" : ""}${dayPct.toFixed(2)}%` : "—"}{" "}
                    {Number.isFinite(dayChg) ? `(${dayChg >= 0 ? "+" : ""}${fmtUsd(dayChg)})` : ""}
                  </div>
                  <div className="text-[#6b7a9f]">{ingestText}</div>
                </div>
              </div>

              <div className="mt-1 grid grid-cols-6 gap-2 text-[10px] text-[#93a4d6]">
                <div>
                  <span className="text-[#6b7a9f]">Score</span>{" "}
                  <span className="text-white font-semibold">{Number(item.score || 0).toFixed(1)}</span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">Rank</span>{" "}
                  <span className="text-white font-semibold">{item.rp != null ? `#${item.rp}` : "—"}</span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">RR</span>{" "}
                  <span className="text-white font-semibold">{Number.isFinite(rr) ? rr.toFixed(2) : "—"}</span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">SL</span>{" "}
                  <span className="text-red-400 font-semibold">{Number.isFinite(sl) ? `$${sl.toFixed(2)}` : "—"}</span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">TP</span>{" "}
                  <span className="text-green-400 font-semibold">{Number.isFinite(tpDisplay) ? `$${tpDisplay.toFixed(2)}` : "—"}</span>
                </div>
                <div>
                  <span className="text-[#6b7a9f]">ETA</span>{" "}
                  <span className="text-white font-semibold">{eta != null ? `${eta.toFixed(1)}d` : "—"}</span>
                </div>
              </div>
            </button>
          );
        };

        const pill = (label, isActive, onClick) => (
          <button
            onClick={onClick}
            className={`px-2.5 py-1 rounded-lg border text-xs font-semibold transition-all ${
              isActive
                ? "border-blue-400 bg-blue-500/20 text-blue-200"
                : "border-[#26325f] bg-[#0f1630] text-[#93a4d6] hover:text-white"
            }`}
          >
            {label}
          </button>
        );

        return (
          <div className="bg-[#0f1630] border border-[#26325f] rounded-xl p-3">
            <div className="flex items-start justify-between gap-3 flex-wrap">
              <div>
                <div className="text-sm font-bold text-white">{title}</div>
                <div className="text-[10px] text-[#93a4d6] mt-0.5">
                  Prime {counts.prime} • Eligible {counts.eligible} • Total {counts.all}
                </div>
              </div>
              {showControls && (
                <div className="flex items-center gap-2">
                  <input
                    value={query}
                    onChange={(e) => setQuery(e.target.value)}
                    placeholder="Ticker…"
                    className="px-2 py-1 text-xs bg-[#0f1630] border border-[#26325f] rounded text-white w-[110px]"
                  />
                </div>
              )}
            </div>

            {showControls && (
              <div className="mt-2 flex items-center gap-2 flex-wrap">
                {pill("Prime", view === "prime", () => setView("prime"))}
                {pill("Eligible", view === "eligible", () => setView("eligible"))}
                {pill("Watch", view === "watch", () => setView("watch"))}
                {pill("All", view === "all", () => setView("all"))}
                <div className="w-px h-6 bg-[#26325f] mx-1" />
                {pill("All", dir === "ALL", () => setDir("ALL"))}
                {pill("Long", dir === "LONG", () => setDir("LONG"))}
                {pill("Short", dir === "SHORT", () => setDir("SHORT"))}
                <div className="w-px h-6 bg-[#26325f] mx-1" />
                {pill("Any horizon", horizon === "ALL", () => setHorizon("ALL"))}
                {pill("≤7d", horizon === "SHORT_TERM", () => setHorizon("SHORT_TERM"))}
                {pill("8–30d", horizon === "SWING", () => setHorizon("SWING"))}
                {pill("31d+", horizon === "POSITIONAL", () => setHorizon("POSITIONAL"))}
              </div>
            )}

            <div className={`mt-3 ${maxHeightClass} overflow-y-auto space-y-2 pr-1`}>
              {filtered.length === 0 ? (
                <div className="text-xs text-[#6b7a9f] p-3">No matches.</div>
              ) : (
                filtered.slice(0, 75).map((item) => <Row key={item.t.ticker} item={item} />)
              )}
            </div>
          </div>
        );
      }

      function ActionPanel({ tickers = [], onSelectTicker }) {
        const getNum = (x) => {
          const n = Number(x);
          return Number.isFinite(n) ? n : null;
        };

        const ACTION_GATES = {
          minRR: 1.5,
          maxCompletion: 0.6,
          minReturnPct: 5,
          minEtaConf: 0.55,
          minRiskPct: 0.5,
          maxAvgCorr: 0.75,
          minDiversityScore: 25,
        };

        const isActionable = (t) => {
          if (!t) return false;
          const rr = Number(t.rr);
          const completion = Number(t.completion);
          const ret = computeReturnPct(t);
          const risk = computeRiskPct(t);
          const etaConf = getNum(t.eta_confidence);
          const staleness = String(t.staleness || "").toUpperCase();
          const avgCorr = Number(t.avg_corr);
          const diversity = Number(t.diversity_score);

          if (Number.isFinite(rr) && rr < ACTION_GATES.minRR) return false;
          if (
            Number.isFinite(completion) &&
            completion > ACTION_GATES.maxCompletion
          )
            return false;
          if (Number.isFinite(ret) && ret < ACTION_GATES.minReturnPct) return false;
          if (Number.isFinite(risk) && risk < ACTION_GATES.minRiskPct) return false;
          if (
            Number.isFinite(etaConf) &&
            etaConf < ACTION_GATES.minEtaConf
          )
            return false;
          if (staleness && staleness !== "FRESH") return false;
          if (
            Number.isFinite(avgCorr) &&
            avgCorr > ACTION_GATES.maxAvgCorr
          )
            return false;
          if (
            Number.isFinite(diversity) &&
            diversity < ACTION_GATES.minDiversityScore
          )
            return false;
          return true;
        };

        const selectWithConstraints = (list, limit) => {
          const maxPerSector = 1;
          const sectorCounts = new Map();
          const picks = [];
          for (const t of list) {
            if (picks.length >= limit) break;
            if (!isActionable(t)) continue;
            const sector =
              t.sector ||
              (t.fundamentals && t.fundamentals.sector) ||
              "UNKNOWN";
            const count = sectorCounts.get(sector) || 0;
            if (count >= maxPerSector) continue;
            sectorCounts.set(sector, count + 1);
            picks.push(t);
          }
          return picks;
        };

        const normBucket = (t) => {
          const raw = t?.horizon_bucket;
          if (raw) return String(raw).toUpperCase();
          const eta = getNum(t?.eta_days_v2 ?? t?.eta_days);
          if (!Number.isFinite(eta) || eta <= 0) return "UNKNOWN";
          if (eta <= 7) return "SHORT_TERM";
          if (eta <= 30) return "SWING";
          return "POSITIONAL";
        };

        const byBucket = React.useMemo(() => {
          const list = Array.isArray(tickers) ? tickers : [];
          const pickWithConstraints = (bucket, limit) => {
            const sorted = list
              .filter((t) => normBucket(t) === bucket)
              .slice()
              .sort(
                (a, b) =>
                  (Number(b.dynamicRank) || 0) - (Number(a.dynamicRank) || 0)
              );
            return selectWithConstraints(sorted, limit);
          };
          return {
            SHORT_TERM: pickWithConstraints("SHORT_TERM", 3),
            SWING: pickWithConstraints("SWING", 3),
            POSITIONAL: pickWithConstraints("POSITIONAL", 2),
          };
        }, [tickers]);

        const renderRow = (label, bucket, items) => {
          return (
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="text-xs font-bold text-[#e7ecff]">
                  {label}
                </div>
                <div className="text-[10px] text-[#93a4d6]">{bucket}</div>
              </div>
              {items.length === 0 ? (
                <div className="text-xs text-[#6b7a9f]">No matches.</div>
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-2">
                  {items.map((t) => {
                    const eta = computeEtaDays(t);
                    const retPct = computeReturnPct(t);
                    const riskPct = computeRiskPct(t);
                    const conf = getNum(t.eta_confidence);
                    const entryZone = formatEntryZone(t);
                    const sl = Number(t?.sl);
                    const tpTarget = computeTpTargetPrice(t);
                    const tpMax = computeTpMaxPrice(t);
                    const tpDisplay =
                      Number.isFinite(tpTarget) && tpTarget > 0
                        ? tpTarget
                        : Number.isFinite(tpMax) && tpMax > 0
                        ? tpMax
                        : null;
                    const price = Number(t?.price);
                    const staleness = String(t?.staleness || "").toUpperCase();
                    const isStale = staleness && staleness !== "FRESH";
                    const ingestText = formatIngestTime(t);
                    const avgCorr = Number(t?.avg_corr);
                    const diversity = Number(t?.diversity_score);
                    return (
                      <button
                        key={`${bucket}-${t.ticker}`}
                        onClick={() => onSelectTicker && onSelectTicker(t.ticker)}
                        className="text-left px-3 py-2 rounded-lg border border-[#26325f] bg-[#121a33] hover:bg-[#16224a] hover:border-[#3a4aa0] transition-all"
                        title="Open in right rail"
                      >
                        <div className="flex items-center justify-between gap-2">
                          <div className="font-bold text-white">
                            {t.ticker}
                          </div>
                          <div className="text-[10px] text-[#93a4d6]">
                            Score {Number(t.dynamicRank || t.rank || 0).toFixed(1)}
                          </div>
                        </div>
                        <div className="mt-0.5 flex items-center justify-between gap-2 text-[10px] text-[#93a4d6]">
                          <div className="text-white">
                            {Number.isFinite(price) ? `$${price.toFixed(2)}` : "—"}
                          </div>
                          <div className="flex items-center gap-2">
                            {isStale && (
                              <span className="px-1.5 py-0.5 rounded bg-yellow-500/20 text-yellow-300 border border-yellow-500/40">
                                Delayed
                              </span>
                            )}
                            <span className="text-[#6b7a9f]">{ingestText}</span>
                          </div>
                        </div>
                        <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[#93a4d6]">
                          <div>
                            <span className="text-[#6b7a9f]">ETA</span>{" "}
                            <span className="text-white">
                              {eta != null ? `${eta.toFixed(1)}d` : "—"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">Ret</span>{" "}
                            <span className="text-white">
                              {retPct != null ? `${retPct.toFixed(1)}%` : "—"}
                            </span>
                          </div>
                          <div>
                            <span className="text-[#6b7a9f]">Risk</span>{" "}
                            <span className="text-white">
                              {riskPct != null ? `${riskPct.toFixed(1)}%` : "—"}
                            </span>
                          </div>
                        </div>
                        <div className="mt-1 grid grid-cols-3 gap-2 text-[10px] text-[#6b7a9f]">
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">Entry</span>{" "}
                            <span className="text-white whitespace-normal break-words">
                              {entryZone}
                            </span>
                          </div>
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">TP</span>{" "}
                            <span className="text-green-400">
                              {Number.isFinite(tpDisplay)
                                ? `$${tpDisplay.toFixed(2)}`
                                : "—"}
                            </span>
                          </div>
                          <div className="min-w-0">
                            <span className="text-[#5b6890]">SL</span>{" "}
                            <span className="text-red-400">
                              {Number.isFinite(sl) ? `$${sl.toFixed(2)}` : "—"}
                            </span>
                          </div>
                        </div>
                        <div className="mt-1 text-[10px] text-[#6b7a9f]">
                          {conf != null ? `ETA conf: ${conf.toFixed(2)}` : ""}
                          {Number.isFinite(diversity) && (
                            <span className="ml-2 text-[#93a4d6]">
                              Div {Math.round(diversity)}
                            </span>
                          )}
                          {Number.isFinite(avgCorr) && (
                            <span className="ml-2 text-[#93a4d6]">
                              Corr {avgCorr.toFixed(2)}
                            </span>
                          )}
                        </div>
                      </button>
                    );
                  })}
                </div>
              )}
            </div>
          );
        };

        return (
          <div className="mb-4 p-3 bg-[#0f1630] border border-[#26325f] rounded-xl">
            <div className="flex items-center justify-between mb-3">
              <div className="text-sm font-bold text-white">
                🎯 Action Panel (Top Picks)
              </div>
              <div className="text-[10px] text-[#93a4d6]">
                Short=≤7d • Swing=8–30d • Positional=31d+
              </div>
            </div>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
              {renderRow("Short-Term", "SHORT_TERM", byBucket.SHORT_TERM)}
              {renderRow("Swing", "SWING", byBucket.SWING)}
              {renderRow("Positional", "POSITIONAL", byBucket.POSITIONAL)}
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Ingestion Status Panel (minimizable)
      // ─────────────────────────────────────────────────────────────
      function IngestionStatusPanel({
        allData,
        filteredTickers,
        onRefresh,
        defaultMinimized = true,
      }) {
        const storageKey = "timedTrading_ingestionPanelMinimized";
        const [minimized, setMinimized] = React.useState(() => {
          try {
            const raw = localStorage.getItem(storageKey);
            if (raw === null) return defaultMinimized;
            return raw === "true";
          } catch {
            return defaultMinimized;
          }
        });

        React.useEffect(() => {
          try {
            localStorage.setItem(storageKey, String(minimized));
          } catch {}
        }, [minimized]);

        const now = Date.now();
        const allTickers = React.useMemo(() => {
          if (!allData || typeof allData !== "object") return [];
          const values = Array.isArray(allData)
            ? allData
            : Object.values(allData);
          return values.filter((t) => t && typeof t === "object" && t.ticker);
        }, [allData]);

        const getMs = (x) => {
          if (!x) return null;
          if (typeof x === "number" && Number.isFinite(x)) return x;
          if (typeof x === "string") {
            const ms = new Date(x).getTime();
            return Number.isFinite(ms) ? ms : null;
          }
          return null;
        };

        const toAgeMin = (t) => {
          // Prefer ingest_ts, then ts
          const ms =
            getMs(t.ingest_ts) ||
            getMs(t.ts) ||
            getMs(t.timestamp) ||
            getMs(t.last_update);
          if (!ms) return null;
          return (now - ms) / 60000;
        };

        const stats = React.useMemo(() => {
          const bucket = {
            total: allTickers.length,
            filtered: Array.isArray(filteredTickers)
              ? filteredTickers.length
              : 0,
            missing: 0,
            fresh: 0,
            warn: 0,
            stale: 0,
            veryStale: 0,
            worst: [],
          };

          const withAge = allTickers
            .map((t) => {
              const ageMin = toAgeMin(t);
              return {
                ticker: t.ticker,
                ageMin,
                ingest_ts: t.ingest_ts,
                ts: t.ts,
              };
            })
            .sort((a, b) => {
              const aa = a.ageMin ?? -1;
              const bb = b.ageMin ?? -1;
              return bb - aa;
            });

          withAge.forEach((r) => {
            if (r.ageMin === null) {
              bucket.missing++;
              return;
            }
            if (r.ageMin <= 10) bucket.fresh++;
            else if (r.ageMin <= 20) bucket.warn++;
            else if (r.ageMin <= 60) bucket.stale++;
            else bucket.veryStale++;
          });

          bucket.worst = withAge.filter((r) => r.ageMin !== null).slice(0, 10);

          return bucket;
        }, [allTickers, filteredTickers, now]);

        const badge = (() => {
          if (stats.total === 0) return "—";
          if (stats.veryStale > 0 || stats.missing > 0) return "⚠️";
          if (stats.stale > 0) return "🟡";
          return "✅";
        })();

        if (minimized) {
          return (
            <div className="fixed bottom-4 left-4 z-50">
              <button
                onClick={() => setMinimized(false)}
                className="px-3 py-2 bg-[#0f1630]/95 backdrop-blur-sm border border-[#26325f] rounded-lg text-xs text-white shadow-lg hover:bg-[#141f3d]"
              >
                📡 Ingestion {badge} ({stats.fresh}/{stats.total})
              </button>
            </div>
          );
        }

        return (
          <div className="fixed bottom-4 left-4 z-50 w-[340px] max-w-[90vw] bg-[#0f1630]/95 backdrop-blur-sm border border-[#26325f] rounded-xl shadow-2xl">
            <div className="flex items-center justify-between px-3 py-2 border-b border-[#26325f]">
              <div className="text-sm font-bold text-white flex items-center gap-2">
                📡 Ingestion Status <span className="text-xs">{badge}</span>
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={onRefresh}
                  className="px-2 py-1 bg-[#26325f] hover:bg-[#3a4aa0] rounded text-xs text-white"
                  title="Refresh data"
                >
                  🔄
                </button>
                <button
                  onClick={() => setMinimized(true)}
                  className="px-2 py-1 bg-[#26325f] hover:bg-[#3a4aa0] rounded text-xs text-white"
                  title="Minimize"
                >
                  ▾
                </button>
              </div>
            </div>

            <div className="p-3 text-xs text-[#93a4d6] space-y-2">
              <div className="flex flex-wrap gap-x-3 gap-y-1">
                <div>
                  <span className="text-white font-semibold">Total:</span>{" "}
                  {stats.total}
                </div>
                <div>
                  <span className="text-white font-semibold">Visible:</span>{" "}
                  {stats.filtered}
                </div>
              </div>

              <div className="grid grid-cols-2 gap-2">
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">Fresh (≤10m)</div>
                  <div className="text-[#2ecc71] font-bold">{stats.fresh}</div>
                </div>
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">Warn (10–20m)</div>
                  <div className="text-[#f39c12] font-bold">{stats.warn}</div>
                </div>
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">Stale (20–60m)</div>
                  <div className="text-[#e67e22] font-bold">{stats.stale}</div>
                </div>
                <div className="bg-[#121a33] border border-[#26325f] rounded p-2">
                  <div className="text-white font-semibold">
                    &gt;60m / Missing
                  </div>
                  <div className="text-[#e74c3c] font-bold">
                    {stats.veryStale + stats.missing}
                  </div>
                </div>
              </div>

              <div className="mt-2">
                <div className="text-white font-semibold mb-1">
                  Worst offenders
                </div>
                <div className="max-h-[160px] overflow-y-auto space-y-1 pr-1">
                  {stats.worst.length === 0 ? (
                    <div className="text-[#93a4d6]">No timestamps found.</div>
                  ) : (
                    stats.worst.map((r) => (
                      <div
                        key={r.ticker}
                        className="flex items-center justify-between bg-[#121a33] border border-[#26325f] rounded px-2 py-1"
                      >
                        <div className="text-white font-semibold">
                          {r.ticker}
                        </div>
                        <div className="text-[#93a4d6]">
                          {Math.round(r.ageMin)}m
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>

              <div className="text-[10px] text-[#6b7a9f]">
                Uses `ingest_ts` (preferred) then `ts` to estimate freshness.
              </div>
            </div>
          </div>
        );
      }

      // Helper: Get quadrant from state
      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK")
          return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL")
          return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR")
          return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK")
          return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      // Pattern detection
      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map((p) => p.state).filter(Boolean);
        const safeFlags = flags || {};

        // Pattern 1: Clean Q1→Q2 or Q4→Q3 transition (ideal entry)
        for (let i = 1; i < states.length; i++) {
          if (
            states[i - 1] === "HTF_BULL_LTF_PULLBACK" &&
            states[i] === "HTF_BULL_LTF_BULL"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1→Q2 transition (Bull Entry)",
              quadrant: "Q1→Q2",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
          if (
            states[i - 1] === "HTF_BEAR_LTF_PULLBACK" &&
            states[i] === "HTF_BEAR_LTF_BEAR"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4→Q3 transition (Bear Entry)",
              quadrant: "Q4→Q3",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 2: Momentum Elite + Setup quadrant
        const currentState = states[states.length - 1];
        if (
          (currentState === "HTF_BULL_LTF_PULLBACK" ||
            currentState === "HTF_BEAR_LTF_PULLBACK") &&
          safeFlags.momentum_elite
        ) {
          patterns.push({
            type: "ELITE_SETUP",
            description: "Momentum Elite in Setup Quadrant",
            quadrant: getQuadrantFromState(currentState)?.name,
            confidence: "HIGH",
          });
        }

        // Pattern 3: Squeeze release in setup quadrant
        const lastPoint = trail[trail.length - 1];
        if (lastPoint && lastPoint.flags && lastPoint.flags.sq30_release) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "SQUEEZE_SETUP",
              description: "Squeeze Release in Setup Quadrant",
              quadrant: q.name,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 4: Multiple quadrant visits (chop vs clean)
        const uniqueQuads = new Set(
          states.map((s) => getQuadrantFromState(s)?.q).filter(Boolean)
        );
        if (uniqueQuads.size > 2 && states.length > 5) {
          patterns.push({
            type: "CHOPPY",
            description: "Multiple quadrant visits (choppy action)",
            confidence: "MEDIUM",
          });
        } else if (uniqueQuads.size === 1 && states.length >= 3) {
          patterns.push({
            type: "STABLE",
            description: "Stable quadrant (consistent state)",
            quadrant: getQuadrantFromState(states[0])?.name,
            confidence: "MEDIUM",
          });
        }

        // Pattern 5: Phase zone change in setup
        if (lastPoint && lastPoint.flags && lastPoint.flags.phase_zone_change) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "PHASE_SHIFT",
              description: "Phase zone change in Setup",
              quadrant: q.name,
              confidence: "MEDIUM",
            });
          }
        }

        return patterns;
      }

      // Separate component for Quadrant Progression to properly use hooks
      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = React.useState([]);
        const [loading, setLoading] = React.useState(false); // Start as false
        const [hasLoaded, setHasLoaded] = React.useState(false);

        React.useEffect(() => {
          // Defer trail loading to not block initial render
          // Only load if component is mounted and ticker is valid
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const controller = new AbortController();
                const timeoutId2 = setTimeout(() => controller.abort(), 3000); // 3s timeout (reduced from 5s)

                const response = await fetch(
                  `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                    ticker.ticker
                  )}`,
                  { signal: controller.signal }
                );

                clearTimeout(timeoutId2);

                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                if (data.ok && Array.isArray(data.trail)) {
                  setTrail(data.trail);
                } else {
                  setTrail([]); // Set empty if no trail data
                }
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.error("Failed to load trail:", e);
                }
                // Set empty trail on error to prevent infinite retries
                setTrail([]);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300); // Slightly longer delay to ensure overlay is rendered first
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);

        const sampledTrail = React.useMemo(
          () => downsampleByInterval(trail, 15 * 60 * 1000),
          [trail]
        );

        const patterns = detectPatterns(sampledTrail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = sampledTrail
          .map((p) => getQuadrantFromState(p.state))
          .filter(Boolean);

        return (
          <div className="mb-4 p-4 bg-[#0f1630] rounded-lg border border-[#26325f]">
            <div className="text-sm font-bold mb-3 text-[#93a4d6]">
              Quadrant Progression (15m increments)
            </div>

            {/* Quadrant Map */}
            <div className="grid grid-cols-2 gap-2 mb-4">
              {/* Q1 - Bull Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 1
                    ? "border-blue-400 bg-blue-500/20"
                    : quadHistory.some((q) => q && q.q === 1)
                    ? "border-blue-500/50 bg-blue-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-blue-400">
                  Q1: Bull Setup
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BULL_LTF_PULLBACK
                </div>
              </div>

              {/* Q2 - Bull Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 2
                    ? "border-green-400 bg-green-500/20"
                    : quadHistory.some((q) => q && q.q === 2)
                    ? "border-green-500/50 bg-green-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-green-400">
                  Q2: Bull Momentum
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BULL_LTF_BULL
                </div>
              </div>

              {/* Q4 - Bear Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 4
                    ? "border-orange-400 bg-orange-500/20"
                    : quadHistory.some((q) => q && q.q === 4)
                    ? "border-orange-500/50 bg-orange-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-orange-400">
                  Q4: Bear Setup
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BEAR_LTF_PULLBACK
                </div>
              </div>

              {/* Q3 - Bear Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 3
                    ? "border-red-400 bg-red-500/20"
                    : quadHistory.some((q) => q && q.q === 3)
                    ? "border-red-500/50 bg-red-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-red-400">
                  Q3: Bear Momentum
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BEAR_LTF_BEAR
                </div>
              </div>
            </div>

            {/* Path Visualization */}
            {trail.length > 0 && (
              <div className="mb-4">
                <div className="text-xs font-semibold text-[#93a4d6] mb-2">
                  Path ({trail.length} points)
                </div>
                <div className="flex items-center gap-1 flex-wrap">
                  {quadHistory.map((q, idx) => {
                    if (!q) return null;
                    const isLast = idx === quadHistory.length - 1;
                    const colorClasses = {
                      blue: isLast
                        ? "bg-blue-500/30 border-2 border-blue-400 text-blue-300"
                        : "bg-blue-500/10 border border-blue-500/50 text-blue-400",
                      green: isLast
                        ? "bg-green-500/30 border-2 border-green-400 text-green-300"
                        : "bg-green-500/10 border border-green-500/50 text-green-400",
                      red: isLast
                        ? "bg-red-500/30 border-2 border-red-400 text-red-300"
                        : "bg-red-500/10 border border-red-500/50 text-red-400",
                      orange: isLast
                        ? "bg-orange-500/30 border-2 border-orange-400 text-orange-300"
                        : "bg-orange-500/10 border border-orange-500/50 text-orange-400",
                    };
                    return (
                      <React.Fragment key={idx}>
                        <div
                          className={`px-2 py-1 rounded text-[10px] font-bold ${
                            colorClasses[q.color] || colorClasses.blue
                          }`}
                        >
                          {q.name}
                        </div>
                        {idx < quadHistory.length - 1 && (
                          <span className="text-[#93a4d6] text-xs">→</span>
                        )}
                      </React.Fragment>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Pattern Detection */}
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs font-bold text-yellow-400 mb-2">
                  🎯 Detected Patterns
                </div>
                <div className="space-y-2">
                  {patterns.map((pattern, idx) => (
                    <div
                      key={idx}
                      className={`p-2 rounded border ${
                        pattern.confidence === "HIGH"
                          ? "bg-yellow-500/20 border-yellow-400/50"
                          : "bg-blue-500/10 border-blue-500/30"
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="text-xs font-bold text-white">
                            {pattern.description}
                          </div>
                          {pattern.quadrant && (
                            <div className="text-[10px] text-[#93a4d6] mt-0.5">
                              {pattern.quadrant}
                            </div>
                          )}
                        </div>
                        <span
                          className={`text-[10px] px-1.5 py-0.5 rounded ${
                            pattern.confidence === "HIGH"
                              ? "bg-yellow-500/30 text-yellow-300"
                              : "bg-blue-500/30 text-blue-300"
                          }`}
                        >
                          {pattern.confidence}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {loading && (
              <div className="text-xs text-[#93a4d6] text-center py-2">
                Loading history...
              </div>
            )}
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // Unified Ticker Detail Right Rail Component
      // Reusable component that shows comprehensive ticker information
      // and optionally trade history if a trade is associated
      // ─────────────────────────────────────────────────────────────
      function TickerDetailRightRail({
        ticker,
        trade = null,
        onClose,
        allLoadedData = null,
        rankedTickers = null,
        rankedTickerPositions = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
      }) {
        const tickerSymbol = ticker?.ticker ? String(ticker.ticker) : "";

        const [ledgerTrades, setLedgerTrades] = useState([]);
        const [ledgerTradesLoading, setLedgerTradesLoading] = useState(false);
        const [ledgerTradesError, setLedgerTradesError] = useState(null);

        const [bubbleJourney, setBubbleJourney] = useState([]);
        const [bubbleJourneyLoading, setBubbleJourneyLoading] = useState(false);
        const [bubbleJourneyError, setBubbleJourneyError] = useState(null);

        useEffect(() => {
          const sym = String(tickerSymbol || "").trim().toUpperCase();
          if (!sym) {
            setLedgerTrades([]);
            setLedgerTradesError(null);
            setLedgerTradesLoading(false);
            return;
          }

          let cancelled = false;
          const fetchLedgerTrades = async () => {
            try {
              setLedgerTradesLoading(true);
              setLedgerTradesError(null);
              const qs = new URLSearchParams();
              qs.set("ticker", sym);
              qs.set("limit", "20");
              const res = await fetch(
                `${API_BASE}/timed/ledger/trades?${qs.toString()}`,
                { cache: "no-store" }
              );
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok) throw new Error(json.error || "ledger_trades_failed");
              const trades = Array.isArray(json.trades) ? json.trades : [];
              if (!cancelled) setLedgerTrades(trades);
            } catch (e) {
              if (!cancelled) {
                setLedgerTrades([]);
                setLedgerTradesError(String(e.message || e));
              }
            } finally {
              if (!cancelled) setLedgerTradesLoading(false);
            }
          };

          fetchLedgerTrades();
          return () => {
            cancelled = true;
          };
        }, [tickerSymbol]);

        useEffect(() => {
          const sym = String(tickerSymbol || "").trim().toUpperCase();
          if (!sym) {
            setBubbleJourney([]);
            setBubbleJourneyError(null);
            setBubbleJourneyLoading(false);
            return;
          }

          let cancelled = false;

          const toMs = (v) => {
            if (v == null) return NaN;
            if (typeof v === "number") return v;
            const n = Number(v);
            if (Number.isFinite(n)) return n;
            const d = new Date(String(v));
            const ms = d.getTime();
            return Number.isFinite(ms) ? ms : NaN;
          };

          const fetchBubbleJourney = async () => {
            try {
              setBubbleJourneyLoading(true);
              setBubbleJourneyError(null);
              const qs = new URLSearchParams();
              qs.set("ticker", sym);
              // Server may return oldest->newest; grab a reasonable window and sort client-side.
              qs.set("limit", "250");
              const res = await fetch(`${API_BASE}/timed/trail?${qs.toString()}`, {
                cache: "no-store",
              });
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (!json.ok) throw new Error(json.error || "trail_failed");
              const raw = Array.isArray(json.trail) ? json.trail : [];
              const normalized = normalizeTrailPoints(raw);
              const withTs = normalized
                .map((p) => {
                  const ts = toMs(p.ts ?? p.timestamp ?? p.ingest_ts ?? p.ingest_time);
                  if (!Number.isFinite(ts)) return null;
                  return { ...p, __ts_ms: ts };
                })
                .filter(Boolean)
                .sort((a, b) => a.__ts_ms - b.__ts_ms);
              const last20 = withTs.slice(-20);
              if (!cancelled) setBubbleJourney(last20);
            } catch (e) {
              if (!cancelled) {
                setBubbleJourney([]);
                setBubbleJourneyError(String(e.message || e));
              }
            } finally {
              if (!cancelled) setBubbleJourneyLoading(false);
            }
          };

          fetchBubbleJourney();
          return () => {
            cancelled = true;
          };
        }, [tickerSymbol]);

        if (!ticker || !tickerSymbol) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);
        const decisionSummary = summarizeEntryDecision(ticker);
        const detectedPatterns = React.useMemo(
          () => detectPatterns(bubbleJourney, flags || {}),
          [bubbleJourney, flags]
        );

        const baseScore = Number(ticker.rank) || 0;
        const sortedByRank =
          rankedTickers && rankedTickers.length > 0
            ? rankedTickers
            : getRankedTickers(allLoadedData);
        const rankPosition =
          getRankPositionFromMap(rankedTickerPositions, tickerSymbol) ??
          getRankPosition(sortedByRank, tickerSymbol);
        const totalTickers = sortedByRank.length;
        const rankTotal =
          Number.isFinite(Number(ticker.rank_total)) && Number(ticker.rank_total) > 0
            ? Number(ticker.rank_total)
            : totalTickers;

        return (
          <div className="w-full h-full flex flex-col">
            <div
              className="bg-[#121a33] border-2 border-[#26325f] rounded-xl w-full h-full flex flex-col shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Scrollable Content Area */}
              <div className="flex-1 overflow-y-auto">
                <div className="sticky top-0 z-30 bg-[#121a33] border-b border-[#26325f] px-6 py-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-xl font-bold">{tickerSymbol}</h3>
                      {ticker.price && (
                        <div className="text-sm text-white mt-1">
                          ${Number(ticker.price).toFixed(2)}
                        </div>
                      )}
                    </div>
                    <button
                      onClick={onClose}
                      className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-8 h-8 flex items-center justify-center rounded hover:bg-[#26325f]"
                    >
                      ✕
                    </button>
                  </div>

                  {/* Last Ingest Date/Time */}
                  {(() => {
                    const ingestTime =
                      ticker.ingest_ts || ticker.ingest_time || ticker.ts;
                    if (!ingestTime) return null;
                    try {
                      const timeValue =
                        typeof ingestTime === "string"
                          ? new Date(ingestTime)
                          : new Date(Number(ingestTime));
                      if (isNaN(timeValue.getTime())) return null;
                      const displayDate = timeValue.toLocaleDateString("en-US", {
                        month: "short",
                        day: "numeric",
                        year: "numeric",
                      });
                      const displayTime = timeValue.toLocaleTimeString("en-US", {
                        hour: "numeric",
                        minute: "2-digit",
                        hour12: true,
                      });
                      const ageMs = Date.now() - timeValue.getTime();
                      const ageMinutes = Math.floor(ageMs / 60000);
                      const ageHours = Math.floor(ageMinutes / 60);
                      const ageDays = Math.floor(ageHours / 24);
                      let ageText;
                      let ageColor = "text-green-400";
                      if (ageMinutes < 5) {
                        ageText = `${ageMinutes}m ago`;
                        ageColor = "text-green-400";
                      } else if (ageMinutes < 60) {
                        ageText = `${ageMinutes}m ago`;
                        ageColor = "text-yellow-400";
                      } else if (ageHours < 24) {
                        ageText = `${ageHours}h ago`;
                        ageColor =
                          ageHours < 2 ? "text-yellow-400" : "text-orange-400";
                      } else {
                        ageText = `${ageDays}d ago`;
                        ageColor = "text-red-400";
                      }
                      return (
                        <div className="mt-2 text-xs flex items-center gap-2">
                          <span className="text-[#93a4d6]">
                            Last Ingest:
                          </span>
                          <span className="text-white font-semibold">
                            {displayDate} {displayTime}
                          </span>
                          <span className={`font-semibold ${ageColor}`}>
                            ({ageText})
                          </span>
                        </div>
                      );
                    } catch {
                      return null;
                    }
                  })()}
                </div>

                {/* Padded body content (keeps header top-aligned) */}
                <div className="p-6 pt-4">
                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      🚀 MOMENTUM ELITE 🚀
                    </div>
                    <div className="text-xs text-purple-200/80 font-normal mb-2">
                      High-quality momentum stock with strong fundamentals
                    </div>
                    {ticker.momentum_pct && (
                      <div className="mt-2 pt-2 border-t border-purple-400/30">
                        <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">
                          Momentum Performance:
                        </div>
                        <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                          {ticker.momentum_pct.week != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1W:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.week) >= 10
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.week).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.month != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.month) >= 25
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.month).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.three_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">3M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.three_months) >= 50
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(
                                  ticker.momentum_pct.three_months
                                ).toFixed(1)}
                                %
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.six_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">6M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.six_months) >= 100
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.six_months).toFixed(
                                  1
                                )}
                                %
                              </span>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                    ⭐ PRIME SETUP ⭐
                  </div>
                )}

                {/* Sector and Rating */}
                {(() => {
                  const tickerSector =
                    getTickerSector(ticker.ticker) ||
                    ticker.sector ||
                    ticker.fundamentals?.sector;
                  if (tickerSector && sectors.length > 0) {
                    const sectorInfo = sectors.find(
                      (s) => (s.sector || s.name) === tickerSector
                    );
                    const rating = sectorInfo?.rating || "neutral";
                    const boost =
                      sectorInfo?.boost != null
                        ? Number(sectorInfo.boost)
                        : null;
                    const emoji =
                      rating === "overweight"
                        ? "📈"
                        : rating === "underweight"
                        ? "📉"
                        : "➡️";
                    return (
                      <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                        <div className="text-sm text-[#93a4d6] mb-2">
                          Sector
                        </div>
                        <div className="flex items-center gap-2 flex-wrap">
                          <span className="text-lg">{emoji}</span>
                          <span className="font-semibold text-white">
                            {tickerSector}
                          </span>
                          <span
                            className={`text-xs px-2 py-1 rounded ${
                              rating === "overweight"
                                ? "bg-green-500/20 text-green-400"
                                : rating === "underweight"
                                ? "bg-red-500/20 text-red-400"
                                : "bg-[#26325f] text-[#93a4d6]"
                            }`}
                          >
                            {rating.charAt(0).toUpperCase() + rating.slice(1)}
                          </span>
                          {Number.isFinite(boost) && boost !== 0 && (
                            <span className="text-[10px] text-[#93a4d6]">
                              Boost {boost > 0 ? `+${boost}` : boost}
                            </span>
                          )}
                        </div>
                      </div>
                    );
                  }
                  return null;
                })()}

                {/* Bias/Direction */}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                      <div className="text-sm text-[#93a4d6] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}
                      >
                        {dir.text === "LONG"
                          ? "📈 LONG"
                          : dir.text === "SHORT"
                          ? "📉 SHORT"
                          : dir.text}
                      </div>
                    </div>
                  );
                })()}

                {/* System Decision */}
                {decisionSummary && (
                  <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                    <div className="text-sm text-[#93a4d6] mb-2">
                      System Decision (Entry)
                    </div>
                    <div className="flex items-center gap-2">
                      <span
                        className={`px-2 py-1 rounded text-xs font-semibold ${decisionSummary.bg} ${decisionSummary.tone}`}
                      >
                        {decisionSummary.status}
                      </span>
                      <span className="text-xs text-[#cbd5ff]">
                        {decisionSummary.detail}
                      </span>
                    </div>
                    {decisionSummary.blockers &&
                      decisionSummary.blockers.length > 0 && (
                        <div className="mt-2 text-[11px] text-[#cbd5ff] space-y-1">
                          {decisionSummary.blockers.map((item, idx) => (
                            <div key={`blocker-${idx}`} className="flex gap-2">
                              <span className="text-yellow-400">•</span>
                              <span>{item}</span>
                            </div>
                          ))}
                        </div>
                      )}
                    {decisionSummary.warnings &&
                      decisionSummary.warnings.length > 0 && (
                        <div className="mt-1 text-[10px] text-yellow-300">
                          Warning: {decisionSummary.warnings[0]}
                        </div>
                      )}
                  </div>
                )}

                {/* Action Description */}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[#93a4d6]">
                    {actionInfo.description}
                  </div>
                </div>



                {/* Score and Ranking */}
                <div className="space-y-2.5 text-sm">
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Score</span>
                    <span className="font-semibold text-blue-400 text-lg">
                      {baseScore}
                    </span>
                  </div>
                  {rankTotal > 0 && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Rank</span>
                      <span className="font-semibold">
                        {rankPosition > 0
                          ? `#${rankPosition} of ${rankTotal}`
                          : "—"}
                      </span>
                    </div>
                  )}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const breakdownComponents = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.rsiDivergence !== 0
                        ? {
                            label: "RSI Divergence",
                            value:
                              breakdown.rsiDivergence > 0
                                ? `+${breakdown.rsiDivergence.toFixed(1)}`
                                : breakdown.rsiDivergence.toFixed(1),
                            color:
                              breakdown.rsiDivergence > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return breakdownComponents.length > 0 ? (
                      <div className="border-t border-[#26325f] my-3 pt-3">
                        <div className="text-xs text-[#93a4d6] mb-3 font-semibold">
                          Score Breakdown
                        </div>
                        <div className="space-y-1.5">
                          {breakdownComponents.map((comp, idx) => (
                            <div
                              key={idx}
                              className="flex justify-between items-center text-xs"
                            >
                              <span className="text-[#93a4d6]">
                                {comp.label}
                              </span>
                              <span className={`font-semibold ${comp.color}`}>
                                {comp.value}
                              </span>
                            </div>
                          ))}
                          <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                            <span className="text-[#93a4d6] font-semibold">
                              Total Score
                            </span>
                            <span className="text-blue-400 font-bold text-base">
                              {Math.round(breakdown.total)}
                            </span>
                          </div>
                        </div>
                      </div>
                    ) : null;
                  })()}

                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Stop Loss (SL)</span>
                    <span className="font-semibold text-red-400">
                      {ticker.sl ? `$${Number(ticker.sl).toFixed(2)}` : "—"}
                    </span>
                  </div>
                  {(() => {
                    const tpTarget = computeTpTargetPrice(ticker);
                    const tpMax = computeTpMaxPrice(ticker);
                    const tpTargetSource = String(
                      ticker.tp_target_source ||
                        ticker.tp_target_kind ||
                        ticker.tp_target_label ||
                        ""
                    ).trim();
                    const targetValid = Number.isFinite(tpTarget) && tpTarget > 0;
                    const maxValid = Number.isFinite(tpMax) && tpMax > 0;
                    const showMax =
                      maxValid && (!targetValid || Math.abs(tpMax - tpTarget) > 0.01);
                    return (
                      <>
                        {showMax && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">TP (Max)</span>
                            <span className="font-semibold text-green-400">
                              ${tpMax.toFixed(2)}
                            </span>
                          </div>
                        )}
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">TP (Target)</span>
                          <div className="text-right">
                            <div className="font-semibold text-green-400">
                              {targetValid ? `$${tpTarget.toFixed(2)}` : "—"}
                            </div>
                            {tpTargetSource && (
                              <div className="text-[10px] text-[#93a4d6]">
                                {tpTargetSource}
                              </div>
                            )}
                          </div>
                        </div>
                      </>
                    );
                  })()}

                  {/* TP Levels Array - Always show if available */}
                  {(() => {
                    const tpLevels = ticker.tp_levels || [];
                    if (Array.isArray(tpLevels) && tpLevels.length > 0) {
                      // Extract prices from tp_levels (handle both object and number formats)
                      const tpPrices = tpLevels
                        .map((tpItem) => {
                          if (
                            typeof tpItem === "object" &&
                            tpItem !== null &&
                            tpItem.price != null
                          ) {
                            return {
                              price: Number(tpItem.price),
                              source: tpItem.source || "ATR Level",
                              type: tpItem.type || "ATR_FIB",
                              timeframe: tpItem.timeframe || "D",
                              label: tpItem.label || "TP",
                            };
                          }
                          return {
                            price:
                              typeof tpItem === "number"
                                ? Number(tpItem)
                                : Number(tpItem),
                            source: "ATR Level",
                            type: "ATR_FIB",
                            timeframe: "D",
                            label: "TP",
                          };
                        })
                        .filter((p) => Number.isFinite(p.price) && p.price > 0);

                      if (tpPrices.length > 0) {
                        // Sort by price (ascending for LONG, descending for SHORT)
                        const direction = ticker.state?.includes("BULL")
                          ? "LONG"
                          : ticker.state?.includes("BEAR")
                          ? "SHORT"
                          : null;
                        const isLong = direction === "LONG";
                        tpPrices.sort((a, b) =>
                          isLong ? a.price - b.price : b.price - a.price
                        );

                        const maxTP = Math.max(
                          ...tpPrices.map((tp) => tp.price)
                        );
                        const minTP = Math.min(
                          ...tpPrices.map((tp) => tp.price)
                        );

                        return (
                          <>
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">Max TP</span>
                              <span className="font-semibold text-green-400">
                                ${maxTP.toFixed(2)}
                              </span>
                            </div>
                            <div className="py-2 border-b border-[#26325f]/50">
                              <div className="text-xs text-[#93a4d6] mb-2">
                                TP Levels ({tpPrices.length})
                              </div>
                              <div className="space-y-1 max-h-32 overflow-y-auto">
                                {tpPrices.map((tpItem, idx) => {
                                  const tf = tpItem.timeframe || "D";
                                  const tfLabel =
                                    tf === "W"
                                      ? "W"
                                      : tf === "D"
                                      ? "D"
                                      : tf === "240" || tf === "4H"
                                      ? "4H"
                                      : tf;
                                  return (
                                    <div
                                      key={idx}
                                      className="flex justify-between items-center text-xs bg-[#0f1630] rounded px-2 py-1"
                                    >
                                      <div className="flex items-center gap-2">
                                        <span className="text-green-400 font-semibold">
                                          ${tpItem.price.toFixed(2)}
                                        </span>
                                        <span className="text-[#93a4d6] text-[10px]">
                                          {tpItem.source !== "ATR Level"
                                            ? tpItem.source
                                            : ""}
                                          {tpItem.timeframe
                                            ? ` (${tfLabel})`
                                            : ""}
                                        </span>
                                      </div>
                                      <span className="text-[#93a4d6] text-[10px]">
                                        {tpItem.type !== "ATR_FIB"
                                          ? tpItem.type
                                          : ""}
                                      </span>
                                    </div>
                                  );
                                })}
                              </div>
                            </div>
                          </>
                        );
                      }
                    }
                    // Show Max TP even if only primary TP exists
                    if (ticker.tp && Number(ticker.tp) > 0) {
                      return (
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Max TP</span>
                          <span className="font-semibold text-green-400">
                            ${Number(ticker.tp).toFixed(2)}
                          </span>
                        </div>
                      );
                    }
                    return null;
                  })()}
                </div>

                {/* TD Sequential */}
                {ticker.td_sequential &&
                  (() => {
                    const tdSeq = ticker.td_sequential;
                    return (
                      <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                        <div className="text-sm font-bold text-[#93a4d6] mb-4">
                          📈 TD Sequential
                        </div>

                        {/* Counts */}
                        <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          <div className="text-xs text-[#93a4d6] mb-2">
                            Counts
                          </div>
                          <div className="grid grid-cols-2 gap-2 text-xs">
                            <div className="flex justify-between">
                              <span className="text-[#93a4d6]">
                                Bullish Prep:
                              </span>
                              <span
                                className={`font-semibold ${
                                  Number(tdSeq.bullish_prep_count || 0) >= 6
                                    ? "text-yellow-400"
                                    : Number(tdSeq.bullish_prep_count || 0) >= 3
                                    ? "text-green-400"
                                    : "text-[#93a4d6]"
                                }`}
                              >
                                {tdSeq.bullish_prep_count || 0}/9
                              </span>
                            </div>
                            <div className="flex justify-between">
                              <span className="text-[#93a4d6]">
                                Bearish Prep:
                              </span>
                              <span
                                className={`font-semibold ${
                                  Number(tdSeq.bearish_prep_count || 0) >= 6
                                    ? "text-yellow-400"
                                    : Number(tdSeq.bearish_prep_count || 0) >= 3
                                    ? "text-red-400"
                                    : "text-[#93a4d6]"
                                }`}
                              >
                                {tdSeq.bearish_prep_count || 0}/9
                              </span>
                            </div>
                            <div className="flex justify-between">
                              <span className="text-[#93a4d6]">
                                Bullish Leadup:
                              </span>
                              <span
                                className={`font-semibold ${
                                  Number(tdSeq.bullish_leadup_count || 0) >= 6
                                    ? "text-yellow-400"
                                    : Number(tdSeq.bullish_leadup_count || 0) >=
                                      3
                                    ? "text-green-400"
                                    : "text-[#93a4d6]"
                                }`}
                              >
                                {tdSeq.bullish_leadup_count || 0}/13
                              </span>
                            </div>
                            <div className="flex justify-between">
                              <span className="text-[#93a4d6]">
                                Bearish Leadup:
                              </span>
                              <span
                                className={`font-semibold ${
                                  Number(tdSeq.bearish_leadup_count || 0) >= 6
                                    ? "text-yellow-400"
                                    : Number(tdSeq.bearish_leadup_count || 0) >=
                                      3
                                    ? "text-red-400"
                                    : "text-[#93a4d6]"
                                }`}
                              >
                                {tdSeq.bearish_leadup_count || 0}/13
                              </span>
                            </div>
                          </div>
                        </div>

                        {/* Signals */}
                        <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          <div className="text-xs text-[#93a4d6] mb-2">
                            Signals
                          </div>
                          <div className="space-y-2">
                            {(tdSeq.td9_bullish === true ||
                              tdSeq.td9_bullish === "true") && (
                              <div className="flex items-center gap-2">
                                <span className="text-green-400 font-bold">
                                  TD9
                                </span>
                                <span className="text-xs text-[#93a4d6]">
                                  Bullish (Prep Complete)
                                </span>
                              </div>
                            )}
                            {(tdSeq.td9_bearish === true ||
                              tdSeq.td9_bearish === "true") && (
                              <div className="flex items-center gap-2">
                                <span className="text-red-400 font-bold">
                                  TD9
                                </span>
                                <span className="text-xs text-[#93a4d6]">
                                  Bearish (Prep Complete)
                                </span>
                              </div>
                            )}
                            {(tdSeq.td13_bullish === true ||
                              tdSeq.td13_bullish === "true") && (
                              <div className="flex items-center gap-2">
                                <span className="text-green-400 font-bold">
                                  TD13
                                </span>
                                <span className="text-xs text-[#93a4d6]">
                                  Bullish (Leadup Complete)
                                </span>
                              </div>
                            )}
                            {(tdSeq.td13_bearish === true ||
                              tdSeq.td13_bearish === "true") && (
                              <div className="flex items-center gap-2">
                                <span className="text-red-400 font-bold">
                                  TD13
                                </span>
                                <span className="text-xs text-[#93a4d6]">
                                  Bearish (Leadup Complete)
                                </span>
                              </div>
                            )}
                            {!tdSeq.td9_bullish &&
                              !tdSeq.td9_bearish &&
                              !tdSeq.td13_bullish &&
                              !tdSeq.td13_bearish && (
                                <div className="text-xs text-[#93a4d6]">
                                  No TD9/TD13 signals active
                                </div>
                              )}
                          </div>
                        </div>

                        {/* Exit Signals */}
                        {(tdSeq.exit_long === true ||
                          tdSeq.exit_long === "true" ||
                          tdSeq.exit_short === true ||
                          tdSeq.exit_short === "true") && (
                          <div
                            className={`mb-4 p-3 rounded-lg border-2 ${
                              tdSeq.exit_long === true ||
                              tdSeq.exit_long === "true"
                                ? "bg-red-500/20 border-red-500/50"
                                : "bg-red-500/20 border-red-500/50"
                            }`}
                          >
                            <div className="flex items-center justify-between">
                              <span className="text-xs text-[#93a4d6]">
                                Exit Signal
                              </span>
                              <span className="font-bold text-sm text-red-400">
                                {tdSeq.exit_long === true ||
                                tdSeq.exit_long === "true"
                                  ? "EXIT LONG"
                                  : "EXIT SHORT"}
                              </span>
                            </div>
                            <div className="text-xs text-[#93a4d6] mt-1">
                              TD Sequential exhaustion/reversal detected
                            </div>
                          </div>
                        )}

                        {/* Boost */}
                        {tdSeq.boost !== undefined &&
                          tdSeq.boost !== null &&
                          Number(tdSeq.boost) !== 0 && (
                            <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                              <div className="flex justify-between items-center">
                                <span className="text-xs text-[#93a4d6]">
                                  Score Boost
                                </span>
                                <span
                                  className={`font-semibold ${
                                    Number(tdSeq.boost) > 0
                                      ? "text-green-400"
                                      : "text-red-400"
                                  }`}
                                >
                                  {Number(tdSeq.boost) > 0 ? "+" : ""}
                                  {Number(tdSeq.boost).toFixed(1)}
                                </span>
                              </div>
                            </div>
                          )}
                      </div>
                    );
                  })()}

                {/* RSI & Divergence */}
                {ticker.rsi &&
                  (() => {
                    const rsi = ticker.rsi;
                    const rsiValue = Number(rsi.value || 0);
                    const rsiLevel = rsi.level || "neutral";
                    const divergence = rsi.divergence || {};
                    const divType = divergence.type || "none";
                    const divStrength = Number(divergence.strength || 0);

                    const rsiColor =
                      rsiValue >= 70
                        ? "text-red-400"
                        : rsiValue <= 30
                        ? "text-green-400"
                        : rsiValue >= 50
                        ? "text-yellow-400"
                        : "text-blue-400";
                    const levelColor =
                      rsiLevel === "overbought"
                        ? "text-red-400"
                        : rsiLevel === "oversold"
                        ? "text-green-400"
                        : rsiLevel === "bullish"
                        ? "text-yellow-400"
                        : "text-blue-400";

                    return (
                      <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                        <div className="text-sm font-bold text-[#93a4d6] mb-4">
                          📊 RSI & Divergence
                        </div>

                        {/* RSI Value */}
                        <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          <div className="flex justify-between items-center mb-2">
                            <span className="text-xs text-[#93a4d6]">
                              RSI (14)
                            </span>
                            <span className={`font-bold text-lg ${rsiColor}`}>
                              {rsiValue.toFixed(2)}
                            </span>
                          </div>
                          <div className="flex justify-between items-center">
                            <span className="text-xs text-[#93a4d6]">
                              Level
                            </span>
                            <span
                              className={`text-xs font-semibold ${levelColor}`}
                            >
                              {rsiLevel.charAt(0).toUpperCase() +
                                rsiLevel.slice(1)}
                            </span>
                          </div>
                          {/* RSI Visual Bar */}
                          <div className="mt-2 h-2 bg-[#26325f] rounded-full overflow-hidden">
                            <div
                              className={`h-full rounded-full transition-all ${
                                rsiValue >= 70
                                  ? "bg-red-500"
                                  : rsiValue <= 30
                                  ? "bg-green-500"
                                  : rsiValue >= 50
                                  ? "bg-yellow-500"
                                  : "bg-blue-500"
                              }`}
                              style={{ width: `${rsiValue}%` }}
                            />
                          </div>
                          <div className="flex justify-between text-[10px] text-[#93a4d6] mt-1">
                            <span>0</span>
                            <span>30</span>
                            <span>50</span>
                            <span>70</span>
                            <span>100</span>
                          </div>
                        </div>

                        {/* Divergence */}
                        {divType !== "none" && (
                          <div
                            className={`mb-4 p-3 rounded-lg border-2 ${
                              divType === "bullish"
                                ? "bg-green-500/20 border-green-500/50"
                                : "bg-red-500/20 border-red-500/50"
                            }`}
                          >
                            <div className="flex items-center justify-between mb-1">
                              <span className="text-xs text-[#93a4d6]">
                                Divergence
                              </span>
                              <span
                                className={`font-bold text-sm ${
                                  divType === "bullish"
                                    ? "text-green-400"
                                    : "text-red-400"
                                }`}
                              >
                                {divType === "bullish"
                                  ? "🔼 BULLISH"
                                  : "🔽 BEARISH"}
                              </span>
                            </div>
                            <div className="text-xs text-[#93a4d6]">
                              {divType === "bullish"
                                ? "Price lower low, RSI higher low (potential reversal up)"
                                : "Price higher high, RSI lower high (potential reversal down)"}
                            </div>
                            {divStrength > 0 && (
                              <div className="text-xs text-[#93a4d6] mt-1">
                                Strength: {divStrength.toFixed(2)}
                              </div>
                            )}
                          </div>
                        )}
                        {divType === "none" && (
                          <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                            <div className="text-xs text-[#93a4d6]">
                              No divergence detected
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })()}

                {/* State, Horizon, Detected Patterns */}
                <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                  <div className="text-sm text-[#93a4d6] mb-2">
                    State & Horizon
                  </div>
                  <div className="space-y-2 text-xs">
                    <div className="flex justify-between items-center">
                      <span className="text-[#93a4d6]">State</span>
                      <span className="font-semibold">
                        {ticker.state || "—"}
                      </span>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-[#93a4d6]">Horizon</span>
                      <span className="font-semibold">
                        {(() => {
                          const bucket = String(ticker.horizon_bucket || "")
                            .trim()
                            .toUpperCase();
                          if (bucket) return bucket.replace("_", " ");
                          const eta = computeEtaDays(ticker);
                          if (!Number.isFinite(eta)) return "—";
                          if (eta <= 7) return "SHORT TERM";
                          if (eta <= 30) return "SWING";
                          return "POSITIONAL";
                        })()}
                      </span>
                    </div>
                  </div>
                  {detectedPatterns && detectedPatterns.length > 0 && (
                    <div className="mt-3 pt-3 border-t border-[#26325f]">
                      <div className="text-xs font-semibold text-yellow-400 mb-2">
                        Detected Patterns
                      </div>
                      <div className="space-y-2">
                        {detectedPatterns.map((pattern, idx) => (
                          <div
                            key={`pattern-${idx}`}
                            className="p-2 rounded border bg-[#121a33] border-[#26325f]"
                          >
                            <div className="flex items-center justify-between">
                              <div className="text-xs text-white font-semibold">
                                {pattern.description}
                              </div>
                              <span className="text-[10px] px-1.5 py-0.5 rounded bg-yellow-500/20 text-yellow-300">
                                {pattern.confidence}
                              </span>
                            </div>
                            {pattern.quadrant && (
                              <div className="text-[10px] text-[#93a4d6] mt-0.5">
                                {pattern.quadrant}
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>

                {/* EMA Cloud Positions */}
                {(ticker.daily_ema_cloud ||
                  ticker.fourh_ema_cloud ||
                  ticker.oneh_ema_cloud) &&
                  (() => {
                    const daily = ticker.daily_ema_cloud;
                    const fourH = ticker.fourh_ema_cloud;
                    const oneH = ticker.oneh_ema_cloud;

                    const getPositionColor = (position) => {
                      if (position === "above") return "text-green-400";
                      if (position === "below") return "text-red-400";
                      return "text-yellow-400";
                    };

                    const getPositionEmoji = (position) => {
                      if (position === "above") return "🔼";
                      if (position === "below") return "🔽";
                      return "➡️";
                    };

                    return (
                      <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                        <div className="text-sm font-bold text-[#93a4d6] mb-4">
                          ☁️ EMA Cloud Positions
                        </div>

                        {daily && (
                          <div className="mb-3 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                            <div className="text-xs text-[#93a4d6] mb-2 font-semibold">
                              Daily (5-8 EMA)
                            </div>
                            <div className="flex justify-between items-center mb-1">
                              <span className="text-xs text-[#93a4d6]">
                                Position
                              </span>
                              <span
                                className={`text-xs font-semibold ${getPositionColor(
                                  daily.position
                                )}`}
                              >
                                {getPositionEmoji(daily.position)}{" "}
                                {daily.position.toUpperCase()}
                              </span>
                            </div>
                            <div className="grid grid-cols-2 gap-2 text-xs mt-2">
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">Upper:</span>
                                <span className="text-white">
                                  ${Number(daily.upper).toFixed(2)}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">Lower:</span>
                                <span className="text-white">
                                  ${Number(daily.lower).toFixed(2)}
                                </span>
                              </div>
                              <div className="flex justify-between col-span-2">
                                <span className="text-[#93a4d6]">Price:</span>
                                <span className="text-white font-semibold">
                                  ${Number(daily.price).toFixed(2)}
                                </span>
                              </div>
                            </div>
                          </div>
                        )}

                        {fourH && (
                          <div className="mb-3 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                            <div className="text-xs text-[#93a4d6] mb-2 font-semibold">
                              4H (8-13 EMA)
                            </div>
                            <div className="flex justify-between items-center mb-1">
                              <span className="text-xs text-[#93a4d6]">
                                Position
                              </span>
                              <span
                                className={`text-xs font-semibold ${getPositionColor(
                                  fourH.position
                                )}`}
                              >
                                {getPositionEmoji(fourH.position)}{" "}
                                {fourH.position.toUpperCase()}
                              </span>
                            </div>
                            <div className="grid grid-cols-2 gap-2 text-xs mt-2">
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">Upper:</span>
                                <span className="text-white">
                                  ${Number(fourH.upper).toFixed(2)}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">Lower:</span>
                                <span className="text-white">
                                  ${Number(fourH.lower).toFixed(2)}
                                </span>
                              </div>
                              <div className="flex justify-between col-span-2">
                                <span className="text-[#93a4d6]">Price:</span>
                                <span className="text-white font-semibold">
                                  ${Number(fourH.price).toFixed(2)}
                                </span>
                              </div>
                            </div>
                          </div>
                        )}

                        {oneH && (
                          <div className="mb-3 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                            <div className="text-xs text-[#93a4d6] mb-2 font-semibold">
                              1H (13-21 EMA)
                            </div>
                            <div className="flex justify-between items-center mb-1">
                              <span className="text-xs text-[#93a4d6]">
                                Position
                              </span>
                              <span
                                className={`text-xs font-semibold ${getPositionColor(
                                  oneH.position
                                )}`}
                              >
                                {getPositionEmoji(oneH.position)}{" "}
                                {oneH.position.toUpperCase()}
                              </span>
                            </div>
                            <div className="grid grid-cols-2 gap-2 text-xs mt-2">
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">Upper:</span>
                                <span className="text-white">
                                  ${Number(oneH.upper).toFixed(2)}
                                </span>
                              </div>
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">Lower:</span>
                                <span className="text-white">
                                  ${Number(oneH.lower).toFixed(2)}
                                </span>
                              </div>
                              <div className="flex justify-between col-span-2">
                                <span className="text-[#93a4d6]">Price:</span>
                                <span className="text-white font-semibold">
                                  ${Number(oneH.price).toFixed(2)}
                                </span>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })()}

                {/* Fundamental & Valuation Metrics */}
                {ticker.fundamentals &&
                  (() => {
                    const fund = ticker.fundamentals;
                    const hasValuationData =
                      fund.pe_ratio !== null ||
                      fund.peg_ratio !== null ||
                      fund.eps_growth_rate !== null;

                    if (!hasValuationData) return null;

                    const valuationSignal = fund.valuation_signal || "fair";
                    const signalColor =
                      valuationSignal === "undervalued"
                        ? "text-green-400"
                        : valuationSignal === "overvalued"
                        ? "text-red-400"
                        : "text-yellow-400";
                    const signalBg =
                      valuationSignal === "undervalued"
                        ? "bg-green-500/20 border-green-500/50"
                        : valuationSignal === "overvalued"
                        ? "bg-red-500/20 border-red-500/50"
                        : "bg-yellow-500/20 border-yellow-500/50";

                    return (
                      <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                        <div className="text-sm font-bold text-[#93a4d6] mb-4">
                          📊 Fundamental & Valuation
                        </div>

                        {/* Valuation Signal Badge */}
                        {fund.valuation_signal && (
                          <div
                            className={`mb-4 p-3 rounded-lg border-2 ${signalBg}`}
                          >
                            <div className="flex items-center justify-between">
                              <span className="text-xs text-[#93a4d6]">
                                Valuation Signal
                              </span>
                              <span
                                className={`font-bold text-sm ${signalColor}`}
                              >
                                {fund.valuation_signal.toUpperCase()}
                              </span>
                            </div>
                            {fund.valuation_confidence && (
                              <div className="text-xs text-[#93a4d6] mt-1">
                                Confidence:{" "}
                                <span className="font-semibold">
                                  {fund.valuation_confidence}
                                </span>
                              </div>
                            )}
                            {fund.valuation_reasons &&
                              fund.valuation_reasons.length > 0 && (
                                <div className="mt-2 pt-2 border-t border-current/30">
                                  <div className="text-[10px] text-[#93a4d6] mb-1">
                                    Reasons:
                                  </div>
                                  {fund.valuation_reasons.map((reason, idx) => (
                                    <div
                                      key={idx}
                                      className="text-[10px] text-[#93a4d6]/80 mb-0.5"
                                    >
                                      • {reason}
                                    </div>
                                  ))}
                                </div>
                              )}
                          </div>
                        )}

                        {/* Basic Metrics */}
                        <div className="space-y-2 text-sm mb-4">
                          {fund.pe_ratio !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">P/E Ratio</span>
                              <span className="font-semibold">
                                {Number(fund.pe_ratio).toFixed(2)}
                              </span>
                            </div>
                          )}
                          {fund.peg_ratio !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">PEG Ratio</span>
                              <span
                                className={`font-semibold ${
                                  fund.peg_ratio < 0.8
                                    ? "text-green-400"
                                    : fund.peg_ratio < 1.0
                                    ? "text-yellow-400"
                                    : fund.peg_ratio > 1.5
                                    ? "text-red-400"
                                    : "text-[#93a4d6]"
                                }`}
                              >
                                {Number(fund.peg_ratio).toFixed(2)}
                              </span>
                            </div>
                          )}
                          {fund.eps !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">EPS (TTM)</span>
                              <span className="font-semibold">
                                ${Number(fund.eps).toFixed(2)}
                              </span>
                            </div>
                          )}
                          {fund.eps_growth_rate !== null && (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">
                                EPS Growth (Annual)
                              </span>
                              <span
                                className={`font-semibold ${
                                  fund.eps_growth_rate > 20
                                    ? "text-green-400"
                                    : fund.eps_growth_rate > 10
                                    ? "text-yellow-400"
                                    : fund.eps_growth_rate > 0
                                    ? "text-[#93a4d6]"
                                    : "text-red-400"
                                }`}
                              >
                                {Number(fund.eps_growth_rate).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {(() => {
                            const marketCap = fund.market_cap;
                            const isValid =
                              marketCap !== null &&
                              marketCap !== undefined &&
                              marketCap !== "" &&
                              (typeof marketCap === "number" ||
                                typeof marketCap === "string") &&
                              !isNaN(Number(marketCap)) &&
                              Number(marketCap) > 0;
                            if (!isValid) return null;
                            const numCap = Number(marketCap);
                            let formatted;
                            if (numCap >= 1e12) {
                              formatted = `$${(numCap / 1e12).toFixed(2)}T`;
                            } else if (numCap >= 1e9) {
                              formatted = `$${(numCap / 1e9).toFixed(2)}B`;
                            } else if (numCap >= 1e6) {
                              formatted = `$${(numCap / 1e6).toFixed(2)}M`;
                            } else {
                              formatted = `$${numCap.toLocaleString()}`;
                            }
                            return (
                              <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                                <span className="text-[#93a4d6]">
                                  Market Cap
                                </span>
                                <span className="font-semibold">
                                  {formatted}
                                </span>
                              </div>
                            );
                          })()}
                          {fund.industry && (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">Industry</span>
                              <span className="font-semibold text-xs">
                                {fund.industry}
                              </span>
                            </div>
                          )}
                        </div>

                        {/* Fair Value */}
                        {fund.fair_value_price !== null &&
                          fund.fair_value_price > 0 && (
                            <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                              <div className="text-xs text-[#93a4d6] mb-2">
                                Fair Value
                              </div>
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-sm text-[#93a4d6]">
                                  Fair Value Price
                                </span>
                                <span className="font-bold text-lg text-blue-400">
                                  ${Number(fund.fair_value_price).toFixed(2)}
                                </span>
                              </div>
                              {fund.premium_discount_pct !== null && (
                                <div className="flex items-center justify-between">
                                  <span className="text-xs text-[#93a4d6]">
                                    Premium/Discount
                                  </span>
                                  <span
                                    className={`font-semibold ${
                                      fund.premium_discount_pct < -10
                                        ? "text-green-400"
                                        : fund.premium_discount_pct < 0
                                        ? "text-yellow-400"
                                        : fund.premium_discount_pct > 10
                                        ? "text-red-400"
                                        : "text-[#93a4d6]"
                                    }`}
                                  >
                                    {fund.premium_discount_pct > 0 ? "+" : ""}
                                    {Number(fund.premium_discount_pct).toFixed(
                                      1
                                    )}
                                    %
                                  </span>
                                </div>
                              )}
                              {fund.fair_value_pe &&
                                fund.fair_value_pe.preferred && (
                                  <div className="mt-2 pt-2 border-t border-[#26325f] text-xs text-[#93a4d6]">
                                    Fair P/E:{" "}
                                    <span className="font-semibold">
                                      {Number(
                                        fund.fair_value_pe.preferred
                                      ).toFixed(2)}
                                    </span>
                                  </div>
                                )}
                            </div>
                          )}

                        {/* Historical P/E Percentiles */}
                        {fund.pe_percentiles && (
                          <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                            <div className="text-xs text-[#93a4d6] mb-2">
                              Historical P/E Percentiles
                            </div>
                            <div className="grid grid-cols-2 gap-2 text-xs">
                              {fund.pe_percentiles.p10 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[#93a4d6]">10th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p10).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p25 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[#93a4d6]">25th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p25).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p50 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[#93a4d6]">
                                    50th (Median):
                                  </span>
                                  <span className="font-semibold text-blue-400">
                                    {Number(fund.pe_percentiles.p50).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p75 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[#93a4d6]">75th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p75).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.p90 !== null && (
                                <div className="flex justify-between">
                                  <span className="text-[#93a4d6]">90th:</span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.p90).toFixed(1)}
                                  </span>
                                </div>
                              )}
                              {fund.pe_percentiles.avg !== null && (
                                <div className="flex justify-between col-span-2 pt-1 border-t border-[#26325f]">
                                  <span className="text-[#93a4d6]">
                                    Average:
                                  </span>
                                  <span className="font-semibold">
                                    {Number(fund.pe_percentiles.avg).toFixed(1)}
                                  </span>
                                </div>
                              )}
                            </div>
                            {fund.pe_percentile_position && (
                              <div className="mt-2 pt-2 border-t border-[#26325f] text-xs">
                                <span className="text-[#93a4d6]">
                                  Current Position:{" "}
                                </span>
                                <span
                                  className={`font-semibold ${
                                    fund.pe_percentile_position.includes(
                                      "Bottom"
                                    )
                                      ? "text-green-400"
                                      : fund.pe_percentile_position.includes(
                                          "Top"
                                        )
                                      ? "text-red-400"
                                      : "text-[#93a4d6]"
                                  }`}
                                >
                                  {fund.pe_percentile_position}
                                </span>
                              </div>
                            )}
                          </div>
                        )}

                        {/* Valuation Boost in Rank */}
                        {ticker.rank_components &&
                          ticker.rank_components.valuation_boost !==
                            undefined &&
                          ticker.rank_components.valuation_boost !== 0 && (
                            <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                              <div className="text-xs text-[#93a4d6] mb-1">
                                Rank Components
                              </div>
                              <div className="flex justify-between items-center text-xs">
                                <span className="text-[#93a4d6]">
                                  Base Rank
                                </span>
                                <span className="font-semibold">
                                  {ticker.rank_components.base_rank ||
                                    baseScore}
                                </span>
                              </div>
                              <div className="flex justify-between items-center text-xs mt-1">
                                <span className="text-[#93a4d6]">
                                  Valuation Boost
                                </span>
                                <span
                                  className={`font-semibold ${
                                    ticker.rank_components.valuation_boost > 0
                                      ? "text-green-400"
                                      : "text-red-400"
                                  }`}
                                >
                                  {ticker.rank_components.valuation_boost > 0
                                    ? "+"
                                    : ""}
                                  {ticker.rank_components.valuation_boost}
                                </span>
                              </div>
                              <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                                <span className="text-[#93a4d6] font-semibold">
                                  Final Rank
                                </span>
                                <span className="font-bold text-blue-400">
                                  {baseScore}
                                </span>
                              </div>
                            </div>
                          )}
                      </div>
                    );
                  })()}

                {/* Trade Journey (Ledger trades) */}
                <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                  <div className="flex items-center justify-between mb-2">
                    <div className="text-sm text-[#93a4d6]">Trade Journey</div>
                    <a
                      href={`simulation-dashboard.html?ticker=${encodeURIComponent(
                        String(tickerSymbol).toUpperCase()
                      )}`}
                      className="text-xs px-2 py-1 rounded bg-blue-500/20 border border-blue-500/30 text-blue-300 hover:bg-blue-500/30"
                      title="Open full Trade Tracker"
                    >
                      Open
                    </a>
                  </div>
                  {ledgerTradesLoading ? (
                    <div className="text-xs text-[#93a4d6] flex items-center gap-2">
                      <div className="loading-spinner"></div>
                      Loading ledger trades…
                    </div>
                  ) : ledgerTradesError ? (
                    <div className="text-xs text-red-400">
                      Ledger unavailable: {ledgerTradesError}
                    </div>
                  ) : ledgerTrades.length === 0 ? (
                    <div className="text-xs text-[#93a4d6]">
                      No ledger trades found for this ticker.
                    </div>
                  ) : (
                    <div className="space-y-2">
                      {ledgerTrades.slice(0, 5).map((t) => {
                        const isClosed =
                          t.status === "WIN" || t.status === "LOSS";
                        const pnl = Number(t.pnl || 0);
                        return (
                          <div
                            key={t.trade_id}
                            className="p-2 bg-[#121a33] border border-[#26325f] rounded flex items-center justify-between gap-2"
                          >
                            <div className="min-w-0">
                              <div className="text-xs text-[#93a4d6]">
                                {t.entry_ts
                                  ? new Date(Number(t.entry_ts)).toLocaleString()
                                  : "—"}
                              </div>
                              <div className="text-sm font-semibold text-white truncate">
                                {t.ticker}{" "}
                                <span
                                  className={`text-xs font-semibold ${
                                    t.direction === "LONG"
                                      ? "text-green-400"
                                      : "text-red-400"
                                  }`}
                                >
                                  {t.direction}
                                </span>
                              </div>
                            </div>
                            <div className="text-right">
                              <div className="text-xs">
                                {isClosed ? (
                                  <span
                                    className={`px-2 py-0.5 rounded text-[10px] font-semibold ${
                                      t.status === "WIN"
                                        ? "bg-green-500/20 text-green-400"
                                        : "bg-red-500/20 text-red-400"
                                    }`}
                                  >
                                    {t.status}
                                  </span>
                                ) : (
                                  <span className="px-2 py-0.5 rounded text-[10px] font-semibold bg-yellow-500/15 text-yellow-300">
                                    {t.status || "OPEN"}
                                  </span>
                                )}
                              </div>
                              <div
                                className={`text-xs font-semibold ${
                                  pnl >= 0 ? "text-green-400" : "text-red-400"
                                }`}
                              >
                                {isClosed ? `$${pnl.toFixed(2)}` : "—"}
                              </div>
                            </div>
                          </div>
                        );
                      })}
                      {ledgerTrades.length > 5 && (
                        <div className="text-[10px] text-[#6b7a9f]">
                          Showing 5 of {ledgerTrades.length} recent trades.
                        </div>
                      )}
                    </div>
                  )}
                </div>

                {/* Completion, Phase, Dynamic ETA */}
                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[#93a4d6]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                      {ticker.phase_zone && ` (${ticker.phase_zone})`}
                    </span>
                  </div>
                  <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                        boxShadow: `0 0 8px ${phaseColor}40`,
                      }}
                    />
                  </div>
                  <div className="mt-2 flex items-center justify-between text-xs">
                    <span className="text-[#93a4d6]">Completion</span>
                    <span className="font-semibold text-white">
                      {ticker.completion != null
                        ? `${(Number(ticker.completion) * 100).toFixed(2)}%`
                        : "—"}
                    </span>
                  </div>
                  <div className="mt-1 flex items-center justify-between text-xs">
                    <span className="text-[#93a4d6]">Dynamic ETA</span>
                    <span className="font-semibold text-white">
                      {(() => {
                        const eta = computeEtaDays(ticker);
                        return Number.isFinite(eta) ? `${eta.toFixed(1)}d` : "—";
                      })()}
                    </span>
                  </div>
                </div>

                {/* Bubble Journey (15m increments) */}
                <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                  <div className="flex items-center justify-between mb-2">
                    <div className="text-sm text-[#93a4d6]">
                      Bubble Journey (15m increments)
                    </div>
                    <a
                      href={`index-react.html?timeTravel=1&ticker=${encodeURIComponent(
                        String(tickerSymbol).toUpperCase()
                      )}`}
                      className="text-xs px-2 py-1 rounded bg-purple-500/20 border border-purple-500/30 text-purple-300 hover:bg-purple-500/30"
                      title="Open Time Travel (if supported)"
                    >
                      Time Travel
                    </a>
                  </div>

                  {bubbleJourneyLoading ? (
                    <div className="text-xs text-[#93a4d6] flex items-center gap-2">
                      <div className="loading-spinner"></div>
                      Loading trail…
                    </div>
                  ) : bubbleJourneyError ? (
                    <div className="text-xs text-red-400">
                      Trail unavailable: {bubbleJourneyError}
                    </div>
                  ) : bubbleJourney.length === 0 ? (
                    <div className="text-xs text-[#93a4d6]">
                      No trail points found for this ticker.
                    </div>
                  ) : (
                    <div className="space-y-1 max-h-64 overflow-y-auto pr-1">
                      {downsampleByInterval(bubbleJourney, 15 * 60 * 1000)
                        .slice()
                        .reverse()
                        .slice(0, 40)
                        .map((p, idx) => {
                          const ts = Number(p.__ts_ms);
                          const state = p.state || p.quadrant || p.zone || "—";
                          const phasePct =
                            p.phase_pct != null
                              ? `${Math.round(Number(p.phase_pct) * 100)}%`
                              : "—";
                          const htf =
                            p.htf_score != null &&
                            Number.isFinite(Number(p.htf_score))
                              ? Number(p.htf_score).toFixed(1)
                              : "—";
                          const ltf =
                            p.ltf_score != null &&
                            Number.isFinite(Number(p.ltf_score))
                              ? Number(p.ltf_score).toFixed(1)
                              : "—";
                          const rank = p.rank != null ? String(p.rank) : "—";
                          const rr =
                            p.rr != null && Number.isFinite(Number(p.rr))
                              ? Number(p.rr).toFixed(2)
                              : p.rr_at_alert != null &&
                                Number.isFinite(Number(p.rr_at_alert))
                              ? Number(p.rr_at_alert).toFixed(2)
                              : "—";
                          const isSelected =
                            selectedJourneyTs != null &&
                            Number.isFinite(ts) &&
                            Number(ts) === Number(selectedJourneyTs);

                          const pointForChart = {
                            ts: Number.isFinite(ts) ? ts : null,
                            htf_score:
                              p.htf_score != null ? Number(p.htf_score) : null,
                            ltf_score:
                              p.ltf_score != null ? Number(p.ltf_score) : null,
                            phase_pct:
                              p.phase_pct != null ? Number(p.phase_pct) : null,
                            completion:
                              p.completion != null ? Number(p.completion) : null,
                            rank: p.rank != null ? Number(p.rank) : null,
                            rr: p.rr != null ? Number(p.rr) : null,
                            state: p.state || null,
                          };
                          return (
                            <div
                              key={`${ts}-${idx}`}
                              className={`px-2 py-1 bg-[#121a33] border rounded flex items-center justify-between gap-2 cursor-pointer transition-colors ${
                                isSelected
                                  ? "border-cyan-400/80 bg-cyan-500/10"
                                  : "border-[#26325f] hover:border-cyan-400/40 hover:bg-[#16224a]"
                              }`}
                              onMouseEnter={() => {
                                if (onJourneyHover)
                                  onJourneyHover(pointForChart);
                              }}
                              onMouseLeave={() => {
                                if (onJourneyHover) onJourneyHover(null);
                              }}
                              onClick={() => {
                                if (onJourneySelect)
                                  onJourneySelect(pointForChart);
                              }}
                            >
                              <div className="min-w-0">
                                <div className="text-[10px] text-[#93a4d6]">
                                  {Number.isFinite(ts)
                                    ? new Date(ts).toLocaleString()
                                    : "—"}
                                </div>
                                <div className="text-xs text-white truncate">
                                  {state}
                                  <span className="text-[#6b7a9f]"> • </span>
                                  <span className="text-[#93a4d6]">Phase</span>{" "}
                                  {phasePct}
                                </div>
                                <div className="text-[10px] text-[#93a4d6]">
                                  <span className="text-[#6b7a9f]">HTF</span>{" "}
                                  <span className="text-white font-semibold">
                                    {htf}
                                  </span>
                                  <span className="text-[#6b7a9f]"> • </span>
                                  <span className="text-[#6b7a9f]">LTF</span>{" "}
                                  <span className="text-white font-semibold">
                                    {ltf}
                                  </span>
                                </div>
                              </div>
                              <div className="text-right text-[10px] text-[#93a4d6] whitespace-nowrap">
                                <div>
                                  <span className="text-[#6b7a9f]">Rank</span>{" "}
                                  <span className="text-white font-semibold">
                                    {rank}
                                  </span>
                                </div>
                                <div>
                                  <span className="text-[#6b7a9f]">RR</span>{" "}
                                  <span className="text-white font-semibold">
                                    {rr}
                                  </span>
                                </div>
                              </div>
                            </div>
                          );
                        })}
                    </div>
                  )}
                </div>

                {/* Quadrant Progression */}
                <QuadrantProgression ticker={ticker} flags={flags} />
                </div>
              </div>

              {/* Fixed Footer */}
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[#26325f] bg-[#121a33]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(
                    tickerSymbol
                  )}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  📊 Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // Legacy TickerDetails component - kept for backward compatibility but now uses unified component
      function TickerDetails({
        ticker,
        onClose,
        allTickers = [],
        allLoadedData = null,
      }) {
        if (!ticker) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);

        // Convert allLoadedData (object) to array if provided, otherwise use allTickers
        // allLoadedData contains ALL loaded tickers (unfiltered), while allTickers is filtered
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) {
              return allLoadedData;
            } else {
              // Convert object to array: { "GOOGL": {...}, "MSFT": {...} } -> [...]
              return Object.values(allLoadedData).filter(
                (t) => t && typeof t === "object" && t.ticker
              );
            }
          }
          // Fallback to allTickers if allLoadedData not provided
          return allTickers || [];
        })();

        return (
          <div className="w-full h-full flex flex-col">
            {/* Detail Card - slides in from right, positioned in hero layout */}
            <div
              className="bg-[#121a33] border-2 border-[#26325f] rounded-xl w-full h-full flex flex-col shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Scrollable Content Area */}
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button
                    onClick={onClose}
                    className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
                  >
                    ✕
                  </button>
                </div>

                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      🚀 MOMENTUM ELITE 🚀
                    </div>
                    <div className="text-xs text-purple-200/80 font-normal mb-2">
                      High-quality momentum stock with strong fundamentals
                    </div>
                    {ticker.momentum_pct && (
                      <div className="mt-2 pt-2 border-t border-purple-400/30">
                        <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">
                          Momentum Performance:
                        </div>
                        <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                          {ticker.momentum_pct.week != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1W:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.week) >= 10
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.week).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.month != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.month) >= 25
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.month).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.three_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">3M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.three_months) >= 50
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(
                                  ticker.momentum_pct.three_months
                                ).toFixed(1)}
                                %
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.six_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">6M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.six_months) >= 100
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.six_months).toFixed(
                                  1
                                )}
                                %
                              </span>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                    ⭐ PRIME SETUP ⭐
                  </div>
                )}

                {/* Bias/Direction - Prominent */}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                      <div className="text-sm text-[#93a4d6] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}
                      >
                        {dir.text === "LONG"
                          ? "📈 LONG"
                          : dir.text === "SHORT"
                          ? "📉 SHORT"
                          : dir.text}
                      </div>
                    </div>
                  );
                })()}

                {/* Action Description */}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[#93a4d6]">
                    {actionInfo.description}
                  </div>
                </div>

                {/* Quadrant Progression Visualization */}
                <QuadrantProgression ticker={ticker} flags={flags} />

                {/* Phase indicator */}
                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[#93a4d6]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                      {ticker.phase_zone && ` (${ticker.phase_zone})`}
                    </span>
                  </div>
                  <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                        boxShadow: `0 0 8px ${phaseColor}40`,
                      }}
                    />
                  </div>
                </div>

                <div className="space-y-2.5 text-sm">
                  {(() => {
                    const baseScore = Number(ticker.rank) || 0; // Base Score from worker
                    const sortedByRank = getRankedTickers(allLoadedTickersArray);
                    const rankPosition = getRankPosition(
                      sortedByRank,
                      ticker.ticker
                    );
                    const totalTickersRaw = sortedByRank.length;
                    const totalTickers =
                      Number.isFinite(Number(ticker.rank_total)) &&
                      Number(ticker.rank_total) > 0
                        ? Number(ticker.rank_total)
                        : totalTickersRaw;

                    return (
                      <>
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Base Score</span>
                          <span className="font-semibold text-blue-400">
                            {baseScore}
                          </span>
                        </div>
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Rank</span>
                          <span className="font-semibold">
                            {rankPosition > 0
                              ? `#${rankPosition} of ${totalTickers}`
                              : "—"}
                          </span>
                        </div>
                      </>
                    );
                  })()}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const breakdownComponents = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return breakdownComponents.length > 0 ? (
                      <>
                        <div className="border-t border-[#26325f] my-3 pt-3">
                          <div className="text-xs text-[#93a4d6] mb-3 font-semibold">
                            Score Breakdown
                          </div>
                          <div className="space-y-1.5">
                            {breakdownComponents.map((comp, idx) => (
                              <div
                                key={idx}
                                className="flex justify-between items-center text-xs"
                              >
                                <span className="text-[#93a4d6]">
                                  {comp.label}
                                </span>
                                <span className={`font-semibold ${comp.color}`}>
                                  {comp.value}
                                </span>
                              </div>
                            ))}
                            <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                              <span className="text-[#93a4d6] font-semibold">
                                Total Score
                              </span>
                              <span className="text-blue-400 font-bold text-base">
                                {Math.round(breakdown.total)}
                              </span>
                            </div>
                          </div>
                        </div>
                      </>
                    ) : null;
                  })()}

                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">State</span>
                    <span className="font-semibold">{ticker.state || "—"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Completion</span>
                    <span className="font-semibold">
                      {Math.round(completionForSize(ticker) * 100)}%
                    </span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                        {ent.side}
                      </span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Current Price</span>
                    <span className="font-semibold text-lg">
                      {ticker.price
                        ? `$${Number(ticker.price).toFixed(2)}`
                        : "—"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">TP (Primary)</span>
                    <span className="font-semibold">
                      {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "—"}
                      {ticker.tp_levels &&
                        Array.isArray(ticker.tp_levels) &&
                        ticker.tp_levels.length > 0 &&
                        (() => {
                          const firstTp = ticker.tp_levels[0];
                          const tpInfo =
                            typeof firstTp === "object" && firstTp !== null
                              ? firstTp
                              : { price: firstTp };
                          if (tpInfo.label) {
                            const refParts = [];
                            if (tpInfo.timeframe)
                              refParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              refParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`
                              );
                            }
                            const refStr =
                              refParts.length > 0
                                ? ` (${tpInfo.label} - ${refParts.join(", ")})`
                                : ` (${tpInfo.label})`;
                            return refStr;
                          }
                          return "";
                        })()}
                    </span>
                  </div>
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 1 &&
                    (() => {
                      // Calculate max TP
                      const tpPrices = ticker.tp_levels
                        .map((tpItem) => {
                          if (
                            typeof tpItem === "object" &&
                            tpItem !== null &&
                            tpItem.price != null
                          ) {
                            return Number(tpItem.price);
                          }
                          return typeof tpItem === "number"
                            ? tpItem
                            : Number(tpItem);
                        })
                        .filter((p) => Number.isFinite(p));

                      if (tpPrices.length > 0) {
                        const maxTP = Math.max(...tpPrices);
                        const primaryTP = Number(ticker.tp) || tpPrices[0];

                        if (maxTP > primaryTP) {
                          return (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">TP (Max)</span>
                              <span className="font-semibold text-green-400">
                                ${maxTP.toFixed(2)}
                              </span>
                            </div>
                          );
                        }
                      }
                      return null;
                    })()}
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 0 && (
                      <div className="py-1 border-b border-[#26325f]/50">
                        <div className="text-[#93a4d6] text-xs mb-2 font-semibold">
                          TP Levels
                        </div>
                        <div className="space-y-1.5 max-h-48 overflow-y-auto">
                          {ticker.tp_levels.map((tp, idx) => {
                            // Handle both old format (just price) and new format (object with metadata)
                            const tpInfo =
                              typeof tp === "object" && tp !== null
                                ? tp
                                : { price: tp, label: `TP${idx + 1}` };
                            const price = Number(tpInfo.price || tp);
                            const label = tpInfo.label || `TP${idx + 1}`;
                            const source = tpInfo.source || "";
                            const type = tpInfo.type || "";
                            const confidence = tpInfo.confidence || null;

                            // Build reference string from all available metadata
                            const referenceParts = [];
                            if (tpInfo.timeframe)
                              referenceParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              referenceParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`
                              );
                            }
                            if (tpInfo.source)
                              referenceParts.push(tpInfo.source);
                            if (tpInfo.type) referenceParts.push(tpInfo.type);
                            const referenceStr =
                              referenceParts.length > 0
                                ? referenceParts.join(" • ")
                                : null;

                            return (
                              <div
                                key={idx}
                                className="flex items-start justify-between p-1.5 rounded bg-[#0f1630] border border-[#26325f]/50 hover:border-[#3a4aa0] transition-colors"
                              >
                                <div className="flex-1">
                                  <div className="flex items-center gap-2 flex-wrap">
                                    <span className="text-xs font-semibold text-green-400">
                                      {label}
                                    </span>
                                    <span className="text-xs font-mono text-white font-bold">
                                      ${price.toFixed(2)}
                                    </span>
                                    {confidence !== null && (
                                      <span
                                        className={`text-[10px] px-1 py-0.5 rounded ${
                                          confidence >= 0.8
                                            ? "bg-green-500/20 text-green-400"
                                            : confidence >= 0.6
                                            ? "bg-yellow-500/20 text-yellow-400"
                                            : "bg-orange-500/20 text-orange-400"
                                        }`}
                                      >
                                        {Math.round(confidence * 100)}%
                                      </span>
                                    )}
                                  </div>
                                  {referenceStr && (
                                    <div className="text-[10px] text-[#93a4d6] mt-1 italic">
                                      {referenceStr}
                                    </div>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">SL</span>
                    <span className="font-semibold">
                      {ticker.sl ? Number(ticker.sl).toFixed(2) : "—"}
                    </span>
                  </div>
                </div>

                {/* Flags */}
                {(flags.sq30_on ||
                  flags.sq30_release ||
                  flags.phase_dot ||
                  flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[#93a4d6] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && (
                        <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                          🧨 Squeeze ON
                        </span>
                      )}
                      {flags.sq30_release && (
                        <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                          ⚡ Squeeze Release
                        </span>
                      )}
                      {flags.phase_dot && (
                        <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                          Phase Dot
                        </span>
                      )}
                      {flags.phase_zone_change && (
                        <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                          Zone Change
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </div>

              {/* Fixed Footer - Open in TradingView button */}
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[#26325f] bg-[#121a33]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(
                    ticker.ticker
                  )}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  📊 Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // ─────────────────────────────────────────────────────────────
      // AI Chat Interface Component
      // ─────────────────────────────────────────────────────────────
      const AIChatInterface = ({ isOpen, onClose, tickerData }) => {
        const [messages, setMessages] = useState([
          {
            role: "assistant",
            content:
              "👋 Hi! I'm your AI trading assistant. I can help you analyze tickers, understand setups, and provide insights. What would you like to know?",
            timestamp: new Date(),
          },
        ]);
        const [input, setInput] = useState("");
        const [loading, setLoading] = useState(false);
        const [periodicUpdates, setPeriodicUpdates] = useState([]);
        const [showUpdates, setShowUpdates] = useState(false);
        const messagesEndRef = useRef(null);
        const inputRef = useRef(null);

        const scrollToBottom = () => {
          if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
          }
        };

        useEffect(() => {
          scrollToBottom();
        }, [messages]);

        useEffect(() => {
          if (isOpen && inputRef.current) {
            inputRef.current.focus();
          }
        }, [isOpen]);

        // Load periodic updates when chat opens
        useEffect(() => {
          if (isOpen) {
            const fetchUpdates = async () => {
              try {
                const timestamp = Date.now();
                const res = await fetch(
                  `${API_BASE}/timed/ai/updates?limit=5&_t=${timestamp}`,
                  {
                    cache: "no-store",
                    headers: {
                      "Cache-Control": "no-cache, no-store, must-revalidate",
                      Pragma: "no-cache",
                      Expires: "0",
                    },
                  }
                );
                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && data.updates) {
                    setPeriodicUpdates(data.updates);
                  }
                }
              } catch (err) {
                console.warn("Failed to fetch periodic updates:", err);
              }
            };
            fetchUpdates();
          }
        }, [isOpen]);

        const handleMonitor = async () => {
          setLoading(true);

          const monitorMessage = {
            role: "user",
            content: "🔍 Run market monitoring analysis",
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, monitorMessage]);

          try {
            const timestamp = Date.now();
            const response = await fetch(
              `${API_BASE}/timed/ai/monitor?_t=${timestamp}`,
              {
                method: "GET",
                cache: "no-store",
                headers: {
                  "Content-Type": "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                },
              }
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "Monitoring service error");
            }

            const assistantMessage = {
              role: "assistant",
              content: `📊 **Market Monitoring Analysis**\n\n${data.analysis}\n\n---\n**Stats:** ${data.stats.primeSetups} prime setups, ${data.stats.highRiskPositions} high-risk positions, ${data.stats.momentumElite} Momentum Elite`,
              timestamp: new Date(),
              sources: [
                `Monitoring data: ${data.stats.totalTickers} tickers, ${data.stats.recentActivity} events`,
              ],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Monitor error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "⚠️ AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `❌ Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const handleSend = async (e) => {
          e.preventDefault();
          if (!input.trim() || loading) return;

          const userMessage = {
            role: "user",
            content: input.trim(),
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, userMessage]);
          setInput("");
          setLoading(true);

          try {
            // Fetch recent activity for context
            let activityData = [];
            try {
              const activityRes = await fetch(
                `${API_BASE}/timed/activity?limit=20`
              );
              if (activityRes.ok) {
                const activityJson = await activityRes.json();
                if (activityJson.ok && Array.isArray(activityJson.events)) {
                  activityData = activityJson.events;
                }
              }
            } catch (e) {
              console.warn("Failed to fetch activity for chat:", e);
            }

            const timestamp = Date.now();
            const response = await fetch(
              `${API_BASE}/timed/ai/chat?_t=${timestamp}`,
              {
                method: "POST",
                cache: "no-store",
                headers: {
                  "Content-Type": "application/json",
                  "Cache-Control": "no-cache, no-store, must-revalidate",
                  Pragma: "no-cache",
                  Expires: "0",
                },
                body: JSON.stringify({
                  message: userMessage.content,
                  conversationHistory: messages.slice(-10).map((m) => ({
                    role: m.role,
                    content: m.content,
                  })),
                  tickerData: tickerData
                    ? Object.keys(tickerData).slice(0, 50)
                    : [],
                  activityData: activityData,
                }),
              }
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "AI service error");
            }

            const assistantMessage = {
              role: "assistant",
              content:
                data.response || "Sorry, I couldn't process that request.",
              timestamp: new Date(),
              sources: data.sources || [],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Chat error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "⚠️ AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `❌ Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const formatMessage = (content) => {
          // Simple markdown-like formatting
          const lines = content.split("\n");
          return lines.map((line, i) => {
            let formatted = line;
            // Bold
            formatted = formatted.replace(
              /\*\*(.+?)\*\*/g,
              '<strong class="font-semibold">$1</strong>'
            );
            // Code blocks
            formatted = formatted.replace(
              /`(.+?)`/g,
              '<code class="bg-[#26325f] px-1 py-0.5 rounded text-xs">$1</code>'
            );
            // Links
            formatted = formatted.replace(
              /\[(.+?)\]\((.+?)\)/g,
              '<a href="$2" target="_blank" class="text-blue-400 hover:underline">$1</a>'
            );
            // Use React.createElement instead of JSX for better Babel compatibility
            return React.createElement("p", {
              key: i,
              dangerouslySetInnerHTML: { __html: formatted },
            });
          });
        };

        if (!isOpen) return null;

        return (
          <div className="fixed right-0 top-0 h-full w-96 bg-[#0f1630] border-l border-[#26325f] flex flex-col shadow-2xl z-50 slide-in-right">
            {/* Header */}
            <div className="flex items-center justify-between p-4 border-b border-[#26325f] bg-[#121a33]">
              <div className="flex items-center gap-2">
                <div className="w-8 h-8 rounded-full bg-gradient-to-br from-blue-500 to-purple-500 flex items-center justify-center text-white font-bold text-sm">
                  AI
                </div>
                <div>
                  <h3 className="text-sm font-semibold text-white">
                    Trading Assistant
                  </h3>
                  <p className="text-xs text-[#93a4d6]">Powered by OpenAI</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                {periodicUpdates.length > 0 && (
                  <button
                    onClick={() => setShowUpdates(!showUpdates)}
                    className="px-3 py-1.5 text-xs bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/30 rounded-lg text-purple-400 font-semibold transition-colors relative"
                    title="View periodic updates"
                  >
                    📅 Updates
                    {periodicUpdates.length > 0 && (
                      <span className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full text-[8px] flex items-center justify-center text-white">
                        {periodicUpdates.length}
                      </span>
                    )}
                  </button>
                )}
                <button
                  onClick={handleMonitor}
                  disabled={loading}
                  className="px-3 py-1.5 text-xs bg-green-500/20 hover:bg-green-500/30 disabled:bg-[#26325f] disabled:text-[#6b7a9f] border border-green-500/30 rounded-lg text-green-400 font-semibold transition-colors disabled:cursor-not-allowed"
                  title="Run market monitoring analysis"
                >
                  🔍 Monitor
                </button>
                <button
                  onClick={onClose}
                  className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
                >
                  ✕
                </button>
              </div>
            </div>

            {/* Periodic Updates Panel */}
            {showUpdates && periodicUpdates.length > 0 && (
              <div className="border-b border-[#26325f] bg-[#0f1630] max-h-64 overflow-y-auto">
                <div className="p-3">
                  <h4 className="text-xs font-semibold text-white mb-2">
                    📅 Periodic Updates
                  </h4>
                  <div className="space-y-2">
                    {periodicUpdates.map((update, idx) => (
                      <div
                        key={idx}
                        className="p-2 bg-[#121a33] border border-[#26325f] rounded-lg cursor-pointer hover:bg-[#1a2550] transition-colors"
                        onClick={() => {
                          setMessages((prev) => [
                            ...prev,
                            {
                              role: "assistant",
                              content: `📅 **${update.updateTime}**\n\n${update.analysis}\n\n---\n**Stats:** ${update.stats.primeSetups} prime setups, ${update.stats.highRiskPositions} high-risk positions`,
                              timestamp: new Date(update.timestamp),
                            },
                          ]);
                          setShowUpdates(false);
                        }}
                      >
                        <div className="text-xs font-semibold text-purple-400">
                          {update.updateTime}
                        </div>
                        <div className="text-xs text-[#93a4d6] mt-1 line-clamp-2">
                          {update.analysis.substring(0, 100)}...
                        </div>
                        <div className="text-[10px] text-[#6b7a9f] mt-1">
                          {new Date(update.timestamp).toLocaleString()}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
              {messages.map((msg, idx) => (
                <div
                  key={idx}
                  className={`flex ${
                    msg.role === "user" ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[80%] rounded-lg p-3 ${
                      msg.role === "user"
                        ? "bg-blue-500/20 border border-blue-500/30 text-white"
                        : msg.error
                        ? "bg-red-500/20 border border-red-500/30 text-red-300"
                        : "bg-[#121a33] border border-[#26325f] text-[#e7ecff]"
                    }`}
                  >
                    <div className="text-sm whitespace-pre-wrap">
                      {formatMessage(msg.content)}
                    </div>
                    {msg.sources && msg.sources.length > 0 && (
                      <div className="mt-2 pt-2 border-t border-[#26325f]">
                        <p className="text-xs text-[#93a4d6] mb-1">Sources:</p>
                        <ul className="text-xs text-[#93a4d6] space-y-1">
                          {msg.sources.map((source, i) => (
                            <li key={i}>• {source}</li>
                          ))}
                        </ul>
                      </div>
                    )}
                    <div className="text-xs text-[#6b7a9f] mt-1">
                      {new Date(msg.timestamp).toLocaleTimeString()}
                    </div>
                  </div>
                </div>
              ))}
              {loading && (
                <div className="flex justify-start">
                  <div className="bg-[#121a33] border border-[#26325f] rounded-lg p-3">
                    <div className="flex items-center gap-2 text-[#93a4d6] text-sm">
                      <div className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"></div>
                      <div
                        className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"
                        style={{ animationDelay: "0.2s" }}
                      ></div>
                      <div
                        className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"
                        style={{ animationDelay: "0.4s" }}
                      ></div>
                      <span>Thinking...</span>
                    </div>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <form
              onSubmit={handleSend}
              className="p-4 border-t border-[#26325f] bg-[#121a33]"
            >
              <div className="flex gap-2">
                <input
                  ref={inputRef}
                  type="text"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="Ask about tickers, setups, or market conditions..."
                  className="flex-1 px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6] focus:outline-none focus:border-[#3a4aa0]"
                  disabled={loading}
                />
                <button
                  type="submit"
                  disabled={loading || !input.trim()}
                  className="px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-[#26325f] disabled:text-[#6b7a9f] rounded-lg text-white font-semibold transition-colors disabled:cursor-not-allowed"
                >
                  Send
                </button>
              </div>
              <div className="flex items-center justify-between mt-2">
                <p className="text-xs text-[#6b7a9f]">
                  💡 Try: "What's the status of AAPL?" or "Show me prime setups"
                </p>
              </div>
            </form>
          </div>
        );
      };

      // ─────────────────────────────────────────────────────────────
      // TickerDetailsLoader - must be defined before App
      // ─────────────────────────────────────────────────────────────
      const TickerDetailsLoader = ({
        tickerSymbol,
        onClose,
        rankedTickers = null,
        rankedTickerPositions = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
      }) => {
        const [tickerData, setTickerData] = useState(null);
        const [allLoadedData, setAllLoadedData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              // Fetch both the ticker data and all tickers for absolute ranking
              const timestamp = Date.now();
              const [tickerRes, allRes] = await Promise.all([
                fetch(
                  `${API_BASE}/timed/latest?ticker=${encodeURIComponent(
                    tickerSymbol
                  )}&_t=${timestamp}`,
                  {
                    cache: "no-store",
                    headers: {
                      "Cache-Control": "no-cache, no-store, must-revalidate",
                      Pragma: "no-cache",
                      Expires: "0",
                    },
                  }
                ),
                fetch(`${API_BASE}/timed/all?_t=${timestamp}`, {
                  cache: "no-store",
                  headers: {
                    "Cache-Control": "no-cache, no-store, must-revalidate",
                    Pragma: "no-cache",
                    Expires: "0",
                  },
                }),
              ]);

              if (!tickerRes.ok) throw new Error(`HTTP ${tickerRes.status}`);
              const tickerJson = await tickerRes.json();
              if (!tickerJson.ok || !tickerJson.latestData) {
                throw new Error(tickerJson.error || "Ticker not found");
              }

              // Try to get all tickers for ranking (may fail, that's okay)
              let allData = null;
              try {
                if (allRes.ok) {
                  const allJson = await allRes.json();
                  if (allJson.ok && allJson.data) {
                    allData = allJson.data;
                  }
                }
              } catch (e) {
                console.warn("Failed to fetch all tickers for ranking:", e);
              }

              setTickerData(tickerJson.latestData);
              setAllLoadedData(allData);
            } catch (err) {
              console.error("Failed to fetch ticker:", err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };

          fetchTicker();
        }, [tickerSymbol]);

        if (loading) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-[#26325f] rounded-xl p-6">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[#93a4d6]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }

        if (error || !tickerData) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-red-500 rounded-xl p-6">
              <div className="text-center">
                <div className="text-red-400 mb-2">
                  Failed to load {tickerSymbol}
                </div>
                <div className="text-[#93a4d6] text-sm mb-4">
                  {error || "No data available"}
                </div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-[#26325f] hover:bg-[#3a4aa0] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }

        return (
          <TickerDetailRightRail
            ticker={tickerData}
            trade={null}
            onClose={onClose}
            allLoadedData={allLoadedData}
            rankedTickers={rankedTickers}
            rankedTickerPositions={rankedTickerPositions}
            sectors={sectors}
            onJourneyHover={onJourneyHover}
            onJourneySelect={onJourneySelect}
            selectedJourneyTs={selectedJourneyTs}
          />
        );
      };

      // ─────────────────────────────────────────────────────────────
      // OverlayPortal - must be defined before App
      // ─────────────────────────────────────────────────────────────
      const OverlayPortal = ({
        selectedTicker,
        tickers,
        data,
        onClose,
        rankedTickers = null,
        rankedTickerPositions = null,
        sectors = [],
        onJourneyHover = null,
        onJourneySelect = null,
        selectedJourneyTs = null,
      }) => {
        if (!selectedTicker) return null;

        try {
          // Normalize ticker name
          const tickerUpper = String(selectedTicker).toUpperCase();

          // Search in filtered tickers first
          let foundTicker = tickers.find((t) => {
            if (!t || typeof t !== "object") return false;
            const tTicker = String(t.ticker || "").toUpperCase();
            return tTicker === tickerUpper;
          });

          // If not found, search in original data object
          if (!foundTicker && data && typeof data === "object") {
            if (Array.isArray(data)) {
              foundTicker = data.find((t) => {
                if (!t || typeof t !== "object") return false;
                const tTicker = String(t.ticker || "").toUpperCase();
                return tTicker === tickerUpper;
              });
            } else {
              // Object format: check if ticker is a key (data structure: { "ETHA": {...}, ... })
              if (data[tickerUpper]) {
                foundTicker = data[tickerUpper];
              } else {
                // Search through all values in case structure is different
                const dataArray = Object.values(data);
                foundTicker = dataArray.find((t) => {
                  if (!t || typeof t !== "object") return false;
                  const tTicker = String(t.ticker || "").toUpperCase();
                  return tTicker === tickerUpper;
                });
              }
            }
          }

          // If still not found, fetch from API
          if (!foundTicker) {
            console.warn(
              "Ticker not found in local data, fetching from API:",
              tickerUpper
            );
            return (
              <TickerDetailsLoader
                tickerSymbol={tickerUpper}
                onClose={onClose}
                allLoadedData={data}
                rankedTickers={rankedTickers}
                rankedTickerPositions={rankedTickerPositions}
                sectors={sectors}
                onJourneyHover={onJourneyHover}
                onJourneySelect={onJourneySelect}
                selectedJourneyTs={selectedJourneyTs}
              />
            );
          }

          // TEMPORARILY DISABLE PORTAL - render inline to avoid freeze issues
          // TODO: Re-enable portal once freeze is resolved
          return (
            <TickerDetailRightRail
              ticker={foundTicker}
              trade={null}
              onClose={onClose}
              allLoadedData={data}
              rankedTickers={rankedTickers}
              rankedTickerPositions={rankedTickerPositions}
              sectors={sectors}
              onJourneyHover={onJourneyHover}
              onJourneySelect={onJourneySelect}
              selectedJourneyTs={selectedJourneyTs}
            />
          );

          /* Portal code - disabled for now
          const overlayContent = (
            <TickerDetails
              ticker={foundTicker}
              onClose={onClose}
            />
          );
          
          // Use portal to render at document body level, but only if available
          if (ReactDOM && ReactDOM.createPortal && document && document.body) {
            try {
              return ReactDOM.createPortal(overlayContent, document.body);
            } catch (portalError) {
              console.error('Portal error:', portalError);
              // Fallback to inline rendering
              return overlayContent;
            }
          }
          // Fallback if portal not available
          return overlayContent;
          */
        } catch (error) {
          console.error("OverlayPortal error:", error);
          return null;
        }
      };

      // ─────────────────────────────────────────────────────────────
      // Main App
      // ─────────────────────────────────────────────────────────────
      function App() {
        const {
          data,
          loading,
          error,
          lastUpdate,
          versionInfo,
          tickersWithoutScores,
          refetch,
        } = useTickerData();
        const { trades } = useTrades();
        const { sectors } = useSectors();
        const [filters, setFilters] = useState({
          search: "",
          tickerFilter: "", // Comma-separated ticker symbols for filtering specific tickers
          quadrants: [
            "HTF_BULL_LTF_PULLBACK",
            "HTF_BULL_LTF_BULL",
            "HTF_BEAR_LTF_BEAR",
            "HTF_BEAR_LTF_PULLBACK",
          ],
          minRank: 0,
          minRR: 0,
          maxCompletion: 1.01,
          group: "ALL",
          sector: null, // Filter by sector name
          td9Setup: null, // Filter by TD9 setup: "bullish", "bearish", or null for all
        });
        const [selectedTicker, setSelectedTicker] = useState(null);
        const [selectedTrail, setSelectedTrail] = useState(null);
        const [hoveredTicker, setHoveredTicker] = useState(null);
        const [journeyHoverPoint, setJourneyHoverPoint] = useState(null);
        const [journeySelectedPoint, setJourneySelectedPoint] = useState(null);
        // AI Assistant removed (unused)
        const [showWelcomeDashboard, setShowWelcomeDashboard] = useState(() => {
          // Check if user has seen dashboard welcome page before
          const hasSeenWelcome = localStorage.getItem(
            "timedTrading_welcomeSeen"
          );
          return !hasSeenWelcome;
        });

        const [showWelcomeTracker, setShowWelcomeTracker] = useState(false);
        const [missingIngest, setMissingIngest] = useState([]);
        const [missingIngestLoading, setMissingIngestLoading] = useState(false);
        const [missingIngestError, setMissingIngestError] = useState(null);
        const [missingIngestOpen, setMissingIngestOpen] = useState(false);
        const [ingestAudit, setIngestAudit] = useState(null);
        const [ingestAuditLoading, setIngestAuditLoading] = useState(false);
        const [ingestAuditError, setIngestAuditError] = useState(null);
        const [ingestAuditOpen, setIngestAuditOpen] = useState(false);

        const fetchMissingIngest = useCallback(async () => {
          try {
            setMissingIngestLoading(true);
            setMissingIngestError(null);
            const res = await fetch(`${API_BASE}/timed/ingest-status`, {
              cache: "no-store",
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ingest_status_failed");
            const missing = Array.isArray(json.missing) ? json.missing : [];
            setMissingIngest(missing);
          } catch (e) {
            setMissingIngest([]);
            setMissingIngestError(String(e.message || e));
          } finally {
            setMissingIngestLoading(false);
          }
        }, []);

        const fetchIngestAudit = useCallback(async () => {
          try {
            setIngestAuditLoading(true);
            setIngestAuditError(null);
            const until = Date.now();
            const since = until - 6 * 60 * 60 * 1000;
            const res = await fetch(
              `${API_BASE}/timed/ingest-audit?since=${since}&until=${until}&bucket=5`,
              { cache: "no-store" }
            );
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (!json.ok) throw new Error(json.error || "ingest_audit_failed");
            setIngestAudit(json);
          } catch (e) {
            setIngestAudit(null);
            setIngestAuditError(String(e.message || e));
          } finally {
            setIngestAuditLoading(false);
          }
        }, []);

        const ingestAuditSummary = useMemo(() => {
          const rows = Array.isArray(ingestAudit?.perTicker)
            ? ingestAudit.perTicker
            : [];
          if (rows.length === 0) return null;
          let expected = 0;
          let received = 0;
          rows.forEach((r) => {
            expected += Number(r.expectedBuckets || 0);
            received += Number(r.receiptBuckets || 0);
          });
          const coveragePct =
            expected > 0 ? (received / expected) * 100 : 0;
          const worst = [...rows]
            .sort(
              (a, b) =>
                Number(b.missingReceipts || 0) - Number(a.missingReceipts || 0)
            )
            .slice(0, 12);
          return { expected, received, coveragePct, worst };
        }, [ingestAudit]);

        // Fetch trail data when ticker is selected
        useEffect(() => {
          if (selectedTicker) {
            // Reset any journey highlight when switching tickers
            setJourneyHoverPoint(null);
            setJourneySelectedPoint(null);

            // ✅ Immediately set to empty array to trigger selected-only view
            setSelectedTrail([]);

            const controller = new AbortController();
            // Trail payloads can be large; request a small window and allow a bit more time.
            const timeoutId = setTimeout(() => controller.abort(), 8000);

            const fetchSelectedTrail = async () => {
              const qs = new URLSearchParams();
              qs.set("ticker", String(selectedTicker || "").toUpperCase());
              // We only need recent history for Bubble Journey rendering
              qs.set("limit", "250");
              const url = `${API_BASE}/timed/trail?${qs.toString()}`;

              // A couple of light retries on 429/5xx to survive transient limits.
              for (let attempt = 0; attempt < 2; attempt++) {
                try {
                  const res = await fetch(url, {
                    signal: controller.signal,
                    cache: "no-store",
                  });

                  if (res.status === 429) {
                    // Respect Retry-After if present (seconds)
                    const retryAfterHeader = res.headers.get("Retry-After");
                    const retryAfterSec = retryAfterHeader
                      ? Math.min(60, Math.max(1, Number(retryAfterHeader)))
                      : 5;
                    await new Promise((r) =>
                      setTimeout(r, retryAfterSec * 1000)
                    );
                    continue;
                  }

                  if (!res.ok) {
                    // Retry once on 5xx; otherwise stop.
                    if (res.status >= 500 && attempt === 0) {
                      await new Promise((r) => setTimeout(r, 500));
                      continue;
                    }
                    setSelectedTrail([]);
                    return;
                  }

                  const data = await res.json();
                  if (data.ok && Array.isArray(data.trail)) {
                    const normalized = normalizeTrailPoints(data.trail);
                    const last20 =
                      normalized.length > 20 ? normalized.slice(-20) : normalized;
                    // One-time sample log to confirm keys look right
                    if (!window._trailSampleLogged) {
                      window._trailSampleLogged = true;
                      console.log(`[TRAIL SAMPLE] ${selectedTicker}`, {
                        first: last20[0],
                        rawFirst: Array.isArray(data.trail)
                          ? data.trail[0]
                          : null,
                        rawKeys:
                          data.trail && data.trail[0]
                            ? Object.keys(data.trail[0])
                            : [],
                      });
                    }
                    setSelectedTrail(last20);
                    return;
                  }

                  setSelectedTrail([]);
                  return;
                } catch (err) {
                  if (err.name === "AbortError") return;
                  if (attempt === 0) {
                    await new Promise((r) => setTimeout(r, 300));
                    continue;
                  }
                  console.error("Failed to load trail:", err);
                  setSelectedTrail([]);
                  return;
                }
              }

              // If we exhausted retries, keep empty
              setSelectedTrail([]);
            };

            fetchSelectedTrail().finally(() => clearTimeout(timeoutId));
          } else {
            setSelectedTrail(null);
          }
        }, [selectedTicker]);

        // Debug: Log when selectedTicker changes
        React.useEffect(() => {
          console.log(`[SELECTED TICKER STATE] Changed to:`, selectedTicker, {
            isTruthy: !!selectedTicker,
            type: typeof selectedTicker,
            value: selectedTicker,
          });
        }, [selectedTicker]);

        // Safe setter for selectedTicker to prevent infinite loops
        const handleTickerSelect = useCallback((ticker) => {
          try {
            console.log(`[CLICK HANDLER] Setting selectedTicker to:`, ticker);
            setSelectedTicker(ticker);
            console.log(
              `[CLICK HANDLER] selectedTicker set, should trigger re-render`
            );
          } catch (error) {
            console.error("Error setting selected ticker:", error);
          }
        }, []);

        const debouncedSearch = useDebounce(filters.search, 300);
        const effectiveFilters = { ...filters, search: debouncedSearch };

        const [timeTravelTickers, setTimeTravelTickers] = useState(null);

        const tickers = useMemo(() => {
          // If time travel is active, use time travel tickers, otherwise use filtered tickers
          if (timeTravelTickers !== null) {
            return timeTravelTickers;
          }
          return applyFilters(data, effectiveFilters, trades);
        }, [data, effectiveFilters, trades, timeTravelTickers]);

        // Base filtered tickers for Time Travel slider controls.
        // IMPORTANT: Hooks must never be called conditionally inside JSX.
        const timeTravelBaseTickers = useMemo(() => {
          return applyFilters(data, effectiveFilters, trades);
        }, [data, effectiveFilters, trades]);

        // Compute dynamic ranks once for all tickers to ensure consistency
        // IMPORTANT: Use ALL tickers from data, not filtered tickers, for Ranked List
        const allTickersForRanking = useMemo(() => {
          if (!data || typeof data !== "object") return [];
          return Object.values(data).filter(
            (t) =>
              t &&
              typeof t === "object" &&
              t.ticker &&
              t.rank !== undefined &&
              t.rank !== null
          );
        }, [data]);

        // Use dynamicScore from API (backend calculation) - no frontend calculation needed
        const allTickersWithRanks = useMemo(() => {
          const withRanks = allTickersForRanking.map((t) => ({
            ...t,
            dynamicRank: t.dynamicScore || computeDynamicRank(t), // Use API value, fallback to calculation if missing
          }));

          // Debug: Check if we're using API scores or calculating
          const usingApiScores = withRanks.filter(
            (t) => t.dynamicScore !== undefined
          ).length;
          console.log(
            `🔍 [RANKED LIST] Using API dynamicScore: ${usingApiScores}/${withRanks.length} tickers`
          );

          // Debug: Log top 5 BEFORE sorting to see original order
          const beforeSort = [...withRanks].slice(0, 5);
          console.log(
            "🔍 [RANKED LIST] Before sort (first 5):",
            beforeSort.map((t) => ({
              ticker: t.ticker,
              dynamicRank: t.dynamicRank,
              dynamicScore: t.dynamicScore,
              baseRank: t.rank,
            }))
          );

          // Debug: Log top 5 AFTER sorting
          const sorted = [...withRanks].sort((a, b) => {
            const scoreA = Number(a.dynamicRank) || 0;
            const scoreB = Number(b.dynamicRank) || 0;
            // NO alphabetical tie-breaker - pure score sorting
            return scoreB - scoreA;
          });

          if (sorted.length > 0) {
            console.log(
              "🔍 [RANKED LIST] After sort (Top 5):",
              sorted.slice(0, 5).map((t, i) => ({
                rank: i + 1,
                ticker: t.ticker,
                dynamicRank: t.dynamicRank,
                dynamicScore: t.dynamicScore,
                baseRank: t.rank,
              }))
            );
            console.log(
              "🔍 [RANKED LIST] #1 Ticker:",
              sorted[0].ticker,
              "Score:",
              sorted[0].dynamicRank,
              "From API:",
              sorted[0].dynamicScore !== undefined
                ? "YES ✅"
                : "NO ❌ (calculated)"
            );
          }

          return withRanks;
        }, [allTickersForRanking]);

        const rankedTickers = useMemo(() => {
          return getRankedTickers(allTickersWithRanks);
        }, [allTickersWithRanks]);

        const rankedTickerPositions = useMemo(() => {
          const map = {};
          rankedTickers.forEach((t, idx) => {
            const sym = String(t.ticker || "").trim().toUpperCase();
            const pos = Number(t?.rank_position);
            const rankPos =
              Number.isFinite(pos) && pos > 0 ? pos : idx + 1;
            if (sym && map[sym] == null) {
              map[sym] = rankPos;
            }
          });
          return map;
        }, [rankedTickers]);

        // Use dynamicScore from API (backend calculation) - no frontend calculation needed
        const tickersWithRanks = useMemo(() => {
          return tickers.map((t) => ({
            ...t,
            dynamicRank: t.dynamicScore || computeDynamicRank(t), // Use API value, fallback to calculation if missing
          }));
        }, [tickers]);

        const primeTickers = useMemo(
          () => tickersWithRanks.filter(isPrimeBubble),
          [tickersWithRanks]
        );

        const handleFilterChange = useCallback((newFilters) => {
          setFilters((prev) => {
            // Create a new object to ensure React detects the change
            const updated = { ...prev };
            // Apply new filters
            Object.keys(newFilters).forEach((key) => {
              if (newFilters[key] === undefined || newFilters[key] === null) {
                // Explicitly delete undefined/null values to clear filters
                delete updated[key];
              } else {
                updated[key] = newFilters[key];
              }
            });
            return updated;
          });
        }, []);

        const handleWelcomeDashboardClose = () => {
          setShowWelcomeDashboard(false);
          localStorage.setItem("timedTrading_welcomeSeen", "true");
        };

        const handleWelcomeTrackerClose = () => {
          setShowWelcomeTracker(false);
        };

        return (
          <>
            {/* Welcome Modals */}
            {showWelcomeDashboard && (
              <DashboardWelcomeModal onClose={handleWelcomeDashboardClose} />
            )}
            {showWelcomeTracker && (
              <TrackerWelcomeModal onClose={handleWelcomeTrackerClose} />
            )}

            <div className="min-h-screen p-4">
              <div className="w-full mx-auto">
                {/* Navigation */}
                <nav className="mb-4 p-3 bg-[#121a33] border border-[#26325f] rounded-lg">
                  <div className="flex items-center gap-3 flex-wrap">
                    <span className="text-sm text-[#93a4d6]">Navigate:</span>
                    <a
                      href="index-react.html"
                      className="px-3 py-1.5 rounded bg-blue-500/20 border border-blue-500 text-sm text-blue-400 font-semibold"
                    >
                      Dashboard
                    </a>
                    <a
                      href="simulation-dashboard.html"
                      className="px-3 py-1.5 rounded bg-[#0f1630] border border-[#26325f] text-sm hover:bg-[#1a2550] transition-colors"
                    >
                      Trade Tracker
                    </a>
                    <button
                      onClick={() => setShowWelcomeDashboard(true)}
                      className="px-3 py-1.5 rounded bg-purple-500/20 border border-purple-500 text-sm text-purple-400 font-semibold hover:bg-purple-500/30 transition-colors"
                      title="Show Dashboard Guide (Trading Concepts)"
                    >
                      📚 Dashboard Guide
                    </button>
                    <button
                      onClick={() => setShowWelcomeTracker(true)}
                      className="px-3 py-1.5 rounded bg-blue-500/20 border border-blue-500 text-sm text-blue-400 font-semibold hover:bg-blue-500/30 transition-colors"
                      title="Show Trade Tracker Guide (Simulated Trades)"
                    >
                      📊 Trade Tracker Guide
                    </button>
                  </div>
                </nav>

                {/* Header */}
                <header className="mb-6">
                  <div className="flex items-center justify-between mb-4">
                    <div className="flex items-center gap-4 flex-wrap">
                      <h1 className="text-3xl font-bold">Timed Trading</h1>
                      <div className="flex gap-3 text-sm items-center flex-wrap">
                        <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                          <span className="text-[#93a4d6]">Tickers: </span>
                          <span className="font-bold text-white">
                            {tickers.length}
                          </span>
                        </div>
                        <div className="px-3 py-1.5 rounded-lg bg-green-500/10 border border-green-500/30">
                          <span className="text-green-400">Prime: </span>
                          <span className="font-bold text-green-400">
                            {primeTickers.length}
                          </span>
                        </div>
                        {versionInfo && (
                          <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                            <span className="text-[#93a4d6]">Version: </span>
                            <span className="font-bold text-blue-400">
                              {versionInfo.currentDataVersion ||
                                versionInfo.storedVersion}
                            </span>
                            {versionInfo.versionFiltered > 0 && (
                              <span className="text-yellow-400 ml-2 text-xs">
                                ({versionInfo.versionFiltered} filtered)
                              </span>
                            )}
                          </div>
                        )}
                        {tickers.length > 0 && (
                          <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                            <span className="text-[#93a4d6]">In Corridor: </span>
                            <span className="font-bold text-white">
                              {tickers.filter((t) => entryType(t).corridor).length}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                    <div className="flex items-center gap-4">
                      {loading && <div className="loading-spinner"></div>}
                      {error && (
                        <div className="px-4 py-2 bg-red-500/20 border border-red-500 rounded-lg text-red-400 text-sm">
                          Error: {error}
                        </div>
                      )}
                      <button
                        onClick={refetch}
                        className="px-4 py-2 bg-[#1a2550] border border-[#26325f] rounded-lg hover:bg-[#26325f] transition-colors"
                      >
                        Refresh
                      </button>
                      {lastUpdate && (
                        <span className="text-sm text-[#93a4d6]">
                          Updated {lastUpdate.toLocaleTimeString()}
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Filters */}
                  <div className="mt-4">
                    <div className="mb-4">
                      <input
                        type="text"
                        placeholder="Search tickers, filters, or conditions... (e.g., 'AAPL, GOOGL, TSLA' or 'top 40' or 'rank over 75')"
                        value={filters.search}
                        onChange={(e) => {
                          const value = e.target.value;
                          handleFilterChange({ search: value });
                          // Also update tickerFilter if it looks like a simple ticker list (for Time Travel compatibility)
                          // Only if it's comma-separated and doesn't contain filter keywords
                          if (
                            value.includes(",") &&
                            !value.match(
                              /rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup|above|over|below|under/
                            )
                          ) {
                            handleFilterChange({ tickerFilter: value });
                          } else if (!value.trim()) {
                            handleFilterChange({ tickerFilter: "" });
                          }
                        }}
                        className="w-full px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6]"
                      />
                      <div className="mt-1 text-xs text-[#6b7a9f]">
                        💡 Search by tickers (comma-separated), natural language
                        filters, or conditions.{" "}
                        <span className="text-[#93a4d6]">
                          Examples: "AAPL, GOOGL, TSLA" • "top 40" • "rank over
                          75" • "RR above 2" • "prime setup and in corridor"
                        </span>
                      </div>
                    </div>
                    <ViewportFilterTags
                      filters={filters}
                      onChange={handleFilterChange}
                      sectors={sectors}
                    />
                  </div>
                </header>

                {/* Error Display */}
                {error && (
                  <div className="mb-4 p-4 bg-red-500/20 border-2 border-red-500 rounded-xl">
                    <div className="flex items-center justify-between">
                      <div>
                        <h3 className="text-lg font-bold text-red-400 mb-2">
                          Error Loading Data
                        </h3>
                        <p className="text-red-300">{error}</p>
                      </div>
                      <button
                        onClick={refetch}
                        className="px-4 py-2 bg-red-500 hover:bg-red-600 rounded-lg text-white font-semibold"
                      >
                        Retry
                      </button>
                    </div>
                  </div>
                )}

                {/* Ingestion Status Panel (minimizable, always accessible) */}
                <IngestionStatusPanel
                  allData={data}
                  filteredTickers={applyFilters(data, effectiveFilters, trades)}
                  onRefresh={refetch}
                />

                {/* Main Content - Hero Layout: Activity Feed (left) | Bubble Chart (center) | Detail (right) */}
                {!error && (
                  <div className="space-y-4">
                    {/* Hero Section: Activity Feed | Bubble Chart | Detail View */}
                    <div className="flex flex-col lg:flex-row gap-4 items-start">
                      {/* Viewport - Left side */}
                      <div className="w-full lg:w-[440px] lg:flex-shrink-0">
                        <OpportunitiesPanel
                          tickers={tickersWithRanks}
                          rankPositions={rankedTickerPositions}
                          onSelectTicker={handleTickerSelect}
                          title="🔭 Viewport"
                          maxHeightClass="max-h-[900px]"
                          showControls={false}
                        />
                      </div>

                      {/* Bubble Chart - Center Hero (flexible, takes remaining space) */}
                      <div
                        className={`w-full lg:flex-1 lg:min-w-0 transition-all ${
                          selectedTicker ? "lg:mr-[470px]" : ""
                        }`}
                      >
                        <TimeTravelSlider
                          tickers={timeTravelBaseTickers}
                          allTickers={data}
                          data={data}
                          onTimeChange={setTimeTravelTickers}
                          tickerFilter={filters.tickerFilter}
                        />
                        {/* Bubble Chart Legend - Compact Horizontal */}
                        <div className="w-full bg-[#0f1630] border border-[#26325f] rounded-lg px-4 py-2 mb-2">
                          <div className="flex flex-wrap items-center gap-x-6 gap-y-2 text-xs text-[#93a4d6]">
                            {/* Colors Section */}
                            <div className="flex items-center gap-2">
                              <span className="text-[#e7ecff] font-semibold">
                                Colors:
                              </span>
                              <div className="flex items-center gap-1">
                                <div className="w-3 h-3 rounded-full bg-[#2ecc71] border border-[#1e8449]"></div>
                                <span>&lt;30%</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <div className="w-3 h-3 rounded-full bg-[#f39c12] border border-[#d68910]"></div>
                                <span>30-60%</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <div className="w-3 h-3 rounded-full bg-[#e74c3c] border border-[#c0392b]"></div>
                                <span>&gt;60%</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <div className="w-3 h-3 rounded-full bg-[#6b7a9f] border border-[#93a4d6]"></div>
                                <span>Waiting</span>
                              </div>
                            </div>

                            {/* Size Section */}
                            <div className="flex items-center gap-2">
                              <span className="text-[#e7ecff] font-semibold">
                                Size:
                              </span>
                              <div className="flex items-center gap-1">
                                <div className="w-2 h-2 rounded-full bg-[#93a4d6]"></div>
                                <span>Small = Low R:R</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <div className="w-4 h-4 rounded-full bg-[#93a4d6]"></div>
                                <span>Large = High R:R</span>
                              </div>
                            </div>

                            {/* Emojis Section */}
                            <div className="flex items-center gap-2">
                              <span className="text-[#e7ecff] font-semibold">
                                Emojis:
                              </span>
                              <div className="flex items-center gap-1">
                                <span className="text-base">👑</span>
                                <span>#1 Ranked</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <span className="text-base">⭐</span>
                                <span>Prime</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <span className="text-base">⚡</span>
                                <span>Squeeze Release</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <span className="text-base">🧨</span>
                                <span>In Squeeze</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <span className="text-base">⏳</span>
                                <span>Waiting</span>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div className="h-[600px] sm:h-[700px] md:h-[800px] lg:h-[900px]">
                          {loading && tickers.length === 0 ? (
                            <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] flex items-center justify-center">
                              <div className="text-center">
                                <div className="loading-spinner mx-auto mb-4"></div>
                                <div className="text-[#93a4d6]">
                                  Loading tickers...
                                </div>
                              </div>
                            </div>
                          ) : (
                            <BubbleChart
                              tickers={tickers}
                              onBubbleClick={handleTickerSelect}
                              hoveredTicker={hoveredTicker}
                              onHover={setHoveredTicker}
                              selectedTicker={selectedTicker}
                              selectedTrail={selectedTrail}
                              highlightTrailPoint={
                                journeyHoverPoint || journeySelectedPoint
                              }
                              allData={data}
                              rankedTickers={rankedTickers}
                              rankedTickerPositions={rankedTickerPositions}
                            />
                          )}
                        </div>
                      </div>
                    </div>

                    {/* Right Rail - Detail View (slides in from right, fixed to viewport) */}
                    {selectedTicker && (
                      <div className="fixed right-0 top-0 w-full sm:w-[450px] h-screen bg-[#0f1630] border-l border-[#26325f] z-40 slide-in-right shadow-2xl overflow-y-auto">
                        <OverlayPortal
                          selectedTicker={selectedTicker}
                          tickers={tickers}
                          data={data}
                          onClose={() => handleTickerSelect(null)}
                            rankedTickers={rankedTickers}
                            rankedTickerPositions={rankedTickerPositions}
                          sectors={sectors}
                          onJourneyHover={setJourneyHoverPoint}
                          onJourneySelect={(p) => {
                            setJourneySelectedPoint(p);
                          }}
                          selectedJourneyTs={journeySelectedPoint?.ts ?? null}
                        />
                      </div>
                    )}

                    {/* Lists - All five side by side in columns */}
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4">
                      {/* Ranked List - All tickers sorted by rank */}
                      <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-3">
                        <h2 className="text-sm font-bold mb-1">📊 Ranked</h2>
                        <div className="text-[9px] text-[#93a4d6] mb-2">
                          All tickers sorted by rank
                        </div>
                        <div className="space-y-1">
                          {(() => {
                            // CRITICAL: Sort by dynamicRank (score) to determine Rank (position)
                            // MUST sort - do not use original order!
                            if (!rankedTickers || rankedTickers.length === 0) {
                              console.warn(
                                "⚠️ [RANKED LIST] rankedTickers is empty!"
                              );
                              return [];
                            }

                            const sorted = rankedTickers;

                            // Verify sorting worked
                            if (sorted.length > 1) {
                              const firstScore =
                                Number(sorted[0].dynamicRank) || 0;
                              const secondScore =
                                Number(sorted[1].dynamicRank) || 0;
                              if (firstScore < secondScore) {
                                console.error(
                                  "❌ [RANKED LIST] SORTING FAILED! First score < Second score!"
                                );
                              }
                            }

                            // Debug: Log what Ranked List will show
                            if (sorted.length > 0) {
                              console.log(
                                "🔍 [RANKED LIST RENDER] Top 5 by Score (Rank 1-5):",
                                sorted.slice(0, 5).map((t, i) => ({
                                  rank: i + 1,
                                  ticker: t.ticker,
                                  score: t.dynamicRank,
                                  baseScore: t.rank,
                                  fromAPI: t.dynamicScore !== undefined,
                                }))
                              );
                              console.log(
                                "🔍 [RANKED LIST RENDER] #1 Ticker:",
                                sorted[0].ticker,
                                "Score:",
                                sorted[0].dynamicRank,
                                "From API:",
                                sorted[0].dynamicScore !== undefined
                                  ? "YES"
                                  : "NO"
                              );

                              // Check if AWI is incorrectly at top
                              if (sorted[0].ticker === "AWI") {
                                console.warn(
                                  "⚠️ [RANKING ISSUE] AWI is showing as #1!"
                                );
                                console.warn(
                                  "   Expected #1: QQQ (score ~129.51)"
                                );
                                console.warn(
                                  "   AWI score:",
                                  sorted[0].dynamicRank
                                );
                                console.warn(
                                  "   QQQ score:",
                                  sorted.find((t) => t.ticker === "QQQ")
                                    ?.dynamicRank || "NOT FOUND"
                                );
                                console.warn(
                                  "   Top 10:",
                                  sorted
                                    .slice(0, 10)
                                    .map((t) => `${t.ticker}:${t.dynamicRank}`)
                                );
                              }
                            }

                            return sorted.map((ticker, idx) => {
                              const rank = idx + 1; // Rank is position (1, 2, 3...)
                              const score = ticker.dynamicRank; // Score is the numeric value
                              return (
                                <div
                                  key={ticker.ticker}
                                  className="flex items-center gap-1"
                                >
                                  <div className="w-5 text-center flex-shrink-0">
                                    <span
                                      className={`text-[10px] font-bold ${
                                        rank <= 3
                                          ? "text-yellow-400"
                                          : rank <= 10
                                          ? "text-green-400"
                                          : "text-[#93a4d6]"
                                      }`}
                                    >
                                      #{rank}
                                    </span>
                                  </div>
                                  <div className="flex-1 min-w-0">
                                    <SetupCard
                                      ticker={{
                                        ...ticker,
                                        rank: score, // Pass score, not rank position
                                      }}
                                      isSelected={
                                        selectedTicker === ticker.ticker
                                      }
                                      onClick={() =>
                                        handleTickerSelect(ticker.ticker)
                                      }
                                    />
                                  </div>
                                </div>
                              );
                            });
                          })()}
                        </div>
                      </div>

                    </div>
                  </div>
                )}
              </div>
            </div>

          </>
        );
      }

      // Make App accessible from outside the Babel script
      window.App = App;
    </script>

    <!-- Initialize app - separate script to avoid Babel parsing issues -->
    <script>
      // Render with error handling
      // Wait for all scripts to load before rendering
      function initializeApp() {
        try {
          // Check if React and ReactDOM are loaded
          if (typeof React === "undefined") {
            throw new Error("React not loaded. Check CDN connection.");
          }
          if (typeof ReactDOM === "undefined") {
            throw new Error("ReactDOM not loaded. Check CDN connection.");
          }

          const rootElement = document.getElementById("root");
          if (!rootElement) {
            throw new Error("Root element not found");
          }

          // Check if App component is available (from Babel script)
          if (typeof window.App === "undefined") {
            throw new Error(
              "App component not loaded. Babel may not have finished processing."
            );
          }

          // Check if React 18 createRoot is available
          if (ReactDOM.createRoot) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(React.createElement(window.App));
          } else {
            // Fallback for React 17
            ReactDOM.render(React.createElement(window.App), rootElement);
          }

          console.log("[App] Dashboard initialized successfully");
        } catch (error) {
          console.error("Error rendering app:", error);
          const rootElement = document.getElementById("root");
          if (rootElement) {
            rootElement.innerHTML = `
              <div style="padding: 40px; text-align: center; color: #e7ecff; max-width: 800px; margin: 0 auto;">
                <h2 style="color: #e74c3c; margin-bottom: 20px;">Error Loading Dashboard</h2>
                <p style="margin-bottom: 20px; color: #ff6b6b;">${error.message}</p>
                <div style="background: #1a2440; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left; color: #93a4d6;">
                  <h3 style="color: #e7ecff; margin-bottom: 10px;">Troubleshooting:</h3>
                  <ul style="list-style: disc; padding-left: 20px; line-height: 1.8;">
                    <li>Open browser console (F12 or Cmd+Option+I) to see detailed errors</li>
                    <li>Check your internet connection - CDN resources need to load</li>
                    <li>Try refreshing the page (Cmd+R or Ctrl+R)</li>
                    <li>Check if React is loaded: <code style="background: #26325f; padding: 2px 6px; border-radius: 4px;">typeof React !== 'undefined'</code></li>
                    <li>Check if API is reachable: <a href="https://timed-trading-ingest.shashant.workers.dev/timed/health" target="_blank" style="color: #4a9eff;">API Health Check</a></li>
                  </ul>
                </div>
                <button 
                  onclick="window.location.reload()" 
                  style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;"
                >
                  Reload Page
                </button>
              </div>
            `;
          }
        }
      }

      // Wait for DOM and scripts to be ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
          // Wait a bit for Babel to process
          setTimeout(initializeApp, 100);
        });
      } else {
        // DOM already loaded
        setTimeout(initializeApp, 100);
      }

      // Fallback: If React still isn't loaded after 5 seconds, show error
      setTimeout(function () {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          const rootElement = document.getElementById("root");
          if (
            rootElement &&
            rootElement.innerHTML.includes("Loading dashboard")
          ) {
            rootElement.innerHTML = `
          <div style="padding: 40px; text-align: center; color: #e7ecff;">
                <h2 style="color: #e74c3c;">CDN Resources Not Loading</h2>
                <p style="margin: 20px 0; color: #93a4d6;">
                  React or other CDN resources failed to load. This may be due to:
                </p>
                <ul style="text-align: left; display: inline-block; color: #93a4d6; margin: 20px 0;">
                  <li>Network connectivity issues</li>
                  <li>Ad blockers blocking CDN scripts</li>
                  <li>Corporate firewall blocking unpkg.com</li>
                </ul>
                <p style="margin-top: 20px;">
                  <button onclick="window.location.reload()" style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Retry
                  </button>
            </p>
          </div>
        `;
          }
        }
      }, 5000);
    </script>
  </body>
</html>
