<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timed Trading â€” React Dashboard</title>

    <!-- React & ReactDOM via CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
      onerror="console.error('Failed to load React')"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      onerror="console.error('Failed to load ReactDOM')"
    ></script>

    <!-- Babel Standalone for JSX -->
    <script
      src="https://unpkg.com/@babel/standalone/babel.min.js"
      onerror="console.error('Failed to load Babel')"
    ></script>

    <!-- Tailwind CSS -->
    <script
      src="https://cdn.tailwindcss.com"
      onerror="console.error('Failed to load Tailwind')"
    ></script>

    <!-- Recharts for lightweight charting - try multiple sources -->
    <script
      src="https://unpkg.com/recharts@2.10.3/umd/Recharts.js"
      onerror="console.error('Failed to load Recharts from unpkg, trying alternative...'); loadRechartsFallback();"
    ></script>
    <script>
      function loadRechartsFallback() {
        // Try alternative CDN
        const script = document.createElement("script");
        script.src =
          "https://cdn.jsdelivr.net/npm/recharts@2.10.3/umd/Recharts.js";
        script.onerror = function () {
          console.error("Recharts failed to load from all sources");
          window.RechartsFailed = true;
        };
        script.onload = function () {
          console.log("Recharts loaded from jsdelivr");
        };
        document.head.appendChild(script);
      }

      // Check if Recharts loaded after a delay
      window.addEventListener("load", function () {
        setTimeout(function () {
          if (typeof Recharts === "undefined" && !window.RechartsFailed) {
            console.warn("Recharts may not have loaded yet");
          }
        }, 2000);
      });
    </script>

    <!-- Loading indicator while scripts load -->
    <script>
      window.addEventListener("load", function () {
        // Check if all scripts loaded
        setTimeout(function () {
          const root = document.getElementById("root");
          if (root && root.innerHTML === "") {
            if (typeof React === "undefined") {
              root.innerHTML =
                '<div style="padding: 40px; text-align: center; color: #e7ecff;"><h2 style="color: #e74c3c;">Loading Error</h2><p>React failed to load. Check console (F12) for details.</p></div>';
            }
          }
        }, 2000);
      });
    </script>

    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --text: #e7ecff;
        --muted: #93a4d6;
        --line: #26325f;
        --good: #2ecc71;
        --bad: #e74c3c;
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Arial;
        background: var(--bg);
        color: var(--text);
      }

      .loading-spinner {
        border: 2px solid var(--line);
        border-top: 2px solid var(--text);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .prime-glow {
        box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        animation: pulse-glow 2s ease-in-out infinite;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          box-shadow: 0 0 12px rgba(46, 204, 113, 0.4);
        }
        50% {
          box-shadow: 0 0 20px rgba(46, 204, 113, 0.6);
        }
      }

      .momentum-elite-glow {
        box-shadow: 0 0 15px rgba(168, 85, 247, 0.5),
          0 0 25px rgba(236, 72, 153, 0.3);
        animation: momentum-pulse 2.5s ease-in-out infinite;
      }

      @keyframes momentum-pulse {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(168, 85, 247, 0.8),
            0 0 45px rgba(236, 72, 153, 0.6);
        }
      }

      /* Slide-in overlay from right */
      .slide-in-right {
        animation: slideInRight 0.3s ease-out;
      }
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      /* Comet trail effect */
      .comet-trail {
        stroke-dasharray: 5, 5;
        animation: cometMove 2s linear infinite;
      }
      @keyframes cometMove {
        from {
          stroke-dashoffset: 0;
        }
        to {
          stroke-dashoffset: 20;
        }
      }

      @keyframes momentum-pulse-old {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(168, 85, 247, 0.5),
            0 0 25px rgba(236, 72, 153, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(168, 85, 247, 0.7),
            0 0 35px rgba(236, 72, 153, 0.5);
        }
      }

      .bubble-transition {
        transition: all 0.2s ease-out;
      }

      .bubble-hover {
        transform: scale(1.15);
        filter: brightness(1.2);
      }

      .fade-in {
        animation: fadeIn 0.3s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slide-in {
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Phase color gradient helper */
      .phase-gradient {
        background: linear-gradient(
          to right,
          #2ecc71 0%,
          #27ae60 20%,
          #f39c12 40%,
          #e67e22 60%,
          #e74c3c 80%,
          #c0392b 100%
        );
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div style="padding: 40px; text-align: center; color: #e7ecff">
        <div class="loading-spinner" style="margin: 0 auto 20px"></div>
        <p>Loading dashboard...</p>
      </div>
    </div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef, memo } = React;

      // Get Recharts components with fallback
      let RechartsComponents = null;
      if (typeof Recharts !== "undefined") {
        RechartsComponents = {
          ScatterChart: Recharts.ScatterChart,
          Scatter: Recharts.Scatter,
          XAxis: Recharts.XAxis,
          YAxis: Recharts.YAxis,
          CartesianGrid: Recharts.CartesianGrid,
          Tooltip: Recharts.Tooltip,
          ResponsiveContainer: Recharts.ResponsiveContainer,
        };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Types & Constants
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const LONG_CORRIDOR = { ltfMin: -8, ltfMax: 12 };
      const SHORT_CORRIDOR = { ltfMin: -12, ltfMax: 8 };
      const API_BASE = "https://timed-trading-ingest.shashant.workers.dev";

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Hooks
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function useTickerData() {
      const [data, setData] = useState({});
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [lastUpdate, setLastUpdate] = useState(null);
      const [versionInfo, setVersionInfo] = useState(null);

        const fetchData = useCallback(async () => {
          try {
            setLoading(true);
            setError(null); // Clear any previous errors
            // Add timeout to prevent hanging - increased to 30s for large datasets
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

            // Fetch both ticker data and ticker index to ensure all 133 tickers are shown
            const [dataRes, tickersRes] = await Promise.all([
              fetch(`${API_BASE}/timed/all`, {
                signal: controller.signal,
                headers: { Accept: "application/json" },
              }),
              fetch(`${API_BASE}/timed/tickers`, {
                signal: controller.signal,
                headers: { Accept: "application/json" },
              }),
            ]);

            clearTimeout(timeoutId);

            if (!dataRes.ok) {
              const errorText = await dataRes.text();
              throw new Error(
                `HTTP ${dataRes.status}: ${errorText || "Unknown error"}`
              );
            }

            const dataJson = await dataRes.json();
            const tickersJson = await tickersRes.json();

            if (dataJson.ok) {
              const tickerData = dataJson.data || {};
              const allTickers =
                tickersJson.ok && tickersJson.tickers
                  ? tickersJson.tickers
                  : [];

              // Log version information for debugging
              const dataVersion = dataJson.dataVersion || "unknown";
              const versionsSeen = dataJson.versionsSeen || [];
              const versionFiltered = dataJson.versionFiltered || 0;
              const versionBreakdown = dataJson.versionBreakdown || {};
              const acceptedVersions = dataJson.acceptedVersions || [];
              const currentDataVersion = dataJson.currentDataVersion || "unknown";
              
              // Store version info for UI display
              setVersionInfo({
                storedVersion: dataVersion,
                versionsSeen: versionsSeen,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                acceptedVersions: acceptedVersions,
                currentDataVersion: currentDataVersion
              });
              
              console.log(`[UI] Data Version Info:`, {
                storedVersion: dataVersion,
                currentDataVersion: currentDataVersion,
                versionsSeen: versionsSeen,
                acceptedVersions: acceptedVersions,
                versionFiltered: versionFiltered,
                versionBreakdown: versionBreakdown,
                tickersReturned: Object.keys(tickerData).length,
                totalTickersInIndex: allTickers.length
              });

              // Merge: ensure all tickers from index are present, even if no recent data
              // This maintains the full 133 ticker baseline
              const mergedData = { ...tickerData };
              allTickers.forEach((ticker) => {
                if (!mergedData[ticker]) {
                  // Add placeholder for tickers without recent data
                  // They'll appear on the chart with their last known position (if available)
                  // or won't render until data comes in
                  mergedData[ticker] = {
                    ticker: ticker,
                    // Note: Without data, these tickers won't render bubbles
                    // but they'll be available when data arrives
                  };
                }
              });

              setData(mergedData);
              setLastUpdate(new Date());
              setError(null);

              // Log ticker counts for debugging
              const tickersWithData = Object.keys(mergedData).filter((t) => {
                const d = mergedData[t];
                return (
                  d && d.htf_score !== undefined && d.ltf_score !== undefined
                );
              });
              // Log detailed breakdown
              const tickersByVersion = {};
              const tickersWithoutScores = [];
              Object.keys(mergedData).forEach((t) => {
                const d = mergedData[t];
                if (d) {
                  const version = d.script_version || "unknown";
                  if (!tickersByVersion[version]) {
                    tickersByVersion[version] = [];
                  }
                  tickersByVersion[version].push(t);
                  
                  if (d.htf_score === undefined && d.ltf_score === undefined) {
                    tickersWithoutScores.push({ ticker: t, version: version, hasPrice: !!d.price });
                  }
                }
              });
              
              console.log(
                `[UI] Loaded ${tickersWithData.length} tickers with scores, ${allTickers.length} total in index`
              );
              console.log(`[UI] Tickers by version:`, tickersByVersion);
              if (tickersWithoutScores.length > 0) {
                console.warn(`[UI] âš ï¸ ${tickersWithoutScores.length} tickers without scores:`, tickersWithoutScores.slice(0, 10));
              }
              
              if (versionFiltered > 0) {
                console.warn(
                  `[UI] âš ï¸ ${versionFiltered} tickers filtered out due to version mismatch.`,
                  {
                    storedVersion: dataVersion,
                    currentDataVersion: currentDataVersion,
                    versionsSeen: versionsSeen,
                    acceptedVersions: acceptedVersions,
                    versionBreakdown: versionBreakdown
                  }
                );
              }
              
              // Log sample tickers to see what we're getting
              const sampleTickers = Object.keys(tickerData).slice(0, 10);
              console.log(`[UI] Sample tickers:`, sampleTickers.map(t => ({
                ticker: t,
                version: tickerData[t]?.script_version || "unknown",
                hasScores: !!(tickerData[t]?.htf_score !== undefined && tickerData[t]?.ltf_score !== undefined),
                htf_score: tickerData[t]?.htf_score,
                ltf_score: tickerData[t]?.ltf_score
              })));
            } else {
              setError(
                `API Error: ${dataJson.error || "Failed to fetch data"}`
              );
            }
          } catch (e) {
            if (e.name === "AbortError") {
              setError("Request timeout - please try again");
            } else if (
              e.message.includes("Failed to fetch") ||
              e.message.includes("Load failed")
            ) {
              setError(
                "Network error - check console for details. API may be temporarily unavailable."
              );
            } else {
              setError(e.message);
            }
            console.error("Fetch error:", e);
            console.error("Error details:", {
              name: e.name,
              message: e.message,
              stack: e.stack,
            });
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchData();
          const interval = setInterval(fetchData, 180000); // 3 minutes auto-refresh
          return () => clearInterval(interval);
        }, [fetchData]);

        return { data, loading, error, lastUpdate, versionInfo, refetch: fetchData };
      }

      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = useState(value);

        useEffect(() => {
          const handler = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);

          return () => {
            clearTimeout(handler);
          };
        }, [value, delay]);

        return debouncedValue;
      }

      function useTrades() {
        const [trades, setTrades] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchTrades = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/trades`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.trades)) {
              setTrades(json.trades);
            } else {
              setTrades([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch trades:", err);
            setTrades([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchTrades();
          const interval = setInterval(fetchTrades, 180000); // Refresh every 3 minutes
          return () => clearInterval(interval);
        }, [fetchTrades]);

        return { trades, loading, error, refetch: fetchTrades };
      }

      // Hook to fetch sector ratings
      function useSectors() {
        const [sectors, setSectors] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        const fetchSectors = useCallback(async () => {
          try {
            setLoading(true);
            setError(null);
            const res = await fetch(`${API_BASE}/timed/sectors`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            if (json.ok && Array.isArray(json.sectors)) {
              setSectors(json.sectors);
            } else {
              setSectors([]);
            }
          } catch (err) {
            setError(err.message);
            console.error("Failed to fetch sectors:", err);
            setSectors([]);
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchSectors();
          // Refresh sectors every 5 minutes
          const interval = setInterval(fetchSectors, 300000);
          return () => clearInterval(interval);
        }, [fetchSectors]);

        return { sectors, loading, error, refetch: fetchSectors };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Groups (matching original)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const GROUPS = {
        UPTICKS: new Set([
          "TSLA",
          "STX",
          "AU",
          "CCJ",
          "CLS",
          "CRS",
          "VST",
          "FSLR",
          "JCI",
          "ORCL",
          "AMZN",
          "BRK.B",
          "BABA",
          "WMT",
          "PH",
          "GEV",
          "HII",
          "ULTA",
          "SHOP",
          "CSX",
          "PWR",
          "HOOD",
          "SPGI",
          "APP",
          "PANW",
          "RDDT",
          "TT",
          "GLXY",
          "ETHA",
        ]),
        SuperGranny: new Set(["META", "NVDA", "AMD", "ANET", "GS"]),
        GRNI: new Set([
          "VST",
          "TSLA",
          "TJX",
          "SPGI",
          "SOFI",
          "PWR",
          "PNC",
          "PLTR",
          "PANW",
          "NVDA",
          "NFLX",
          "MSTR",
          "MSFT",
          "MNST",
          "META",
          "LRCX",
          "KLAC",
          "JPM",
          "HOOD",
          "GS",
          "GOOGL",
          "GEV",
          "GE",
          "EXPE",
          "ETN",
          "EMR",
          "DE",
          "CRWD",
          "COST",
          "CDNS",
          "CAT",
          "BK",
          "AXP",
          "AXON",
          "AVGO",
          "ANET",
          "AMZN",
          "AMD",
          "AAPL",
        ]),
        GRNJ: new Set([
          "RKLB",
          "LITE",
          "SN",
          "ALB",
          "RDDT",
          "RGLD",
          "MTZ",
          "ON",
          "ALLY",
          "DY",
          "CCJ",
          "EWBC",
          "PATH",
          "WFRD",
          "WAL",
          "IESC",
          "ENS",
          "TWLO",
          "MLI",
          "KTOS",
          "MDB",
          "TLN",
          "EME",
          "AWI",
          "IBP",
          "DCI",
          "WTS",
          "FIX",
          "UTHR",
          "NBIS",
          "SGI",
          "AYI",
          "RIOT",
          "NXT",
          "SANM",
          "BWXT",
          "PEGA",
          "JOBY",
          "IONQ",
          "SOFI",
          "ITT",
          "STRL",
          "QLYS",
          "MP",
          "GLXY",
          "HIMS",
          "IOT",
          "BE",
          "NEU",
          "AVAV",
          "PSTG",
          "RBLX",
        ]),
        GRNY: new Set([
          "GEV",
          "LRCX",
          "PNC",
          "GOOGL",
          "GS",
          "META",
          "MNST",
          "KLAC",
          "TJX",
          "GE",
          "EXPE",
          "CAT",
          "BK",
          "SPGI",
          "TSLA",
          "EMR",
          "JPM",
          "AXP",
          "ANET",
          "AXON",
          "AAPL",
          "NVDA",
          "AVGO",
          "PWR",
          "CDNS",
          "DE",
          "MSFT",
          "COST",
          "VST",
          "PLTR",
          "AMZN",
          "HOOD",
          "ETN",
          "SOFI",
          "AMD",
          "PANW",
          "CRWD",
          "NFLX",
          "MSTR",
        ]),
        Social: new Set(["CSCO", "BA", "NKE", "AAPL", "PI", "APLD", "MU"]),
        SP_Sectors: new Set([
          "XLK",
          "XLF",
          "XLY",
          "XLP",
          "XLC",
          "XLI",
          "XLB",
          "XLE",
          "XLRE",
          "XLU",
          "XLV",
        ]),
        Futures: new Set(["ES1!", "NQ1!", "BTC1!", "ETHUSD", "ETHA"]),
      };

      const GROUP_LABELS = {
        SP_Sectors: "S&P Sectors",
        Futures: "Futures",
      };

      const GROUP_ORDER = [
        "SP_Sectors",
        "Futures",
        "UPTICKS",
        "SuperGranny",
        "GRNI",
        "GRNJ",
        "GRNY",
        "Social",
      ];

      function normTicker(t) {
        const s = String(t || "")
          .trim()
          .toUpperCase();
        if (s === "BRK-B") return "BRK.B";
        return s;
      }

      function groupsForTicker(t) {
        const T = normTicker(t);
        const out = [];
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) out.push(g);
        return out;
      }

      // Check if ticker is in any group
      function isTickerInGroups(t) {
        const T = normTicker(t);
        for (const [g, set] of Object.entries(GROUPS))
          if (set.has(T)) return true;
        return false;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Utils
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // Phase-based color (Turbo-like gradient: 0=green, 0.5=yellow, 1=red)
      // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
      function phaseCompletionToColor(phasePct) {
        const p = Math.max(0, Math.min(1, phasePct));
        if (p < 0.3) {
          // Green: #2ecc71 (under 30%)
          return "#2ecc71";
        } else if (p < 0.6) {
          // Yellow: #f39c12 (30-60%)
          return "#f39c12";
        } else {
          // Red: #e74c3c (60-100%)
          return "#e74c3c";
        }
      }

      function phaseToColor(phase) {
        const p = Math.max(0, Math.min(1, phase));
        if (p < 0.2) {
          // Green to light green: #2ecc71 to #27ae60
          const t = p / 0.2;
          return `rgb(${Math.round(46 + (39 - 46) * t)}, ${Math.round(
            204 + (174 - 204) * t
          )}, ${Math.round(113 + (96 - 113) * t)})`;
        } else if (p < 0.4) {
          // Light green to yellow: #27ae60 to #f39c12
          const t = (p - 0.2) / 0.2;
          return `rgb(${Math.round(39 + (243 - 39) * t)}, ${Math.round(
            174 + (156 - 174) * t
          )}, ${Math.round(96 + (18 - 96) * t)})`;
        } else if (p < 0.6) {
          // Yellow to orange: #f39c12 to #e67e22
          const t = (p - 0.4) / 0.2;
          return `rgb(${Math.round(243 + (230 - 243) * t)}, ${Math.round(
            156 + (126 - 156) * t
          )}, ${Math.round(18 + (34 - 18) * t)})`;
        } else if (p < 0.8) {
          // Orange to red: #e67e22 to #e74c3c
          const t = (p - 0.6) / 0.2;
          return `rgb(${Math.round(230 + (231 - 230) * t)}, ${Math.round(
            126 + (76 - 126) * t
          )}, ${Math.round(34 + (60 - 34) * t)})`;
        } else {
          // Red to dark red: #e74c3c to #c0392b
          const t = (p - 0.8) / 0.2;
          return `rgb(${Math.round(231 + (192 - 231) * t)}, ${Math.round(
            76 + (57 - 76) * t
          )}, ${Math.round(60 + (43 - 60) * t)})`;
        }
      }

      function isPrimeBubble(ticker) {
        const rank = Number(ticker.rank || 0);
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;
        const comp = ticker.completion != null ? Number(ticker.completion) : 1;
        const phase = ticker.phase_pct != null ? Number(ticker.phase_pct) : 1;
        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const phaseZoneChange = !!flags.phase_zone_change;
        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";

        return (
          rank >= 75 &&
          rr >= 1.5 &&
          comp < 0.4 &&
          phase < 0.6 &&
          (aligned || sqRel || phaseZoneChange)
        );
      }

      function entryType(ticker) {
        const h = Number(ticker.htf_score);
        const l = Number(ticker.ltf_score);
        if (!Number.isFinite(h) || !Number.isFinite(l)) {
          return { corridor: false, side: null };
        }
        if (h > 0 && l >= LONG_CORRIDOR.ltfMin && l <= LONG_CORRIDOR.ltfMax) {
          return { corridor: true, side: "LONG" };
        }
        if (h < 0 && l >= SHORT_CORRIDOR.ltfMin && l <= SHORT_CORRIDOR.ltfMax) {
          return { corridor: true, side: "SHORT" };
        }
        return { corridor: false, side: null };
      }

      function completionForSize(ticker) {
        // Use the completion value from Pine Script payload directly
        // Pine Script calculates: completion = abs(close - triggerPrice) / expectedMove
        // This is more accurate than recalculating from trigger to TP because:
        // 1. It accounts for expectedMove (which may differ from TP distance)
        // 2. It handles direction correctly
        // 3. It works even when price hasn't reached trigger yet
        const c = Number(ticker.completion);
        return Number.isFinite(c) ? Math.max(0, Math.min(1, c)) : 0;
      }

      // Calculate score breakdown (mirrors worker computeRank logic)
      function calculateScoreBreakdown(ticker) {
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = Number(ticker.completion) || 0;
        const phase = Number(ticker.phase_pct) || 0;
        const rr = ticker.rr != null ? Number(ticker.rr) : 0;

        const flags = ticker.flags || {};
        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const momentumElite = !!flags.momentum_elite;

        const state = String(ticker.state || "");
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const setup =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";

        const breakdown = {
          base: 30,
          aligned: aligned ? 12 : 0,
          setup: setup ? 4 : 0,
          htf: 0,
          ltf: 0,
          completion: 0,
          phase: 0,
          squeezeRelease: sqRel ? 12 : 0,
          squeezeOn: sqOn && !sqRel ? 4 : 0,
          phaseZoneChange: phaseZoneChange ? 2 : 0,
          rr: 0,
          momentumElite: momentumElite ? 15 : 0,
        };

        // HTF contribution
        if (Number.isFinite(htf)) {
          const htfAbs = Math.abs(htf);
          if (htfAbs >= 25) breakdown.htf = Math.min(10, htfAbs * 0.4);
          else if (htfAbs >= 15) breakdown.htf = Math.min(7, htfAbs * 0.35);
          else breakdown.htf = Math.min(4, htfAbs * 0.25);
        }

        // LTF contribution
        if (Number.isFinite(ltf)) {
          const ltfAbs = Math.abs(ltf);
          if (ltfAbs >= 20) breakdown.ltf = Math.min(10, ltfAbs * 0.3);
          else if (ltfAbs >= 12) breakdown.ltf = Math.min(6, ltfAbs * 0.25);
          else breakdown.ltf = Math.min(3, ltfAbs * 0.2);
        }

        // Completion bonus
        if (Number.isFinite(comp)) {
          if (comp <= 0.2) breakdown.completion = 15;
          else if (comp <= 0.4) breakdown.completion = 10;
          else if (comp <= 0.6) breakdown.completion = 5;
        }

        // Phase penalty/bonus
        if (Number.isFinite(phase)) {
          if (phase > 0.5) breakdown.phase = -Math.max(0, (phase - 0.5) * 30);
          if (phase <= 0.3) breakdown.phase = 3;
        }

        // RR contribution
        if (Number.isFinite(rr)) {
          if (rr >= 2.0) breakdown.rr = 10;
          else if (rr >= 1.5) breakdown.rr = 7;
          else if (rr >= 1.2) breakdown.rr = 4;
        }

        breakdown.total = Math.max(
          0,
          Math.min(
            100,
            breakdown.base +
              breakdown.aligned +
              breakdown.setup +
              breakdown.htf +
              breakdown.ltf +
              breakdown.completion +
              breakdown.phase +
              breakdown.squeezeRelease +
              breakdown.squeezeOn +
              breakdown.phaseZoneChange +
              breakdown.rr +
              breakdown.momentumElite
          )
        );

        return breakdown;
      }

      // Dynamic ranking that considers real-time conditions
      function computeDynamicRank(ticker) {
        const baseRank = Number(ticker.rank) || 50;
        const htf = Number(ticker.htf_score) || 0;
        const ltf = Number(ticker.ltf_score) || 0;
        const comp = completionForSize(ticker);
        const phase = Number(ticker.phase_pct) || 0;
        const rr = Number(ticker.rr) || 0;
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        const sqRel = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;
        const phaseZoneChange = !!flags.phase_zone_change;
        const aligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const ent = entryType(ticker);
        const inCorridor = ent.corridor;

        let dynamicScore = baseRank;

        // Corridor bonus (high priority - active setups)
        if (inCorridor) {
          dynamicScore += 12; // Strong bonus for being in corridor

          // Extra bonus if aligned AND in corridor (perfect setup)
          if (aligned) {
            dynamicScore += 8;
          }
        }

        // Squeeze release in corridor = very strong signal
        if (sqRel && inCorridor) {
          dynamicScore += 10;
        }

        // Squeeze on in corridor = building pressure
        if (sqOn && inCorridor && !sqRel) {
          dynamicScore += 5;
        }

        // RR bonus (scaled - better RR = higher rank)
        if (rr >= 2.0) {
          dynamicScore += 8; // Excellent RR
        } else if (rr >= 1.5) {
          dynamicScore += 5; // Good RR
        } else if (rr >= 1.0) {
          dynamicScore += 2; // Acceptable RR
        }

        // Phase bonus (early phase = better opportunity)
        if (phase < 0.3) {
          dynamicScore += 6; // Very early
        } else if (phase < 0.5) {
          dynamicScore += 3; // Early
        } else if (phase > 0.7) {
          dynamicScore -= 5; // Late phase penalty
        }

        // Completion bonus (low completion = more room to run)
        if (comp < 0.3) {
          dynamicScore += 5; // Early in move
        } else if (comp > 0.8) {
          dynamicScore -= 8; // Near completion penalty
        }

        // Score strength bonus (strong HTF/LTF scores)
        const htfStrength = Math.min(8, Math.abs(htf) * 0.15);
        const ltfStrength = Math.min(6, Math.abs(ltf) * 0.12);
        dynamicScore += htfStrength + ltfStrength;

        // Phase zone change bonus
        if (phaseZoneChange) {
          dynamicScore += 4;
        }

        // Clamp to 0-100 range
        dynamicScore = Math.max(0, Math.min(100, dynamicScore));

        return Math.round(dynamicScore);
      }

      // Parse natural language query into filter conditions
      function parseNaturalLanguageQuery(query) {
        if (!query || typeof query !== "string") return null;

        const queryLower = query.toLowerCase().trim();
        const conditions = {};

        // Multi-ticker search: "AAPL, GOOGL, TSLA"
        if (
          query.includes(",") &&
          !query.match(
            /rank|rr|risk|reward|phase|completion|moved|points|prime|squeeze|corridor|momentum|top|long|short|setup/
          )
        ) {
          return {
            type: "multi-ticker",
            tickers: query.split(",").map((t) => t.trim().toUpperCase()),
          };
        }

        // Top 40 filter
        if (queryLower.match(/\btop\s*40\b|\btop40\b/)) {
          conditions.top40 = true;
        }

        // Top Long Setup
        if (queryLower.match(/\btop\s*long\s*setup\b|\btop\s*long\b/)) {
          conditions.topLongSetup = true;
        }

        // Top Short Setup
        if (queryLower.match(/\btop\s*short\s*setup\b|\btop\s*short\b/)) {
          conditions.topShortSetup = true;
        }

        // Prime setup
        if (queryLower.match(/\bprime\b|\bprime setup\b/)) {
          conditions.prime = true;
        }

        // Momentum Elite
        if (queryLower.match(/\bmomentum elite\b|\belite\b/)) {
          conditions.momentumElite = true;
        }

        // In corridor
        if (queryLower.match(/\bin corridor\b|\bcorridor\b/)) {
          conditions.inCorridor = true;
        }

        // Squeeze release
        if (queryLower.match(/\bsqueeze release\b|\bsqueeze released\b/)) {
          conditions.squeezeRelease = true;
        }

        // Helper function to extract numeric value with various operators
        const extractNumericCondition = (
          pattern,
          fieldName,
          isPercentage = false
        ) => {
          // Match operators: >, >=, <, <=, above, below, over, under, greater than, less than, at least, at most
          const operators = {
            ">": "min",
            ">=": "min",
            above: "min",
            over: "min",
            "greater than": "min",
            "at least": "min",
            "<": "max",
            "<=": "max",
            below: "max",
            under: "max",
            "less than": "max",
            "at most": "max",
          };

          for (const [op, type] of Object.entries(operators)) {
            const regex = new RegExp(
              `\\b${pattern}\\s*(?:${op.replace(
                /[.*+?^${}()|[\]\\]/g,
                "\\$&"
              )})\\s*([\\d.]+)\\s*%?`,
              "i"
            );
            const match = queryLower.match(regex);
            if (match) {
              const value = isPercentage
                ? parseFloat(match[1]) / 100
                : parseFloat(match[1]);
              return { type, value };
            }
          }
          return null;
        };

        // Rank conditions: "rank > 75", "rank above 75", "rank over 75", "rank below 50", "rank under 50"
        const rankCondition = extractNumericCondition("rank", "rank");
        if (rankCondition) {
          if (rankCondition.type === "min") {
            conditions.minRank = rankCondition.value;
          } else {
            // For max rank, we'd need a maxRank filter - skip for now
          }
        }

        // RR/Risk-Reward conditions: "RR > 2", "risk reward over 2", "RR above 1.5"
        const rrCondition = extractNumericCondition(
          "(?:rr|risk[\\s-]?reward)",
          "rr"
        );
        if (rrCondition && rrCondition.type === "min") {
          conditions.minRR = rrCondition.value;
        }

        // Phase conditions: "phase > 50%", "phase over 50%", "phase above 50", "phase under 30%"
        const phaseMinCondition = extractNumericCondition(
          "phase",
          "phase",
          true
        );
        if (phaseMinCondition && phaseMinCondition.type === "min") {
          conditions.minPhase = phaseMinCondition.value;
        }
        const phaseMaxCondition = extractNumericCondition(
          "phase",
          "phase",
          true
        );
        if (phaseMaxCondition && phaseMaxCondition.type === "max") {
          conditions.maxPhase = phaseMaxCondition.value;
        }

        // Completion conditions: "completion < 30%", "completion under 30%", "completion below 50%"
        const compCondition = extractNumericCondition(
          "completion",
          "completion",
          true
        );
        if (compCondition && compCondition.type === "max") {
          conditions.maxCompletion = compCondition.value;
        }

        // Price change: "moved 5 points", "moved $5", "price change > 5", "price change over 5"
        const priceChangeMatch = queryLower.match(
          /\b(?:moved|price\s*change)\s+(?:over|above|greater\s*than|>|>=|at\s*least)\s*(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/
        );
        if (priceChangeMatch) {
          conditions.minPriceChange = parseFloat(priceChangeMatch[1]);
        } else {
          // Also support "moved 5 points" without operator
          const simplePriceChangeMatch = queryLower.match(
            /\bmoved\s+(\d+(?:\.\d+)?)\s*(?:points?|\$|dollars?)?/
          );
          if (simplePriceChangeMatch) {
            conditions.minPriceChange = parseFloat(simplePriceChangeMatch[1]);
          }
        }

        // If we found any conditions, return them
        if (Object.keys(conditions).length > 0) {
          return { type: "query", conditions };
        }

        return null;
      }

      function applyFilters(dataObj, filters, trades = []) {
        const out = [];

        // Create a set of tickers that have trades (normalize ticker names)
        const tickersWithTrades = new Set();
        if (Array.isArray(trades)) {
          trades.forEach((trade) => {
            if (trade && trade.ticker) {
              tickersWithTrades.add(normTicker(trade.ticker));
            }
          });
        }

        // Parse natural language query if search field looks like a query
        const queryResult = parseNaturalLanguageQuery(filters.search);
        let effectiveFilters = { ...filters };
        let multiTickerList = null;

        if (queryResult) {
          if (queryResult.type === "multi-ticker") {
            multiTickerList = queryResult.tickers;
            // Clear search filter since we're handling it manually
            effectiveFilters = { ...effectiveFilters, search: "" };
          } else if (queryResult.type === "query") {
            // Merge query conditions into filters
            effectiveFilters = {
              ...effectiveFilters,
              ...queryResult.conditions,
              search: "",
            };
          }
        }

        for (const [tickerRaw, d] of Object.entries(dataObj)) {
          // Skip completely empty entries, but allow entries with just ticker name
          if (!d || typeof d !== "object") continue;
          const ticker = String(tickerRaw || d.ticker || "")
            .trim()
            .toUpperCase();
          if (!ticker) continue;

          // Only show tickers that are in at least one group OR are S&P Sectors or Futures
          // S&P Sectors and Futures should always be visible
          const isSPSector =
            GROUPS.SP_Sectors && GROUPS.SP_Sectors.has(normTicker(ticker));
          const isFuture =
            GROUPS.Futures && GROUPS.Futures.has(normTicker(ticker));
          const inGroups = isTickerInGroups(ticker);
          
          // Debug: Log tickers being filtered out
          if (!isSPSector && !isFuture && !inGroups) {
            console.log(`[FILTER] ${ticker} skipped: not in any group`);
            continue;
          }

          // Skip tickers that don't have scores (can't render without position data)
          // These will appear once they receive data from TradingView
          if (d.htf_score === undefined && d.ltf_score === undefined) {
            console.log(`[FILTER] ${ticker} skipped: missing htf_score and ltf_score`, {
              hasHtf: d.htf_score !== undefined,
              hasLtf: d.ltf_score !== undefined,
              scriptVersion: d.script_version,
              hasPrice: d.price !== undefined
            });
            continue;
          }

          // Multi-ticker search
          if (multiTickerList && multiTickerList.length > 0) {
            if (!multiTickerList.includes(ticker)) continue;
          } else if (
            effectiveFilters.search &&
            !ticker.includes(effectiveFilters.search.toUpperCase())
          ) {
            // Regular search (if not multi-ticker)
            continue;
          }

          // Group filter
          if (effectiveFilters.group && effectiveFilters.group !== "ALL") {
            const T = normTicker(ticker);
            const gs = groupsForTicker(T);
            if (effectiveFilters.group === "ANY") {
              if (gs.length === 0) continue;
            } else if (effectiveFilters.group === "UNGROUPED") {
              if (gs.length > 0) continue;
            } else {
              if (!gs.includes(effectiveFilters.group)) continue;
            }
          }

          // Handle Top Long Setup and Top Short Setup from natural language
          if (effectiveFilters.topLongSetup === true) {
            if (d.state !== "HTF_BULL_LTF_PULLBACK") continue;
          }
          if (effectiveFilters.topShortSetup === true) {
            if (d.state !== "HTF_BEAR_LTF_PULLBACK") continue;
          }

          if (
            effectiveFilters.quadrants &&
            !effectiveFilters.quadrants.includes(d.state)
          )
            continue;
          if (
            effectiveFilters.minRank &&
            (Number(d.rank) || 0) < effectiveFilters.minRank
          )
            continue;
          if (
            effectiveFilters.minRR &&
            (Number(d.rr) || 0) < effectiveFilters.minRR
          )
            continue;
          if (
            effectiveFilters.maxCompletion &&
            completionForSize(d) > effectiveFilters.maxCompletion
          )
            continue;
          if (effectiveFilters.inCorridor === true) {
            const ent = entryType(d);
            if (!ent.corridor) continue;
          }
          if (effectiveFilters.squeezeRelease === true) {
            const flags = d.flags || {};
            if (!flags.sq30_release) continue;
          }
          if (effectiveFilters.momentumElite === true) {
            const flags = d.flags || {};
            if (!flags.momentum_elite) continue;
          }
          if (effectiveFilters.prime === true) {
            if (!isPrimeBubble(d)) continue;
          }
          if (effectiveFilters.minPriceChange !== undefined) {
            // Calculate price change from trigger price to current price
            const currentPrice = Number(d.price) || 0;
            const triggerPrice = Number(d.trigger_price) || 0;
            if (triggerPrice > 0) {
              const priceChange = Math.abs(currentPrice - triggerPrice);
              if (priceChange < effectiveFilters.minPriceChange) continue;
            } else {
              // No trigger price, skip this filter
              continue;
            }
          }
          if (effectiveFilters.minPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase < effectiveFilters.minPhase) continue;
          }
          if (effectiveFilters.maxPhase !== undefined) {
            const phase = Number(d.phase_pct) || 0;
            if (phase > effectiveFilters.maxPhase) continue;
          }

          // Trades filter - only show tickers that have trades
          if (effectiveFilters.hasTrades === true) {
            if (!tickersWithTrades.has(normTicker(ticker))) continue;
          }

          // Sector filter - only show tickers in the selected sector
          if (effectiveFilters.sector) {
            // Check both top-level sector and fundamentals.sector
            const tickerSector = d.sector || d.fundamentals?.sector || "";
            if (tickerSector !== effectiveFilters.sector) continue;
          }

          out.push({ ticker, ...d });
        }

        // Apply Top 40 filter if active (after computing dynamic ranks)
        if (effectiveFilters.top40 === true) {
          const withRanks = out.map((t) => ({
            ...t,
            dynamicRank: computeDynamicRank(t),
          }));
          withRanks.sort((a, b) => b.dynamicRank - a.dynamicRank);
          return withRanks.slice(0, 40);
        }

        return out;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Components
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Native SVG Bubble component (works without Recharts)
      const SVGBubble = memo(
        ({
          ticker,
          onClick,
          onHover,
          isHovered,
          scaleX,
          scaleY,
          offsetX,
          offsetY,
          showLabels,
        }) => {
          const comp = Number(ticker.completion) || 0;
          const phasePct = Number(ticker.phase_pct) || 0;
          const rr = Number(ticker.rr) || 0;

          // Bubble size based on RR, adjusted for completion (lower completion = larger size)
          // RR is the opportunity, but we want to reduce size as completion increases
          // Formula: baseSize + (RR * multiplier) * (1 - completion)
          // This makes high RR + low completion = largest bubbles
          // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
          // Normalized to show more tickers - reduced multiplier significantly
          const cappedRR = Math.min(rr, 5); // Cap RR at 5 for size calculation
          const completionPenalty = 1 - comp; // 1.0 when completion is 0, 0.0 when completion is 1
          const baseSize = 4; // Reduced from 8
          const rrMultiplier = 2; // Reduced from 6 - much smaller bubbles
          const size = baseSize + cappedRR * rrMultiplier * completionPenalty;

          const prime = isPrimeBubble(ticker);
          const flags = ticker.flags || {};
          const ent = entryType(ticker);

          // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
          const color = phaseCompletionToColor(phasePct);
          const opacity = isHovered ? 1 : prime ? 0.9 : 0.7;
          const borderWidth = prime
            ? 3
            : flags.sq30_release
            ? 2
            : flags.sq30_on
            ? 2
            : 1;
          const borderColor = prime
            ? "#2ecc71"
            : flags.sq30_release
            ? "#00ffff"
            : flags.sq30_on
            ? "#ffd700"
            : "#ffffff";

          const bubbleSize = isHovered ? size * 1.2 : size;

          const x = (Number(ticker.ltf_score) || 0) * scaleX + offsetX;
          const y = (Number(ticker.htf_score) || 0) * scaleY + offsetY;

          // Determine emoji and label position
          const hasSqueeze = flags.sq30_release || flags.sq30_on;
          const emoji = prime
            ? "â­"
            : flags.sq30_release
            ? "âš¡"
            : flags.sq30_on
            ? "ðŸ§¨"
            : "";
          const labelY = y - bubbleSize - (emoji ? 12 : 8);

          return (
            <g
              onClick={() => onClick(ticker.ticker)}
              onMouseEnter={() => onHover(ticker.ticker)}
              onMouseLeave={() => onHover(null)}
              style={{ cursor: "pointer", transition: "all 0.2s ease-out" }}
            >
              {/* Glow effect for prime */}
              {prime && (
                <circle
                  cx={x}
                  cy={y}
                  r={bubbleSize + 2}
                  fill="none"
                  stroke="#2ecc71"
                  strokeWidth="1"
                  opacity="0.3"
                />
              )}
              <circle
                cx={x}
                cy={y}
                r={bubbleSize}
                fill={color}
                fillOpacity={opacity}
                stroke={borderColor}
                strokeWidth={borderWidth}
                style={{ transition: "all 0.2s ease-out" }}
              />
              {/* Emoji above bubble */}
              {emoji && (
                <text
                  x={x}
                  y={labelY}
                  textAnchor="middle"
                  fontSize={prime ? "14" : "12"}
                  fill={
                    prime
                      ? "#2ecc71"
                      : flags.sq30_release
                      ? "#00ffff"
                      : "#ffd700"
                  }
                  fontWeight="bold"
                  style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
                >
                  {emoji}
                </text>
              )}
              {/* Ticker label */}
              {(showLabels || isHovered) && (
                <text
                  x={x}
                  y={labelY - (emoji ? 14 : 8)}
                  textAnchor="middle"
                  fontSize="10"
                  fill="#e7ecff"
                  fontWeight="600"
                  style={{
                    textShadow: "0 0 4px rgba(0,0,0,0.9)",
                    pointerEvents: "none",
                  }}
                >
                  {ticker.ticker}
                </text>
              )}
            </g>
          );
        }
      );

      const Bubble = memo(
        ({ ticker, onClick, onHover, isHovered, showLabels }) => {
          const comp = Number(ticker.completion) || 0;
          const phasePct = Number(ticker.phase_pct) || 0;
          const rr = Number(ticker.rr) || 0;

          // Bubble size based on RR, adjusted for completion (lower completion = larger size)
          // CAP: Any RR over 5 should max out at size for RR=5 (relative to list, not absolute)
          const cappedRR = Math.min(rr, 5); // Cap RR at 5 for size calculation
          const completionPenalty = 1 - comp; // 1.0 when completion is 0, 0.0 when completion is 1
          const baseSize = 8;
          const rrMultiplier = 6; // Scale factor for RR
          const size = baseSize + cappedRR * rrMultiplier * completionPenalty;

          const prime = isPrimeBubble(ticker);
          const flags = ticker.flags || {};

          // Phase Completion color (Green < 30%, Yellow 30-60%, Red 60-100%)
          const color = phaseCompletionToColor(phasePct);
          const opacity = isHovered ? 1 : prime ? 0.9 : 0.7;
          const borderWidth = prime
            ? 3
            : flags.sq30_release
            ? 2
            : flags.sq30_on
            ? 2
            : 1;
          const borderColor = prime
            ? "#2ecc71"
            : flags.sq30_release
            ? "#00ffff"
            : flags.sq30_on
            ? "#ffd700"
            : "#ffffff";

          const bubbleSize = isHovered ? size * 1.2 : size;
          const x = Number(ticker.ltf_score) || 0;
          const y = Number(ticker.htf_score) || 0;

          // Determine emoji and label position
          const hasSqueeze = flags.sq30_release || flags.sq30_on;
          const emoji = prime
            ? "â­"
            : flags.sq30_release
            ? "âš¡"
            : flags.sq30_on
            ? "ðŸ§¨"
            : "";
          const labelY = y - bubbleSize - (emoji ? 12 : 8);

          return (
            <g
              onClick={() => onClick(ticker.ticker)}
              onMouseEnter={() => onHover(ticker.ticker)}
              onMouseLeave={() => onHover(null)}
              style={{ cursor: "pointer", transition: "all 0.2s ease-out" }}
            >
              {/* Glow effect for prime */}
              {prime && (
                <circle
                  cx={x}
                  cy={y}
                  r={bubbleSize + 2}
                  fill="none"
                  stroke="#2ecc71"
                  strokeWidth="1"
                  opacity="0.3"
                />
              )}
              <circle
                cx={x}
                cy={y}
                r={bubbleSize}
                fill={color}
                fillOpacity={opacity}
                stroke={borderColor}
                strokeWidth={borderWidth}
                style={{ transition: "all 0.2s ease-out" }}
              />
              {/* Emoji above bubble */}
              {emoji && (
                <text
                  x={x}
                  y={labelY}
                  textAnchor="middle"
                  fontSize={prime ? "14" : "12"}
                  fill={
                    prime
                      ? "#2ecc71"
                      : flags.sq30_release
                      ? "#00ffff"
                      : "#ffd700"
                  }
                  fontWeight="bold"
                  style={{ textShadow: "0 0 3px rgba(0,0,0,0.8)" }}
                >
                  {emoji}
                </text>
              )}
              {/* Ticker label */}
              {(showLabels || isHovered) && (
                <text
                  x={x}
                  y={labelY - (emoji ? 14 : 8)}
                  textAnchor="middle"
                  fontSize="10"
                  fill="#e7ecff"
                  fontWeight="600"
                  style={{
                    textShadow: "0 0 4px rgba(0,0,0,0.9)",
                    pointerEvents: "none",
                  }}
                >
                  {ticker.ticker}
                </text>
              )}
            </g>
          );
        }
      );

      function BubbleChart({
        tickers,
        onBubbleClick,
        hoveredTicker,
        onHover,
        selectedTicker,
        selectedTrail,
        allData,
      }) {
        const [tooltip, setTooltip] = useState(null);
        const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
        const [showLabels, setShowLabels] = useState(true);
        const containerRef = React.useRef(null);
        const [dimensions, setDimensions] = React.useState({
          width: 1600,
          height: 1000,
        });

        // Update dimensions on mount and resize to use full container space
        React.useEffect(() => {
          const updateDimensions = () => {
            if (containerRef.current) {
              const rect = containerRef.current.getBoundingClientRect();
              // Use actual container size, with minimums
              setDimensions({
                width: Math.max(rect.width - 16, 1200), // Account for padding
                height: Math.max(rect.height - 16, 800),
              });
            }
          };
          // Initial update
          const timeoutId = setTimeout(updateDimensions, 100);
          window.addEventListener("resize", updateDimensions);
          return () => {
            clearTimeout(timeoutId);
            window.removeEventListener("resize", updateDimensions);
          };
        }, []);

        // Fallback: Native SVG chart (works without Recharts)
        if (!RechartsComponents) {
          const chartWidth = dimensions.width;
          const chartHeight = dimensions.height;
          const margin = 50; // Reduced margin for more plot space
          const plotWidth = chartWidth - 2 * margin;
          const plotHeight = chartHeight - 2 * margin;

          // More precise scaling for better granularity
          const scaleX = plotWidth / 100; // -50 to 50 range
          const scaleY = plotHeight / 100;
          const offsetX = margin;
          const offsetY = margin;

          const handleMouseMove = (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            setTooltipPos({
              x: e.clientX - rect.left,
              y: e.clientY - rect.top,
            });
          };

          return (
            <div
              ref={containerRef}
              className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-2 relative"
            >
              {/* Label toggle */}
              <div className="absolute top-2 right-2 z-10">
                <button
                  onClick={() => setShowLabels(!showLabels)}
                  className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f] text-xs text-[#93a4d6] hover:bg-[#1a2550] transition-colors"
                >
                  {showLabels ? "Hide Labels" : "Show Labels"}
                </button>
              </div>
              <svg
                width="100%"
                height="100%"
                viewBox={`0 0 ${chartWidth} ${chartHeight}`}
                preserveAspectRatio="xMidYMid meet"
                onMouseMove={handleMouseMove}
                onMouseLeave={() => setTooltip(null)}
                className="w-full h-full"
              >
                {/* Grid with better styling */}
                <defs>
                  <pattern
                    id="grid"
                    width="50"
                    height="50"
                    patternUnits="userSpaceOnUse"
                  >
                    <path
                      d="M 50 0 L 0 0 0 50"
                      fill="none"
                      stroke="#26325f"
                      strokeWidth="0.5"
                      opacity="0.5"
                    />
                  </pattern>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                      <feMergeNode in="coloredBlur" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />

                {/* Axes - Much more visible - Both center lines same style */}
                {/* Vertical center line (x=0) */}
                <line
                  x1={offsetX + 50 * scaleX}
                  y1={offsetY}
                  x2={offsetX + 50 * scaleX}
                  y2={offsetY + plotHeight}
                  stroke="#e7ecff"
                  strokeWidth="3"
                  opacity="0.9"
                />
                <line
                  x1={offsetX + 50 * scaleX}
                  y1={offsetY}
                  x2={offsetX + 50 * scaleX}
                  y2={offsetY + plotHeight}
                  stroke="#ffffff"
                  strokeWidth="1"
                  opacity="0.5"
                />
                {/* Horizontal center line (y=0) */}
                <line
                  x1={offsetX}
                  y1={offsetY + plotHeight / 2}
                  x2={offsetX + plotWidth}
                  y2={offsetY + plotHeight / 2}
                  stroke="#e7ecff"
                  strokeWidth="3"
                  opacity="0.9"
                />
                <line
                  x1={offsetX}
                  y1={offsetY + plotHeight / 2}
                  x2={offsetX + plotWidth}
                  y2={offsetY + plotHeight / 2}
                  stroke="#ffffff"
                  strokeWidth="1"
                  opacity="0.5"
                />
                {/* Vertical axis line (y-axis) */}
                <line
                  x1={offsetX}
                  y1={offsetY}
                  x2={offsetX}
                  y2={offsetY + plotHeight}
                  stroke="#93a4d6"
                  strokeWidth="2"
                  opacity="0.6"
                />

                {/* Axis labels */}
                <text
                  x={offsetX - 50}
                  y={offsetY + plotHeight / 2}
                  fill="#93a4d6"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                  transform={`rotate(-90 ${offsetX - 50} ${
                    offsetY + plotHeight / 2
                  })`}
                >
                  HTF Score
                </text>
                <text
                  x={offsetX + plotWidth / 2}
                  y={offsetY + plotHeight + 40}
                  fill="#93a4d6"
                  textAnchor="middle"
                  fontSize="13"
                  fontWeight="600"
                >
                  LTF Score
                </text>

                {/* Axis scale markers */}
                {[-50, -25, 0, 25, 50].map((val) => {
                  const x = offsetX + (val + 50) * scaleX;
                  const y = offsetY + plotHeight / 2;
                  return (
                    <g key={`x-${val}`}>
                      <line
                        x1={x}
                        y1={y - 5}
                        x2={x}
                        y2={y + 5}
                        stroke="#93a4d6"
                        strokeWidth="2"
                      />
                      <text
                        x={x}
                        y={y + 20}
                        fill="#93a4d6"
                        textAnchor="middle"
                        fontSize="10"
                      >
                        {val}
                      </text>
                    </g>
                  );
                })}
                {[-50, -25, 0, 25, 50].map((val) => {
                  const x = offsetX;
                  const y = offsetY + plotHeight - (val + 50) * scaleY;
                  return (
                    <g key={`y-${val}`}>
                      <line
                        x1={x - 5}
                        y1={y}
                        x2={x + 5}
                        y2={y}
                        stroke="#93a4d6"
                        strokeWidth="2"
                      />
                      <text
                        x={x - 15}
                        y={y + 4}
                        fill="#93a4d6"
                        textAnchor="end"
                        fontSize="10"
                      >
                        {val}
                      </text>
                    </g>
                  );
                })}

                {/* Quadrant labels - moved further from center for more bubble space */}
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + 20}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q1 Prep
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + 20}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q2 Bull
                </text>
                <text
                  x={offsetX + plotWidth * 0.12}
                  y={offsetY + plotHeight - 5}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q3 Bear
                </text>
                <text
                  x={offsetX + plotWidth * 0.88}
                  y={offsetY + plotHeight - 5}
                  fill="#93a4d6"
                  fontSize="12"
                  fontWeight="600"
                  textAnchor="middle"
                >
                  Q4 Pullback
                </text>

                {/* Corridors */}
                <rect
                  x={offsetX + (LONG_CORRIDOR.ltfMin + 50) * scaleX}
                  y={offsetY}
                  width={(LONG_CORRIDOR.ltfMax - LONG_CORRIDOR.ltfMin) * scaleX}
                  height={plotHeight / 2}
                  fill="rgba(46,204,113,0.1)"
                />
                <rect
                  x={offsetX + (SHORT_CORRIDOR.ltfMin + 50) * scaleX}
                  y={offsetY + plotHeight / 2}
                  width={
                    (SHORT_CORRIDOR.ltfMax - SHORT_CORRIDOR.ltfMin) * scaleX
                  }
                  height={plotHeight / 2}
                  fill="rgba(231,76,60,0.1)"
                />

                {/* Bubbles - Show only selected ticker with trail if selected, otherwise show all */}
                {selectedTicker && selectedTrail ? (
                  <>
                    {/* Trail path - comet effect */}
                    {selectedTrail.length > 1 &&
                      selectedTrail.map((point, idx) => {
                        if (idx === 0) return null;
                        const prevPoint = selectedTrail[idx - 1];
                        const x1 =
                          (Number(prevPoint.ltf_score) || 0) * scaleX +
                          offsetX +
                          50 * scaleX;
                        const y1 =
                          (Number(prevPoint.htf_score) || 0) * -scaleY +
                          offsetY +
                          plotHeight -
                          50 * scaleY;
                        const x2 =
                          (Number(point.ltf_score) || 0) * scaleX +
                          offsetX +
                          50 * scaleX;
                        const y2 =
                          (Number(point.htf_score) || 0) * -scaleY +
                          offsetY +
                          plotHeight -
                          50 * scaleY;
                        const opacity =
                          0.3 + (idx / selectedTrail.length) * 0.5; // Fade in from past to present
                        return (
                          <line
                            key={`trail-${idx}`}
                            x1={x1}
                            y1={y1}
                            x2={x2}
                            y2={y2}
                            stroke="#00ffff"
                            strokeWidth="2"
                            opacity={opacity}
                            className="comet-trail"
                          />
                        );
                      })}
                    {/* Trail points (smaller bubbles) - show historical positions */}
                    {selectedTrail.slice(0, -1).map((point, idx) => {
                      // Create a ticker-like object from trail point
                      const tickerData = {
                        ticker: selectedTicker,
                        htf_score: point.htf_score || 0,
                        ltf_score: point.ltf_score || 0,
                        phase_pct: point.phase_pct || 0,
                        completion: point.completion || 0,
                        flags: {},
                        state: point.state || "",
                      };
                      const x =
                        (Number(tickerData.ltf_score) || 0) * scaleX +
                        offsetX +
                        50 * scaleX;
                      const y =
                        (Number(tickerData.htf_score) || 0) * -scaleY +
                        offsetY +
                        plotHeight -
                        50 * scaleY;
                      const size = 3 + (idx / selectedTrail.length) * 4; // Smaller, growing towards present
                      const opacity = 0.3 + (idx / selectedTrail.length) * 0.4; // Fade in from past to present

                      return (
                        <circle
                          key={`trail-point-${idx}`}
                          cx={x}
                          cy={y}
                          r={size}
                          fill="#00ffff"
                          fillOpacity={opacity}
                          stroke="#00ffff"
                          strokeWidth="1"
                          strokeOpacity={opacity * 0.5}
                        />
                      );
                    })}
                    {/* Current position (larger, highlighted) */}
                    {(() => {
                      // Try to find ticker in filtered list first
                      let currentTicker = tickers.find((t) => {
                        if (!t || typeof t !== "object") return false;
                        const tTicker = String(t.ticker || "").toUpperCase();
                        return tTicker === String(selectedTicker).toUpperCase();
                      });

                      // If not in filtered list, try to get from allData (for tickers filtered out but selected)
                      if (
                        !currentTicker &&
                        allData &&
                        typeof allData === "object"
                      ) {
                        const tickerUpper =
                          String(selectedTicker).toUpperCase();
                        if (allData[tickerUpper]) {
                          currentTicker = allData[tickerUpper];
                        } else {
                          // Search through values
                          const dataArray = Object.values(allData);
                          currentTicker = dataArray.find((t) => {
                            if (!t || typeof t !== "object") return false;
                            const tTicker = String(
                              t.ticker || ""
                            ).toUpperCase();
                            return tTicker === tickerUpper;
                          });
                        }
                      }

                      // Only render if we have valid scores to position the bubble
                      if (
                        currentTicker &&
                        (currentTicker.htf_score !== undefined ||
                          currentTicker.ltf_score !== undefined)
                      ) {
                        return (
                          <SVGBubble
                            key={selectedTicker}
                            ticker={currentTicker}
                            onClick={() => {}}
                            onHover={() => {}}
                            isHovered={true}
                            scaleX={scaleX}
                            scaleY={-scaleY}
                            offsetX={offsetX + 50 * scaleX}
                            offsetY={offsetY + plotHeight - 50 * scaleY}
                            showLabels={true}
                          />
                        );
                      }
                      return null;
                    })()}
                  </>
                ) : (
                  tickers.map((ticker) => (
                    <SVGBubble
                      key={ticker.ticker}
                      ticker={ticker}
                      onClick={onBubbleClick}
                      onHover={(t) => {
                        onHover(t);
                        if (t)
                          setTooltip(tickers.find((tt) => tt.ticker === t));
                      }}
                      isHovered={hoveredTicker === ticker.ticker}
                      scaleX={scaleX}
                      scaleY={-scaleY}
                      offsetX={offsetX + 50 * scaleX}
                      offsetY={offsetY + plotHeight - 50 * scaleY}
                      showLabels={showLabels}
                    />
                  ))
                )}
              </svg>

              {/* Tooltip */}
              {tooltip && (
                <div
                  className="absolute bg-[#121a33] border-2 border-[#26325f] rounded-lg p-3 text-sm pointer-events-none z-10 shadow-xl fade-in"
                  style={{
                    left: tooltipPos.x + 10,
                    top: tooltipPos.y - 10,
                    minWidth: "200px",
                  }}
                >
                  <div className="font-bold text-base mb-2">
                    {tooltip.ticker}
                  </div>
                  {isPrimeBubble(tooltip) && (
                    <div className="mb-2 px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold text-center">
                      â­ PRIME SETUP
                    </div>
                  )}
                  <div className="space-y-1">
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Score</span>
                      <span className="font-semibold">
                        {tooltip.rank || "â€”"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">RR</span>
                      <span className="font-semibold">
                        {tooltip.rr ? Number(tooltip.rr).toFixed(2) : "â€”"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">State</span>
                      <span className="font-semibold">
                        {tooltip.state || "â€”"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Phase</span>
                      <span
                        className="font-semibold"
                        style={{
                          color: phaseToColor(Number(tooltip.phase_pct) || 0),
                        }}
                      >
                        {Math.round((Number(tooltip.phase_pct) || 0) * 100)}%
                        {tooltip.phase_zone && ` (${tooltip.phase_zone})`}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-[#93a4d6]">Completion</span>
                      <span className="font-semibold">
                        {Math.round(completionForSize(tooltip) * 100)}%
                      </span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }

        // Recharts version (if loaded)
        const {
          ScatterChart,
          Scatter,
          XAxis,
          YAxis,
          CartesianGrid,
          Tooltip,
          ResponsiveContainer,
        } = RechartsComponents;

        const data = useMemo(
          () =>
            tickers.map((t) => ({
              x: Number(t.ltf_score) || 0,
              y: Number(t.htf_score) || 0,
              ticker: t,
            })),
          [tickers]
        );

        return (
          <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] p-4">
            <ResponsiveContainer width="100%" height="100%">
              <ScatterChart
                margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#26325f" />
                <XAxis
                  type="number"
                  dataKey="x"
                  name="LTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <YAxis
                  type="number"
                  dataKey="y"
                  name="HTF Score"
                  domain={[-50, 50]}
                  stroke="#93a4d6"
                />
                <Tooltip
                  content={({ active, payload }) => {
                    if (!active || !payload?.[0]) return null;
                    const t = payload[0].payload.ticker;
                    return (
                      <div className="bg-[#121a33] border border-[#26325f] rounded p-3 text-sm">
                        <div className="font-bold">{t.ticker}</div>
                        <div>Rank: {t.rank || "â€”"}</div>
                        <div>RR: {t.rr ? Number(t.rr).toFixed(2) : "â€”"}</div>
                        <div>State: {t.state || "â€”"}</div>
                        {isPrimeBubble(t) && (
                          <div className="text-[#2ecc71]">â­ PRIME SETUP</div>
                        )}
                      </div>
                    );
                  }}
                />
                <Scatter data={data}>
                  {data.map((entry, index) => (
                    <Bubble
                      key={entry.ticker.ticker}
                      ticker={entry.ticker}
                      onClick={onBubbleClick}
                      onHover={onHover}
                      isHovered={hoveredTicker === entry.ticker.ticker}
                    />
                  ))}
                </Scatter>
              </ScatterChart>
            </ResponsiveContainer>
          </div>
        );
      }

      // Format date/time from timestamp
      function formatTriggerDateTime(ts) {
        if (!ts || typeof ts !== "number") return "â€”";
        const date = new Date(ts);
        return {
          date: date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          }),
          time: date.toLocaleTimeString("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          }),
        };
      }

      // Get "Why" reason from ticker data
      function getWhyReason(ticker) {
        const reasons = ticker.reasons || [];
        const flags = ticker.flags || {};
        const state = String(ticker.state || "");

        if (flags.sq30_release) return "Squeeze Release";
        if (flags.phase_zone_change) return "Phase Zone Change";
        if (state.includes("BULL") && state.includes("BULL"))
          return "Both Timeframes Bullish";
        if (state.includes("BEAR") && state.includes("BEAR"))
          return "Both Timeframes Bearish";
        if (reasons.length > 0) return reasons[0];
        return "Setup Active";
      }

      // Get direction from state
      function getDirection(ticker) {
        const state = String(ticker.state || "");
        if (state.includes("BULL"))
          return {
            text: "LONG",
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        if (state.includes("BEAR"))
          return { text: "SHORT", color: "text-red-400", bg: "bg-red-500/20" };
        return { text: "â€”", color: "text-[#93a4d6]", bg: "bg-[#26325f]" };
      }

      function SetupCard({ ticker, isSelected, onClick }) {
        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const momentumElite = !!flags.momentum_elite;
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const dir = getDirection(ticker);
        const why = getWhyReason(ticker);
        const triggerDT = formatTriggerDateTime(ticker.trigger_ts);
        const tpLevels = ticker.tp_levels || [];
        const comp = completionForSize(ticker);

        return (
          <div
            className={`p-1.5 rounded-lg border cursor-pointer transition-all ${
              isSelected
                ? "border-blue-500 bg-blue-500/10 shadow-lg"
                : momentumElite
                ? "border-purple-500 bg-purple-500/15 momentum-elite-glow border-2"
                : prime
                ? "border-green-500 bg-green-500/10 prime-glow"
                : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0]"
            }`}
            onClick={onClick}
          >
            {/* Header */}
            <div className="flex items-center justify-between mb-1">
              <div className="flex items-center gap-1.5">
                <span className="font-bold text-sm">{ticker.ticker}</span>
                {momentumElite && (
                  <span
                    className="text-purple-400 text-xs font-bold"
                    title="Momentum Elite"
                  >
                    ðŸš€
                  </span>
                )}
                {prime && <span className="text-green-500 text-xs">â­</span>}
                {flags.sq30_release && (
                  <span className="text-cyan-400 text-xs">âš¡</span>
                )}
                {flags.sq30_on && (
                  <span className="text-yellow-400 text-xs">ðŸ§¨</span>
                )}
              </div>
              <div className="flex items-center gap-1.5">
                {ticker.price && (
                  <span className="text-xs font-semibold text-white">
                    ${Number(ticker.price).toFixed(2)}
                  </span>
                )}
                <div
                  className={`px-1.5 py-0.5 rounded font-bold text-[10px] ${dir.bg} ${dir.color}`}
                >
                  {dir.text}
                </div>
              </div>
            </div>

            {/* Why and Action - Compact */}
            <div className="mb-1">
              <div className="text-[8px] text-[#93a4d6] mb-0.5">
                Why:{" "}
                <span className="text-white font-semibold text-[9px]">
                  {why}
                </span>
              </div>
              {(() => {
                const actionInfo = getActionDescription(ticker);
                return (
                  <div
                    className={`text-[8px] ${actionInfo.color} font-semibold`}
                  >
                    {actionInfo.action}
                  </div>
                );
              })()}
            </div>

            {/* Price, SL, TP - Compact inline */}
            <div className="grid grid-cols-3 gap-1 mb-1 text-[8px]">
              {ticker.price && (
                <div>
                  <div className="text-[8px] text-[#93a4d6]">Price</div>
                  <div className="font-semibold text-white">
                    ${Number(ticker.price).toFixed(2)}
                  </div>
                </div>
              )}
              <div>
                <div className="text-[8px] text-[#93a4d6]">SL</div>
                <div className="font-semibold text-red-400">
                  {ticker.sl ? `$${Number(ticker.sl).toFixed(2)}` : "â€”"}
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6]">TP</div>
                <div className="font-semibold text-green-400">
                  {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "â€”"}
                </div>
              </div>
            </div>

            {/* Trigger Info - Compact */}
            {ticker.trigger_price && (
              <div className="mb-1 text-[8px]">
                <span className="text-[#93a4d6]">Trigger: </span>
                <span className="text-white font-semibold">
                  ${Number(ticker.trigger_price).toFixed(2)}
                </span>
                {ticker.trigger_ts && (
                  <>
                    <span className="text-[#93a4d6] ml-1.5">@ </span>
                    <span className="text-white text-[7px]">
                      {triggerDT.date} {triggerDT.time}
                    </span>
                  </>
                )}
              </div>
            )}

            {/* Phase and Completion - Compact */}
            <div className="grid grid-cols-2 gap-1 mb-1">
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Phase</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full transition-all"
                    style={{
                      width: `${phase * 100}%`,
                      backgroundColor: phaseColor,
                    }}
                  />
                </div>
                <div
                  className="text-[9px] mt-0.5"
                  style={{ color: phaseColor }}
                >
                  {Math.round(phase * 100)}%
                </div>
              </div>
              <div>
                <div className="text-[8px] text-[#93a4d6] mb-0.5">Complete</div>
                <div className="h-1.5 bg-[#26325f] rounded-full overflow-hidden">
                  <div
                    className="h-full rounded-full bg-blue-500 transition-all"
                    style={{ width: `${comp * 100}%` }}
                  />
                </div>
                <div className="text-[9px] mt-0.5 text-blue-400">
                  {Math.round(comp * 100)}%
                </div>
              </div>
            </div>

            {/* TP Levels - Compact */}
            {tpLevels.length > 1 && (
              <div className="mb-1">
                <div className="flex flex-wrap gap-0.5">
                  {tpLevels.slice(0, 2).map((tp, idx) => (
                    <span
                      key={idx}
                      className="px-0.5 py-0 rounded bg-green-500/20 text-green-400 text-[7px] font-mono"
                    >
                      TP{idx + 1}: ${Number(tp).toFixed(2)}
                    </span>
                  ))}
                  {tpLevels.length > 2 && (
                    <span className="px-0.5 py-0 rounded bg-[#26325f] text-[#93a4d6] text-[7px]">
                      +{tpLevels.length - 2}
                    </span>
                  )}
                </div>
              </div>
            )}

            {/* Additional Info - Compact */}
            <div className="flex items-center justify-between text-[8px] pt-0.5 border-t border-[#26325f]/50">
              <div className="flex gap-1">
                <span className="px-1 py-0.5 rounded bg-[#26325f]">
                  R{ticker.rank || "â€”"}
                </span>
                {ticker.rr && (
                  <span className="px-1 py-0.5 rounded bg-[#26325f]">
                    RR{Number(ticker.rr).toFixed(1)}
                  </span>
                )}
              </div>
              {ent.corridor && (
                <span
                  className={`px-1 py-0.5 rounded text-[8px] font-semibold ${dir.bg} ${dir.color}`}
                >
                  {ent.side}
                </span>
              )}
            </div>
          </div>
        );
      }

      // Generate plain English action description
      function getActionDescription(ticker) {
        const state = String(ticker.state || "");
        const phase = Number(ticker.phase_pct) || 0;
        const comp = completionForSize(ticker);
        const flags = ticker.flags || {};
        const ent = entryType(ticker);
        const rank = Number(ticker.rank || 0);
        const rr = Number(ticker.rr || 0);
        const momentumElite = !!flags.momentum_elite;
        const momentumPct = ticker.momentum_pct || {};

        const isAligned =
          state === "HTF_BULL_LTF_BULL" || state === "HTF_BEAR_LTF_BEAR";
        const isPullback =
          state === "HTF_BULL_LTF_PULLBACK" ||
          state === "HTF_BEAR_LTF_PULLBACK";
        const isPrime = isPrimeBubble(ticker);
        const inCorridor = ent.corridor;
        const sqRelease = !!flags.sq30_release;
        const sqOn = !!flags.sq30_on;

        // High completion = near target, consider exit/trim
        if (comp > 0.8) {
          return {
            action: "Prepare for Exit / Trim Position",
            description: `Position has reached ${(comp * 100).toFixed(
              0
            )}% completion, indicating the move is near its target. ${
              momentumElite ? "Despite Momentum Elite status, " : ""
            }Consider taking profits or trimming 50-75% of position to lock in gains while allowing runners to continue. Monitor for signs of reversal or continuation beyond TP levels.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // High phase = late in cycle, be cautious
        if (phase > 0.7) {
          return {
            action: "Wait / Trim Existing Position",
            description: `Phase oscillator at ${(phase * 100).toFixed(
              0
            )}% indicates late-cycle conditions. ${
              momentumElite
                ? "While Momentum Elite suggests continued strength, "
                : ""
            }Market is approaching exhaustion zone. Wait for pullback to better entry or trim existing positions by 30-50% to reduce risk. Look for phase reset or continuation signals before adding size.`,
            color: "text-orange-400",
            bg: "bg-orange-500/20",
          };
        }

        // Momentum Elite + Prime setup = strongest signal
        if (momentumElite && isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          const momentumStr =
            momentumPct.month != null
              ? ` with ${Number(momentumPct.month).toFixed(
                  0
                )}% monthly momentum`
              : "";
          return {
            action: "Initiate Position - High Conviction",
            description: `Momentum Elite stock${momentumStr} showing Prime setup with exceptional alignment. Both HTF and LTF are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2
            )}:1). This represents a high-probability setup with strong fundamentals backing the technical signal. Consider entering with full position size, using TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Momentum Elite + Squeeze release = strong momentum signal
        if (momentumElite && sqRelease && inCorridor && isAligned) {
          const momentumStr =
            momentumPct.week != null
              ? ` (${Number(momentumPct.week).toFixed(0)}% weekly)`
              : "";
          return {
            action: "Initiate Position - Momentum Breakout",
            description: `Momentum Elite stock${momentumStr} experiencing squeeze release with timeframe alignment. This indicates pent-up energy being released in the direction of the trend. The combination of Momentum Elite fundamentals and technical squeeze release creates a high-probability momentum continuation setup. Enter on pullback to corridor or on break of squeeze high/low, targeting TP levels.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Prime setup with good conditions = initiate
        if (isPrime && inCorridor && rank >= 75 && rr >= 1.5) {
          return {
            action: "Initiate Position - Prime Setup",
            description: `Prime setup detected with strong technical alignment. Both timeframes are aligned, price is in entry corridor, rank is strong (${rank}), and risk/reward is favorable (${rr.toFixed(
              2
            )}:1). ${
              momentumElite
                ? "Momentum Elite status adds fundamental strength to this technical setup. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) with low completion (${(
              comp * 100
            ).toFixed(
              0
            )}%) suggests room to run. Consider entering position, using SL for risk management and TP levels as profit targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // Momentum Elite + In corridor = quality momentum play
        if (
          momentumElite &&
          inCorridor &&
          isAligned &&
          comp < 0.5 &&
          phase < 0.6
        ) {
          return {
            action: "Consider Entry - Momentum Elite Setup",
            description: `Momentum Elite stock in favorable technical setup. Price is in entry corridor with both timeframes aligned, early phase (${(
              phase * 100
            ).toFixed(0)}%), and low completion (${(comp * 100).toFixed(
              0
            )}%) indicating room for continuation. ${
              sqRelease
                ? "Squeeze release adds momentum confirmation. "
                : sqOn
                ? "Squeeze building suggests potential breakout. "
                : ""
            }The combination of strong fundamentals (Momentum Elite) and favorable technicals creates a quality setup. Enter on confirmation or pullback, targeting TP levels.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Squeeze release in corridor = strong signal
        if (sqRelease && inCorridor && isAligned) {
          return {
            action: "Initiate Position - Squeeze Release",
            description: `Squeeze release detected with timeframe alignment in entry corridor. This indicates pent-up energy being released in the direction of the trend. ${
              momentumElite
                ? "Momentum Elite status adds fundamental backing to this technical signal. "
                : ""
            }Early phase (${(phase * 100).toFixed(0)}%) and low completion (${(
              comp * 100
            ).toFixed(
              0
            )}%) suggest continuation potential. Enter on pullback or break, using SL for protection and TP levels as targets.`,
            color: "text-green-400",
            bg: "bg-green-500/20",
          };
        }

        // In corridor and aligned = good setup
        if (inCorridor && isAligned && comp < 0.5 && phase < 0.6) {
          return {
            action: "Consider Entry - Favorable Setup",
            description: `Setup is in entry corridor with both timeframes aligned. Early phase (${(
              phase * 100
            ).toFixed(0)}%) and low completion (${(comp * 100).toFixed(
              0
            )}%) suggest room to run. ${
              momentumElite
                ? "Momentum Elite status adds quality to this setup. "
                : ""
            }${
              sqOn ? "Squeeze building suggests potential momentum. " : ""
            }Rank is ${
              rank >= 70 ? "strong" : "moderate"
            } (${rank}) with RR of ${rr.toFixed(
              2
            )}:1. Monitor for entry confirmation or wait for squeeze release signal before initiating position.`,
            color: "text-blue-400",
            bg: "bg-blue-500/20",
          };
        }

        // Pullback setup = wait for confirmation
        if (isPullback && !inCorridor) {
          return {
            action: "Wait for Entry - Pullback Setup",
            description: `Pullback detected (${state}) but price not yet in entry corridor. ${
              momentumElite
                ? "Momentum Elite status suggests this pullback may be shallow and could present a quality entry. "
                : ""
            }Wait for price to enter corridor (Q1â†’Q2 for LONG, Q4â†’Q3 for SHORT) before considering entry. ${
              sqOn
                ? "Squeeze building suggests potential momentum when released. "
                : ""
            }Monitor for corridor entry and confirmation signals before initiating position.`,
            color: "text-cyan-400",
            bg: "bg-cyan-500/20",
          };
        }

        // Squeeze on but not released = building pressure
        if (sqOn && !sqRelease) {
          return {
            action: "Monitor Closely - Squeeze Building",
            description: `Squeeze building but not yet released, indicating pressure is accumulating. ${
              momentumElite
                ? "Momentum Elite status suggests when released, the move could be significant. "
                : ""
            }${
              inCorridor
                ? "Price is in entry corridor, making this a high-probability setup when squeeze releases. "
                : "Wait for price to enter corridor and squeeze to release before entering. "
            }Monitor closely for squeeze release signal, which typically provides strong directional momentum.`,
            color: "text-yellow-400",
            bg: "bg-yellow-500/20",
          };
        }

        // Default: wait
        return {
          action: "Wait - Setup Not Optimal",
          description: `Setup not yet optimal for entry. ${
            momentumElite ? "Momentum Elite status is positive, but " : ""
          }Technical conditions need improvement. ${
            !inCorridor ? "Price needs to enter entry corridor. " : ""
          }${!isAligned ? "Timeframes need better alignment. " : ""}${
            comp > 0.5
              ? `Completion is high (${(comp * 100).toFixed(
                  0
                )}%), reducing upside potential. `
              : ""
          }Wait for better conditions, confirmation signals, or entry corridor alignment before considering position.`,
          color: "text-[#93a4d6]",
          bg: "bg-[#26325f]",
        };
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Activity Feed Component
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function ActivityFeed({ onTickerClick, tickerData }) {
        const [events, setEvents] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const feedRef = React.useRef(null);

        // Helper to get latest ticker data and merge with event
        // IMPORTANT: Always use latest RR from tickerData to match Bubble Chart (which recomputes RR)
        // This ensures Activity Feed RR matches Bubble Chart RR (both use recomputed values from /timed/all)
        const getEventWithTickerData = useCallback(
          (event) => {
            const latestData = tickerData?.[event.ticker] || {};
            // Merge event data with latest ticker data, preferring latest data for RR (matches Bubble Chart computation)
            // Use event data for historical snapshots (price, sl, tp at event time) but latest RR for consistency
            return {
              ...event,
              price: event.price || latestData.price,
              sl: event.sl !== undefined ? event.sl : latestData.sl,
              tp: event.tp !== undefined ? event.tp : latestData.tp,
              tp_levels: event.tp_levels || latestData.tp_levels,
              // Always use latest RR to match Bubble Chart (which uses recomputed RR from /timed/all)
              // This ensures consistency since worker recomputes RR using fused SL levels
              rr: latestData.rr !== undefined ? latestData.rr : event.rr,
              phase_pct:
                event.phase_pct !== undefined
                  ? event.phase_pct
                  : latestData.phase_pct,
              completion:
                event.completion !== undefined
                  ? event.completion
                  : latestData.completion,
              // Include momentum_pct from latest data if available
              momentum_pct: latestData.momentum_pct || event.momentum_pct,
            };
          },
          [tickerData]
        );

        const fetchActivity = React.useCallback(async () => {
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);

            const res = await fetch(
              "https://timed-trading-ingest.shashant.workers.dev/timed/activity?limit=50",
              { signal: controller.signal }
            );
            clearTimeout(timeoutId);

            const data = await res.json();

            if (res.ok && data.ok && Array.isArray(data.events)) {
              setEvents(data.events);
              setError(null); // Clear any previous errors
            } else {
              // Log error for debugging
              console.warn("Activity feed response:", {
                status: res.status,
                ok: res.ok,
                dataOk: data.ok,
                error: data.error,
                eventsCount: data.events?.length || 0,
              });

              // Handle rate limit error
              if (res.status === 429) {
                setError(
                  "Rate limit exceeded. Please wait a moment and refresh."
                );
              } else if (data.error) {
                setError(data.error);
              } else {
                setError(null);
              }

              // Still set events if it's an empty array (no error, just no data)
              if (res.ok && Array.isArray(data.events)) {
                setEvents(data.events);
              }
            }
          } catch (err) {
            if (err.name !== "AbortError") {
              console.error("Activity feed fetch error:", err);
              setError("Failed to load activity feed");
            }
          } finally {
            setLoading(false);
          }
        }, []);

        // Initial fetch and periodic refresh
        React.useEffect(() => {
          fetchActivity();
          const interval = setInterval(fetchActivity, 5 * 60 * 1000); // Refresh every 5 minutes to align with data updates
          return () => clearInterval(interval);
        }, [fetchActivity]);

        // Auto-scroll to top when new events arrive
        React.useEffect(() => {
          if (feedRef.current && events.length > 0) {
            feedRef.current.scrollTop = 0;
          }
        }, [events.length]);

        const formatTime = (ts) => {
          const date = new Date(ts);
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / 60000);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);

          if (diffMins < 1) return "just now";
          if (diffMins < 60) return `${diffMins}m ago`;
          if (diffHours < 24) return `${diffHours}h ago`;
          if (diffDays < 7) return `${diffDays}d ago`;
          return date.toLocaleDateString();
        };

        const getEventIcon = (type) => {
          switch (type) {
            case "corridor_entry":
              return "ðŸšª";
            case "squeeze_start":
              return "âš¡";
            case "squeeze_release":
              return "ðŸ’¥";
            case "state_aligned":
              return "ðŸŽ¯";
            case "momentum_elite":
              return "ðŸš€";
            default:
              return "ðŸ“Š";
          }
        };

        const getEventColor = (type) => {
          switch (type) {
            case "corridor_entry":
              return "text-blue-400";
            case "squeeze_start":
              return "text-yellow-400";
            case "squeeze_release":
              return "text-green-400";
            case "state_aligned":
              return "text-purple-400";
            case "momentum_elite":
              return "text-pink-400";
            default:
              return "text-gray-400";
          }
        };

        const getEventLabel = (event) => {
          switch (event.type) {
            case "corridor_entry":
              return `${event.ticker} entered ${event.side || "corridor"}`;
            case "squeeze_start":
              return `${event.ticker} squeeze started`;
            case "squeeze_release":
              return `${event.ticker} squeeze released${
                event.side ? ` (${event.side})` : ""
              }`;
            case "state_aligned":
              return `${event.ticker} aligned ${event.side || ""}`;
            case "momentum_elite":
              return `${event.ticker} Momentum Elite`;
            default:
              return `${event.ticker} event`;
          }
        };

        return (
          <div className="w-80 bg-[#0f1630] border border-[#26325f] rounded-xl p-4 flex flex-col">
            <div className="flex items-center justify-between mb-3 pb-2 border-b border-[#26325f]">
              <h3 className="text-lg font-semibold text-white">
                Activity Feed
              </h3>
              <button
                onClick={fetchActivity}
                className="text-xs text-[#93a4d6] hover:text-white transition-colors"
                title="Refresh"
              >
                â†»
              </button>
            </div>

            <div
              ref={feedRef}
              className="flex-1 overflow-y-auto space-y-2 pr-2"
              style={{ maxHeight: "760px" }}
            >
              {loading && events.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  <div className="loading-spinner mx-auto mb-2"></div>
                  Loading events...
                </div>
              ) : error ? (
                <div className="text-center text-yellow-400 py-8 px-2">
                  <div className="text-sm mb-2">{error}</div>
                  <button
                    onClick={fetchActivity}
                    className="text-xs text-[#93a4d6] hover:text-white underline"
                  >
                    Retry
                  </button>
                </div>
              ) : events.length === 0 ? (
                <div className="text-center text-[#93a4d6] py-8">
                  No recent activity
                </div>
              ) : (
                events.map((event) => {
                  const eventData = getEventWithTickerData(event);
                  // Calculate Max TP from tp_levels array
                  let maxTP = eventData.tp;
                  if (
                    eventData.tp_levels &&
                    Array.isArray(eventData.tp_levels) &&
                    eventData.tp_levels.length > 0
                  ) {
                    const tpPrices = eventData.tp_levels
                      .map((tpItem) => {
                        if (
                          typeof tpItem === "object" &&
                          tpItem !== null &&
                          tpItem.price != null
                        ) {
                          return Number(tpItem.price);
                        }
                        return typeof tpItem === "number"
                          ? tpItem
                          : Number(tpItem);
                      })
                      .filter((p) => Number.isFinite(p));
                    if (tpPrices.length > 0) {
                      maxTP = Math.max(...tpPrices);
                    }
                  }

                  return (
                    <div
                      key={event.id || `${event.ticker}-${event.ts}`}
                      onClick={() =>
                        onTickerClick && onTickerClick(event.ticker)
                      }
                      className="bg-[#121a33] border border-[#26325f] rounded p-2 text-xs hover:border-[#3a4a7a] hover:bg-[#1a2440] transition-colors cursor-pointer"
                    >
                      <div className="flex items-start justify-between gap-2 mb-1.5">
                        <div className="flex items-center gap-1.5 flex-1 min-w-0">
                          <span className="text-base">
                            {getEventIcon(event.type)}
                          </span>
                          <span
                            className={`font-semibold ${getEventColor(
                              event.type
                            )} truncate`}
                          >
                            {getEventLabel(event)}
                          </span>
                        </div>
                        <span className="text-[#6b7a9f] text-[10px] whitespace-nowrap">
                          {formatTime(event.ts)}
                        </span>
                      </div>

                      {/* Standardized Fields - Always Show */}
                      <div className="space-y-1.5 border-t border-[#26325f]/50 pt-1.5 mt-1.5">
                        {/* Price Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            Price:
                          </span>
                          <span className="text-white font-semibold text-[10px]">
                            {eventData.price
                              ? `$${Number(eventData.price).toFixed(2)}`
                              : "â€”"}
                          </span>
                        </div>

                        {/* SL Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            SL:
                          </span>
                          <span className="text-red-400 font-mono text-[10px]">
                            {eventData.sl != null
                              ? `$${Number(eventData.sl).toFixed(2)}`
                              : "â€”"}
                          </span>
                        </div>

                        {/* Max TP Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            Max TP:
                          </span>
                          <span className="text-green-400 font-mono text-[10px]">
                            {maxTP != null
                              ? `$${Number(maxTP).toFixed(2)}`
                              : "â€”"}
                          </span>
                        </div>

                        {/* RR Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            RR:
                          </span>
                          <span className="text-blue-400 font-mono text-[10px]">
                            {eventData.rr != null
                              ? Number(eventData.rr).toFixed(2)
                              : "â€”"}
                          </span>
                        </div>

                        {/* Phase Complete Row */}
                        <div className="flex items-center justify-between gap-2">
                          <span className="text-[#6b7a9f] text-[10px]">
                            Phase:
                          </span>
                          <div className="flex items-center gap-1.5">
                            <div className="w-16 h-1 bg-[#26325f] rounded-full overflow-hidden">
                              <div
                                className="h-full rounded-full transition-all"
                                style={{
                                  width: `${
                                    (Number(eventData.phase_pct) || 0) * 100
                                  }%`,
                                  backgroundColor: (() => {
                                    const phase =
                                      Number(eventData.phase_pct) || 0;
                                    if (phase < 0.3) return "#2ecc71";
                                    if (phase < 0.6) return "#f39c12";
                                    return "#e74c3c";
                                  })(),
                                }}
                              />
                            </div>
                            <span className="text-white font-mono text-[10px] min-w-[2.5rem]">
                              {eventData.phase_pct != null
                                ? `${Math.round(
                                    Number(eventData.phase_pct) * 100
                                  )}%`
                                : "â€”"}
                            </span>
                          </div>
                        </div>
                      </div>

                      {/* Additional Info - Compact */}
                      {(event.rank || event.state || event.trigger_dir) && (
                        <div className="flex items-center gap-2 text-[#6b7a9f] text-[10px] mt-1.5 pt-1.5 border-t border-[#26325f]/30">
                          {event.rank && <span>Rank {event.rank}</span>}
                          {event.state && (
                            <span className="truncate" title={event.state}>
                              {event.state.split("_").pop()}
                            </span>
                          )}
                          {event.trigger_dir && (
                            <span>Dir: {event.trigger_dir}</span>
                          )}
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      function QuickFilters({ filters, onFilterChange, sectors = [] }) {
        // Groups (seed list) - one row
        const groupPresets = [
          {
            label: "Upticks",
            filter: { group: "UPTICKS" },
            icon: "ðŸ“Š",
          },
          {
            label: "Super Granny",
            filter: { group: "SuperGranny" },
            icon: "â­",
          },
          {
            label: "GRNI",
            filter: { group: "GRNI" },
            icon: "ðŸ”µ",
          },
          {
            label: "GRNJ",
            filter: { group: "GRNJ" },
            icon: "ðŸŸ¢",
          },
          {
            label: "GRNY",
            filter: { group: "GRNY" },
            icon: "ðŸŸ¡",
          },
          {
            label: "Social",
            filter: { group: "Social" },
            icon: "ðŸ’¬",
          },
          {
            label: "SP Sectors",
            filter: { group: "SP_Sectors" },
            icon: "ðŸ“ˆ",
          },
          {
            label: "Futures",
            filter: { group: "Futures" },
            icon: "âš¡",
          },
        ];

        // Filters - one row
        const filterPresets = [
          {
            label: "Prime Only",
            filter: { minRank: 75, minRR: 1.5, maxCompletion: 0.4 },
            icon: "â­",
          },
          {
            label: "In Corridor",
            filter: { inCorridor: true },
            icon: "ðŸŽ¯",
          },
          {
            label: "Squeeze Release",
            filter: { squeezeRelease: true },
            icon: "âš¡",
          },
          {
            label: "Momentum Elite",
            filter: { momentumElite: true },
            icon: "ðŸš€",
          },
          {
            label: "Q1: Bull Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "ðŸ“ˆ",
          },
          {
            label: "Q2: Bull Momentum",
            filter: { quadrants: ["HTF_BULL_LTF_BULL"] },
            icon: "ðŸš€",
          },
          {
            label: "Q3: Bear Momentum",
            filter: { quadrants: ["HTF_BEAR_LTF_BEAR"] },
            icon: "ðŸ“‰",
          },
          {
            label: "Q4: Bear Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "ðŸ”»",
          },
          {
            label: "Top 40",
            filter: { top40: true },
            icon: "ðŸ†",
          },
          {
            label: "Top Long Setup",
            filter: { quadrants: ["HTF_BULL_LTF_PULLBACK"] },
            icon: "ðŸ“ˆ",
          },
          {
            label: "Top Short Setup",
            filter: { quadrants: ["HTF_BEAR_LTF_PULLBACK"] },
            icon: "ðŸ“‰",
          },
          {
            label: "Trades",
            filter: { hasTrades: true },
            icon: "ðŸ’¼",
          },
        ];

        const isActive = (preset) => {
          if (preset.label === "Prime Only") {
            return (
              filters.minRank === 75 &&
              filters.minRR === 1.5 &&
              filters.maxCompletion === 0.4
            );
          }
          if (preset.label === "In Corridor") {
            return filters.inCorridor === true;
          }
          if (preset.label === "Squeeze Release") {
            return filters.squeezeRelease === true;
          }
          if (preset.label === "Momentum Elite") {
            return filters.momentumElite === true;
          }
          // Check for "Top Long Setup" and "Top Short Setup" specifically
          if (preset.label === "Top Long Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
            );
          }
          if (preset.label === "Top Short Setup") {
            const currentQuadrants = filters.quadrants || [];
            return (
              currentQuadrants.length === 1 &&
              currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
            );
          }
          // Check if quadrant filter matches (for Q1, Q2, Q3, Q4 labels)
          if (preset.label.startsWith("Q")) {
            const presetQuadrants = preset.filter.quadrants || [];
            const currentQuadrants = filters.quadrants || [];
            // Check if preset quadrants are the only ones selected
            if (presetQuadrants.length === 1 && currentQuadrants.length === 1) {
              return presetQuadrants[0] === currentQuadrants[0];
            }
            // Check if preset quadrants are subset of current (and no others)
            if (
              presetQuadrants.length === 1 &&
              currentQuadrants.includes(presetQuadrants[0])
            ) {
              return currentQuadrants.length === 1;
            }
          }
          // Check if group filter matches
          if (preset.filter.group) {
            return filters.group === preset.filter.group;
          }
          // Check if Top 40 filter matches
          if (preset.filter.top40) {
            return filters.top40 === true;
          }
          // Check if Trades filter matches
          if (preset.filter.hasTrades) {
            return filters.hasTrades === true;
          }
          return false;
        };

        const handlePresetClick = (preset) => {
          const active = isActive(preset);
          if (active) {
            // Toggle off - remove this specific filter, keep others
            const newFilters = { ...filters };

            if (preset.label === "Prime Only") {
              // Reset Prime Only filters to defaults
              newFilters.minRank = 0;
              newFilters.minRR = 0;
              newFilters.maxCompletion = 1.01;
            } else if (preset.label === "In Corridor") {
              delete newFilters.inCorridor;
            } else if (preset.label === "Squeeze Release") {
              delete newFilters.squeezeRelease;
            } else if (preset.label === "Momentum Elite") {
              // Explicitly delete to ensure it's removed
              delete newFilters.momentumElite;
              // Set to undefined so handleFilterChange properly removes it
              newFilters.momentumElite = undefined;
            } else if (preset.label === "Top Long Setup") {
              // Restore all quadrants if Top Long Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BULL_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label === "Top Short Setup") {
              // Restore all quadrants if Top Short Setup was the only quadrant filter
              const currentQuadrants = filters.quadrants || [];
              if (
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === "HTF_BEAR_LTF_PULLBACK"
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.label.startsWith("Q")) {
              // For Q1-Q4, restore all quadrants if this was the only one
              const presetQuadrants = preset.filter.quadrants || [];
              const currentQuadrants = filters.quadrants || [];
              if (
                presetQuadrants.length === 1 &&
                currentQuadrants.length === 1 &&
                currentQuadrants[0] === presetQuadrants[0]
              ) {
                newFilters.quadrants = [
                  "HTF_BULL_LTF_PULLBACK",
                  "HTF_BULL_LTF_BULL",
                  "HTF_BEAR_LTF_BEAR",
                  "HTF_BEAR_LTF_PULLBACK",
                ];
              }
            } else if (preset.filter.group) {
              // Reset group filter
              newFilters.group = "ALL";
            } else if (preset.filter.top40) {
              delete newFilters.top40;
            } else if (preset.filter.hasTrades) {
              delete newFilters.hasTrades;
            }

            onFilterChange(newFilters);
          } else {
            // Toggle on - apply filter, merge with existing filters
            const mergedFilters = { ...filters, ...preset.filter };

            // Special handling for quadrant filters - replace, don't merge arrays
            if (preset.filter.quadrants) {
              mergedFilters.quadrants = preset.filter.quadrants;
            }

            onFilterChange(mergedFilters);
          }
        };

        const resetAllFilters = () => {
          // Explicitly reset all filters including boolean flags
          // Use onFilterChange to ensure proper state updates
          const defaultFilters = {
            search: "",
            quadrants: [
              "HTF_BULL_LTF_PULLBACK",
              "HTF_BULL_LTF_BULL",
              "HTF_BEAR_LTF_BEAR",
              "HTF_BEAR_LTF_PULLBACK",
            ],
            minRank: 0,
            minRR: 0,
            maxCompletion: 1.01,
            group: "ALL",
          };
          // Explicitly clear all boolean filters by setting to undefined
          // handleFilterChange will delete undefined values
          onFilterChange({
            ...defaultFilters,
            inCorridor: undefined,
            squeezeRelease: undefined,
            momentumElite: undefined,
            top40: undefined,
            hasTrades: undefined,
          });
        };

        const renderPresetButton = (preset, i) => {
          const active = isActive(preset);
          return (
            <button
              key={i}
              className={`px-4 py-2 rounded-lg border text-sm font-semibold transition-all ${
                active
                  ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                  : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
              }`}
              onClick={() => handlePresetClick(preset)}
            >
              {preset.icon} {preset.label}
            </button>
          );
        };

        return (
          <div className="space-y-3 mb-4">
            {/* Groups Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {groupPresets.map((preset, i) => renderPresetButton(preset, i))}
            </div>
            {/* Filters Row */}
            <div className="flex gap-2 flex-wrap items-center">
              {filterPresets.map((preset, i) => renderPresetButton(preset, i))}
              {/* Reset Filters Button */}
              <button
                onClick={resetAllFilters}
                className="px-4 py-2 rounded-lg border border-red-500/50 bg-red-500/10 hover:bg-red-500/20 text-red-400 text-sm font-semibold transition-all"
                title="Reset all filters to defaults"
              >
                ðŸ”„ Reset Filters
              </button>
            </div>
            {/* Sectors Row */}
            {sectors.length > 0 && (
              <div className="flex gap-2 flex-wrap items-center">
                <span className="text-xs text-[#93a4d6] font-semibold mr-1">Sectors:</span>
                {sectors.map((sectorData) => {
                  const sectorName = sectorData.sector || sectorData.name;
                  const rating = sectorData.rating || "neutral";
                  const emoji =
                    rating === "overweight"
                      ? "ðŸ“ˆ"
                      : rating === "underweight"
                      ? "ðŸ“‰"
                      : "âž¡ï¸";
                  const isActive = filters.sector === sectorName;
                  return (
                    <button
                      key={sectorName}
                      onClick={() => {
                        onFilterChange({
                          sector: isActive ? null : sectorName,
                        });
                      }}
                      className={`px-2 py-1 rounded-lg border text-xs font-semibold transition-all ${
                        isActive
                          ? "border-green-500 bg-green-500/20 text-green-400 shadow-lg"
                          : "border-[#26325f] bg-[#0f1630] hover:bg-[#1a2550] hover:border-[#3a4aa0] text-[#93a4d6]"
                      }`}
                      title={`${sectorName} - ${rating}`}
                    >
                      {emoji} {sectorName}
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        );
      }

      // Helper: Get quadrant from state
      function getQuadrantFromState(state) {
        if (state === "HTF_BULL_LTF_PULLBACK")
          return { q: 1, name: "Q1", label: "Bull Setup", color: "blue" };
        if (state === "HTF_BULL_LTF_BULL")
          return { q: 2, name: "Q2", label: "Bull Momentum", color: "green" };
        if (state === "HTF_BEAR_LTF_BEAR")
          return { q: 3, name: "Q3", label: "Bear Momentum", color: "red" };
        if (state === "HTF_BEAR_LTF_PULLBACK")
          return { q: 4, name: "Q4", label: "Bear Setup", color: "orange" };
        return null;
      }

      // Pattern detection
      function detectPatterns(trail, flags) {
        if (!trail || trail.length < 2) return [];
        const patterns = [];
        const states = trail.map((p) => p.state).filter(Boolean);
        const safeFlags = flags || {};

        // Pattern 1: Clean Q1â†’Q2 or Q4â†’Q3 transition (ideal entry)
        for (let i = 1; i < states.length; i++) {
          if (
            states[i - 1] === "HTF_BULL_LTF_PULLBACK" &&
            states[i] === "HTF_BULL_LTF_BULL"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q1â†’Q2 transition (Bull Entry)",
              quadrant: "Q1â†’Q2",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
          if (
            states[i - 1] === "HTF_BEAR_LTF_PULLBACK" &&
            states[i] === "HTF_BEAR_LTF_BEAR"
          ) {
            patterns.push({
              type: "IDEAL_ENTRY",
              description: "Clean Q4â†’Q3 transition (Bear Entry)",
              quadrant: "Q4â†’Q3",
              timestamp: trail[i].ts,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 2: Momentum Elite + Setup quadrant
        const currentState = states[states.length - 1];
        if (
          (currentState === "HTF_BULL_LTF_PULLBACK" ||
            currentState === "HTF_BEAR_LTF_PULLBACK") &&
          safeFlags.momentum_elite
        ) {
          patterns.push({
            type: "ELITE_SETUP",
            description: "Momentum Elite in Setup Quadrant",
            quadrant: getQuadrantFromState(currentState)?.name,
            confidence: "HIGH",
          });
        }

        // Pattern 3: Squeeze release in setup quadrant
        const lastPoint = trail[trail.length - 1];
        if (lastPoint && lastPoint.flags && lastPoint.flags.sq30_release) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "SQUEEZE_SETUP",
              description: "Squeeze Release in Setup Quadrant",
              quadrant: q.name,
              confidence: "HIGH",
            });
          }
        }

        // Pattern 4: Multiple quadrant visits (chop vs clean)
        const uniqueQuads = new Set(
          states.map((s) => getQuadrantFromState(s)?.q).filter(Boolean)
        );
        if (uniqueQuads.size > 2 && states.length > 5) {
          patterns.push({
            type: "CHOPPY",
            description: "Multiple quadrant visits (choppy action)",
            confidence: "MEDIUM",
          });
        } else if (uniqueQuads.size === 1 && states.length >= 3) {
          patterns.push({
            type: "STABLE",
            description: "Stable quadrant (consistent state)",
            quadrant: getQuadrantFromState(states[0])?.name,
            confidence: "MEDIUM",
          });
        }

        // Pattern 5: Phase zone change in setup
        if (lastPoint && lastPoint.flags && lastPoint.flags.phase_zone_change) {
          const q = getQuadrantFromState(lastPoint.state);
          if (q && (q.q === 1 || q.q === 4)) {
            patterns.push({
              type: "PHASE_SHIFT",
              description: "Phase zone change in Setup",
              quadrant: q.name,
              confidence: "MEDIUM",
            });
          }
        }

        return patterns;
      }

      // Separate component for Quadrant Progression to properly use hooks
      function QuadrantProgression({ ticker, flags }) {
        const [trail, setTrail] = React.useState([]);
        const [loading, setLoading] = React.useState(false); // Start as false
        const [hasLoaded, setHasLoaded] = React.useState(false);

        React.useEffect(() => {
          // Defer trail loading to not block initial render
          // Only load if component is mounted and ticker is valid
          if (!hasLoaded && ticker && ticker.ticker) {
            setLoading(true);
            const timeoutId = setTimeout(async () => {
              try {
                const controller = new AbortController();
                const timeoutId2 = setTimeout(() => controller.abort(), 3000); // 3s timeout (reduced from 5s)

                const response = await fetch(
                  `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                    ticker.ticker
                  )}`,
                  { signal: controller.signal }
                );

                clearTimeout(timeoutId2);

                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                if (data.ok && Array.isArray(data.trail)) {
                  setTrail(data.trail);
                } else {
                  setTrail([]); // Set empty if no trail data
                }
              } catch (e) {
                if (e.name !== "AbortError") {
                  console.error("Failed to load trail:", e);
                }
                // Set empty trail on error to prevent infinite retries
                setTrail([]);
              } finally {
                setLoading(false);
                setHasLoaded(true);
              }
            }, 300); // Slightly longer delay to ensure overlay is rendered first
            return () => clearTimeout(timeoutId);
          }
        }, [ticker?.ticker, hasLoaded]);

        const patterns = detectPatterns(trail, flags || {});
        const currentQuad = getQuadrantFromState(ticker.state);
        const quadHistory = trail
          .map((p) => getQuadrantFromState(p.state))
          .filter(Boolean);

        return (
          <div className="mb-4 p-4 bg-[#0f1630] rounded-lg border border-[#26325f]">
            <div className="text-sm font-bold mb-3 text-[#93a4d6]">
              Quadrant Progression
            </div>

            {/* Quadrant Map */}
            <div className="grid grid-cols-2 gap-2 mb-4">
              {/* Q1 - Bull Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 1
                    ? "border-blue-400 bg-blue-500/20"
                    : quadHistory.some((q) => q && q.q === 1)
                    ? "border-blue-500/50 bg-blue-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-blue-400">
                  Q1: Bull Setup
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BULL_LTF_PULLBACK
                </div>
              </div>

              {/* Q2 - Bull Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 2
                    ? "border-green-400 bg-green-500/20"
                    : quadHistory.some((q) => q && q.q === 2)
                    ? "border-green-500/50 bg-green-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-green-400">
                  Q2: Bull Momentum
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BULL_LTF_BULL
                </div>
              </div>

              {/* Q4 - Bear Setup */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 4
                    ? "border-orange-400 bg-orange-500/20"
                    : quadHistory.some((q) => q && q.q === 4)
                    ? "border-orange-500/50 bg-orange-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-orange-400">
                  Q4: Bear Setup
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BEAR_LTF_PULLBACK
                </div>
              </div>

              {/* Q3 - Bear Momentum */}
              <div
                className={`p-3 rounded-lg border-2 ${
                  currentQuad?.q === 3
                    ? "border-red-400 bg-red-500/20"
                    : quadHistory.some((q) => q && q.q === 3)
                    ? "border-red-500/50 bg-red-500/10"
                    : "border-[#26325f] bg-[#0a0f1f]"
                }`}
              >
                <div className="text-xs font-bold text-red-400">
                  Q3: Bear Momentum
                </div>
                <div className="text-[10px] text-[#93a4d6] mt-1">
                  HTF_BEAR_LTF_BEAR
                </div>
              </div>
            </div>

            {/* Path Visualization */}
            {trail.length > 0 && (
              <div className="mb-4">
                <div className="text-xs font-semibold text-[#93a4d6] mb-2">
                  Path ({trail.length} points)
                </div>
                <div className="flex items-center gap-1 flex-wrap">
                  {quadHistory.map((q, idx) => {
                    if (!q) return null;
                    const isLast = idx === quadHistory.length - 1;
                    const colorClasses = {
                      blue: isLast
                        ? "bg-blue-500/30 border-2 border-blue-400 text-blue-300"
                        : "bg-blue-500/10 border border-blue-500/50 text-blue-400",
                      green: isLast
                        ? "bg-green-500/30 border-2 border-green-400 text-green-300"
                        : "bg-green-500/10 border border-green-500/50 text-green-400",
                      red: isLast
                        ? "bg-red-500/30 border-2 border-red-400 text-red-300"
                        : "bg-red-500/10 border border-red-500/50 text-red-400",
                      orange: isLast
                        ? "bg-orange-500/30 border-2 border-orange-400 text-orange-300"
                        : "bg-orange-500/10 border border-orange-500/50 text-orange-400",
                    };
                    return (
                      <React.Fragment key={idx}>
                        <div
                          className={`px-2 py-1 rounded text-[10px] font-bold ${
                            colorClasses[q.color] || colorClasses.blue
                          }`}
                        >
                          {q.name}
                        </div>
                        {idx < quadHistory.length - 1 && (
                          <span className="text-[#93a4d6] text-xs">â†’</span>
                        )}
                      </React.Fragment>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Pattern Detection */}
            {patterns.length > 0 && (
              <div className="mt-4 pt-4 border-t border-[#26325f]">
                <div className="text-xs font-bold text-yellow-400 mb-2">
                  ðŸŽ¯ Detected Patterns
                </div>
                <div className="space-y-2">
                  {patterns.map((pattern, idx) => (
                    <div
                      key={idx}
                      className={`p-2 rounded border ${
                        pattern.confidence === "HIGH"
                          ? "bg-yellow-500/20 border-yellow-400/50"
                          : "bg-blue-500/10 border-blue-500/30"
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="text-xs font-bold text-white">
                            {pattern.description}
                          </div>
                          {pattern.quadrant && (
                            <div className="text-[10px] text-[#93a4d6] mt-0.5">
                              {pattern.quadrant}
                            </div>
                          )}
                        </div>
                        <span
                          className={`text-[10px] px-1.5 py-0.5 rounded ${
                            pattern.confidence === "HIGH"
                              ? "bg-yellow-500/30 text-yellow-300"
                              : "bg-blue-500/30 text-blue-300"
                          }`}
                        >
                          {pattern.confidence}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {loading && (
              <div className="text-xs text-[#93a4d6] text-center py-2">
                Loading history...
              </div>
            )}
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Unified Ticker Detail Right Rail Component
      // Reusable component that shows comprehensive ticker information
      // and optionally trade history if a trade is associated
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function TickerDetailRightRail({ ticker, trade = null, onClose, allLoadedData = null, sectors = [] }) {
        if (!ticker) return null;

        const tickerSymbol = ticker.ticker;
        if (!tickerSymbol) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);

        // Convert allLoadedData to array for ranking calculations
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) return allLoadedData;
            return Object.values(allLoadedData).filter(
              (t) => t && typeof t === "object" && t.ticker
            );
          }
          return [];
        })();

        const baseScore = Number(ticker.rank) || 0;
        const dynamicRank = computeDynamicRank(ticker);
        const allTickersWithRank = allLoadedTickersArray.map(t => ({ ...t, dynamicRank: computeDynamicRank(t) }));
        const sortedByDynamic = [...allTickersWithRank].sort((a, b) => b.dynamicRank - a.dynamicRank);
        const rankPosition = sortedByDynamic.findIndex(t => String(t.ticker || "").toUpperCase() === String(tickerSymbol).toUpperCase()) + 1;
        const totalTickers = allLoadedTickersArray.length;
        const isInTop40 = rankPosition > 0 && rankPosition <= 40;

        return (
          <div className="w-full h-full flex flex-col">
            <div className="bg-[#121a33] border-2 border-[#26325f] rounded-xl w-full h-full flex flex-col shadow-2xl" onClick={(e) => e.stopPropagation()}>
              {/* Scrollable Content Area */}
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{tickerSymbol}</h3>
                  <button
                    onClick={onClose}
                    className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
                  >
                    âœ•
                  </button>
                </div>

                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                    <div className="text-center font-bold text-purple-300 mb-2">ðŸš€ MOMENTUM ELITE ðŸš€</div>
                    <div className="text-xs text-purple-200/80 font-normal mb-2">High-quality momentum stock with strong fundamentals</div>
                    {ticker.momentum_pct && (
                      <div className="mt-2 pt-2 border-t border-purple-400/30">
                        <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">Momentum Performance:</div>
                        <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                          {ticker.momentum_pct.week != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1W:</span>
                              <span className={`font-bold ${Number(ticker.momentum_pct.week) >= 10 ? "text-green-400" : "text-purple-300"}`}>
                                {Number(ticker.momentum_pct.week).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.month != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1M:</span>
                              <span className={`font-bold ${Number(ticker.momentum_pct.month) >= 25 ? "text-green-400" : "text-purple-300"}`}>
                                {Number(ticker.momentum_pct.month).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.three_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">3M:</span>
                              <span className={`font-bold ${Number(ticker.momentum_pct.three_months) >= 50 ? "text-green-400" : "text-purple-300"}`}>
                                {Number(ticker.momentum_pct.three_months).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.six_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">6M:</span>
                              <span className={`font-bold ${Number(ticker.momentum_pct.six_months) >= 100 ? "text-green-400" : "text-purple-300"}`}>
                                {Number(ticker.momentum_pct.six_months).toFixed(1)}%
                              </span>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                    â­ PRIME SETUP â­
                  </div>
                )}

                {/* Sector and Rating */}
                {(() => {
                  const tickerSector = ticker.sector || ticker.fundamentals?.sector;
                  if (tickerSector && sectors.length > 0) {
                    const sectorInfo = sectors.find(s => (s.sector || s.name) === tickerSector);
                    const rating = sectorInfo?.rating || "neutral";
                    const emoji =
                      rating === "overweight"
                        ? "ðŸ“ˆ"
                        : rating === "underweight"
                        ? "ðŸ“‰"
                        : "âž¡ï¸";
                    return (
                      <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                        <div className="text-sm text-[#93a4d6] mb-2">Sector</div>
                        <div className="flex items-center gap-2">
                          <span className="text-lg">{emoji}</span>
                          <span className="font-semibold text-white">{tickerSector}</span>
                          <span className={`text-xs px-2 py-1 rounded ${
                            rating === "overweight" ? "bg-green-500/20 text-green-400" :
                            rating === "underweight" ? "bg-red-500/20 text-red-400" :
                            "bg-[#26325f] text-[#93a4d6]"
                          }`}>
                            {rating.charAt(0).toUpperCase() + rating.slice(1)}
                          </span>
                        </div>
                      </div>
                    );
                  }
                  return null;
                })()}

                {/* Bias/Direction */}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                      <div className="text-sm text-[#93a4d6] mb-2">Bias / Direction</div>
                      <div className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}>
                        {dir.text === "LONG" ? "ðŸ“ˆ LONG" : dir.text === "SHORT" ? "ðŸ“‰ SHORT" : dir.text}
                      </div>
                    </div>
                  );
                })()}

                {/* Action Description */}
                <div className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}>
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>{actionInfo.action}</div>
                  <div className="text-sm text-[#93a4d6]">{actionInfo.description}</div>
                </div>

                {/* Quadrant Progression */}
                <QuadrantProgression ticker={ticker} flags={flags} />

                {/* Phase indicator */}
                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[#93a4d6]">Phase</span>
                    <span className="text-sm font-semibold" style={{ color: phaseColor }}>
                      {(phase * 100).toFixed(2)}%
                      {ticker.phase_zone && ` (${ticker.phase_zone})`}
                    </span>
                  </div>
                  <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                    <div className="h-full rounded-full transition-all duration-500" style={{ width: `${phase * 100}%`, backgroundColor: phaseColor, boxShadow: `0 0 8px ${phaseColor}40` }} />
                  </div>
                </div>

                {/* Score and Ranking */}
                <div className="space-y-2.5 text-sm">
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Score</span>
                    <span className="font-semibold text-blue-400 text-lg">{baseScore}</span>
                  </div>
                  {totalTickers > 0 && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Rank</span>
                      <span className="font-semibold">
                        {rankPosition > 0 ? `#${rankPosition} of ${totalTickers}` : "â€”"}
                      </span>
                    </div>
                  )}
                  {dynamicRank !== baseScore && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Dynamic Score</span>
                      <span className="font-semibold text-green-400">{dynamicRank}</span>
                    </div>
                  )}
                  {isInTop40 && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Top 40 Position</span>
                      <span className="font-semibold text-yellow-400">#{rankPosition} of 40</span>
                    </div>
                  )}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const breakdownComponents = [
                      { label: "Base Score", value: breakdown.base, color: "text-blue-400" },
                      breakdown.aligned > 0 ? { label: "Aligned State", value: `+${breakdown.aligned}`, color: "text-green-400" } : null,
                      breakdown.setup > 0 ? { label: "Setup State", value: `+${breakdown.setup}`, color: "text-green-400" } : null,
                      breakdown.htf > 0 ? { label: "HTF Score", value: `+${breakdown.htf.toFixed(2)}`, color: "text-cyan-400" } : null,
                      breakdown.ltf > 0 ? { label: "LTF Score", value: `+${breakdown.ltf.toFixed(2)}`, color: "text-cyan-400" } : null,
                      breakdown.completion > 0 ? { label: "Completion Bonus", value: `+${breakdown.completion}`, color: "text-yellow-400" } : null,
                      breakdown.phase !== 0 ? {
                        label: "Phase",
                        value: breakdown.phase > 0 ? `+${breakdown.phase.toFixed(2)}` : breakdown.phase.toFixed(2),
                        color: breakdown.phase > 0 ? "text-green-400" : "text-red-400"
                      } : null,
                      breakdown.squeezeRelease > 0 ? { label: "Squeeze Release", value: `+${breakdown.squeezeRelease}`, color: "text-purple-400" } : null,
                      breakdown.squeezeOn > 0 ? { label: "Squeeze On", value: `+${breakdown.squeezeOn}`, color: "text-yellow-400" } : null,
                      breakdown.phaseZoneChange > 0 ? { label: "Phase Zone Change", value: `+${breakdown.phaseZoneChange}`, color: "text-blue-400" } : null,
                      breakdown.rr > 0 ? { label: "Risk/Reward", value: `+${breakdown.rr}`, color: "text-green-400" } : null,
                      breakdown.momentumElite > 0 ? { label: "Momentum Elite", value: `+${breakdown.momentumElite}`, color: "text-purple-400" } : null,
                    ].filter(Boolean);

                    return breakdownComponents.length > 0 ? (
                      <div className="border-t border-[#26325f] my-3 pt-3">
                        <div className="text-xs text-[#93a4d6] mb-3 font-semibold">Score Breakdown</div>
                        <div className="space-y-1.5">
                          {breakdownComponents.map((comp, idx) => (
                            <div key={idx} className="flex justify-between items-center text-xs">
                              <span className="text-[#93a4d6]">{comp.label}</span>
                              <span className={`font-semibold ${comp.color}`}>{comp.value}</span>
                            </div>
                          ))}
                          <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                            <span className="text-[#93a4d6] font-semibold">Total Score</span>
                            <span className="text-blue-400 font-bold text-base">{Math.round(breakdown.total)}</span>
                          </div>
                        </div>
                      </div>
                    ) : null;
                  })()}

                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">RR</span>
                    <span className="font-semibold">{ticker.rr ? Number(ticker.rr).toFixed(2) : "â€”"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">State</span>
                    <span className="font-semibold">{ticker.state || "â€”"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">HTF Score</span>
                    <span className="font-semibold">{ticker.htf_score != null ? Number(ticker.htf_score).toFixed(2) : "â€”"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">LTF Score</span>
                    <span className="font-semibold">{ticker.ltf_score != null ? Number(ticker.ltf_score).toFixed(2) : "â€”"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Completion</span>
                    <span className="font-semibold">{ticker.completion != null ? `${(Number(ticker.completion) * 100).toFixed(2)}%` : "â€”"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Price</span>
                    <span className="font-semibold">${ticker.price ? Number(ticker.price).toFixed(2) : "â€”"}</span>
                  </div>
                </div>

                {/* Fundamental & Valuation Metrics */}
                {ticker.fundamentals && (() => {
                  const fund = ticker.fundamentals;
                  const hasValuationData = fund.pe_ratio !== null || fund.peg_ratio !== null || fund.eps_growth_rate !== null;
                  
                  if (!hasValuationData) return null;

                  const valuationSignal = fund.valuation_signal || "fair";
                  const signalColor = valuationSignal === "undervalued" ? "text-green-400" : 
                                     valuationSignal === "overvalued" ? "text-red-400" : "text-yellow-400";
                  const signalBg = valuationSignal === "undervalued" ? "bg-green-500/20 border-green-500/50" : 
                                  valuationSignal === "overvalued" ? "bg-red-500/20 border-red-500/50" : 
                                  "bg-yellow-500/20 border-yellow-500/50";

                  return (
                    <div className="mt-6 pt-6 border-t-2 border-[#26325f]">
                      <div className="text-sm font-bold text-[#93a4d6] mb-4">ðŸ“Š Fundamental & Valuation</div>
                      
                      {/* Valuation Signal Badge */}
                      {fund.valuation_signal && (
                        <div className={`mb-4 p-3 rounded-lg border-2 ${signalBg}`}>
                          <div className="flex items-center justify-between">
                            <span className="text-xs text-[#93a4d6]">Valuation Signal</span>
                            <span className={`font-bold text-sm ${signalColor}`}>
                              {fund.valuation_signal.toUpperCase()}
                            </span>
                          </div>
                          {fund.valuation_confidence && (
                            <div className="text-xs text-[#93a4d6] mt-1">
                              Confidence: <span className="font-semibold">{fund.valuation_confidence}</span>
                            </div>
                          )}
                          {fund.valuation_reasons && fund.valuation_reasons.length > 0 && (
                            <div className="mt-2 pt-2 border-t border-current/30">
                              <div className="text-[10px] text-[#93a4d6] mb-1">Reasons:</div>
                              {fund.valuation_reasons.map((reason, idx) => (
                                <div key={idx} className="text-[10px] text-[#93a4d6]/80 mb-0.5">â€¢ {reason}</div>
                              ))}
                            </div>
                          )}
                        </div>
                      )}

                      {/* Basic Metrics */}
                      <div className="space-y-2 text-sm mb-4">
                        {fund.pe_ratio !== null && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">P/E Ratio</span>
                            <span className="font-semibold">{Number(fund.pe_ratio).toFixed(2)}</span>
                          </div>
                        )}
                        {fund.peg_ratio !== null && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">PEG Ratio</span>
                            <span className={`font-semibold ${
                              fund.peg_ratio < 0.8 ? "text-green-400" : 
                              fund.peg_ratio < 1.0 ? "text-yellow-400" : 
                              fund.peg_ratio > 1.5 ? "text-red-400" : "text-[#93a4d6]"
                            }`}>
                              {Number(fund.peg_ratio).toFixed(2)}
                            </span>
                          </div>
                        )}
                        {fund.eps !== null && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">EPS (TTM)</span>
                            <span className="font-semibold">${Number(fund.eps).toFixed(2)}</span>
                          </div>
                        )}
                        {fund.eps_growth_rate !== null && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">EPS Growth (Annual)</span>
                            <span className={`font-semibold ${
                              fund.eps_growth_rate > 20 ? "text-green-400" : 
                              fund.eps_growth_rate > 10 ? "text-yellow-400" : 
                              fund.eps_growth_rate > 0 ? "text-[#93a4d6]" : "text-red-400"
                            }`}>
                              {Number(fund.eps_growth_rate).toFixed(1)}%
                            </span>
                          </div>
                        )}
                        {(() => {
                          const marketCap = fund.market_cap;
                          const isValid = marketCap !== null && 
                                         marketCap !== undefined && 
                                         marketCap !== "" &&
                                         (typeof marketCap === 'number' || typeof marketCap === 'string') &&
                                         !isNaN(Number(marketCap)) &&
                                         Number(marketCap) > 0;
                          if (!isValid) return null;
                          const numCap = Number(marketCap);
                          let formatted;
                          if (numCap >= 1e12) {
                            formatted = `$${(numCap / 1e12).toFixed(2)}T`;
                          } else if (numCap >= 1e9) {
                            formatted = `$${(numCap / 1e9).toFixed(2)}B`;
                          } else if (numCap >= 1e6) {
                            formatted = `$${(numCap / 1e6).toFixed(2)}M`;
                          } else {
                            formatted = `$${numCap.toLocaleString()}`;
                          }
                          return (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">Market Cap</span>
                              <span className="font-semibold">{formatted}</span>
                            </div>
                          );
                        })()}
                        {fund.industry && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">Industry</span>
                            <span className="font-semibold text-xs">{fund.industry}</span>
                          </div>
                        )}
                      </div>

                      {/* Fair Value */}
                      {fund.fair_value_price !== null && fund.fair_value_price > 0 && (
                        <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          <div className="text-xs text-[#93a4d6] mb-2">Fair Value</div>
                          <div className="flex items-center justify-between mb-2">
                            <span className="text-sm text-[#93a4d6]">Fair Value Price</span>
                            <span className="font-bold text-lg text-blue-400">
                              ${Number(fund.fair_value_price).toFixed(2)}
                            </span>
                          </div>
                          {fund.premium_discount_pct !== null && (
                            <div className="flex items-center justify-between">
                              <span className="text-xs text-[#93a4d6]">Premium/Discount</span>
                              <span className={`font-semibold ${
                                fund.premium_discount_pct < -10 ? "text-green-400" : 
                                fund.premium_discount_pct < 0 ? "text-yellow-400" : 
                                fund.premium_discount_pct > 10 ? "text-red-400" : "text-[#93a4d6]"
                              }`}>
                                {fund.premium_discount_pct > 0 ? "+" : ""}{Number(fund.premium_discount_pct).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {fund.fair_value_pe && fund.fair_value_pe.preferred && (
                            <div className="mt-2 pt-2 border-t border-[#26325f] text-xs text-[#93a4d6]">
                              Fair P/E: <span className="font-semibold">{Number(fund.fair_value_pe.preferred).toFixed(2)}</span>
                            </div>
                          )}
                        </div>
                      )}

                      {/* Historical P/E Percentiles */}
                      {fund.pe_percentiles && (
                        <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          <div className="text-xs text-[#93a4d6] mb-2">Historical P/E Percentiles</div>
                          <div className="grid grid-cols-2 gap-2 text-xs">
                            {fund.pe_percentiles.p10 !== null && (
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">10th:</span>
                                <span className="font-semibold">{Number(fund.pe_percentiles.p10).toFixed(1)}</span>
                              </div>
                            )}
                            {fund.pe_percentiles.p25 !== null && (
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">25th:</span>
                                <span className="font-semibold">{Number(fund.pe_percentiles.p25).toFixed(1)}</span>
                              </div>
                            )}
                            {fund.pe_percentiles.p50 !== null && (
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">50th (Median):</span>
                                <span className="font-semibold text-blue-400">{Number(fund.pe_percentiles.p50).toFixed(1)}</span>
                              </div>
                            )}
                            {fund.pe_percentiles.p75 !== null && (
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">75th:</span>
                                <span className="font-semibold">{Number(fund.pe_percentiles.p75).toFixed(1)}</span>
                              </div>
                            )}
                            {fund.pe_percentiles.p90 !== null && (
                              <div className="flex justify-between">
                                <span className="text-[#93a4d6]">90th:</span>
                                <span className="font-semibold">{Number(fund.pe_percentiles.p90).toFixed(1)}</span>
                              </div>
                            )}
                            {fund.pe_percentiles.avg !== null && (
                              <div className="flex justify-between col-span-2 pt-1 border-t border-[#26325f]">
                                <span className="text-[#93a4d6]">Average:</span>
                                <span className="font-semibold">{Number(fund.pe_percentiles.avg).toFixed(1)}</span>
                              </div>
                            )}
                          </div>
                          {fund.pe_percentile_position && (
                            <div className="mt-2 pt-2 border-t border-[#26325f] text-xs">
                              <span className="text-[#93a4d6]">Current Position: </span>
                              <span className={`font-semibold ${
                                fund.pe_percentile_position.includes("Bottom") ? "text-green-400" : 
                                fund.pe_percentile_position.includes("Top") ? "text-red-400" : "text-[#93a4d6]"
                              }`}>
                                {fund.pe_percentile_position}
                              </span>
                            </div>
                          )}
                        </div>
                      )}

                      {/* Valuation Boost in Rank */}
                      {ticker.rank_components && ticker.rank_components.valuation_boost !== undefined && ticker.rank_components.valuation_boost !== 0 && (
                        <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                          <div className="text-xs text-[#93a4d6] mb-1">Rank Components</div>
                          <div className="flex justify-between items-center text-xs">
                            <span className="text-[#93a4d6]">Base Rank</span>
                            <span className="font-semibold">{ticker.rank_components.base_rank || baseScore}</span>
                          </div>
                          <div className="flex justify-between items-center text-xs mt-1">
                            <span className="text-[#93a4d6]">Valuation Boost</span>
                            <span className={`font-semibold ${
                              ticker.rank_components.valuation_boost > 0 ? "text-green-400" : "text-red-400"
                            }`}>
                              {ticker.rank_components.valuation_boost > 0 ? "+" : ""}{ticker.rank_components.valuation_boost}
                            </span>
                          </div>
                          <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                            <span className="text-[#93a4d6] font-semibold">Final Rank</span>
                            <span className="font-bold text-blue-400">{baseScore}</span>
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })()}
              </div>

              {/* Fixed Footer */}
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[#26325f] bg-[#121a33]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(tickerSymbol)}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  ðŸ“Š Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // Legacy TickerDetails component - kept for backward compatibility but now uses unified component
      function TickerDetails({
        ticker,
        onClose,
        allTickers = [],
        allLoadedData = null,
      }) {
        if (!ticker) return null;

        const prime = isPrimeBubble(ticker);
        const ent = entryType(ticker);
        const flags = ticker.flags || {};
        const phase = Number(ticker.phase_pct) || 0;
        const phaseColor = phaseToColor(phase);
        const actionInfo = getActionDescription(ticker);

        // Convert allLoadedData (object) to array if provided, otherwise use allTickers
        // allLoadedData contains ALL loaded tickers (unfiltered), while allTickers is filtered
        const allLoadedTickersArray = (() => {
          if (allLoadedData && typeof allLoadedData === "object") {
            if (Array.isArray(allLoadedData)) {
              return allLoadedData;
            } else {
              // Convert object to array: { "GOOGL": {...}, "MSFT": {...} } -> [...]
              return Object.values(allLoadedData).filter(
                (t) => t && typeof t === "object" && t.ticker
              );
            }
          }
          // Fallback to allTickers if allLoadedData not provided
          return allTickers || [];
        })();

        return (
          <div className="w-full h-full flex flex-col">
            {/* Detail Card - slides in from right, positioned in hero layout */}
            <div
              className="bg-[#121a33] border-2 border-[#26325f] rounded-xl w-full h-full flex flex-col shadow-2xl"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Scrollable Content Area */}
              <div className="flex-1 overflow-y-auto p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold">{ticker.ticker}</h3>
                  <button
                    onClick={onClose}
                    className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
                  >
                    âœ•
                  </button>
                </div>

                {flags.momentum_elite && (
                  <div className="mb-4 p-3 bg-gradient-to-r from-purple-500/30 via-pink-500/30 to-purple-500/30 border-2 border-purple-400 rounded-lg momentum-elite-glow">
                    <div className="text-center font-bold text-purple-300 mb-2">
                      ðŸš€ MOMENTUM ELITE ðŸš€
                    </div>
                    <div className="text-xs text-purple-200/80 font-normal mb-2">
                      High-quality momentum stock with strong fundamentals
                    </div>
                    {ticker.momentum_pct && (
                      <div className="mt-2 pt-2 border-t border-purple-400/30">
                        <div className="text-[10px] text-purple-200/70 mb-1 font-semibold">
                          Momentum Performance:
                        </div>
                        <div className="grid grid-cols-2 gap-1.5 text-[9px]">
                          {ticker.momentum_pct.week != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1W:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.week) >= 10
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.week).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.month != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">1M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.month) >= 25
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.month).toFixed(1)}%
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.three_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">3M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.three_months) >= 50
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(
                                  ticker.momentum_pct.three_months
                                ).toFixed(1)}
                                %
                              </span>
                            </div>
                          )}
                          {ticker.momentum_pct.six_months != null && (
                            <div className="flex justify-between">
                              <span className="text-purple-300/80">6M:</span>
                              <span
                                className={`font-bold ${
                                  Number(ticker.momentum_pct.six_months) >= 100
                                    ? "text-green-400"
                                    : "text-purple-300"
                                }`}
                              >
                                {Number(ticker.momentum_pct.six_months).toFixed(
                                  1
                                )}
                                %
                              </span>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {prime && (
                  <div className="mb-4 p-3 bg-green-500/20 border-2 border-green-500 rounded-lg text-center font-bold text-green-500 prime-glow">
                    â­ PRIME SETUP â­
                  </div>
                )}

                {/* Bias/Direction - Prominent */}
                {(() => {
                  const dir = getDirection(ticker);
                  return (
                    <div className="mb-4 p-3 bg-[#0f1630] border-2 border-[#26325f] rounded-lg">
                      <div className="text-sm text-[#93a4d6] mb-2">
                        Bias / Direction
                      </div>
                      <div
                        className={`inline-block px-4 py-2 rounded-lg font-bold text-lg ${dir.bg} ${dir.color} border-2 border-current/30`}
                      >
                        {dir.text === "LONG"
                          ? "ðŸ“ˆ LONG"
                          : dir.text === "SHORT"
                          ? "ðŸ“‰ SHORT"
                          : dir.text}
                      </div>
                    </div>
                  );
                })()}

                {/* Action Description */}
                <div
                  className={`mb-4 p-4 rounded-lg border ${actionInfo.bg} border-current/30`}
                >
                  <div className={`text-lg font-bold mb-2 ${actionInfo.color}`}>
                    {actionInfo.action}
                  </div>
                  <div className="text-sm text-[#93a4d6]">
                    {actionInfo.description}
                  </div>
                </div>

                {/* Quadrant Progression Visualization */}
                <QuadrantProgression ticker={ticker} flags={flags} />

                {/* Phase indicator */}
                <div className="mb-4 p-3 bg-[#0f1630] rounded-lg border border-[#26325f]">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-[#93a4d6]">Phase</span>
                    <span
                      className="text-sm font-semibold"
                      style={{ color: phaseColor }}
                    >
                      {(phase * 100).toFixed(2)}%
                      {ticker.phase_zone && ` (${ticker.phase_zone})`}
                    </span>
                  </div>
                  <div className="h-3 bg-[#26325f] rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all duration-500"
                      style={{
                        width: `${phase * 100}%`,
                        backgroundColor: phaseColor,
                        boxShadow: `0 0 8px ${phaseColor}40`,
                      }}
                    />
                  </div>
                </div>

                <div className="space-y-2.5 text-sm">
                  {(() => {
                    const baseScore = Number(ticker.rank) || 0; // Base Score from worker
                    const dynamicRank = computeDynamicRank(ticker);
                    // Use allLoadedTickersArray (ALL loaded tickers) for absolute ranking, not filtered list
                    const allTickersWithRank = allLoadedTickersArray.map(
                      (t) => ({ ...t, dynamicRank: computeDynamicRank(t) })
                    );
                    const sortedByDynamic = [...allTickersWithRank].sort(
                      (a, b) => b.dynamicRank - a.dynamicRank
                    );
                    const rankPosition =
                      sortedByDynamic.findIndex((t) => {
                        if (!t || !t.ticker) return false;
                        return (
                          String(t.ticker).toUpperCase() ===
                          String(ticker.ticker).toUpperCase()
                        );
                      }) + 1;
                    const totalTickers = allLoadedTickersArray.length;
                    const isInTop40 = rankPosition > 0 && rankPosition <= 40;

                    return (
                      <>
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Base Score</span>
                          <span className="font-semibold text-blue-400">
                            {baseScore}
                          </span>
                        </div>
                        <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                          <span className="text-[#93a4d6]">Rank</span>
                          <span className="font-semibold">
                            {rankPosition > 0
                              ? `#${rankPosition} of ${totalTickers}`
                              : "â€”"}
                          </span>
                        </div>
                        {dynamicRank !== baseScore && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">
                              Dynamic Score
                            </span>
                            <span className="font-semibold text-green-400">
                              {dynamicRank}
                            </span>
                          </div>
                        )}
                        {isInTop40 && (
                          <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                            <span className="text-[#93a4d6]">
                              Top 40 Position
                            </span>
                            <span className="font-semibold text-yellow-400">
                              #{rankPosition} of 40
                            </span>
                          </div>
                        )}
                      </>
                    );
                  })()}

                  {/* Score Breakdown */}
                  {(() => {
                    const breakdown = calculateScoreBreakdown(ticker);
                    const breakdownComponents = [
                      {
                        label: "Base Score",
                        value: breakdown.base,
                        color: "text-blue-400",
                      },
                      breakdown.aligned > 0
                        ? {
                            label: "Aligned State",
                            value: `+${breakdown.aligned}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.setup > 0
                        ? {
                            label: "Setup State",
                            value: `+${breakdown.setup}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.htf > 0
                        ? {
                            label: "HTF Score",
                            value: `+${breakdown.htf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.ltf > 0
                        ? {
                            label: "LTF Score",
                            value: `+${breakdown.ltf.toFixed(2)}`,
                            color: "text-cyan-400",
                          }
                        : null,
                      breakdown.completion > 0
                        ? {
                            label: "Completion Bonus",
                            value: `+${breakdown.completion}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phase !== 0
                        ? {
                            label: "Phase",
                            value:
                              breakdown.phase > 0
                                ? `+${breakdown.phase.toFixed(2)}`
                                : breakdown.phase.toFixed(2),
                            color:
                              breakdown.phase > 0
                                ? "text-green-400"
                                : "text-red-400",
                          }
                        : null,
                      breakdown.squeezeRelease > 0
                        ? {
                            label: "Squeeze Release",
                            value: `+${breakdown.squeezeRelease}`,
                            color: "text-purple-400",
                          }
                        : null,
                      breakdown.squeezeOn > 0
                        ? {
                            label: "Squeeze On",
                            value: `+${breakdown.squeezeOn}`,
                            color: "text-yellow-400",
                          }
                        : null,
                      breakdown.phaseZoneChange > 0
                        ? {
                            label: "Phase Zone Change",
                            value: `+${breakdown.phaseZoneChange}`,
                            color: "text-blue-400",
                          }
                        : null,
                      breakdown.rr > 0
                        ? {
                            label: "Risk/Reward",
                            value: `+${breakdown.rr}`,
                            color: "text-green-400",
                          }
                        : null,
                      breakdown.momentumElite > 0
                        ? {
                            label: "Momentum Elite",
                            value: `+${breakdown.momentumElite}`,
                            color: "text-purple-400",
                          }
                        : null,
                    ].filter(Boolean);

                    return breakdownComponents.length > 0 ? (
                      <>
                        <div className="border-t border-[#26325f] my-3 pt-3">
                          <div className="text-xs text-[#93a4d6] mb-3 font-semibold">
                            Score Breakdown
                          </div>
                          <div className="space-y-1.5">
                            {breakdownComponents.map((comp, idx) => (
                              <div
                                key={idx}
                                className="flex justify-between items-center text-xs"
                              >
                                <span className="text-[#93a4d6]">
                                  {comp.label}
                                </span>
                                <span className={`font-semibold ${comp.color}`}>
                                  {comp.value}
                                </span>
                              </div>
                            ))}
                            <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-[#26325f]">
                              <span className="text-[#93a4d6] font-semibold">
                                Total Score
                              </span>
                              <span className="text-blue-400 font-bold text-base">
                                {Math.round(breakdown.total)}
                              </span>
                            </div>
                          </div>
                        </div>
                      </>
                    ) : null;
                  })()}

                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">RR</span>
                    <span className="font-semibold">
                      {ticker.rr ? Number(ticker.rr).toFixed(2) : "â€”"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">State</span>
                    <span className="font-semibold">{ticker.state || "â€”"}</span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Completion</span>
                    <span className="font-semibold">
                      {Math.round(completionForSize(ticker) * 100)}%
                    </span>
                  </div>
                  {ent.corridor && (
                    <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                      <span className="text-[#93a4d6]">Corridor</span>
                      <span className="px-2 py-1 rounded bg-green-500/20 text-green-400 text-xs font-semibold">
                        {ent.side}
                      </span>
                    </div>
                  )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">Current Price</span>
                    <span className="font-semibold text-lg">
                      {ticker.price
                        ? `$${Number(ticker.price).toFixed(2)}`
                        : "â€”"}
                    </span>
                  </div>
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">TP (Primary)</span>
                    <span className="font-semibold">
                      {ticker.tp ? `$${Number(ticker.tp).toFixed(2)}` : "â€”"}
                      {ticker.tp_levels &&
                        Array.isArray(ticker.tp_levels) &&
                        ticker.tp_levels.length > 0 &&
                        (() => {
                          const firstTp = ticker.tp_levels[0];
                          const tpInfo =
                            typeof firstTp === "object" && firstTp !== null
                              ? firstTp
                              : { price: firstTp };
                          if (tpInfo.label) {
                            const refParts = [];
                            if (tpInfo.timeframe)
                              refParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              refParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`
                              );
                            }
                            const refStr =
                              refParts.length > 0
                                ? ` (${tpInfo.label} - ${refParts.join(", ")})`
                                : ` (${tpInfo.label})`;
                            return refStr;
                          }
                          return "";
                        })()}
                    </span>
                  </div>
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 1 &&
                    (() => {
                      // Calculate max TP
                      const tpPrices = ticker.tp_levels
                        .map((tpItem) => {
                          if (
                            typeof tpItem === "object" &&
                            tpItem !== null &&
                            tpItem.price != null
                          ) {
                            return Number(tpItem.price);
                          }
                          return typeof tpItem === "number"
                            ? tpItem
                            : Number(tpItem);
                        })
                        .filter((p) => Number.isFinite(p));

                      if (tpPrices.length > 0) {
                        const maxTP = Math.max(...tpPrices);
                        const primaryTP = Number(ticker.tp) || tpPrices[0];

                        if (maxTP > primaryTP) {
                          return (
                            <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                              <span className="text-[#93a4d6]">TP (Max)</span>
                              <span className="font-semibold text-green-400">
                                ${maxTP.toFixed(2)}
                              </span>
                            </div>
                          );
                        }
                      }
                      return null;
                    })()}
                  {ticker.tp_levels &&
                    Array.isArray(ticker.tp_levels) &&
                    ticker.tp_levels.length > 0 && (
                      <div className="py-1 border-b border-[#26325f]/50">
                        <div className="text-[#93a4d6] text-xs mb-2 font-semibold">
                          TP Levels
                        </div>
                        <div className="space-y-1.5 max-h-48 overflow-y-auto">
                          {ticker.tp_levels.map((tp, idx) => {
                            // Handle both old format (just price) and new format (object with metadata)
                            const tpInfo =
                              typeof tp === "object" && tp !== null
                                ? tp
                                : { price: tp, label: `TP${idx + 1}` };
                            const price = Number(tpInfo.price || tp);
                            const label = tpInfo.label || `TP${idx + 1}`;
                            const source = tpInfo.source || "";
                            const type = tpInfo.type || "";
                            const confidence = tpInfo.confidence || null;

                            // Build reference string from all available metadata
                            const referenceParts = [];
                            if (tpInfo.timeframe)
                              referenceParts.push(tpInfo.timeframe);
                            if (
                              tpInfo.multiplier != null &&
                              !isNaN(tpInfo.multiplier)
                            ) {
                              referenceParts.push(
                                `${Number(tpInfo.multiplier).toFixed(3)}x ATR`
                              );
                            }
                            if (tpInfo.source)
                              referenceParts.push(tpInfo.source);
                            if (tpInfo.type) referenceParts.push(tpInfo.type);
                            const referenceStr =
                              referenceParts.length > 0
                                ? referenceParts.join(" â€¢ ")
                                : null;

                            return (
                              <div
                                key={idx}
                                className="flex items-start justify-between p-1.5 rounded bg-[#0f1630] border border-[#26325f]/50 hover:border-[#3a4aa0] transition-colors"
                              >
                                <div className="flex-1">
                                  <div className="flex items-center gap-2 flex-wrap">
                                    <span className="text-xs font-semibold text-green-400">
                                      {label}
                                    </span>
                                    <span className="text-xs font-mono text-white font-bold">
                                      ${price.toFixed(2)}
                                    </span>
                                    {confidence !== null && (
                                      <span
                                        className={`text-[10px] px-1 py-0.5 rounded ${
                                          confidence >= 0.8
                                            ? "bg-green-500/20 text-green-400"
                                            : confidence >= 0.6
                                            ? "bg-yellow-500/20 text-yellow-400"
                                            : "bg-orange-500/20 text-orange-400"
                                        }`}
                                      >
                                        {Math.round(confidence * 100)}%
                                      </span>
                                    )}
                                  </div>
                                  {referenceStr && (
                                    <div className="text-[10px] text-[#93a4d6] mt-1 italic">
                                      {referenceStr}
                                    </div>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}
                  <div className="flex justify-between items-center py-1 border-b border-[#26325f]/50">
                    <span className="text-[#93a4d6]">SL</span>
                    <span className="font-semibold">
                      {ticker.sl ? Number(ticker.sl).toFixed(2) : "â€”"}
                    </span>
                  </div>
                </div>

                {/* Flags */}
                {(flags.sq30_on ||
                  flags.sq30_release ||
                  flags.phase_dot ||
                  flags.phase_zone_change) && (
                  <div className="mt-4 pt-4">
                    <div className="text-xs text-[#93a4d6] mb-2">Flags:</div>
                    <div className="flex flex-wrap gap-2">
                      {flags.sq30_on && (
                        <span className="px-2 py-1 rounded bg-yellow-500/20 text-yellow-400 text-xs">
                          ðŸ§¨ Squeeze ON
                        </span>
                      )}
                      {flags.sq30_release && (
                        <span className="px-2 py-1 rounded bg-cyan-500/20 text-cyan-400 text-xs">
                          âš¡ Squeeze Release
                        </span>
                      )}
                      {flags.phase_dot && (
                        <span className="px-2 py-1 rounded bg-purple-500/20 text-purple-400 text-xs">
                          Phase Dot
                        </span>
                      )}
                      {flags.phase_zone_change && (
                        <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">
                          Zone Change
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </div>

              {/* Fixed Footer - Open in TradingView button */}
              <div className="flex-shrink-0 p-6 pt-4 border-t border-[#26325f] bg-[#121a33]">
                <a
                  href={`https://www.tradingview.com/chart/?symbol=${encodeURIComponent(
                    ticker.ticker
                  )}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block w-full text-center px-4 py-2 bg-blue-500/20 border border-blue-500 rounded-lg hover:bg-blue-500/30 transition-all hover:scale-105 font-semibold"
                >
                  ðŸ“Š Open in TradingView
                </a>
              </div>
            </div>
          </div>
        );
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // AI Chat Interface Component
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const AIChatInterface = ({ isOpen, onClose, tickerData }) => {
        const [messages, setMessages] = useState([
          {
            role: "assistant",
            content:
              "ðŸ‘‹ Hi! I'm your AI trading assistant. I can help you analyze tickers, understand setups, and provide insights. What would you like to know?",
            timestamp: new Date(),
          },
        ]);
        const [input, setInput] = useState("");
        const [loading, setLoading] = useState(false);
        const [periodicUpdates, setPeriodicUpdates] = useState([]);
        const [showUpdates, setShowUpdates] = useState(false);
        const messagesEndRef = useRef(null);
        const inputRef = useRef(null);

        const scrollToBottom = () => {
          if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
          }
        };

        useEffect(() => {
          scrollToBottom();
        }, [messages]);

        useEffect(() => {
          if (isOpen && inputRef.current) {
            inputRef.current.focus();
          }
        }, [isOpen]);

        // Load periodic updates when chat opens
        useEffect(() => {
          if (isOpen) {
            const fetchUpdates = async () => {
              try {
                const res = await fetch(`${API_BASE}/timed/ai/updates?limit=5`);
                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && data.updates) {
                    setPeriodicUpdates(data.updates);
                  }
                }
              } catch (err) {
                console.warn("Failed to fetch periodic updates:", err);
              }
            };
            fetchUpdates();
          }
        }, [isOpen]);

        const handleMonitor = async () => {
          setLoading(true);

          const monitorMessage = {
            role: "user",
            content: "ðŸ” Run market monitoring analysis",
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, monitorMessage]);

          try {
            const response = await fetch(`${API_BASE}/timed/ai/monitor`, {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
              },
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "Monitoring service error");
            }

            const assistantMessage = {
              role: "assistant",
              content: `ðŸ“Š **Market Monitoring Analysis**\n\n${data.analysis}\n\n---\n**Stats:** ${data.stats.primeSetups} prime setups, ${data.stats.highRiskPositions} high-risk positions, ${data.stats.momentumElite} Momentum Elite`,
              timestamp: new Date(),
              sources: [
                `Monitoring data: ${data.stats.totalTickers} tickers, ${data.stats.recentActivity} events`,
              ],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Monitor error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "âš ï¸ AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `âŒ Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const handleSend = async (e) => {
          e.preventDefault();
          if (!input.trim() || loading) return;

          const userMessage = {
            role: "user",
            content: input.trim(),
            timestamp: new Date(),
          };

          setMessages((prev) => [...prev, userMessage]);
          setInput("");
          setLoading(true);

          try {
            // Fetch recent activity for context
            let activityData = [];
            try {
              const activityRes = await fetch(
                `${API_BASE}/timed/activity?limit=20`
              );
              if (activityRes.ok) {
                const activityJson = await activityRes.json();
                if (activityJson.ok && Array.isArray(activityJson.events)) {
                  activityData = activityJson.events;
                }
              }
            } catch (e) {
              console.warn("Failed to fetch activity for chat:", e);
            }

            const response = await fetch(`${API_BASE}/timed/ai/chat`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                message: userMessage.content,
                conversationHistory: messages.slice(-10).map((m) => ({
                  role: m.role,
                  content: m.content,
                })),
                tickerData: tickerData
                  ? Object.keys(tickerData).slice(0, 50)
                  : [],
                activityData: activityData,
              }),
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data.ok) {
              throw new Error(data.error || "AI service error");
            }

            const assistantMessage = {
              role: "assistant",
              content:
                data.response || "Sorry, I couldn't process that request.",
              timestamp: new Date(),
              sources: data.sources || [],
            };

            setMessages((prev) => [...prev, assistantMessage]);
          } catch (error) {
            console.error("Chat error:", error);
            const errorMessage = {
              role: "assistant",
              content: error.message.includes("not configured")
                ? "âš ï¸ AI service is not configured yet. Please set OPENAI_API_KEY in Cloudflare Workers secrets."
                : `âŒ Error: ${error.message}. Please try again.`,
              timestamp: new Date(),
              error: true,
            };
            setMessages((prev) => [...prev, errorMessage]);
          } finally {
            setLoading(false);
          }
        };

        const formatMessage = (content) => {
          // Simple markdown-like formatting
          const lines = content.split("\n");
          return lines.map((line, i) => {
            let formatted = line;
            // Bold
            formatted = formatted.replace(
              /\*\*(.+?)\*\*/g,
              '<strong class="font-semibold">$1</strong>'
            );
            // Code blocks
            formatted = formatted.replace(
              /`(.+?)`/g,
              '<code class="bg-[#26325f] px-1 py-0.5 rounded text-xs">$1</code>'
            );
            // Links
            formatted = formatted.replace(
              /\[(.+?)\]\((.+?)\)/g,
              '<a href="$2" target="_blank" class="text-blue-400 hover:underline">$1</a>'
            );
            // Use React.createElement instead of JSX for better Babel compatibility
            return React.createElement("p", {
              key: i,
              dangerouslySetInnerHTML: { __html: formatted },
            });
          });
        };

        if (!isOpen) return null;

        return (
          <div className="fixed right-0 top-0 h-full w-96 bg-[#0f1630] border-l border-[#26325f] flex flex-col shadow-2xl z-50 slide-in-right">
            {/* Header */}
            <div className="flex items-center justify-between p-4 border-b border-[#26325f] bg-[#121a33]">
              <div className="flex items-center gap-2">
                <div className="w-8 h-8 rounded-full bg-gradient-to-br from-blue-500 to-purple-500 flex items-center justify-center text-white font-bold text-sm">
                  AI
                </div>
                <div>
                  <h3 className="text-sm font-semibold text-white">
                    Trading Assistant
                  </h3>
                  <p className="text-xs text-[#93a4d6]">Powered by OpenAI</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                {periodicUpdates.length > 0 && (
                  <button
                    onClick={() => setShowUpdates(!showUpdates)}
                    className="px-3 py-1.5 text-xs bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/30 rounded-lg text-purple-400 font-semibold transition-colors relative"
                    title="View periodic updates"
                  >
                    ðŸ“… Updates
                    {periodicUpdates.length > 0 && (
                      <span className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full text-[8px] flex items-center justify-center text-white">
                        {periodicUpdates.length}
                      </span>
                    )}
                  </button>
                )}
                <button
                  onClick={handleMonitor}
                  disabled={loading}
                  className="px-3 py-1.5 text-xs bg-green-500/20 hover:bg-green-500/30 disabled:bg-[#26325f] disabled:text-[#6b7a9f] border border-green-500/30 rounded-lg text-green-400 font-semibold transition-colors disabled:cursor-not-allowed"
                  title="Run market monitoring analysis"
                >
                  ðŸ” Monitor
                </button>
                <button
                  onClick={onClose}
                  className="text-[#93a4d6] hover:text-white transition-colors text-xl leading-none w-6 h-6 flex items-center justify-center rounded hover:bg-[#26325f]"
                >
                  âœ•
                </button>
              </div>
            </div>

            {/* Periodic Updates Panel */}
            {showUpdates && periodicUpdates.length > 0 && (
              <div className="border-b border-[#26325f] bg-[#0f1630] max-h-64 overflow-y-auto">
                <div className="p-3">
                  <h4 className="text-xs font-semibold text-white mb-2">
                    ðŸ“… Periodic Updates
                  </h4>
                  <div className="space-y-2">
                    {periodicUpdates.map((update, idx) => (
                      <div
                        key={idx}
                        className="p-2 bg-[#121a33] border border-[#26325f] rounded-lg cursor-pointer hover:bg-[#1a2550] transition-colors"
                        onClick={() => {
                          setMessages((prev) => [
                            ...prev,
                            {
                              role: "assistant",
                              content: `ðŸ“… **${update.updateTime}**\n\n${update.analysis}\n\n---\n**Stats:** ${update.stats.primeSetups} prime setups, ${update.stats.highRiskPositions} high-risk positions`,
                              timestamp: new Date(update.timestamp),
                            },
                          ]);
                          setShowUpdates(false);
                        }}
                      >
                        <div className="text-xs font-semibold text-purple-400">
                          {update.updateTime}
                        </div>
                        <div className="text-xs text-[#93a4d6] mt-1 line-clamp-2">
                          {update.analysis.substring(0, 100)}...
                        </div>
                        <div className="text-[10px] text-[#6b7a9f] mt-1">
                          {new Date(update.timestamp).toLocaleString()}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
              {messages.map((msg, idx) => (
                <div
                  key={idx}
                  className={`flex ${
                    msg.role === "user" ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[80%] rounded-lg p-3 ${
                      msg.role === "user"
                        ? "bg-blue-500/20 border border-blue-500/30 text-white"
                        : msg.error
                        ? "bg-red-500/20 border border-red-500/30 text-red-300"
                        : "bg-[#121a33] border border-[#26325f] text-[#e7ecff]"
                    }`}
                  >
                    <div className="text-sm whitespace-pre-wrap">
                      {formatMessage(msg.content)}
                    </div>
                    {msg.sources && msg.sources.length > 0 && (
                      <div className="mt-2 pt-2 border-t border-[#26325f]">
                        <p className="text-xs text-[#93a4d6] mb-1">Sources:</p>
                        <ul className="text-xs text-[#93a4d6] space-y-1">
                          {msg.sources.map((source, i) => (
                            <li key={i}>â€¢ {source}</li>
                          ))}
                        </ul>
                      </div>
                    )}
                    <div className="text-xs text-[#6b7a9f] mt-1">
                      {new Date(msg.timestamp).toLocaleTimeString()}
                    </div>
                  </div>
                </div>
              ))}
              {loading && (
                <div className="flex justify-start">
                  <div className="bg-[#121a33] border border-[#26325f] rounded-lg p-3">
                    <div className="flex items-center gap-2 text-[#93a4d6] text-sm">
                      <div className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"></div>
                      <div
                        className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"
                        style={{ animationDelay: "0.2s" }}
                      ></div>
                      <div
                        className="w-2 h-2 bg-[#93a4d6] rounded-full animate-pulse"
                        style={{ animationDelay: "0.4s" }}
                      ></div>
                      <span>Thinking...</span>
                    </div>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <form
              onSubmit={handleSend}
              className="p-4 border-t border-[#26325f] bg-[#121a33]"
            >
              <div className="flex gap-2">
                <input
                  ref={inputRef}
                  type="text"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="Ask about tickers, setups, or market conditions..."
                  className="flex-1 px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6] focus:outline-none focus:border-[#3a4aa0]"
                  disabled={loading}
                />
                <button
                  type="submit"
                  disabled={loading || !input.trim()}
                  className="px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-[#26325f] disabled:text-[#6b7a9f] rounded-lg text-white font-semibold transition-colors disabled:cursor-not-allowed"
                >
                  Send
                </button>
              </div>
              <div className="flex items-center justify-between mt-2">
                <p className="text-xs text-[#6b7a9f]">
                  ðŸ’¡ Try: "What's the status of AAPL?" or "Show me prime setups"
                </p>
              </div>
            </form>
          </div>
        );
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // TickerDetailsLoader - must be defined before App
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const TickerDetailsLoader = ({ tickerSymbol, onClose }) => {
        const [tickerData, setTickerData] = useState(null);
        const [allLoadedData, setAllLoadedData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchTicker = async () => {
            try {
              setLoading(true);
              // Fetch both the ticker data and all tickers for absolute ranking
              const [tickerRes, allRes] = await Promise.all([
                fetch(
                  `${API_BASE}/timed/latest?ticker=${encodeURIComponent(
                    tickerSymbol
                  )}`
                ),
                fetch(`${API_BASE}/timed/all`),
              ]);

              if (!tickerRes.ok) throw new Error(`HTTP ${tickerRes.status}`);
              const tickerJson = await tickerRes.json();
              if (!tickerJson.ok || !tickerJson.latestData) {
                throw new Error(tickerJson.error || "Ticker not found");
              }

              // Try to get all tickers for ranking (may fail, that's okay)
              let allData = null;
              try {
                if (allRes.ok) {
                  const allJson = await allRes.json();
                  if (allJson.ok && allJson.data) {
                    allData = allJson.data;
                  }
                }
              } catch (e) {
                console.warn("Failed to fetch all tickers for ranking:", e);
              }

              setTickerData(tickerJson.latestData);
              setAllLoadedData(allData);
            } catch (err) {
              console.error("Failed to fetch ticker:", err);
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };

          fetchTicker();
        }, [tickerSymbol]);

        if (loading) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-[#26325f] rounded-xl p-6">
              <div className="text-center">
                <div className="loading-spinner mx-auto mb-4"></div>
                <div className="text-[#93a4d6]">Loading {tickerSymbol}...</div>
              </div>
            </div>
          );
        }

        if (error || !tickerData) {
          return (
            <div className="w-[450px] bg-[#0f1630] border border-red-500 rounded-xl p-6">
              <div className="text-center">
                <div className="text-red-400 mb-2">
                  Failed to load {tickerSymbol}
                </div>
                <div className="text-[#93a4d6] text-sm mb-4">
                  {error || "No data available"}
                </div>
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-[#26325f] hover:bg-[#3a4aa0] rounded-lg text-white"
                >
                  Close
                </button>
              </div>
            </div>
          );
        }

        return (
          <TickerDetailRightRail
            ticker={tickerData}
            trade={null}
            onClose={onClose}
            allLoadedData={allLoadedData}
            sectors={sectors}
          />
        );
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // OverlayPortal - must be defined before App
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const OverlayPortal = ({ selectedTicker, tickers, data, onClose, sectors = [] }) => {
        if (!selectedTicker) return null;

        try {
          // Normalize ticker name
          const tickerUpper = String(selectedTicker).toUpperCase();

          // Search in filtered tickers first
          let foundTicker = tickers.find((t) => {
            if (!t || typeof t !== "object") return false;
            const tTicker = String(t.ticker || "").toUpperCase();
            return tTicker === tickerUpper;
          });

          // If not found, search in original data object
          if (!foundTicker && data && typeof data === "object") {
            if (Array.isArray(data)) {
              foundTicker = data.find((t) => {
                if (!t || typeof t !== "object") return false;
                const tTicker = String(t.ticker || "").toUpperCase();
                return tTicker === tickerUpper;
              });
            } else {
              // Object format: check if ticker is a key (data structure: { "ETHA": {...}, ... })
              if (data[tickerUpper]) {
                foundTicker = data[tickerUpper];
              } else {
                // Search through all values in case structure is different
                const dataArray = Object.values(data);
                foundTicker = dataArray.find((t) => {
                  if (!t || typeof t !== "object") return false;
                  const tTicker = String(t.ticker || "").toUpperCase();
                  return tTicker === tickerUpper;
                });
              }
            }
          }

          // If still not found, fetch from API
          if (!foundTicker) {
            console.warn(
              "Ticker not found in local data, fetching from API:",
              tickerUpper
            );
            return (
              <TickerDetailsLoader
                tickerSymbol={tickerUpper}
                onClose={onClose}
              />
            );
          }

          // TEMPORARILY DISABLE PORTAL - render inline to avoid freeze issues
          // TODO: Re-enable portal once freeze is resolved
          return (
            <TickerDetailRightRail
              ticker={foundTicker}
              trade={null}
              onClose={onClose}
              allLoadedData={data}
            />
          );

          /* Portal code - disabled for now
          const overlayContent = (
            <TickerDetails
              ticker={foundTicker}
              onClose={onClose}
            />
          );
          
          // Use portal to render at document body level, but only if available
          if (ReactDOM && ReactDOM.createPortal && document && document.body) {
            try {
              return ReactDOM.createPortal(overlayContent, document.body);
            } catch (portalError) {
              console.error('Portal error:', portalError);
              // Fallback to inline rendering
              return overlayContent;
            }
          }
          // Fallback if portal not available
          return overlayContent;
          */
        } catch (error) {
          console.error("OverlayPortal error:", error);
          return null;
        }
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Main App
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function App() {
        const { data, loading, error, lastUpdate, versionInfo, refetch } = useTickerData();
        const { trades } = useTrades();
        const { sectors } = useSectors();
        const [filters, setFilters] = useState({
          search: "",
          quadrants: [
            "HTF_BULL_LTF_PULLBACK",
            "HTF_BULL_LTF_BULL",
            "HTF_BEAR_LTF_BEAR",
            "HTF_BEAR_LTF_PULLBACK",
          ],
          minRank: 0,
          minRR: 0,
          maxCompletion: 1.01,
          group: "ALL",
          sector: null, // Filter by sector name
        });
        const [selectedTicker, setSelectedTicker] = useState(null);
        const [selectedTrail, setSelectedTrail] = useState(null);
        const [hoveredTicker, setHoveredTicker] = useState(null);
        const [chatOpen, setChatOpen] = useState(false);

        // Fetch trail data when ticker is selected
        useEffect(() => {
          if (selectedTicker) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);

            fetch(
              `https://timed-trading-ingest.shashant.workers.dev/timed/trail?ticker=${encodeURIComponent(
                selectedTicker
              )}`,
              { signal: controller.signal }
            )
              .then((res) => res.json())
              .then((data) => {
                if (data.ok && Array.isArray(data.trail)) {
                  setSelectedTrail(data.trail);
                } else {
                  setSelectedTrail([]);
                }
              })
              .catch((err) => {
                if (err.name !== "AbortError") {
                  console.error("Failed to load trail:", err);
                }
                setSelectedTrail([]);
              })
              .finally(() => {
                clearTimeout(timeoutId);
              });
          } else {
            setSelectedTrail(null);
          }
        }, [selectedTicker]);

        // Safe setter for selectedTicker to prevent infinite loops
        const handleTickerSelect = useCallback((ticker) => {
          try {
            setSelectedTicker(ticker);
          } catch (error) {
            console.error("Error setting selected ticker:", error);
          }
        }, []);

        const debouncedSearch = useDebounce(filters.search, 300);
        const effectiveFilters = { ...filters, search: debouncedSearch };

        const tickers = useMemo(() => {
          return applyFilters(data, effectiveFilters, trades);
        }, [data, effectiveFilters, trades]);

        // Compute dynamic ranks once for all tickers to ensure consistency
        const tickersWithRanks = useMemo(() => {
          return tickers.map((t) => ({
            ...t,
            dynamicRank: computeDynamicRank(t),
          }));
        }, [tickers]);

        const primeTickers = useMemo(
          () => tickersWithRanks.filter(isPrimeBubble),
          [tickersWithRanks]
        );

        const handleFilterChange = useCallback((newFilters) => {
          setFilters((prev) => {
            // Create a new object to ensure React detects the change
            const updated = { ...prev };
            // Apply new filters
            Object.keys(newFilters).forEach((key) => {
              if (newFilters[key] === undefined || newFilters[key] === null) {
                // Explicitly delete undefined/null values to clear filters
                delete updated[key];
              } else {
                updated[key] = newFilters[key];
              }
            });
            return updated;
          });
        }, []);

        return (
          <>
            <div className="min-h-screen p-4">
              <div className="w-full mx-auto">
                {/* Navigation */}
                <nav className="mb-4 p-3 bg-[#121a33] border border-[#26325f] rounded-lg">
                  <div className="flex items-center gap-3 flex-wrap">
                    <span className="text-sm text-[#93a4d6]">Navigate:</span>
                    <a
                      href="index-react.html"
                      className="px-3 py-1.5 rounded bg-blue-500/20 border border-blue-500 text-sm text-blue-400 font-semibold"
                    >
                      Dashboard
                    </a>
                    <a
                      href="simulation-dashboard.html"
                      className="px-3 py-1.5 rounded bg-[#0f1630] border border-[#26325f] text-sm hover:bg-[#1a2550] transition-colors"
                    >
                      Simulation Dashboard
                    </a>
                  </div>
                </nav>

                {/* Header */}
                <header className="mb-6">
                  <div className="flex items-center justify-between mb-4">
                    <h1 className="text-3xl font-bold">
                      Timed Trading â€” React Dashboard
                    </h1>
                    <div className="flex items-center gap-4">
                      {loading && <div className="loading-spinner"></div>}
                      {error && (
                        <div className="px-4 py-2 bg-red-500/20 border border-red-500 rounded-lg text-red-400 text-sm">
                          Error: {error}
                        </div>
                      )}
                      <button
                        onClick={() => setChatOpen(true)}
                        className="px-4 py-2 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 border border-blue-400/30 rounded-lg text-white font-semibold transition-all shadow-lg hover:shadow-xl flex items-center gap-2"
                        title="Open AI Assistant"
                      >
                        <span>ðŸ¤–</span>
                        <span>AI Assistant</span>
                      </button>
                      <button
                        onClick={refetch}
                        className="px-4 py-2 bg-[#1a2550] border border-[#26325f] rounded-lg hover:bg-[#26325f] transition-colors"
                      >
                        Refresh
                      </button>
                      {lastUpdate && (
                        <span className="text-sm text-[#93a4d6]">
                          Updated {lastUpdate.toLocaleTimeString()}
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Quick Stats */}
                  <div className="flex gap-4 text-sm items-center flex-wrap">
                    <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                      <span className="text-[#93a4d6]">Tickers: </span>
                      <span className="font-bold text-white">
                        {tickers.length}
                      </span>
                    </div>
                    <div className="px-3 py-1.5 rounded-lg bg-green-500/10 border border-green-500/30">
                      <span className="text-green-400">Prime: </span>
                      <span className="font-bold text-green-400">
                        {primeTickers.length}
                      </span>
                    </div>
                    {versionInfo && (
                      <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                        <span className="text-[#93a4d6]">Version: </span>
                        <span className="font-bold text-blue-400">
                          {versionInfo.currentDataVersion || versionInfo.storedVersion}
                        </span>
                        {versionInfo.versionsSeen && versionInfo.versionsSeen.length > 0 && (
                          <span className="text-[#93a4d6] ml-2 text-xs">
                            ({versionInfo.versionsSeen.join(", ")})
                          </span>
                        )}
                        {versionInfo.versionFiltered > 0 && (
                          <span className="text-yellow-400 ml-2 text-xs">
                            ({versionInfo.versionFiltered} filtered)
                          </span>
                        )}
                      </div>
                    )}
                    {tickers.length > 0 && (
                      <div className="px-3 py-1.5 rounded-lg bg-[#0f1630] border border-[#26325f]">
                        <span className="text-[#93a4d6]">In Corridor: </span>
                        <span className="font-bold text-white">
                          {tickers.filter((t) => entryType(t).corridor).length}
                        </span>
                      </div>
                    )}
                    {error && (
                      <div className="px-3 py-1.5 rounded-lg bg-red-500/10 border border-red-500/30">
                        <span className="text-red-400">Error: {error}</span>
                      </div>
                    )}
                  </div>

                  {/* Filters */}
                  <div className="mt-4">
                    <div className="mb-4">
                      <input
                        type="text"
                        placeholder="Search ticker(s) or use natural language... (e.g., 'AAPL, GOOGL' or 'top 40' or 'rank over 75')"
                        value={filters.search}
                        onChange={(e) =>
                          handleFilterChange({ search: e.target.value })
                        }
                        className="w-full px-4 py-2 bg-[#0f1630] border border-[#26325f] rounded-lg text-white placeholder-[#93a4d6]"
                      />
                      <div className="mt-1 text-xs text-[#6b7a9f]">
                        ðŸ’¡ Examples:{" "}
                        <span className="text-[#93a4d6]">
                          "AAPL, GOOGL, TSLA"
                        </span>{" "}
                        â€¢ <span className="text-[#93a4d6]">"top 40"</span> â€¢{" "}
                        <span className="text-[#93a4d6]">"top long setup"</span>{" "}
                        â€¢ <span className="text-[#93a4d6]">"rank over 75"</span>{" "}
                        â€¢ <span className="text-[#93a4d6]">"RR above 2"</span> â€¢{" "}
                        <span className="text-[#93a4d6]">
                          "prime setup and in corridor"
                        </span>
                      </div>
                    </div>
                    <QuickFilters
                      filters={filters}
                      onFilterChange={handleFilterChange}
                      sectors={sectors}
                    />
                  </div>
                </header>

                {/* Error Display */}
                {error && (
                  <div className="mb-4 p-4 bg-red-500/20 border-2 border-red-500 rounded-xl">
                    <div className="flex items-center justify-between">
                      <div>
                        <h3 className="text-lg font-bold text-red-400 mb-2">
                          Error Loading Data
                        </h3>
                        <p className="text-red-300">{error}</p>
                      </div>
                      <button
                        onClick={refetch}
                        className="px-4 py-2 bg-red-500 hover:bg-red-600 rounded-lg text-white font-semibold"
                      >
                        Retry
                      </button>
                    </div>
                  </div>
                )}

                {/* Main Content - Hero Layout: Activity Feed (left) | Bubble Chart (center) | Detail (right) */}
                {!error && (
                  <div className="space-y-4">
                    {/* Hero Section: Activity Feed | Bubble Chart | Detail View */}
                    <div className="flex gap-4 items-start">
                      {/* Activity Feed - Left side (complementary, fixed width) */}
                      <div className="flex-shrink-0">
                        <ActivityFeed
                          onTickerClick={handleTickerSelect}
                          tickerData={data}
                        />
                      </div>

                      {/* Bubble Chart - Center Hero (flexible, takes remaining space) */}
                      <div
                        className={`flex-1 min-w-0 transition-all ${
                          selectedTicker ? "mr-[470px]" : ""
                        }`}
                      >
                        <div className="h-[900px]">
                          {loading && tickers.length === 0 ? (
                            <div className="w-full h-full bg-[#121a33] rounded-xl border border-[#26325f] flex items-center justify-center">
                              <div className="text-center">
                                <div className="loading-spinner mx-auto mb-4"></div>
                                <div className="text-[#93a4d6]">
                                  Loading tickers...
                                </div>
                              </div>
                            </div>
                          ) : (
                            <BubbleChart
                              tickers={tickers}
                              onBubbleClick={handleTickerSelect}
                              hoveredTicker={hoveredTicker}
                              onHover={setHoveredTicker}
                              selectedTicker={selectedTicker}
                              selectedTrail={selectedTrail}
                              allData={data}
                            />
                          )}
                        </div>
                      </div>
                    </div>

                    {/* Right Rail - Detail View (slides in from right, fixed to viewport) */}
                    {selectedTicker && (
                      <div className="fixed right-0 top-0 w-[450px] h-screen bg-[#0f1630] border-l border-[#26325f] z-40 slide-in-right shadow-2xl">
                        <OverlayPortal
                          selectedTicker={selectedTicker}
                          tickers={tickers}
                          data={data}
                          onClose={() => handleTickerSelect(null)}
                          sectors={sectors}
                        />
                      </div>
                    )}

                    {/* Lists - All five side by side in columns */}
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4">
                      {/* Top 40 Dynamic Ranking - Narrower column */}
                      <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-3">
                        <h2 className="text-sm font-bold mb-1">
                          ðŸ† Top 40
                        </h2>
                        <div className="text-[9px] text-[#93a4d6] mb-2">
                          Dynamic rankings
                        </div>
                        <div className="space-y-1">
                          {[...tickersWithRanks]
                            .sort((a, b) => b.dynamicRank - a.dynamicRank)
                            .slice(0, 40)
                            .map((ticker, idx) => (
                              <div
                                key={ticker.ticker}
                                className="flex items-center gap-1"
                              >
                                <div className="w-5 text-center flex-shrink-0">
                                  <span
                                    className={`text-[10px] font-bold ${
                                      idx < 3
                                        ? "text-yellow-400"
                                        : idx < 10
                                        ? "text-green-400"
                                        : "text-[#93a4d6]"
                                    }`}
                                  >
                                    #{idx + 1}
                                  </span>
                                </div>
                                <div className="flex-1 min-w-0">
                                  <SetupCard
                                    ticker={{
                                      ...ticker,
                                      rank: ticker.dynamicRank,
                                    }}
                                    isSelected={
                                      selectedTicker === ticker.ticker
                                    }
                                    onClick={() =>
                                      handleTickerSelect(ticker.ticker)
                                    }
                                  />
                                </div>
                              </div>
                            ))}
                        </div>
                      </div>

                      {/* Top Long */}
                      {(() => {
                        const longTickers = tickersWithRanks
                          .filter((t) => {
                            const dir = getDirection(t);
                            return dir.text === "LONG";
                          })
                          .sort((a, b) => b.dynamicRank - a.dynamicRank)
                          .slice(0, 25);

                        if (longTickers.length === 0) return null;

                        return (
                          <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-3">
                            <h2 className="text-sm font-bold mb-1">
                              ðŸ“ˆ Top Long
                            </h2>
                            <div className="text-[9px] text-[#93a4d6] mb-2">
                              Best long setups
                            </div>
                            <div className="space-y-1">
                              {longTickers.map((ticker) => (
                                <SetupCard
                                  key={ticker.ticker}
                                  ticker={{
                                    ...ticker,
                                    rank: ticker.dynamicRank,
                                  }}
                                  isSelected={
                                    selectedTicker === ticker.ticker
                                  }
                                  onClick={() =>
                                    handleTickerSelect(ticker.ticker)
                                  }
                                />
                              ))}
                            </div>
                          </div>
                        );
                      })()}

                      {/* Top Short */}
                      {(() => {
                        const shortTickers = tickersWithRanks
                          .filter((t) => {
                            const dir = getDirection(t);
                            return dir.text === "SHORT";
                          })
                          .sort((a, b) => b.dynamicRank - a.dynamicRank)
                          .slice(0, 25);

                        if (shortTickers.length === 0) return null;

                        return (
                          <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-3">
                            <h2 className="text-sm font-bold mb-1">
                              ðŸ“‰ Top Short
                            </h2>
                            <div className="text-[9px] text-[#93a4d6] mb-2">
                              Best short setups
                            </div>
                            <div className="space-y-1">
                              {shortTickers.map((ticker) => (
                                <SetupCard
                                  key={ticker.ticker}
                                  ticker={{
                                    ...ticker,
                                    rank: ticker.dynamicRank,
                                  }}
                                  isSelected={
                                    selectedTicker === ticker.ticker
                                  }
                                  onClick={() =>
                                    handleTickerSelect(ticker.ticker)
                                  }
                                />
                              ))}
                            </div>
                          </div>
                        );
                      })()}

                      {/* Prime Setups */}
                      {(() => {
                        const primeTickersSorted = primeTickers
                          .sort((a, b) => b.dynamicRank - a.dynamicRank)
                          .slice(0, 15);

                        if (primeTickersSorted.length === 0) return null;

                        return (
                          <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-3">
                            <h2 className="text-sm font-bold mb-1">
                              â­ Prime Setups
                            </h2>
                            <div className="text-[9px] text-[#93a4d6] mb-2">
                              High-quality setups
                            </div>
                            <div className="space-y-1">
                              {primeTickersSorted.map((ticker) => (
                                <SetupCard
                                  key={ticker.ticker}
                                  ticker={{
                                    ...ticker,
                                    rank: ticker.dynamicRank,
                                  }}
                                  isSelected={
                                    selectedTicker === ticker.ticker
                                  }
                                  onClick={() =>
                                    handleTickerSelect(ticker.ticker)
                                  }
                                />
                              ))}
                            </div>
                          </div>
                        );
                      })()}

                      {/* In Corridor */}
                      {(() => {
                        const corridorTickers = tickersWithRanks
                          .filter((t) => entryType(t).corridor)
                          .sort((a, b) => b.dynamicRank - a.dynamicRank)
                          .slice(0, 15);

                        if (corridorTickers.length === 0) return null;

                        return (
                          <div className="bg-[#121a33] border border-[#26325f] rounded-xl p-3">
                            <h2 className="text-sm font-bold mb-1">
                              ðŸŽ¯ In Corridor
                            </h2>
                            <div className="text-[9px] text-[#93a4d6] mb-2">
                              Entry-ready setups
                            </div>
                            <div className="space-y-1">
                              {corridorTickers.map((ticker) => (
                                <SetupCard
                                  key={ticker.ticker}
                                  ticker={{
                                    ...ticker,
                                    rank: ticker.dynamicRank,
                                  }}
                                  isSelected={
                                    selectedTicker === ticker.ticker
                                  }
                                  onClick={() =>
                                    handleTickerSelect(ticker.ticker)
                                  }
                                />
                              ))}
                            </div>
                          </div>
                        );
                      })()}
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* AI Chat Interface */}
            {chatOpen && (
              <AIChatInterface
                isOpen={chatOpen}
                onClose={() => setChatOpen(false)}
                tickerData={data}
              />
            )}
          </>
        );
      }

      // Make App accessible from outside the Babel script
      window.App = App;
    </script>

    <!-- Initialize app - separate script to avoid Babel parsing issues -->
    <script>
      // Render with error handling
      // Wait for all scripts to load before rendering
      function initializeApp() {
        try {
          // Check if React and ReactDOM are loaded
          if (typeof React === "undefined") {
            throw new Error("React not loaded. Check CDN connection.");
          }
          if (typeof ReactDOM === "undefined") {
            throw new Error("ReactDOM not loaded. Check CDN connection.");
          }

          const rootElement = document.getElementById("root");
          if (!rootElement) {
            throw new Error("Root element not found");
          }

          // Check if App component is available (from Babel script)
          if (typeof window.App === "undefined") {
            throw new Error(
              "App component not loaded. Babel may not have finished processing."
            );
          }

          // Check if React 18 createRoot is available
          if (ReactDOM.createRoot) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(React.createElement(window.App));
          } else {
            // Fallback for React 17
            ReactDOM.render(React.createElement(window.App), rootElement);
          }

          console.log("[App] Dashboard initialized successfully");
        } catch (error) {
          console.error("Error rendering app:", error);
          const rootElement = document.getElementById("root");
          if (rootElement) {
            rootElement.innerHTML = `
              <div style="padding: 40px; text-align: center; color: #e7ecff; max-width: 800px; margin: 0 auto;">
                <h2 style="color: #e74c3c; margin-bottom: 20px;">Error Loading Dashboard</h2>
                <p style="margin-bottom: 20px; color: #ff6b6b;">${error.message}</p>
                <div style="background: #1a2440; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left; color: #93a4d6;">
                  <h3 style="color: #e7ecff; margin-bottom: 10px;">Troubleshooting:</h3>
                  <ul style="list-style: disc; padding-left: 20px; line-height: 1.8;">
                    <li>Open browser console (F12 or Cmd+Option+I) to see detailed errors</li>
                    <li>Check your internet connection - CDN resources need to load</li>
                    <li>Try refreshing the page (Cmd+R or Ctrl+R)</li>
                    <li>Check if React is loaded: <code style="background: #26325f; padding: 2px 6px; border-radius: 4px;">typeof React !== 'undefined'</code></li>
                    <li>Check if API is reachable: <a href="https://timed-trading-ingest.shashant.workers.dev/timed/health" target="_blank" style="color: #4a9eff;">API Health Check</a></li>
                  </ul>
                </div>
                <button 
                  onclick="window.location.reload()" 
                  style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;"
                >
                  Reload Page
                </button>
              </div>
            `;
          }
        }
      }

      // Wait for DOM and scripts to be ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
          // Wait a bit for Babel to process
          setTimeout(initializeApp, 100);
        });
      } else {
        // DOM already loaded
        setTimeout(initializeApp, 100);
      }

      // Fallback: If React still isn't loaded after 5 seconds, show error
      setTimeout(function () {
        if (typeof React === "undefined" || typeof ReactDOM === "undefined") {
          const rootElement = document.getElementById("root");
          if (
            rootElement &&
            rootElement.innerHTML.includes("Loading dashboard")
          ) {
            rootElement.innerHTML = `
          <div style="padding: 40px; text-align: center; color: #e7ecff;">
                <h2 style="color: #e74c3c;">CDN Resources Not Loading</h2>
                <p style="margin: 20px 0; color: #93a4d6;">
                  React or other CDN resources failed to load. This may be due to:
                </p>
                <ul style="text-align: left; display: inline-block; color: #93a4d6; margin: 20px 0;">
                  <li>Network connectivity issues</li>
                  <li>Ad blockers blocking CDN scripts</li>
                  <li>Corporate firewall blocking unpkg.com</li>
                </ul>
                <p style="margin-top: 20px;">
                  <button onclick="window.location.reload()" style="padding: 12px 24px; background: #4a9eff; color: white; border: none; border-radius: 8px; cursor: pointer;">
                    Retry
                  </button>
            </p>
          </div>
        `;
          }
        }
      }, 5000);
    </script>
  </body>
</html>
